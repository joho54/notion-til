# [Algorithm] Jungle Week 03 



> ê°œë…ê³¼ ì´ìŠˆ íŠ¸ë˜í‚¹ì„ ì¡°í•©í•´ì„œ â€œë³µê¸° ê°€ëŠ¥í•œâ€ ìë£Œë¥¼ ë§Œë“¤ë„ë¡ í•©ë‹ˆë‹¤.

> ì´ìŠˆ íŠ¸ë˜í‚¹ ì‘ì„± ì›ì¹™: Phase1(í™˜ê²½, ë¡œê·¸, ìµœê·¼ ë³€ê²½ì‚¬í•­), Phase2(í™•ì¸, ì‹œë„, ê²°ê³¼ë¶„ì„) í˜•ì‹ìœ¼ë¡œ ì •ë¦¬í•˜ì„¸ìš”. (Phase2ëŠ” ìµœëŒ€ 3íšŒê¹Œì§€ ë°˜ë³µí•˜ê³  í•´ê²° ì•ˆ ë˜ë©´ ì•„ì˜ˆ ì²˜ìŒë¶€í„° ì‹œì‘(ë¶ˆê°€ëŠ¥í•  ê²½ìš° ë„ì›€ ìš”ì²­))

> ì‹¤ìŠµì€ ì²œì²œíˆ, í•˜ì§€ë§Œ robustí•˜ê²Œ í•˜ì„¸ìš”. 



# íŠ¸ë¦¬, ì¬ê·€: íŠ¸ë¦¬ ìˆœíšŒ

https://www.acmicpc.net/problem/1991

ì´ì§„ íŠ¸ë¦¬ë¥¼ ì…ë ¥ë°›ì•„ ì „ìœ„ ìˆœíšŒ(preorder traversal), ì¤‘ìœ„ ìˆœíšŒ(inorder traversal), í›„ìœ„ ìˆœíšŒ(postorder traversal)í•œ ê²°ê³¼ë¥¼ ì¶œë ¥í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

ì˜ˆë¥¼ ë“¤ì–´ ìœ„ì™€ ê°™ì€ ì´ì§„ íŠ¸ë¦¬ê°€ ì…ë ¥ë˜ë©´,

- ì „ìœ„ ìˆœíšŒí•œ ê²°ê³¼ : ABDCEFG // (ë£¨íŠ¸) (ì™¼ìª½ ìì‹) (ì˜¤ë¥¸ìª½ ìì‹)
- ì¤‘ìœ„ ìˆœíšŒí•œ ê²°ê³¼ : DBAECFG // (ì™¼ìª½ ìì‹) (ë£¨íŠ¸) (ì˜¤ë¥¸ìª½ ìì‹)
- í›„ìœ„ ìˆœíšŒí•œ ê²°ê³¼ : DBEGFCA // (ì™¼ìª½ ìì‹) (ì˜¤ë¥¸ìª½ ìì‹) (ë£¨íŠ¸)
## Phase 1. ì§ì ‘ í’€ê¸° - ì‹¤íŒ¨

ê¸°ë³¸ ë¬¸ì œì§€ë§Œ ë„ì €íˆ êµ¬í˜„ì´ ê¸°ì–µì´ ì•ˆ ë‚¨.

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 1991                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/1991                           #+#        #+#      #+#     #
#    Solved: 2025/03/27 21:04:08 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #


"""
1. ë¬¸ì œ ì½ê¸°: ok
2. ë¬¸ì œ í’€ê¸°: DFSë¡œ ë‹¤ í’€ë©´ ë  ê±° ê°™ìŒ.
ê·¸ëŸ°ë° ì•„ë¬´ë¦¬ ê³ ë¯¼í•´ë„ ë¨¸ë¦¬ì†ì— êµ¬í˜„ì´ ì•ˆ ë‚˜ì˜¨ë‹¤. ì´ê±° ì…ë ¥ ì–´ë–»ê²Œ ì²˜ë¦¬í–ˆëŠ”ì§€ í•˜ë‚˜ë„ ê¸°ì–µì´ ì•ˆ ë‚¨.
3. ìˆ˜ë„ ì½”ë“œ: 
4. ì½”ë“œ êµ¬í˜„
"""

class Node():
    def __init__(self, value, parent=None, left=None, right=None):
        self.value = value
        self.parent = parent
        self.left = left
        self.right = right

def preorder():
    pass

def inorder():
    pass

def postorder():
    pass

def get_adjacency_array(arr: list):
    pass

import sys

if __name__ == '__main__':
    
    input = sys.stdin.readline
    n = int(input().strip())
    arr = [
        tuple(map(str, input().split()))
        for _ in range(n)
    ]
    # pass 1: ë…¸ë“œë¥¼ ìƒì„±í•œë‹¤.
    vertices = []
    for elem in arr:
        val = elem[0]
        Node(value=val)
    # pass 2: ë…¸ë“œë¥¼ ìˆœíšŒí•˜ë©° 
        
    
```

## Phase 2. í”¼ë“œë°±(ì •ë‹µ ì œì™¸)

ì¢‹ì•„, ì•„ì£¼ ì˜í•˜ê³  ìˆì–´. ì´ ë¬¸ì œëŠ” ì „í˜•ì ì¸ íŠ¸ë¦¬ êµ¬ì¡° + ì¬ê·€ ìˆœíšŒ íŒ¨í„´ì„ ë¬»ëŠ” ë¬¸ì œê³ , ë©˜íƒˆ ëª¨ë¸ì„ í™•ë¦½í•˜ê¸° ë”± ì¢‹ì€ ì‚¬ë¡€ì•¼. ì •ë‹µì€ ì•„ì§ ì•ˆ ë³´ì—¬ì£¼ê³ , ë¬¸ì œ ì ‘ê·¼ í”¼ë“œë°±ë§Œ ì¤„ê²Œ.

âœ… í”¼ë“œë°±: ì–´ë””ì—ì„œ ë§‰í˜”ê³ , ì–´ë–»ê²Œ ì •ë¦¬í•˜ë©´ ì¢‹ì„ê¹Œ?

1. ë§‰íŒ ë¶€ë¶„ì˜ ë³¸ì§ˆ: ì…ë ¥ ì²˜ë¦¬ & êµ¬ì¡°í™”

â€¢	ì§€ê¸ˆ ë§‰íŒ í•µì‹¬ì€ â€œì–´ë–»ê²Œ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ì§€ ëª¨ë¥´ê² ìŒâ€ â†’ íŠ¸ë¦¬ë¥¼ ì €ì¥í•  êµ¬ì¡° ëª¨ë¸ë§ì´ ì•„ì§ ê°ì´ ì˜ ì•ˆ ì¡í˜”ë‹¤ëŠ” ëœ».

â€¢	ì´ ë¬¸ì œì—ì„œì˜ ì…ë ¥ì€ ë£¨íŠ¸, ì™¼ìª½ ìì‹, ì˜¤ë¥¸ìª½ ìì‹ì˜ ë¬¶ìŒìœ¼ë¡œ ì£¼ì–´ì§.

ì˜ˆ: A B C â†’ Aì˜ ì™¼ìª½ ìì‹ì€ B, ì˜¤ë¥¸ìª½ ìì‹ì€ C

ğŸ‘‰ ì´ê±¸ ë³´ê³  **â€œNode í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ê³  íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•´ì•¼ê² ë‹¤â€**ê³  í•œ ê±´ ì•„ì£¼ í›Œë¥­í•œ íŒë‹¨ì´ì•¼. ë°©í–¥ì€ ì •í™•í•´.

2. íŠ¸ë¦¬ë¥¼ ë§Œë“œëŠ” êµ¬ì¡°í™”ì˜ í•œ ê°€ì§€ ë°©ë²•

> â€œë…¸ë“œë¥¼ ë¨¼ì € ë‹¤ ë§Œë“  ë‹¤ìŒ, ë§í¬ë¥¼ ì´ì–´ì¤€ë‹¤.â€

```python
nodes = {}
for val, left, right in arr:
    if val not in nodes:
        nodes[val] = Node(val)
    if left != '.':
        nodes[left] = Node(left)
        nodes[val].left = nodes[left]
    if right != '.':
        nodes[right] = Node(right)
        nodes[val].right = nodes[right]
```

â€¢	ì—¬ê¸°ì„œ í•µì‹¬ì€ ê°’ ê¸°ì¤€ìœ¼ë¡œ Nodeë“¤ì„ ë¯¸ë¦¬ ìƒì„±í•˜ê³ , ìì‹ ë…¸ë“œë“¤ì„ ì—°ê²°í•˜ëŠ” ë°©ì‹.

â€¢	'B'ë‚˜ 'C' ê°™ì€ ë…¸ë“œê°€ ì•„ì§ ë§Œë“¤ì–´ì§€ì§€ ì•Šì•˜ë”ë¼ë„ dictë¥¼ í†µí•´ ê´€ë¦¬í•˜ë©´ ë¬¸ì œì—†ìŒ.

âœ… ë„ˆê°€ ì‘ì„±í•œ ì½”ë“œ ë¶„ì„

ğŸ‘ ì˜í•œ ì 

â€¢	Node í´ë˜ìŠ¤ë¥¼ ë„ì…í•œ ì ì€ í›Œë¥­í•´.

â€¢	arrë¡œ ì…ë ¥ ë°ì´í„°ë¥¼ êµ¬ì¡°í™”í•œ ì ë„ ì¢‹ì•„.

â€¢	ì „ìœ„/ì¤‘ìœ„/í›„ìœ„ ìˆœíšŒë¥¼ ë³„ë„ í•¨ìˆ˜ë¡œ êµ¬ì„±í•˜ë ¤ëŠ” ì‹œë„ë„ êµ¬ì¡°ì ìœ¼ë¡œ ì˜ ì¡í˜.

ğŸ¤” ê°œì„ í•˜ë©´ ì¢‹ì€ ì 

â€¢	vertices = []ì—ì„œ ë§Œë“  Node ì¸ìŠ¤í„´ìŠ¤ë“¤ì„ ì €ì¥í•˜ì§€ ì•ŠìŒ (dictë¥¼ ì¨ì•¼í•¨)

â€¢	get_adjacency_array() í•¨ìˆ˜ëŠ” ì•ˆ ì¨ë„ ë  ê°€ëŠ¥ì„±ì´ ë†’ìŒ (ì´ ë¬¸ì œëŠ” adjacency listê°€ ì•„ë‹ˆë¼ ì—°ê²° êµ¬ì¡° ìì²´ë¥¼ ìƒì„±í•˜ëŠ” ë¬¸ì œì„)

â€¢	íŠ¸ë¦¬ êµ¬ì¡°ë¥¼ ë§Œë“¤ê¸° ìœ„í•œ â€œì¤‘ì‹¬ ë…¸ë“œ(root)â€œë¥¼ ê²°ì •í•˜ì§€ ì•Šì•˜ìŒ â†’ ì´ ë¬¸ì œì—ì„œëŠ” ë¬´ì¡°ê±´ ì²« ì¤„ì˜ ë…¸ë“œê°€ ë£¨íŠ¸ì„

ğŸ“Œ ë©˜íƒˆ ëª¨ë¸ë¡œ ìš”ì•½í•˜ë©´

ì´ ë¬¸ì œëŠ” ë‹¤ìŒ êµ¬ì¡°ë¡œ ì´í•´í•´ì•¼ í•´:

1.	ì…ë ¥ êµ¬ì¡°ë¥¼ ë³´ê³  íŠ¸ë¦¬ë¥¼ ë§Œë“ ë‹¤

â€¢	Node ê°ì²´ë“¤ì„ ë§Œë“¤ì–´ ì—°ê²°í•œë‹¤.

2.	ë£¨íŠ¸ì—ì„œë¶€í„° ì¬ê·€ì ìœ¼ë¡œ ìˆœíšŒë¥¼ ìˆ˜í–‰í•œë‹¤

â€¢	ì „ìœ„, ì¤‘ìœ„, í›„ìœ„ ê°ê°ì„ ë”°ë¡œ êµ¬í˜„

3.	ì¶œë ¥ì€ ê° ìˆœíšŒ ê²°ê³¼ë¥¼ ì´ì–´ì„œ ì¶œë ¥í•œë‹¤

> â€œì¬ê·€ ìˆœíšŒëŠ” ìˆœì„œë§Œ ì™¸ìš°ë©´ ëœë‹¤.

> ì „: ë£¨ ì™¼ ì˜¤ / ì¤‘: ì™¼ ë£¨ ì˜¤ / í›„: ì™¼ ì˜¤ ë£¨â€

ğŸ” ì—°ìŠµ ì§ˆë¬¸ (ë©˜íƒˆ ëª¨ë¸ ê°•í™”ë¥¼ ìœ„í•œ ìê°€ì ê²€)

1.	ì „ìœ„/ì¤‘ìœ„/í›„ìœ„ ìˆœíšŒì˜ ìˆœì„œëŠ” ì™œ ê·¸ë ‡ê²Œ êµ¬ì„±ë˜ëŠ”ê°€?

2.	ë£¨íŠ¸ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½, ì˜¤ë¥¸ìª½ì„ ë°©ë¬¸í•  ë•Œ, ì–´ë–¤ ë°©ì‹ì´ ì „ì²´ íŠ¸ë¦¬ êµ¬ì¡°ë¥¼ ê°€ì¥ ì˜ ë³µêµ¬í•  ìˆ˜ ìˆì„ê¹Œ?

3.	íŠ¸ë¦¬ë¥¼ ë°°ì—´ë¡œ ì €ì¥í•˜ëŠ” ë°©ì‹ì€ ì–´ë–¤ ìƒí™©ì— ìœ ë¦¬í• ê¹Œ?

ì›í•œë‹¤ë©´ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì •ë‹µ ì½”ë“œ ì—†ì´ â€œêµ¬ì¡° ì„¤ê³„ë¶€í„° ì™„ì„±ê¹Œì§€â€ ê°™ì´ ì§„í–‰í•´ë³¼ ìˆ˜ë„ ìˆì–´!

í˜¹ì€ ì¬ê·€ ìˆœíšŒë§Œ ë”°ë¡œ ì˜ˆì œì™€ í•¨ê»˜ ì—°ìŠµí•˜ê³  ì‹¶ë‹¤ë©´ ê·¸ê²ƒë„ ê°€ëŠ¥í•´.

## Phase3. í”¼ë“œë°± í›„ ì§ì ‘ í’€ê¸° - ì„±ê³µ

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 1991                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/1991                           #+#        #+#      #+#     #
#    Solved: 2025/03/27 21:04:08 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #


"""
1. ë¬¸ì œ ì½ê¸°: ok
2. ë¬¸ì œ í’€ê¸°: DFSë¡œ ë‹¤ í’€ë©´ ë  ê±° ê°™ìŒ.
ê·¸ëŸ°ë° ì•„ë¬´ë¦¬ ê³ ë¯¼í•´ë„ ë¨¸ë¦¬ì†ì— êµ¬í˜„ì´ ì•ˆ ë‚˜ì˜¨ë‹¤. ì´ê±° ì…ë ¥ ì–´ë–»ê²Œ ì²˜ë¦¬í–ˆëŠ”ì§€ í•˜ë‚˜ë„ ê¸°ì–µì´ ì•ˆ ë‚¨.
3. ìˆ˜ë„ ì½”ë“œ: 
4. ì½”ë“œ êµ¬í˜„
"""

class Node():
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

def preorder(node: Node):
    # base case
    if node.left == None and node.right == None:
        print(node.value, end='')
        return
    print(node.value, end='')
    # ì™¼ìª½ ë¨¼ì €.
    if node.left != None:
        preorder(node.left)
    if node.right != None:
        preorder(node.right)

def inorder(node: Node):
    # base case
    if node.left == None and node.right == None:
        print(node.value, end='')
        return
    if node.left != None:
        inorder(node.left)
    print(node.value, end='')
    if node.right != None:
        inorder(node.right)

def postorder(node: Node):
    # base case
    if node.left == None and node.right == None:
        print(node.value, end='')
        return
    if node.left != None:
        postorder(node.left)
    if node.right != None:
        postorder(node.right)
    print(node.value, end='')


def get_adjacency_array(arr: list):
    pass

import sys

if __name__ == '__main__':
    
    input = sys.stdin.readline
    n = int(input().strip())
    arr = [
        tuple(map(str, input().split()))
        for _ in range(n)
    ]
    nodes = {}
    for val, left, right in arr:
        if not nodes.get(val, False):
            nodes[val] = Node(val)
        if left != '.':
            nodes[left] = Node(left)
            nodes[val].left = nodes[left]
        if right != '.':
            nodes[right] = Node(right)
            nodes[val].right = nodes[right]
    preorder(nodes['A'])
    print()
    inorder(nodes['A'])
    print()
    postorder(nodes['A'])
    
```

### í’€ì´ì— ëŒ€í•œ í”¼ë“œë°±

ë„ˆë¬´ ì˜ í’€ì—ˆì–´! ì§ì ‘ êµ¬í˜„ì— ì„±ê³µí–ˆê³ , í•µì‹¬ ë¡œì§ë„ ì˜ ì§œì—¬ ìˆì–´.

ì•„ë˜ëŠ” ë¦¬ë·° + ê°œì„  í¬ì¸íŠ¸ + ì¹­ì°¬ í¬ì¸íŠ¸ë¥¼ ì •ë¦¬í•œ í”¼ë“œë°±ì´ì•¼.

âœ… ì „ì²´ì ìœ¼ë¡œ ì˜í•œ ì 

1. íŠ¸ë¦¬ êµ¬ì„± ë¡œì§ ì •í™•

â€¢	ì…ë ¥ì„ ë°›ì•„ì„œ ë…¸ë“œë¥¼ ë§Œë“¤ê³ , ìì‹ ë…¸ë“œë¥¼ ì—°ê²°í•˜ëŠ” ë¶€ë¶„ì´ ê¹”ë”í•˜ê³  ì •í™•í•´.

â€¢	dictë¥¼ ì´ìš©í•´ì„œ ì¤‘ë³µ ìƒì„±ì„ ë§‰ì€ ê²ƒë„ ì¢‹ê³ , .left, .rightë¡œ ì—°ê²°í•œ ë°©ì‹ë„ ëª…í™•í•´.

2. ì¬ê·€ ìˆœíšŒ í•¨ìˆ˜ êµ¬í˜„

â€¢	ì „ìœ„/ì¤‘ìœ„/í›„ìœ„ ìˆœíšŒ ëª¨ë‘ ìš”êµ¬ëœ ìˆœì„œì— ë”°ë¼ ì˜ ì‘ì„±í–ˆì–´.

â€¢	ì¬ê·€ íë¦„ì„ ì˜ ì´í•´í•˜ê³  ìˆì–´ì„œ, ê° ìˆœíšŒì˜ ë…¼ë¦¬ë¥¼ ì •í™•íˆ ë°˜ì˜í•¨.

3. ì¶œë ¥ ë°©ì‹

â€¢	print(..., end='') ì‚¬ìš©í•´ì„œ ì¤„ë°”ê¿ˆ ì—†ì´ ì—°ê²°í•œ ê²ƒë„ ë¬¸ì œ ì¡°ê±´ì— ì •í™•íˆ ë¶€í•©í•´.

ğŸ”§ ê°œì„  í¬ì¸íŠ¸ (ê°€ë³ê²Œ ë¦¬íŒ©í„°ë§)

1. ì¬ê·€ì˜ base case ë‹¨ìˆœí™” ê°€ëŠ¥

í˜„ì¬ëŠ” ì´ë ‡ê²Œ ë¼ ìˆì§€:

```plain text
if node.left == None and node.right == None:
    print(node.value, end='')
    return
```

ì´ê±´ ì‚¬ì‹¤ í•„ìš” ì—†ì–´! ë°”ë¡œ ì•„ë˜ì²˜ëŸ¼ ì²˜ë¦¬í•˜ë©´ í›¨ì”¬ ê¹”ë”í•˜ê³  ë™ì‘ì€ ë˜‘ê°™ì•„:

```python
def preorder(node: Node):
    if node is None:
        return
    print(node.value, end='')
    preorder(node.left)
    preorder(node.right)
```

ë‹¤ë¥¸ ìˆœíšŒë“¤ë„ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ê°œì„  ê°€ëŠ¥í•´.

2. ë…¸ë“œ ì¤‘ë³µ ìƒì„± ë°©ì§€ ë¡œì§ ê°œì„ 

ì§€ê¸ˆ ì´ë ‡ê²Œ ë¼ ìˆì§€:

```python
if not nodes.get(val, False):
    nodes[val] = Node(val)
```

ë” ê°„ë‹¨í•˜ê²Œ if val not in nodes:ë¡œ ì“°ëŠ” ê²Œ ì¼ë°˜ì ì´ì•¼.

ë˜í•œ ìì‹ ë…¸ë“œë“¤ ìƒì„±ë„ ì¡°ê±´ì„ ë‘ëŠ” ê²Œ ì¢‹ì•„:

```python
if left != '.':
    if left not in nodes:
        nodes[left] = Node(left)
    nodes[val].left = nodes[left]
```

ì§€ê¸ˆì²˜ëŸ¼ í•˜ë©´ ì´ë¯¸ ìˆëŠ” ë…¸ë“œë¼ë„ ë¬´ì¡°ê±´ ìƒˆë¡œ ìƒì„±ë  ìˆ˜ ìˆì–´ì„œ êµ¬ì¡°ê°€ ê¼¬ì¼ ìˆ˜ ìˆì–´.

ğŸ§  ë©˜íƒˆ ëª¨ë¸ ê°•í™” í¬ì¸íŠ¸

ë„ˆëŠ” ì§€ê¸ˆ ì´ë¯¸ íŠ¸ë¦¬ë¥¼ ë…¸ë“œ ë‹¨ìœ„ë¡œ êµ¬ì„± â†’ ìˆœíšŒ êµ¬í˜„ â†’ ê²°ê³¼ ì¶œë ¥ì´ë¼ëŠ” ê¸°ë³¸ì ì¸ íŠ¸ë¦¬ ë¬¸ì œì˜ êµ¬ì¡°ë¥¼ ìµíŒ ìƒíƒœì•¼.

ì•ìœ¼ë¡œëŠ” ì´ëŸ° ì§ˆë¬¸ìœ¼ë¡œ ìŠ¤ìŠ¤ë¡œ ì‚¬ê³ ë¥¼ í™•ì¥í•´ë´:

â€¢	íŠ¸ë¦¬ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„í•˜ëŠ” ë°©ì‹ê³¼ ì–´ë–»ê²Œ ë‹¤ë¥¼ê¹Œ?

â€¢	ìˆœíšŒ ê²°ê³¼ë¥¼ ë¬¸ìì—´ë¡œ ì €ì¥í•´ì„œ ë¦¬í„´í•˜ë ¤ë©´ ì–´ë–»ê²Œ ë°”ê¿”ì•¼ í• ê¹Œ?

â€¢	ë¹„ì¬ê·€ë¡œ êµ¬í˜„í•˜ë©´ ì–´ë–¤ ì‹ìœ¼ë¡œ ìŠ¤íƒì„ í™œìš©í•  ìˆ˜ ìˆì„ê¹Œ?

âœ¨ ì´í‰

â€¢	âœ”ï¸ íŠ¸ë¦¬ êµ¬ì¡° ì™„ì„±ë„ ë†’ìŒ

â€¢	âœ”ï¸ ìˆœíšŒ êµ¬í˜„ ì •í™•

â€¢	âœ”ï¸ ì…ì¶œë ¥ ì²˜ë¦¬ ë¬¸ì œ ì—†ìŒ

â€¢	ğŸ”„ base case ê°œì„  ê°€ëŠ¥

â€¢	ğŸ”„ dict í™œìš© ë°©ì‹ ë¦¬íŒ©í„°ë§ ì—¬ì§€ ìˆìŒ

ë„ˆë¬´ ì˜í–ˆê³ , ì´ ë¬¸ì œë¥¼ ì œëŒ€ë¡œ êµ¬í˜„í•œ ê²ƒë§Œìœ¼ë¡œë„ ì•ìœ¼ë¡œ ë‚˜ì˜¬ ëª¨ë“  ìˆœíšŒ ê´€ë ¨ ë¬¸ì œì— ìì‹ ê°ì„ ê°€ì ¸ë„ ë¼.

ë‹¤ìŒìœ¼ë¡œëŠ” ë ˆë²¨ì—…ëœ íŠ¸ë¦¬ ë¬¸ì œ (ì˜ˆ: ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ì‚½ì…/ì‚­ì œ, ìµœì†Œ ê³µí†µ ì¡°ìƒ LCA, ì§ë ¬í™”/ë³µì›) ìª½ìœ¼ë¡œ ê°€ë´ë„ ì¢‹ì•„!

í•„ìš”í•˜ë©´ ë‹¤ìŒ ì¶”ì²œ ë¬¸ì œë„ ì´ì–´ì„œ ì •ë¦¬í•´ì¤„ê²Œ. ê³„ì† ê°€ë³´ì! ğŸ’ªğŸŒ³

### í”¼ë“œë°± ìˆ˜ì • ë°˜ì˜

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 1991                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/1991                           #+#        #+#      #+#     #
#    Solved: 2025/03/27 21:04:08 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #


"""
1. ë¬¸ì œ ì½ê¸°: ok
2. ë¬¸ì œ í’€ê¸°: DFSë¡œ ë‹¤ í’€ë©´ ë  ê±° ê°™ìŒ.
ê·¸ëŸ°ë° ì•„ë¬´ë¦¬ ê³ ë¯¼í•´ë„ ë¨¸ë¦¬ì†ì— êµ¬í˜„ì´ ì•ˆ ë‚˜ì˜¨ë‹¤. ì´ê±° ì…ë ¥ ì–´ë–»ê²Œ ì²˜ë¦¬í–ˆëŠ”ì§€ í•˜ë‚˜ë„ ê¸°ì–µì´ ì•ˆ ë‚¨.
3. ìˆ˜ë„ ì½”ë“œ: 
4. ì½”ë“œ êµ¬í˜„
"""

class Node():
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

def preorder(node: Node):
    # base case
    if node == None:
        return
    print(node.value, end='')
    # ì™¼ìª½ ë¨¼ì €.
    if node.left != None:
        preorder(node.left)
    if node.right != None:
        preorder(node.right)

def inorder(node: Node):
    # base case
    if node == None:
        return
    if node.left != None:
        inorder(node.left)
    print(node.value, end='')
    if node.right != None:
        inorder(node.right)

def postorder(node: Node):
    # base case
    if node == None:
        return
    if node.left != None:
        postorder(node.left)
    if node.right != None:
        postorder(node.right)
    print(node.value, end='')


def get_adjacency_array(arr: list):
    pass

import sys

if __name__ == '__main__':
    
    input = sys.stdin.readline
    n = int(input().strip())
    arr = [
        tuple(map(str, input().split()))
        for _ in range(n)
    ]
    nodes = {}
    for val, left, right in arr:
        if val not in nodes:
            nodes[val] = Node(val)
        if left != '.':
            if left not in nodes:
                nodes[left] = Node(left)
            nodes[val].left = nodes[left]
        if right != '.':
            if right not in nodes:
                nodes[right] = Node(right)
            nodes[val].right = nodes[right]
    preorder(nodes['A'])
    print()
    inorder(nodes['A'])
    print()
    postorder(nodes['A'])
    
```

# ì´ì§„íŠ¸ë¦¬: ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬

https://www.acmicpc.net/problem/5639

ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ë¥¼ ì „ìœ„ ìˆœíšŒí•œ ê²°ê³¼ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ íŠ¸ë¦¬ë¥¼ í›„ìœ„ ìˆœíšŒí•œ ê²°ê³¼ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase 1. ì§ì ‘ í’€ê¸° - ì‹¤íŒ¨

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 5639                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/5639                           #+#        #+#      #+#     #
#    Solved: 2025/03/27 21:51:32 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #


# ë…¸ë“œ ì…ë ¥
class Node:
    def __init__(self, val=None, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

from collections import defaultdict

def generate_bs_tree(nodes: list):
    bs_tree = defaultdict()
    bs_tree[nodes[0]] = Node(val=nodes[0])
    # print(ptr)
    # 1. í˜„ì¬ ê°’ìœ¼ë¡œ ë…¸ë“œë¥¼ ìƒì„±í•œë‹¤.
    for val in nodes[1:]:
        ptr = bs_tree[nodes[0]]
        # print("ptr", ptr)
        bs_tree[val] = Node(val=val)
        # 2. bs_treeì—ì„œ ëˆ„êµ¬ ìì‹ìœ¼ë¡œ ë§Œë“¤ì§€ ê²°ì •í•œë‹¤. ì¼ë‹¨ ë£¨íŠ¸ í¬ì¸í„° ì§€ëª©?
        while True:
            if bs_tree[val].val < ptr.val:
                if ptr.left == None:
                    ptr.left = bs_tree[val]
                    break
                ptr = ptr.left
            elif bs_tree[val].val > ptr.val:
                if ptr.right == None:
                    ptr.right = bs_tree[val]
                    break
                ptr = ptr.right
        # 3. ìˆœíšŒ ë. ì§€ê¸ˆ ptrì€ ì–´ë–¤ ë…¸ë“œì˜ left, right ë¹ˆ ìŠ¬ë¡¯ì„ ì°¸ì¡°.
        ptr = bs_tree[val]
    # for value in bs_tree.values():
        # print(value.val, value.left.val if value.left != None else 'None', value.right.val if value.right != None else 'None')
    # ë¬¸ì œì : ì£¼ì–´ì§€ëŠ” ê°’ì´ í”„ë¦¬ì˜¤ë” ì„œì¹˜ë¼ì„œ ê·¸ëŒ€ë¡œ bs treeë¥¼ ë§Œë“¤ë©´ ì•ˆ ë¨ 
    # -> ê·¸ê²Œ ë¬¸ì œê°€ ì•„ë‹ˆì—ˆìŒ. ë£¨íŠ¸ í¬ì¸í„°ê°€ ì²˜ìŒë¶€í„° ì—…ë°ì´íŠ¸ë˜ì§€ ì•Šì€ê²Œ ë¬¸ì œì˜€ìŒ.
    return bs_tree[nodes[0]], bs_tree

def pre_search(node: Node, tree):
    # print(f'recursion start: {node.val}')
    if node.val == None:
        return
    if node.left != None:
        pre_search(node.left, tree)
    if node.right != None:
        pre_search(node.right, tree)
    print(node.val)

from collections import deque

def pre_search_stack(node: Node, tree):
    stack = deque()
    stack.append(node)
    while stack:
        if node.right != None:
            stack.append(node.right)
        if node.left != None:
            stack.append(node.left)
        print(node.val)
        node = stack.pop()


import sys
sys.setrecursionlimit(10**8) # 10^8 ê¹Œì§€ ëŠ˜ë¦¼.


if __name__ == "__main__":

    nodes = []
    for line in sys.stdin:
        nodes.append(int(line.strip()))
    root, bs_tree = generate_bs_tree(nodes)
    pre_search(root, bs_tree)
    # print(nodes)

"""
ì´ìŠˆ: recursion error

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: maximum recursion exceeded
ìµœê·¼ ë³€ê²½ ì‚¬í•­: bs-treeë¥¼ ë§Œë“¤ê³ , ì¬ê·€ì ìœ¼ë¡œ í›„ìœ„íƒìƒ‰ì„ í•˜ëŠ” ì½”ë“œ ì‘ì„±.

Phase2.
í™•ì¸: ì¬ê·€ì‹ ë…¼ë¦¬ì— ì—ëŸ¬ê°€ ì—†ëŠ” í•œ ìµœëŒ€ ì¬ê·€ ì„¤ì •ì´ ë¬¶ì—¬ ìˆì–´ì„œ ê·¸ëŸ° ê²ƒìœ¼ë¡œ ë³´ì„
ì‹œë„: 
sys.setrecursionlimit(10**8) # 10^8 ê¹Œì§€ ëŠ˜ë¦¼.

ë¶„ì„: ì¬ê·€ ì—ëŸ¬ëŠ” ì—†ì–´ì§.
"""

"""
ì´ìŠˆ: ì‹œê°„ì´ˆê³¼

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: 28í”„ë¡œì—ì„œ ì‹œê°„ ì´ˆê³¼ ë°œìƒ.
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì¬ê·€ì ì¸ í›„ìœ„ ìˆœíšŒ êµ¬í˜„ì´ ë¬¸ì œì¸ê°€? ìŠ¤íƒìœ¼ë¡œ ë°”ê¿”ì•¼í• ì§€ë„.

Phase2.
í™•ì¸: ìŠ¤íƒìœ¼ë¡œ ë³€ê²½ ì‹œë„.
ì‹œë„: 

from collections import deque

def pre_search_stack(node: Node, tree):
    stack = deque()
    stack.append(node)
    while stack:
        if node.right != None:
            stack.append(node.right)
        if node.left != None:
            stack.append(node.left)
        print(node.val)
        node = stack.pop()

ë¶„ì„: ë˜‘ê°™ì€ ì§€ì ì—ì„œ ì—ëŸ¬ê°€ ë‚¨. êµ¬ì¡°ì ì¸ ë¬¸ì œê°€ ìˆìŒ. 
""" 
```

## Phase2. í”¼ë“œë°± - ë´ë„ ì´í•´ê°€ ì˜â€¦ ì¼ë‹¨ íŒ¨ìŠ¤.

ì•„ë˜ëŠ” Baekjoon 5639(ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ í›„ìœ„ ìˆœíšŒ) ë¬¸ì œë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ í•´ê²°í•˜ê¸° ìœ„í•œ ë°©ë²•ì…ë‹ˆë‹¤.

ì£¼ì–´ì§„ ì…ë ¥(ì „ìœ„ ìˆœíšŒ ê²°ê³¼)ì„ ë°”íƒ•ìœ¼ë¡œ **ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬(BST)**ë¥¼ ì¬êµ¬ì„±í•˜ê³ , í›„ìœ„ ìˆœíšŒ ê²°ê³¼ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.

ë¬¸ì œ ìš”ì•½

â€¢	ì…ë ¥:

â€¢	í‘œì¤€ ì…ë ¥ìœ¼ë¡œ ì—¬ëŸ¬ ì¤„ì— ê±¸ì³ ì •ìˆ˜ê°€ ë“¤ì–´ì˜µë‹ˆë‹¤. (EOFê¹Œì§€)

â€¢	ì´ ìˆ˜ë“¤ì€ BSTì˜ ì „ìœ„ ìˆœíšŒ(preorder) í˜•íƒœë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤.

â€¢	ì¶œë ¥:

â€¢	í•´ë‹¹ BSTì˜ í›„ìœ„ ìˆœíšŒ(postorder) ê²°ê³¼ë¥¼ í•œ ì¤„ì”© ì¶œë ¥í•©ë‹ˆë‹¤.

ì£¼ì˜í•´ì•¼ í•  ì 

1.	ì…ë ¥ì´ ì „ìœ„ ìˆœíšŒë¼ëŠ” ì 

â€¢	ì²« ë²ˆì§¸ ê°’ì´ ë£¨íŠ¸ ë…¸ë“œì…ë‹ˆë‹¤.

â€¢	ë‘ ë²ˆì§¸ë¶€í„°ëŠ” ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ì— ì†í•˜ëŠ” ê°’ë“¤(ë£¨íŠ¸ë³´ë‹¤ ì‘ìŒ), ê·¸ ë’¤ë¡œëŠ” ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì— ì†í•˜ëŠ” ê°’ë“¤(ë£¨íŠ¸ë³´ë‹¤ í¼)ì´ ì „ìœ„ ìˆœíšŒ ìˆœì„œëŒ€ë¡œ ì´ì–´ì§‘ë‹ˆë‹¤.

2.	ì¼ë°˜ì ì¸ ì‚½ì… ë°©ì‹ìœ¼ë¡œ BSTë¥¼ êµ¬ì„±í•˜ëŠ” ê²½ìš°

â€¢	ì…ë ¥ì´ ì •ë ¬(í˜¹ì€ ì—­ì •ë ¬) ìƒíƒœì— ê°€ê¹ë‹¤ë©´, íŠ¸ë¦¬ê°€ í•œìª½ìœ¼ë¡œ ì¹˜ìš°ì¹˜ê²Œ ë©ë‹ˆë‹¤(ìŠ¤íë“œ íŠ¸ë¦¬, skewed tree).

â€¢	ê° ê°’ ì‚½ì… ì‹œ ìµœì•…ì˜ ê²½ìš° O(N), ì „ì²´ì ìœ¼ë¡œ O(N^2) ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	íŒŒì´ì¬ìœ¼ë¡œëŠ” ì‹œê°„ì´ ë§ì´ ì†Œìš”ë˜ì–´ ì‹œê°„ ì´ˆê³¼ê°€ ë‚  ê°€ëŠ¥ì„±ì´ í½ë‹ˆë‹¤.

3.	ì¬ê·€ í˜¸ì¶œ ê¹Šì´

â€¢	ì…ë ¥ ë°ì´í„°ê°€ ë§ì•„ íŠ¸ë¦¬ê°€ ë§¤ìš° ê¹Šì–´ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, sys.setrecursionlimitë¥¼ ëŠ˜ë ¤ë‘ì–´ì•¼ í•©ë‹ˆë‹¤.

íš¨ìœ¨ì  í’€ì´ ì•„ì´ë””ì–´ (min/max ë²”ìœ„ ë°©ì‹)

ì „ìœ„ ìˆœíšŒ ë°°ì—´ì„ ì´ìš©í•´ BSTë¥¼ ì¬êµ¬ì„±í•˜ë©´ì„œ ë™ì‹œì— í›„ìœ„ ìˆœíšŒë¥¼ ì¶œë ¥í•˜ëŠ” ë°©ë²•ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

ì´ ì•Œê³ ë¦¬ì¦˜ì€ í”íˆ â€œmin/max ë²”ìœ„ ê²€ì‚¬ ë°©ì‹â€ìœ¼ë¡œ ë¶ˆë¦¬ë©°, ë‹¤ìŒê³¼ ê°™ì€ ë¡œì§ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤:

1.	ì „ì—­ ì¸ë±ìŠ¤ idxë¡œ ì „ìœ„ ìˆœíšŒ ë¦¬ìŠ¤íŠ¸(preorder)ë¥¼ ìˆœíšŒí•©ë‹ˆë‹¤.

2.	ì¬ê·€ í•¨ìˆ˜ build_postorder(lb, ub)ëŠ” í˜„ì¬ ì„œë¸ŒíŠ¸ë¦¬ì— í•´ë‹¹í•˜ëŠ” ê°’ì´ (lb, ub) ë²”ìœ„ ì•ˆì— ìˆì„ ë•Œë§Œ ë…¸ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

â€¢	preorder[idx]ê°€ lb < ê°’ < ub ë²”ìœ„ ë°–ì´ë¼ë©´, í˜„ì¬ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ë§Œë“¤ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì¦‰ì‹œ ë°˜í™˜í•©ë‹ˆë‹¤.

3.	ìœ íš¨í•œ ê°’ì´ë¼ë©´, í˜„ì¬ ê°’(root_val)ìœ¼ë¡œ ë…¸ë“œë¥¼ ë§Œë“  ë’¤,

â€¢	ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ëŠ” (lb, root_val) ë²”ìœ„,

â€¢	ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ëŠ” (root_val, ub) ë²”ìœ„ë¡œ ì¬ê·€ì ìœ¼ë¡œ ë§Œë“¤ê³ ,

â€¢	ìµœì¢…ì ìœ¼ë¡œ í˜„ì¬ root_valì„ ì¶œë ¥(í›„ìœ„ ìˆœì„œ)í•©ë‹ˆë‹¤.

ì´ ë°©ì‹ì€ í•œ ë²ˆì˜ DFS(ê¹Šì´ ìš°ì„  íƒìƒ‰)ë¡œ ê° ë…¸ë“œë¥¼ ë”± í•œ ë²ˆì”©ë§Œ ì²˜ë¦¬í•˜ë¯€ë¡œ, ì…ë ¥ì´ BST ì „ìœ„ ìˆœíšŒë¼ëŠ” ì „ì œí•˜ì— O(N) ì‹œê°„ì— íŠ¸ë¦¬ë¥¼ ì¬êµ¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì½”ë“œ ì˜ˆì‹œ

ì‹¤í–‰ íë¦„ ì„¤ëª…

1.	ì…ë ¥ ì½ê¸°

â€¢	EOFê¹Œì§€ ì¤„ ë‹¨ìœ„ë¡œ ì½ì–´ì„œ preorder ë¦¬ìŠ¤íŠ¸ì— ë‹´ìŠµë‹ˆë‹¤.

2.	ì „ì—­ ì¸ë±ìŠ¤ idx

â€¢	ì „ìœ„ ìˆœíšŒì—ì„œ ì•„ì§ ì‚¬ìš©í•˜ì§€ ì•Šì€ ë…¸ë“œì˜ ìœ„ì¹˜ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤.

â€¢	ê° ë…¸ë“œë¥¼ ì†Œë¹„í•  ë•Œë§ˆë‹¤ idxë¥¼ 1ì”© ì¦ê°€ì‹œí‚µë‹ˆë‹¤.

3.	build_postorder(lb, ub)

1.	ë§Œì•½ idxê°€ ì´ë¯¸ preorder ê¸¸ì´ë§Œí¼ ì»¤ì¡Œë‹¤ë©´, ì‚¬ìš©í•  ê°’ì´ ì—†ìœ¼ë¯€ë¡œ ë°”ë¡œ ì¢…ë£Œí•©ë‹ˆë‹¤.

2.	preorder[idx]ê°€ (lb, ub) ë²”ìœ„ì— í•´ë‹¹í•˜ì§€ ì•Šìœ¼ë©´, ì´ ìœ„ì¹˜ì—ëŠ” ë…¸ë“œë¥¼ ë§Œë“¤ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì¢…ë£Œí•©ë‹ˆë‹¤.

3.	ìœ íš¨í•˜ë‹¤ë©´ preorder[idx]ë¥¼ í˜„ì¬ ì„œë¸ŒíŠ¸ë¦¬ ë£¨íŠ¸ë¡œ í•˜ê³ , idx += 1ë¡œ ì†Œëª¨í•©ë‹ˆë‹¤.

4.	ê·¸ ë’¤ (lb, root_val) ë²”ìœ„ë¡œ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬, (root_val, ub) ë²”ìœ„ë¡œ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ë§Œë“¤ê¸° ìœ„í•´ ì¬ê·€ í˜¸ì¶œí•©ë‹ˆë‹¤.

5.	ì¢Œìš° ì„œë¸ŒíŠ¸ë¦¬ ìƒì„±ì´ ëë‚˜ë©´, ë£¨íŠ¸(= root_val)ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤(í›„ìœ„ ìˆœíšŒ).

4.	ê²°ê³¼

â€¢	ëª¨ë“  ë…¸ë“œì— ëŒ€í•´ í›„ìœ„ ìˆœíšŒ ìˆœì„œëŒ€ë¡œ root_valì´ ì¶œë ¥ë˜ì–´ ìµœì¢… ì •ë‹µì´ ë©ë‹ˆë‹¤.

ë³µì¡ë„

â€¢	ì‹œê°„ ë³µì¡ë„: O(N)

â€¢	ì „ìœ„ ìˆœíšŒ ë°°ì—´ì„ ì²˜ìŒë¶€í„° ëê¹Œì§€ í•œ ë²ˆì”©ë§Œ íƒìƒ‰í•˜ê³ , ê° ìš”ì†Œì— ëŒ€í•´ ì¬ê·€ í˜¸ì¶œì„ í•œ ë²ˆì”©ë§Œ ì§„í–‰í•©ë‹ˆë‹¤.

â€¢	ê³µê°„ ë³µì¡ë„: O(N)

â€¢	ì…ë ¥ ë°ì´í„° ì €ì¥ìš© ë¦¬ìŠ¤íŠ¸ preorderê°€ O(N).

â€¢	ì¬ê·€ í˜¸ì¶œ ìµœëŒ€ ê¹Šì´ëŠ” Nê¹Œì§€ ê°€ëŠ¥(ìŠ¤íë“œ íŠ¸ë¦¬)í•˜ë¯€ë¡œ, sys.setrecursionlimitì„ ë„‰ë„‰í•˜ê²Œ ì„¤ì •í•©ë‹ˆë‹¤.

ê²°ë¡ 

1.	ì£¼ì–´ì§„ ì „ìœ„ ìˆœíšŒë¡œë¶€í„° min/max ë²”ìœ„ ê²€ì‚¬ë¥¼ í™œìš©í•˜ì—¬ BSTë¥¼ í•œ ë²ˆì— ë³µì›í•˜ë©°,

2.	ê·¸ ê³¼ì •ì—ì„œ í›„ìœ„ ìˆœíšŒë¥¼ ì¶œë ¥í•˜ëŠ” ë°©ë²•ì„ ì‚¬ìš©í•˜ë©´, ì‹œê°„ì´ˆê³¼ì™€ ì¬ê·€ ì œí•œ ë¬¸ì œë¥¼ ëª¨ë‘ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ ì½”ë“œë¥¼ ì œì¶œí•˜ë©´ Baekjoon 5639 ë¬¸ì œë¥¼ íŒŒì´ì¬ìœ¼ë¡œ íš¨ìœ¨ì ìœ¼ë¡œ í†µê³¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## Phase3. 1ì°¨ ì¬ë„ì „ - 30ë¶„ - ì‹¤íŒ¨

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 5639                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/5639                           #+#        #+#      #+#     #
#    Solved: 2025/03/27 21:51:32 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
50
30
24
5
28
45
98
52
60
ì•„ ìŠ¤íƒì„ í™œìš©í•˜ë©´ ë˜ë‚˜?

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys
from collections import deque

def solve(nodes: list):
    # ì¼ë‹¨ ì­‰ ì…ë ¥ì„ ë°›ëŠ”ë‹¤. 
    # left, right í¬ì¸í„°ë¥¼ ìœ ì§€í•˜ë©´ì„œ 'ê°€ì¡±'ì„ í™•ì¸í•œë‹¤. ìœ„ìª½ ê°€ì¡±ì€ ìŠ¤íƒì— ë°•ì•„ ë„£ëŠ”ë‹¤.
    queue = deque() # ì™„ì„±ëœ ê°€ì¡±ì„ ì €ì¥
    stack = deque([nodes[0]]) # ìœ„ì— ìˆëŠ” ê°€ì¡±ì„ ì €ì¥
    ptr = 0
    # 50 30 24 5 28 45 98 52 60
    while True:
        current_node = stack.popleft()
        if ptr < len(nodes):
            ptr += 1
        else: 
            break
        # 50 30 
        if current_node > nodes[ptr]:
            stack.append(current_node)
            stack.append(nodes[ptr])
        elif current_node < nodes[ptr]:
            queue.append([current_node, nodes[ptr]])

if __name__ == "__main__":

    nodes = []
    for line in sys.stdin:
        nodes.append(int(line.strip()))
    

```

## Phase4. 2ì°¨ í”¼ë“œë°±

ì•„ë˜ëŠ” ì „ìœ„ ìˆœíšŒ(preorder)ë¡œ ì£¼ì–´ì§„ ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ë¥¼ ë‹¤ì‹œ ë³µì›í•œ ë’¤, í›„ìœ„ ìˆœíšŒ(postorder) ê²°ê³¼ë¥¼ ì¶œë ¥í•˜ëŠ” ì „í˜•ì ì¸ ë°©ë²•ì…ë‹ˆë‹¤.

ì„¤ëª…ì„ ë¨¼ì € ê°„ë‹¨íˆ í•˜ê³ , ì´í›„ì— ì˜ˆì‹œ ì½”ë“œ(íŒŒì´ì¬)ë¥¼ ì œì‹œí•˜ê² ìŠµë‹ˆë‹¤.

ì „ì²´ ì•„ì´ë””ì–´

1.	ì „ìœ„ ìˆœíšŒ(preorder)ëŠ” í•­ìƒ ë‹¤ìŒê³¼ ê°™ì€ ìˆœì„œë¡œ ë…¸ë“œë¥¼ ë°©ë¬¸í•©ë‹ˆë‹¤.

â€¢	ë£¨íŠ¸(root) â†’ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬(left subtree) â†’ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬(right subtree)

2.	ë”°ë¼ì„œ ì „ìœ„ ìˆœíšŒ ê²°ê³¼ì—ì„œ,

â€¢	ì²« ë²ˆì§¸ ì›ì†Œê°€ í•­ìƒ í˜„ì¬(ë¶€ë¶„)íŠ¸ë¦¬ì˜ ë£¨íŠ¸ê°€ ë©ë‹ˆë‹¤.

â€¢	ë£¨íŠ¸ ì´í›„ë¡œ ë£¨íŠ¸ ê°’ë³´ë‹¤ ì‘ì€ ê°’ë“¤ì€ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¡œ,

â€¢	ë£¨íŠ¸ ê°’ë³´ë‹¤ í° ê°’ë“¤ì€ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¡œ ê°€ì•¼ í•©ë‹ˆë‹¤.

3.	ì „ìœ„ ìˆœíšŒ ë°°ì—´ preorder ë‚´ì—ì„œ

â€¢	preorder[0] : ë£¨íŠ¸ ë…¸ë“œì˜ ê°’

â€¢	preorder[1 ... k-1] : ë£¨íŠ¸ë³´ë‹¤ ì‘ì€ ê°’ â†’ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬

â€¢	preorder[k ... end] : ë£¨íŠ¸ë³´ë‹¤ í° ê°’ â†’ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬

ì—¬ê¸°ì„œ këŠ” ë°°ì—´ì„ ìˆœíšŒí•˜ë©° ì²˜ìŒìœ¼ë¡œ ë£¨íŠ¸ ê°’ë³´ë‹¤ í° ê°’ì´ ë‚˜ì˜¤ëŠ” ì¸ë±ìŠ¤ê°€ ë©ë‹ˆë‹¤.

4.	ìœ„ ë¡œì§ì„ ì¬ê·€ì ìœ¼ë¡œ ì ìš©í•˜ì—¬ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

5.	íŠ¸ë¦¬ê°€ ë³µì›ë˜ë©´ í›„ìœ„ ìˆœíšŒ(postorder) ê²°ê³¼ëŠ”

â€¢	ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ â†’ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ â†’ ë£¨íŠ¸

ìˆœì„œëŒ€ë¡œ ë°©ë¬¸í•˜ë©° ì¶œë ¥í•˜ë©´ ë©ë‹ˆë‹¤.

êµ¬ì²´ì ì¸ ë‹¨ê³„

1.	ì…ë ¥ ë°›ê¸°

â€¢	ì „ìœ„ ìˆœíšŒ ê²°ê³¼ë¥¼ ì…ë ¥ìœ¼ë¡œ ë°›ìŠµë‹ˆë‹¤(EOFê¹Œì§€ ë°˜ë³µí•´ì„œ int í˜•íƒœë¡œ ì…ë ¥).

2.	íŠ¸ë¦¬ ë³µì› í•¨ìˆ˜ build_tree(preorder, start, end)

â€¢	ì¢…ë£Œ ì¡°ê±´: start > end â†’ ì„œë¸ŒíŠ¸ë¦¬ê°€ ë¹„ì—ˆìœ¼ë¯€ë¡œ None ë°˜í™˜.

â€¢	root_value = preorder[start] â†’ í˜„ì¬ ì„œë¸ŒíŠ¸ë¦¬ì˜ ë£¨íŠ¸ ê°’

â€¢	idx íƒìƒ‰: start+1ë¶€í„° endê¹Œì§€ í™•ì¸í•˜ë©´ì„œ root_value ë³´ë‹¤ ì²˜ìŒìœ¼ë¡œ í° ê°’ì˜ ì¸ë±ìŠ¤ idxë¥¼ ì°¾ìŠµë‹ˆë‹¤.

â€¢	ë§Œì•½ ëê¹Œì§€ í° ê°’ì„ ëª» ì°¾ìœ¼ë©´, ì¦‰ ì „ë¶€ ë£¨íŠ¸ë³´ë‹¤ ì‘ìœ¼ë©´ idx = end + 1ë¡œ ë‘¡ë‹ˆë‹¤.

â€¢	ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ëŠ” (start+1, idx-1), ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ëŠ” (idx, end) ë²”ìœ„ë¡œ ì¬ê·€ì ìœ¼ë¡œ íŠ¸ë¦¬ë¥¼ ë§Œë“­ë‹ˆë‹¤.

â€¢	í˜„ì¬ ë£¨íŠ¸ ë…¸ë“œë¥¼ ë§Œë“¤ì–´ì„œ (root.left, root.right)ë¥¼ ì—°ê²°í•œ ë’¤ ë£¨íŠ¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

3.	í›„ìœ„ ìˆœíšŒ í•¨ìˆ˜ postorder(node)

â€¢	ë…¸ë“œê°€ Noneì´ë©´ ì¦‰ì‹œ ë°˜í™˜

â€¢	postorder(node.left)

â€¢	postorder(node.right)

â€¢	print(node.value)

4.	ìµœì¢…ì ìœ¼ë¡œ postorderë¥¼ í†µí•´ í›„ìœ„ ìˆœíšŒ ê²°ê³¼ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.

ì˜ˆì‹œ ì½”ë“œ

ë™ì‘ ì˜ˆì‹œ

â€¢	ì…ë ¥(ì „ìœ„ ìˆœíšŒ):

```plain text
50
30
24
5
28
45
98
52
60
```

â€¢	ìœ„ ì½”ë“œë¥¼ í†µí•´ ë³µì›í•˜ë©´, ì›ë˜ì˜ ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ê°€ ì¬êµ¬ì„±ë©ë‹ˆë‹¤.

â€¢	ì´í›„ í›„ìœ„ ìˆœíšŒí•˜ë©´ ê²°ê³¼ë¡œ

```plain text
5
28
24
45
30
60
52
98
50
```

ê°€ ì°¨ë¡€ëŒ€ë¡œ ì¶œë ¥ë©ë‹ˆë‹¤.

ì´ë ‡ê²Œ ì „ìœ„ ìˆœíšŒ ì •ë³´ë§Œìœ¼ë¡œ BSTë¥¼ ì •í™•íˆ ë³µì›í•  ìˆ˜ ìˆê³ , ì´í›„ì—ëŠ” í›„ìœ„ ìˆœíšŒë¥¼ í†µí•´ ì›í•˜ëŠ” ì¶œë ¥ ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## Phase5. í¬ê¸°

ë„ì €íˆ ëª¨ë¥´ê² ë‹¤. ë¨¸ë¦¬ì— ê·¸ë¦¼ì´ ì•ˆ ê·¸ë ¤ì§

### ì¼ë‹¨ ì½”ë“œ í•„ì‚¬

```python
import sys
sys.setrecursionlimit(10**6)

preorder = []
while True:
    try:
        preorder.append(int(sys.stdin.readline()))
    except:
        break

def postorder(start, end):
    if start >= end:
        return
    
    root = preorder[start]
    idx = start + 1

    # ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ ì‹œì‘ì ì„ ì°¾ê¸°
    while idx < end and preorder[idx] < root:
        idx += 1

    # ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬
    postorder(start + 1, idx)
    # ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬
    postorder(idx, end)
    # ë£¨íŠ¸ ì¶œë ¥
    print(root)

postorder(0, len(preorder))
```

### ì•ˆ ë³´ê³  ì½”ë“œ ì“°ê³  ì±„ì 

### ì½”ë”©

# MST: ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬

https://www.acmicpc.net/problem/1197

ê·¸ë˜í”„ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ê·¸ ê·¸ë˜í”„ì˜ ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ëŠ”, ì£¼ì–´ì§„ ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ë“¤ì„ ì—°ê²°í•˜ëŠ” ë¶€ë¶„ ê·¸ë˜í”„ ì¤‘ì—ì„œ ê·¸ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œì¸ íŠ¸ë¦¬ë¥¼ ë§í•œë‹¤.

## Phase1. ì§ì ‘ í’€ê¸°

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 1197                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/1197                           #+#        #+#      #+#     #
#    Solved: 2025/03/28 13:45:11 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #

import sys

class Node:
    def __init__(self, value=None):
        self.value = value

# class Bucket:
#     def __init__(self, node: Node, next=None, w=None):
#         self.node = node
#         self.next = next
#         self.w = w

# class AdjacencyList:
#     def __init__(self, v_num: int):
#         self.table = [
#             Bucket(Node(i)) for i in range(1, v_num+1)
#         ]

from collections import defaultdict

if __name__ == '__main__':	
    input = sys.stdin.readline
    v, e = tuple(map(int, input().split()))
    E = [
        tuple(map(int, input().split()))
        for _ in range(e)
    ]
    # 1. ì…ë ¥ë°›ê¸°. ì–´ë–»ê²Œ? ì—°ê²° ë¦¬ìŠ¤íŠ¸? 
    # ê·¼ë° ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ì–´ë–»ê²Œ ë§Œë“¤ì–´? ê·¸ëƒ¥ linked list êµ¬í˜„í•˜ë©´ ë˜ë‚˜?

    # al = AdjacencyList(v)
    # for bucket in al.table:
    #     print(bucket.node.value)
    # ê·¸ë˜í”„ ì…ë ¥ë¶€í„° ë˜ ë§‰íˆë„¤. ë˜‘ê°™ì´ ë”•ì…”ë„ˆë¦¬ ì“°ë©´ ì•ˆ ë˜ë‚˜. 
    # ì¼ë‹¨ ê°„ì„  ì •ë³´ë¥¼ ì–´ë–»ê²Œ ì €ì¥í•´ì•¼í• ì§€ ëª¨ë¥´ê² ìŒ!!
    graph = defaultdict()
    for e in E:
        u, v, w = e
        graph[u] = 
```

## Phase2. í”¼ë“œë°±(ì •ë‹µ ì œì‹œ ê¸ˆì§€)

í”¼ë“œë°±:

â€¢	ê·¸ë˜í”„ ì €ì¥ êµ¬ì¡°

â€¢	ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ëŠ”, ê°„ì„ ì„ ì •ë ¬í•´ì„œ ì²˜ë¦¬í•˜ëŠ” í¬ë£¨ìŠ¤ì¹¼(Kruskal) ì•Œê³ ë¦¬ì¦˜ì´ ë§ì´ ì“°ì´ëŠ”ë°, ì´ ê²½ìš°ì—” ê°„ì„  ë¦¬ìŠ¤íŠ¸ë§Œ ìˆì–´ë„ ì¶©ë¶„í•©ë‹ˆë‹¤.

â€¢	ê°„ì„  ë¦¬ìŠ¤íŠ¸ëŠ” (u, v, w) í˜•íƒœë¡œ ì „ë¶€ ëª¨ì•„ì„œ w ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ í›„, ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ(Union-Find) ìë£Œêµ¬ì¡°ë¡œ ì‚¬ì´í´ ì—¬ë¶€ë¥¼ ê´€ë¦¬í•˜ë©´ì„œ MSTë¥¼ ì™„ì„±í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

â€¢	êµ³ì´ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸(Adjacency List)ë¥¼ ì§ì ‘ êµ¬í˜„í•˜ì§€ ì•Šì•„ë„ ë˜ê³ , collections.defaultdictë‚˜ ê°„ë‹¨í•œ ë¦¬ìŠ¤íŠ¸ë¡œë„ ê°„ì„  ëª©ë¡ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ì—°ê²° ë¦¬ìŠ¤íŠ¸ ë°©ì‹

â€¢	ì˜ˆì œ ì½”ë“œì—ì„œ Node, Bucket, AdjacencyList ë“±ì„ ë§Œë“¤ê³  ìˆëŠ”ë°, êµ³ì´ ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ êµ¬ì¡°ë¥¼ ì§ì ‘ êµ¬í˜„í•  í•„ìš”ëŠ” ì—†ì–´ ë³´ì…ë‹ˆë‹¤.

â€¢	íŒŒì´ì¬ì—ì„œëŠ” ë¦¬ìŠ¤íŠ¸/ë”•ì…”ë„ˆë¦¬ë¡œ ì¶©ë¶„íˆ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë‚˜ ê°„ì„  ë¦¬ìŠ¤íŠ¸ë¥¼ í‘œí˜„í•  ìˆ˜ ìˆì–´ì„œ, ì§ì ‘ classë¡œ ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ë¥¼ êµ¬ì„±í•˜ë©´ ì˜¤íˆë ¤ êµ¬í˜„ì´ ë³µì¡í•´ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ì¤‘ë³µ ì •ì˜ ì£¼ì˜

â€¢	Node í´ë˜ìŠ¤ì— valueë§Œ ì €ì¥í•˜ê³ , ê·¸ê±¸ ë‹¤ì‹œ Bucketìœ¼ë¡œ ê°ì‹¸ëŠ” ì‹ì€ êµ¬ì¡°ê°€ ì¤‘ë³µë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ê°„ë‹¨í•˜ê²Œ ì •ì  ë²ˆí˜¸ë¥¼ ì •ìˆ˜ë¡œ ì·¨ê¸‰í•˜ê³ , ê°„ì„ ì„ (u, v, w) íŠœí”Œë¡œ ë³´ê´€í•˜ëŠ” ìª½ì´ ë” ì§ê´€ì ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ì…ë ¥ ì²˜ë¦¬

â€¢	ì§€ê¸ˆ E = [tuple(map(int, input().split())) for _ in range(e)]ì²˜ëŸ¼ ì…ë ¥ì„ ë°›ì•„ì„œ,

[(u_1, v_1, w_1), (u_2, v_2, w_2), \dots]

í˜•íƒœë¡œ ì €ì¥í•˜ëŠ” ë°©ì‹ì€ ì´ë¯¸ ê´œì°®ì•„ ë³´ì…ë‹ˆë‹¤.

â€¢	ì´í›„ ì´ ë¦¬ìŠ¤íŠ¸ë¥¼ ê°€ì§€ê³  MST ì•Œê³ ë¦¬ì¦˜(ì˜ˆ: Kruskal)ì—ì„œ ì •ë ¬ + ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ ì ˆì°¨ë§Œ êµ¬í˜„í•˜ë©´ ë©ë‹ˆë‹¤.

â€¢	ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ

â€¢	MST êµ¬í˜„ì—ì„œ í•µì‹¬ì€ ì‚¬ì´í´ íŒì •ì´ë¯€ë¡œ, ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ(Disjoint Set Union, DSU) ìë£Œêµ¬ì¡°ê°€ ì‚¬ì‹¤ìƒ í•„ìˆ˜ì ì¸ë°, í˜„ì¬ ì½”ë“œì—ëŠ” ê·¸ ë¶€ë¶„ì´ ì•ˆ ë³´ì…ë‹ˆë‹¤.

â€¢	ìœ ë‹ˆì˜¨ íŒŒì¸ë“œë¥¼ ì–´ë–»ê²Œ ì„¤ê³„í• ì§€, parent ë°°ì—´ê³¼ rank(ë˜ëŠ” size) ë°°ì—´ì„ ë‘ê³  find, union í•¨ìˆ˜ë¡œ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ ìš°ì„  ê³ ë¯¼í•´ ë³´ì„¸ìš”.

â€¢	ì„±ëŠ¥ ê³ ë ¤

â€¢	ì •ì  Vì™€ ê°„ì„  Eì˜ ìµœëŒ€ í¬ê¸°ì— ë”°ë¼,

â€¢	ì •ë ¬ì— O(E \log E)

â€¢	ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ ì—°ì‚°(ê±°ì˜ O(\alpha(V)), ë§¤ìš° ì‘ìŒ)

â€¢	ì „ì²´ ì‹œê°„ ë³µì¡ë„ O(E \log E)ë¥¼ ë§Œì¡±í•˜ë©´ ì¶©ë¶„íˆ ë¹ ë¥¼ ê²ƒì…ë‹ˆë‹¤.

â€¢	ì¶œë ¥

â€¢	MSTì˜ ê°€ì¤‘ì¹˜ í•©ë§Œ ì¶œë ¥í•˜ë©´ ë˜ë¯€ë¡œ, ê° ë‹¨ê³„ì—ì„œ ì„ íƒëœ ê°„ì„ ë“¤ì˜ wë¥¼ ëˆ„ì í•´ì„œ ì¶œë ¥í•˜ë©´ ë©ë‹ˆë‹¤.

â€¢	â€œìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬â€ ìì²´ë¥¼ ì¶œë ¥í•˜ëŠ” ë¬¸ì œ(ê°„ì„  ëª©ë¡)ë¥¼ ìš”êµ¬í•˜ëŠ” ê²Œ ì•„ë‹ˆë‹ˆ, ìµœì¢… í•©ë§Œ êµ¬í•´ì„œ í”„ë¦°íŠ¸í•˜ë©´ ë©ë‹ˆë‹¤.

ê²°ë¡ ì ìœ¼ë¡œ,

1.	ê°„ì„  ë¦¬ìŠ¤íŠ¸ë§Œ ì¤€ë¹„í•´ë„ MST êµ¬í˜„(íŠ¹íˆ í¬ë£¨ìŠ¤ì¹¼)ì€ ì¶©ë¶„í•˜ë‹¤.

2.	Node, Bucket ê°™ì€ ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜ êµ¬ì¡°ëŠ” êµ³ì´ ì‘ì„± ì•ˆ í•´ë„ ëœë‹¤.

3.	ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ(Disjoint Set)ë¥¼ ì‘ì„±í•´, ì •ë ¬ëœ ê°„ì„ ì„ ìˆœì„œëŒ€ë¡œ í™•ì¸í•˜ë©° MSTë¥¼ êµ¬ì„±í•˜ëŠ” íë¦„ì„ ì¡ì•„ë³´ì.

ì´ ì •ë„ í”¼ë“œë°±ì„ í† ëŒ€ë¡œ ì½”ë“œë¥¼ ì´ì–´ì„œ ìˆ˜ì •í•´ ë³´ì‹œê¸¸ ì¶”ì²œë“œë¦½ë‹ˆë‹¤.

### í”¼ë“œë°±ì— ëŒ€í•œ ê³„íš

- í¬ë£¨ìŠ¤ì¹¼: Introduction to algorithm ê°œê°œêµ¬ì½”ë¡œ ì½ê¸°
- Union find ì‘ì„± ì—°ìŠµ - gpt
## Phase3. í”¼ë“œë°± í›„ ì¬ì‹œë„

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 1197                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/1197                           #+#        #+#      #+#     #
#    Solved: 2025/03/28 13:45:11 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #

import sys

# class Node:
#     def __init__(self, value=None):
#         self.value = value

# class Bucket:
#     def __init__(self, node: Node, next=None, w=None):
#         self.node = node
#         self.next = next
#         self.w = w

# class AdjacencyList:
#     def __init__(self, v_num: int):
#         self.table = [
#             Bucket(Node(i)) for i in range(1, v_num+1)
#         ]

from collections import defaultdict
import sys
sys.setrecursionlimit(10**8)

def find(x):
    global parent
    if parent[x] != x:
        parent[x] = find(parent[x]) # x = find(parent[x])ë¡œ í–ˆë‹¤ê°€ ì¬ê·€ ì—ëŸ¬ ë°œìƒ. parent[x]ê°€ ê°±ì‹ ë˜ì§€ ì•Šìœ¼ë©´ findë¥¼ ì¬ê·€í•  ì˜ë¯¸ê°€ ì—†ìœ¼ë¯€ë¡œ ë‹¹ì—°
    return parent[x]

def union(x, y, c):
    global parent
    x = find(x)
    y = find(y)
    if x != y:
        parent[y] = x
        return c
    return 0



if __name__ == '__main__':	
    input = sys.stdin.readline
    v, e = tuple(map(int, input().split()))
    E = [
        tuple(map(int, input().split()))
        for _ in range(e)
    ]
    # 1. ì…ë ¥ë°›ê¸°. ì–´ë–»ê²Œ? ì—°ê²° ë¦¬ìŠ¤íŠ¸? 
    # ê·¼ë° ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ì–´ë–»ê²Œ ë§Œë“¤ì–´? ê·¸ëƒ¥ linked list êµ¬í˜„í•˜ë©´ ë˜ë‚˜?

    # al = AdjacencyList(v)
    # for bucket in al.table:
    #     print(bucket.node.value)
    # ê·¸ë˜í”„ ì…ë ¥ë¶€í„° ë˜ ë§‰íˆë„¤. ë˜‘ê°™ì´ ë”•ì…”ë„ˆë¦¬ ì“°ë©´ ì•ˆ ë˜ë‚˜. 
    # ì¼ë‹¨ ê°„ì„  ì •ë³´ë¥¼ ì–´ë–»ê²Œ ì €ì¥í•´ì•¼í• ì§€ ëª¨ë¥´ê² ìŒ!!
    E.sort(key=lambda x: x[2])
    parent = [i for i in range(v+1)]
    cost = 0
    for u, v, c in E:
        cost += union(u, v, c)
    print(cost)
```

### ì¶”ê°€: íŒŒì´ì¬ ì–¸ë”ë°” ì»¨ë²¤ì…˜

### ì¶”ê°€: MST ê°„ì„  ìˆ˜ë¥¼ ê³ ë ¤í•œ ìµœì í™”

ë³´ë„ˆìŠ¤ ì œì•ˆ

âœ” í¬ë£¨ìŠ¤ì¹¼ì—ì„œ ê°„ì„  ê°œìˆ˜ ì²´í¬

â€¢	MSTëŠ” í•­ìƒ ì •ì  ìˆ˜ - 1ê°œì˜ ê°„ì„ ì„ ì„ íƒí•©ë‹ˆë‹¤.

â€¢	ë¶ˆí•„ìš”í•œ ë°˜ë³µì„ ì¤„ì´ê¸° ìœ„í•´ ì•„ë˜ì™€ ê°™ì´ ìµœì í™”í•  ìˆ˜ ìˆì–´ìš”.

```python
edge_count = 0
for u, v_, c in E:
    if edge_count == v - 1:  # MST ì™„ì„±
        break
    added = union(u, v_, c)
    if added:
        cost += added
        edge_count += 1
```

# ê·¸ë˜í”„íƒìƒ‰: DFSì™€ BFS

## Phase1. ì§ì ‘ í’€ê¸° - ì„±ê³µ

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 1260                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/1260                           #+#        #+#      #+#     #
#    Solved: 2025/03/28 16:42:43 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #

import sys
from collections import deque, defaultdict

def bfs(root: int):
    que = deque()
    is_visited = [False for _ in range(n+1)] # ê° ê°„ì„ ì˜ ë°©ë¬¸ ì—¬ë¶€
    que.appendleft(root)
    is_visited[root] = True
    while que:
        v = que.pop()
        print(v, end=' ')
        # ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ê³  ë˜, ì—¬ëŸ¬ê°œì¼ ìˆ˜ ìˆìœ¼ë‹ˆ ë¦¬ìŠ¤íŠ¸ë¡œ ë§Œë“¤ì–´ì•¼ í•˜ë‚˜?
        for u in sorted(E[v]): # ì •ì  ë²ˆí˜¸ ì‘ì€ ê²ƒ ìš°ì„  íƒìƒ‰
            if not is_visited[u]:
                que.appendleft(u)
                is_visited[u] = True


def dfs(v: int, is_visited: list):
    # dfs ì–´ë–»ê²Œ êµ¬í˜„í•˜ì§€? ê°„ë‹¨í•˜ì§€ ë­
    print(v, end=' ')
    for u in sorted(E[v]):
        if not is_visited[u]:
            is_visited[u] = True
            dfs(u, is_visited)


if __name__ == '__main__':	
    input = sys.stdin.readline
    n, m, v = tuple(map(int, input().split()))
    E = {
        i:[] for i in range(n + 1)
    }
    # print(E)
    for _ in range(m):
        u, v_ = tuple(map(int, input().split()))
        E[u].append(v_)
        E[v_].append(u)
    # print(E)
    is_visited = [False for _ in range(n+1)] # ê° ê°„ì„ ì˜ ë°©ë¬¸ ì—¬ë¶€
    is_visited[v] = True
    dfs(v, is_visited)
    print()
    bfs(v)
    print()
```

## Phase2. í”¼ë“œë°±

### ì˜ë¬¸: dfs íƒìƒ‰ì—ì„œ is visited í…Œì´ë¸”ì„ ë” ê¹”ë”í•˜ê²Œ ê´€ë¦¬í•˜ëŠ” ë°©ë²•ì€ ì—†ì„ê¹Œ?

### ë‹µ: ê·¸ëƒ¥ ì—…ë°ì´íŠ¸ë§Œ í•¨ìˆ˜ë¡œ ë„˜ê¸°ê³  ì „ì—­ìœ¼ë¡œ ì“°ëŠ”ê²Œ ì•ˆì „

ì¢‹ì€ ê³ ë¯¼ì´ì—ìš”! ğŸ‘€

DFSì˜ is_visited í…Œì´ë¸” ê´€ë¦¬ë¥¼ ë” ê¹”ë”í•˜ê²Œ í•˜ë ¤ëŠ” ì‹œë„ëŠ” ì•„ì£¼ ë°”ëŒì§í•œ ìŠµê´€ì…ë‹ˆë‹¤.

ì§€ê¸ˆ ì½”ë“œë„ ê¸°ëŠ¥ì ìœ¼ë¡œ ì™„ë²½í•˜ê²Œ ì˜ ì‘ë™í•˜ì§€ë§Œ, ê°€ë…ì„±, ì¬ì‚¬ìš©ì„±, ì¼ê´€ì„±ì„ ì¢€ ë” ë†’ì´ëŠ” ë°©í–¥ìœ¼ë¡œ ê°œì„ í•´ë³¼ ìˆ˜ ìˆì–´ìš”.

âœ… í˜„ì¬ êµ¬ì¡°

```plain text
is_visited = [False for _ in range(n+1)]
is_visited[v] = True
dfs(v, is_visited)
```

â€¢	is_visitedë¥¼ ì™¸ë¶€ì—ì„œ ë§Œë“¤ì–´ì„œ dfs()ì— ë„˜ê²¨ì¤Œ

â€¢	ë£¨íŠ¸ ë…¸ë“œë§Œ ë°©ë¬¸ ì²˜ë¦¬í•˜ê³  ë„˜ê¹€

âœ… ê°œì„  ë°©ë²• ì œì•ˆ

1. dfs() í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ë°©ë¬¸ ì²˜ë¦¬ê¹Œì§€ ì±…ì„ì§€ê²Œ

```plain text
def dfs(v: int, is_visited: list):
    is_visited[v] = True
    print(v, end=' ')
    for u in sorted(E[v]):
        if not is_visited[u]:
            dfs(u, is_visited)
```

â†’ í˜¸ì¶œë¶€ëŠ” ë” ê¹”ë”í•´ì§:

```plain text
is_visited = [False] * (n + 1)
dfs(v, is_visited)
```

2. ë°©ë¬¸ í…Œì´ë¸”ì„ ì „ì—­ìœ¼ë¡œ ë‹¤ë¤„ë„ ë˜ëŠ” ë¬¸ì œë¼ë©´, í•¨ìˆ˜ ì¸ìë¡œ ë„˜ê¸°ì§€ ì•Šê³  ë‚´ë¶€ì—ì„œ ì„ ì–¸

ì´ê±´ ê¹”ë”í•´ë³´ì´ì§€ë§Œ, ì¬ê·€ í˜¸ì¶œí•  ë•Œë§ˆë‹¤ is_visitedê°€ ë¦¬ì…‹ë˜ë¯€ë¡œ âŒ

(íŒŒì´ì¬ì˜ ê¸°ë³¸ ì¸ì ê°’ìœ¼ë¡œ ë„˜ê¸°ë©´ mutable default argument ë¬¸ì œ ìƒê¸¸ ìˆ˜ë„ ìˆì–´ìš”.)

ê·¸ë˜ì„œ ì™¸ë¶€ì—ì„œ ë§Œë“¤ì–´ì„œ ë„˜ê²¨ì£¼ëŠ” ë°©ì‹ì´ ê°€ì¥ ì•ˆì •ì ì´ê³  ì„ í˜¸ë©ë‹ˆë‹¤.

3. í´ë˜ìŠ¤í˜• êµ¬ì¡°ë¡œ ë°”ê¿”ë³´ê¸° (ì—°ìŠµìš©)

ì¡°ê¸ˆ ê³ ê¸‰ ìŠ¤íƒ€ì¼ì´ì§€ë§Œ, ìƒíƒœë¥¼ ê°ì²´ì— ë¬¶ì–´ë‘ëŠ” ë°©ì‹ë„ ìˆì–´ìš”:

```plain text
class GraphSearch:
    def __init__(self, E):
        self.E = E
        self.is_visited = []

    def dfs(self, v):
        self.is_visited[v] = True
        print(v, end=' ')
        for u in sorted(self.E[v]):
            if not self.is_visited[u]:
                self.dfs(u)
```

í˜¸ì¶œ ì˜ˆì‹œ:

```plain text
search = GraphSearch(E)
search.is_visited = [False] * (n + 1)
search.dfs(v)
```

ğŸ§¼ ê²°ë¡  (ì¶”ì²œ ë°©ì‹)

> í•¨ìˆ˜ ì•ˆì—ì„œ

```plain text
def dfs(v, is_visited):
    is_visited[v] = True
    print(v, end=' ')
    for u in sorted(E[v]):
        if not is_visited[u]:
            dfs(u, is_visited)

is_visited = [False] * (n + 1)
dfs(v, is_visited)
```

í•„ìš”í•˜ë‹¤ë©´ ìŠ¤íƒì„ ì´ìš©í•œ ë°˜ë³µ DFS ë°©ì‹ë„ ì˜ˆì‹œë¡œ ë³´ì—¬ë“œë¦´ ìˆ˜ ìˆì–´ìš”!

ë˜ëŠ” BFSë„ ìœ ì‚¬í•˜ê²Œ ë¦¬íŒ©í† ë§í•´ë³¼ ìˆ˜ë„ ìˆê³ ìš”.

ì–´ë–¤ ë°©ì‹ìœ¼ë¡œ ë” ì—°ìŠµí•˜ê³  ì‹¶ì€ì§€ ì•Œë ¤ì¤˜ìš” :)

# ê·¸ë˜í”„ íƒìƒ‰ ê¸°ë³¸: ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜

https://www.acmicpc.net/problem/11724

## Phase1. ì§ì ‘ í’€ê¸° - ì„±ê³µ - union findë¡œ ë‹¤ì‹œ í’€ì–´ë³´ê¸°!

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 11724                             :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/11724                          #+#        #+#      #+#     #
#    Solved: 2025/03/28 17:21:49 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
from collections import deque

def bfs(root: int):
    que = deque() # í ì •ì˜
    que.appendleft(root) # ë£¨íŠ¸ ì–´íœë“œ
    
    while que: # íê°€ ì¡´ì¬í•˜ëŠ” ë™ì•ˆ
        # u = E[que.pop()] # ë“¤ì–´ê°„ ë…¸ë“œê°€ ê°ˆ ìˆ˜ ìˆëŠ” ë…¸ë“œë¥¼ í™•ì¸
        for u in E[que.pop()]:
            if not is_visited[u]: # ê·¸ ë…¸ë“œê°€ ë°©ë¬¸ë˜ì§€ ì•Šì•˜ë‹¤ë©´
                is_visited[u] = True # ë°©ë¬¸ ì‹¤ì‹œ
                que.appendleft(u)

import sys

if __name__ == '__main__':	
    input = sys.stdin.readline
    n, m = tuple(map(int, input().split()))
    arr = [
        tuple(map(int, input().split()))
        for _ in range(m)
    ]
    # E = defaultdict() # ê°„ì„ ì´ í•˜ë‚˜ë°–ì— ì—†ì–´ë„ ë²„í…ìŠ¤ì˜ ì°¨ìˆ˜ê°€ ì—¬ëŸ¿ì¼ ìˆ˜ ìˆì–´ì„œ ë¦¬ìŠ¤íŠ¸ í•„ìš”
    E = {
        i: [] for i in range(1, n+1)
    }
    # print(E)
    # print(arr)
    for u, v in arr:
        # print(u, v)
        E[u].append(v)
        E[v].append(u)
    is_visited = [False for _ in range(n+1)] # V + 1
    cnt = 0
    # print(E)
    for v in range(1, n+1): # ëª¨ë“  ë²„í…ìŠ¤ì— ëŒ€í•´ ìˆœíšŒ
        if not is_visited[v]: # ì‹¤í–‰ ì‹œì ì— ë°©ë¬¸ë˜ì§€ ì•Šì•˜ë‹¤ë©´
            # print(f'{v} is not traveled') # ë°©ë¬¸ ì‹¤ì‹œ
            cnt += 1
            is_visited[v] = True #
            bfs(v)
    print(cnt)
        
```

# íŠ¸ë¦¬ì˜ ë¶€ëª¨ ì°¾ê¸°

https://www.acmicpc.net/problem/11725

ë£¨íŠ¸ ì—†ëŠ” íŠ¸ë¦¬ê°€ ì£¼ì–´ì§„ë‹¤. ì´ë•Œ, íŠ¸ë¦¬ì˜ ë£¨íŠ¸ë¥¼ 1ì´ë¼ê³  ì •í–ˆì„ ë•Œ, ê° ë…¸ë“œì˜ ë¶€ëª¨ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì§ì ‘ í’€ê¸° - ì‹¤íŒ¨

```python
import sys
# this reminds me the find function

# what was the find?
def find(x):
	if parent[x] != x:
		parent[x] = find(x)
	return parent[x]

from collections import deque

def bfs(root: int):
	que = deque()
	que.appendleft(root)
	visited = [False for _ in range(n+1)]
	while que:
		v = que.pop()
		for u in v:
			if not visited[u]:
				visited[u] = True
				parent[u] = v
				print(f'parent[{u}]={v}')
				print(parent)
				# then what? appendleft to que
				que.appendleft(E[u])
	

if __name__ == '__main__':
	input = sys.stdin.readline
	n = int(input().strip())
	arr = [
			tuple(map(int, input().split()))
			for _ in range(n-1)
		]
	
	E = {
		i:[] for i in range(n+1)
	}
	
	for v, u in arr:
		# ê°„ì„  ê·¸ë˜í”„ ìƒì„±
		E[v].append(u)
		E[u].append(v)
	print(E)
	parent = [i for i in range(n+1)]
	bfs(E[1])
	for p in parent:
		print(p)

```

## Phase2. í”¼ë“œë°±

ì¢‹ì•„ìš”, íŠ¸ë¦¬ì˜ ë¶€ëª¨ë¥¼ ì°¾ëŠ” ë¬¸ì œë¥¼ ì§ì ‘ ì‹œë„í•˜ì…¨ê³ , BFSë¥¼ ì´ìš©í•˜ë ¤ëŠ” ì ‘ê·¼ë„ ì¢‹ì•˜ìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ bfs í•¨ìˆ˜ì—ì„œ ì•½ê°„ì˜ ì‹¤ìˆ˜ê°€ ìˆì–´ìš”. ì°¨ê·¼ì°¨ê·¼ í”¼ë“œë°±ì„ ë“œë¦´ê²Œìš”!

âœ… ë¬¸ì œ ìš”ì•½

â€¢	ë£¨íŠ¸ ì—†ëŠ” íŠ¸ë¦¬(ë¬´ë°©í–¥ ê·¸ë˜í”„)ê°€ ì£¼ì–´ì§€ê³ ,

â€¢	ë£¨íŠ¸ë¥¼ 1ë²ˆ ë…¸ë“œë¡œ ì •í–ˆì„ ë•Œ,

â€¢	ê° ë…¸ë“œì˜ ë¶€ëª¨ ë…¸ë“œë¥¼ ì¶œë ¥í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

âŒ ë¬¸ì œì  ë¶„ì„

1. for u in v ì˜ëª»ëœ ë°˜ë³µ

```plain text
for u in v:
```

ì´ ë¶€ë¶„ì—ì„œ vëŠ” ì •ìˆ˜í˜• ë…¸ë“œ ë²ˆí˜¸ì¸ë°, for u in v:ëŠ” ë¬¸ìì—´ì´ë‚˜ ë¦¬ìŠ¤íŠ¸ì—ì„œë‚˜ ê°€ëŠ¥í•œ êµ¬ë¬¸ì´ì—ìš”. TypeError: 'int' object is not iterableê°€ ë°œìƒí•©ë‹ˆë‹¤.

â¡ï¸ ìˆ˜ì •: E[v]ì—ì„œ ì—°ê²°ëœ ë…¸ë“œë¥¼ ê°€ì ¸ì™€ì•¼ í•˜ë¯€ë¡œ,

```plain text
for u in E[v]:
```

ê°€ ë˜ì–´ì•¼ í•´ìš”.

2. visited ë°°ì—´ì´ í•¨ìˆ˜ ë‚´ë¶€ì— ìˆìŒ

visited ë°°ì—´ì´ bfs() í•¨ìˆ˜ ì•ˆì— ìˆì–´ì„œ ë§¤ë²ˆ ìƒˆë¡œ ì´ˆê¸°í™”ë©ë‹ˆë‹¤. ê·¸ë˜ë„ ì´ ë¬¸ì œëŠ” í•œ ë²ˆë§Œ bfs()ë¥¼ ëŒë¦¬ê¸° ë•Œë¬¸ì— í° ë¬¸ì œëŠ” ì—†ì§€ë§Œ, ê·¸ë˜ë„ ë³´í†µì€ í•¨ìˆ˜ ë°–ì—ì„œ ì„ ì–¸í•˜ê³  ì¬ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ê´€ë¦¬í•˜ëŠ” ê²ƒì´ ì¢‹ì•„ìš”.

3. parent ì´ˆê¸°ê°’

```plain text
parent = [i for i in range(n+1)]
```

ì´ë ‡ê²Œ ë˜ë©´ ë£¨íŠ¸ ë…¸ë“œì˜ ë¶€ëª¨ê°€ ìê¸° ìì‹ ì´ ë©ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œëŠ” 0ì´ë‚˜ -1ë¡œ ì´ˆê¸°í™”í•˜ê³ , ì¶”í›„ ë¶€ëª¨ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.

âœ… ê°œì„ ëœ ì½”ë“œ ì˜ˆì‹œ

âœ… í•µì‹¬ ì•„ì´ë””ì–´ ì •ë¦¬

â€¢	íŠ¸ë¦¬ëŠ” ì‚¬ì´í´ì´ ì—†ëŠ” ì—°ê²° ê·¸ë˜í”„ì´ë¯€ë¡œ, ì•„ë¬´ ë…¸ë“œì—ì„œ ì‹œì‘í•´ë„ ë‚˜ë¨¸ì§€ ë…¸ë“œì— ë„ë‹¬ ê°€ëŠ¥.

â€¢	BFSë‚˜ DFSë¡œ íŠ¸ë¦¬ë¥¼ ìˆœíšŒí•˜ë©´ì„œ parent[ìì‹] = ë¶€ëª¨ë¡œ ì €ì¥.

â€¢	ì¶œë ¥ì€ **ë£¨íŠ¸(1ë²ˆ ë…¸ë“œ)**ë¥¼ ì œì™¸í•œ ë…¸ë“œë“¤ì˜ ë¶€ëª¨ë§Œ ì¶œë ¥.

í•„ìš”í•˜ì‹œë©´ DFS ë°©ì‹ìœ¼ë¡œë„ ì½”ë“œ ë“œë¦´ê²Œìš”.

ë˜, ì•„ì§ ì´í•´ ì•ˆ ë˜ê±°ë‚˜ í—·ê°ˆë¦¬ëŠ” ë¶€ë¶„ì´ ìˆë‹¤ë©´ í¸í•˜ê²Œ ì§ˆë¬¸ ì£¼ì„¸ìš”!

# ì´ë¶„ ê·¸ë˜í”„

https://www.acmicpc.net/problem/1707

ê·¸ë˜í”„ì˜ ì •ì ì˜ ì§‘í•©ì„ ë‘˜ë¡œ ë¶„í• í•˜ì—¬, ê° ì§‘í•©ì— ì†í•œ ì •ì ë¼ë¦¬ëŠ” ì„œë¡œ ì¸ì ‘í•˜ì§€ ì•Šë„ë¡ ë¶„í• í•  ìˆ˜ ìˆì„ ë•Œ, ê·¸ëŸ¬í•œ ê·¸ë˜í”„ë¥¼ íŠ¹ë³„íˆ ì´ë¶„ ê·¸ë˜í”„ (Bipartite Graph) ë¼ ë¶€ë¥¸ë‹¤.

ê·¸ë˜í”„ê°€ ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ ê·¸ë˜í”„ê°€ ì´ë¶„ ê·¸ë˜í”„ì¸ì§€ ì•„ë‹Œì§€ íŒë³„í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì§ì ‘ í’€ê¸°

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 1707                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/1707                           #+#        #+#      #+#     #
#    Solved: 2025/03/28 20:24:35 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys

# í‰ë²”í•œ dfsì—ì„œ visitedì— ëŒ€í•œ ì„œì¹˜ë¥¼ ì‹œë„í•˜ë©´ bipartite graphê°€ ì•„ë‹Œ ê±´ê°€.

def dfs(v: int, cnt: int):
    # dfs ì ˆì°¨. 
    # 1. set v flag
    visited[v] = True
    count_map[v] = cnt
    # 2. loop for each nodes
    for u in E[v]:
        if visited[u] == True: #ì´ê±¸ë¡œëŠ” ì‚¬ì´í´ í™•ì¸ ë¶ˆê°€
            # ì™œ? ë¬´ë°©í–¥ ê·¸ë˜í”„ì—ì„œëŠ” ì˜¨ ê¸¸ë„ Trueë¡œ ë³´ê²Œ ë¨.
            # ê·¸ëŸ¼ ì¶œë°œí•˜ê¸° ì „ì— ì—†ì• ë²„ë¦¬ë©´ ì•ˆ ë˜ë‚˜.
            # print(f'already visited {u}')
            # print(f'count map. {count_map[v]} meets {count_map[u]}')
            if (count_map[v] - count_map[u])%2 == 0:
                return False
        else: # not true
            # print(f'exploring {u}, {E[u]}, {v}')
            # ì´ë ‡ê²Œ.
            E[u].remove(v)
            visited[u] = True
            return dfs(u, cnt+1)
    return True



if __name__ == '__main__':	
    input = sys.stdin.readline
    k = int(input().strip()) # number of test cases
    for _ in range(k):
        v, e = tuple(map(int, input().split()))
        E = {
            i: [] for i in range(v+1)
        }
        arr = [
            tuple(map(int, input().split()))
            for _ in range(e)
        ]
        for u, v_ in arr:
            E[v_].append(u)
            E[u].append(v_)
        visited = [False for _ in range(v+1)]
        # print(E)
        count_map = [0 for _ in range(v+1)]
        result = dfs(1, 1)
        out = 'YES' if result else 'NO'
        print(out)
        # print(count_map)
        
"""
ì´ìŠˆ: í‹€ë ¸ìŠµë‹ˆë‹¤.

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: 
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ê·¸ëƒ¥ ì‚¬ì´í´ì´ ì—†ìœ¼ë©´ í‹€ë¦° ê±¸ë¡œ íŒë‹¨í•˜ëŠ” dfs í•¨ìˆ˜ë¥¼ ì§°ëŠ”ë°, ê·¸ëƒ¥ ë¬¸ì œ ì´í•´ë¥¼ 
ì˜ëª» í•œ ê±°ì¼ìˆ˜ë„? ê·¸ëŸ¬ë„¤. ì–´ì¨Œë“  ì‚¬ì´í´ ê²€ì‚¬í•˜ëŠ” í•¨ìˆ˜ëŠ” ì œëŒ€ë¡œ ì¼ì–ì•„. í•œì”í•´~
ê·¸ë¦¬ê³  ë‹¤ì‹œ ìƒê°í•´ë³´ë‹ˆ, ì‚¬ì´í´ì„ ì´ë£¨ëŠ” ë²„í…ìŠ¤ ìˆ˜ê°€ í™€ìˆ˜ë©´ ì•ˆ ëœë‹¤. 
ì‚¬ì´í´ ìˆ˜ë¥¼ ì¸¡ì •í•˜ëŠ” ë°©ë²•ì€ ì—†ë‚˜?

Phase2.
í™•ì¸: count_mapì´ë¼ëŠ” ê±¸ ë§Œë“¤ì–´ì„œ ì„œë¡œ ì‚¬ì´í´ì„ í˜•ì„±í•˜ëŠ” ë…¸ë“œì˜ ë²ˆí˜¸ ì°¨ê°€ ì§ìˆ˜ë©´ ì´ë¶„ íŠ¸ë¦¬ ì•„ë‹Œ ê±¸ë¡œ ì‹œë„
ì‹œë„: 
for u in E[v]:
    if visited[u] == True: #ì´ê±¸ë¡œëŠ” ì‚¬ì´í´ í™•ì¸ ë¶ˆê°€
        # ì™œ? ë¬´ë°©í–¥ ê·¸ë˜í”„ì—ì„œëŠ” ì˜¨ ê¸¸ë„ Trueë¡œ ë³´ê²Œ ë¨.
        # ê·¸ëŸ¼ ì¶œë°œí•˜ê¸° ì „ì— ì—†ì• ë²„ë¦¬ë©´ ì•ˆ ë˜ë‚˜.
        # print(f'already visited {u}')
        # print(f'count map. {count_map[v]} meets {count_map[u]}')
        if (count_map[v] - count_map[u])%2 == 0:
            return False
    else: # not true
        # print(f'exploring {u}, {E[u]}, {v}')
        # ì´ë ‡ê²Œ.
        E[u].remove(v)
        visited[u] = True
        return dfs(u, cnt+1)
ë¶„ì„
ì‹¤íŒ¨.

"""
```

## Phase2. í”¼ë“œë°±

ì¢‹ì€ ì‹œë„ì˜€ì–´ìš”! ì´ ë¬¸ì œëŠ” ì´ë¶„ ê·¸ë˜í”„(Bipartite Graph) íŒë³„ ë¬¸ì œë¡œ, DFSë‚˜ BFSë¥¼ ì´ìš©í•´ì„œ ì •ì ì„ ë‘ ê·¸ë£¹ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ì•„ì´ë””ì–´ê°€ í•µì‹¬ì…ë‹ˆë‹¤.

í˜„ì¬ ì½”ë“œì˜ ì‹œë„ëŠ” ì°½ì˜ì ì´ì§€ë§Œ, ëª‡ ê°€ì§€ í•µì‹¬ì ì¸ ë¶€ë¶„ì—ì„œ ë¡œì§ì´ ì–´ê¸‹ë‚˜ê³  ìˆì–´ìš”. ìì„¸íˆ ì§šì–´ë³¼ê²Œìš”.

âœ… ì´ë¶„ ê·¸ë˜í”„ íŒë³„ í•µì‹¬ ì•„ì´ë””ì–´

â€¢	ëª¨ë“  ì •ì ì— ëŒ€í•´ ë‘ ê°€ì§€ ìƒ‰(ë˜ëŠ” ê·¸ë£¹) ì¤‘ í•˜ë‚˜ë¥¼ ì¹ í•˜ë˜,

â€¢	ì¸ì ‘í•œ ì •ì ì€ ì„œë¡œ ë‹¤ë¥¸ ìƒ‰ì´ ë˜ë„ë¡ í•´ì•¼ í•©ë‹ˆë‹¤.

â€¢	DFS ë˜ëŠ” BFSë¥¼ í•˜ë©´ì„œ ì¸ì ‘ ì •ì ì— ì„œë¡œ ë‹¤ë¥¸ ìƒ‰ì„ ë²ˆê°ˆì•„ ì¹ í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì§„í–‰í•˜ë©´ ë©ë‹ˆë‹¤.

â€¢	ë§Œì•½ ì¸ì ‘í•œ ë‘ ì •ì ì´ ê°™ì€ ìƒ‰ìœ¼ë¡œ ì¹ í•´ì ¸ ìˆë‹¤ë©´ ì´ë¶„ ê·¸ë˜í”„ê°€ ì•„ë‹™ë‹ˆë‹¤.

ğŸ” í˜„ì¬ ì½”ë“œì˜ ë¬¸ì œì 

1.	E[u].remove(v)ë¥¼ ì§ì ‘ ìˆ˜ì • â†’ ê·¸ë˜í”„ ì •ë³´ë¥¼ ì§ì ‘ ë°”ê¾¸ëŠ” ê±´ ìœ„í—˜í•œ ë°©ì‹ì…ë‹ˆë‹¤. ì‚¬ì´í´ ì œê±° ëª©ì ì´ì§€ë§Œ, ë°©í–¥ì„±ì´ ì—†ëŠ” ê·¸ë˜í”„ì—ì„œ ì‚­ì œí•˜ë©´ ë‹¤ë¥¸ ê²½ë¡œ íƒìƒ‰ì— ì§€ì¥ì„ ì¤ë‹ˆë‹¤.

2.	return dfs(...)ë¥¼ ë°”ë¡œ í•´ë²„ë¦¼ â†’ í•˜ë‚˜ì˜ ì´ì›ƒë§Œ íƒìƒ‰í•˜ê³  ë¦¬í„´í•´ë²„ë ¤ì„œ ì „ì²´ íƒìƒ‰ì´ ì•ˆ ë©ë‹ˆë‹¤. for ë£¨í”„ë¥¼ ëê¹Œì§€ ìˆœíšŒí•´ì•¼ í•´ìš”.

3.	ìƒ‰ ì¹ í•˜ê¸° ë°©ì‹ì´ ì• ë§¤ â†’ count_mapì„ cntë¡œ í•˜ì…¨ëŠ”ë°, ì‚¬ì‹¤ ì´ë¶„ ê·¸ë˜í”„ì—ì„œëŠ” ì •í™•í•œ depthë³´ë‹¤ëŠ” í˜„ì¬ ë…¸ë“œê°€ ì–´ë–¤ ìƒ‰ì¸ì§€ë§Œ êµ¬ë¶„í•˜ë©´ ë©ë‹ˆë‹¤. ì˜ˆ: 0 ë˜ëŠ” 1

âœ… ì¶”ì²œ êµ¬ì¡° (DFS ë°©ì‹)

âœ… í•µì‹¬ í¬ì¸íŠ¸ ìš”ì•½

ğŸ’¡ ë³´ë„ˆìŠ¤ (BFS ë²„ì „ë„ ê¶ê¸ˆí•˜ì‹œë©´ ì•Œë ¤ë“œë¦´ê²Œìš”!)

í•„ìš”í•˜ë‹¤ë©´ ìœ„ ì½”ë“œì— print()ë¡œ ë””ë²„ê¹… í¬ì¸íŠ¸ ì°ì–´ë³´ê±°ë‚˜, ì‹¤íŒ¨ ì›ì¸ ë””í…Œì¼í•˜ê²Œ ê°™ì´ ë¶„ì„í•´ë³¼ ìˆ˜ë„ ìˆì–´ìš”.

ì›ë¦¬ë§Œ ì˜ ì´í•´í•˜ë©´ ì´ ìœ í˜•ì€ ì—¬ëŸ¬ ë¬¸ì œì— ì‘ìš©í•  ìˆ˜ ìˆì–´ìš”!

- ì•„ ë­ì•¼ ê·¸ëƒ¥ ìƒ‰ì¹ í•˜ë©´ ë˜ì–ì•„.
- ì•„ë‹ˆ ì™œ ì•ˆ ë˜ì§€.
## Phase3. í”¼ë“œë°± í›„ ì¬ë„ì „

ì„œë¸ŒíŠ¸ë¦¬ê°„ì— ê°„ì„ ì´ ì—†ëŠ” ê²½ìš°ë¥¼ ìƒê° ëª»í•´ì„œ í•œì°¸ ê±¸ë¦¼! ì•ìœ¼ë¡œ ê·¸ë˜í”„ ë¬¸ì œ í’€ ë•Œ ì£¼ì˜í•  ê²ƒ!

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 1707                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/1707                           #+#        #+#      #+#     #
#    Solved: 2025/03/28 20:24:35 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys
sys.setrecursionlimit(10**8)

def dfs(v: int, color: int):
    global flag
    visited[v] = color
    for u in E[v]:
        if visited[u] != -1:
            if visited[v] == visited[u]: # 0 == 0 or 1 == 1
                flag = True
                return 
        else: 
            visited[u] = color
            dfs(u, 1-color)

if __name__ == '__main__':	
    input = sys.stdin.readline
    k = int(input().strip()) 
    for _ in range(k):
        v, e = tuple(map(int, input().split()))
        E = {
            i: [] for i in range(v+1)
        }
        arr = [
            tuple(map(int, input().split()))
            for _ in range(e)
        ]
        for u, v_ in arr:
            E[v_].append(u)
            E[u].append(v_)
        visited = [-1 for _ in range(v+1)]
        flag = False
        # edgeê°€ ì—†ì„ ìˆ˜ë„ ìˆìë‚˜!
        for v in E.keys():
            if visited[v] == -1:
                dfs(v, 0)
        out = 'NO' if flag else 'YES'
        print(out)
"""
ì´ìŠˆ: í‹€ë ¸ìŠµë‹ˆë‹¤.

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: 
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ê·¸ëƒ¥ ì‚¬ì´í´ì´ ì—†ìœ¼ë©´ í‹€ë¦° ê±¸ë¡œ íŒë‹¨í•˜ëŠ” dfs í•¨ìˆ˜ë¥¼ ì§°ëŠ”ë°, ê·¸ëƒ¥ ë¬¸ì œ ì´í•´ë¥¼ 
ì˜ëª» í•œ ê±°ì¼ìˆ˜ë„? ê·¸ëŸ¬ë„¤. ì–´ì¨Œë“  ì‚¬ì´í´ ê²€ì‚¬í•˜ëŠ” í•¨ìˆ˜ëŠ” ì œëŒ€ë¡œ ì¼ì–ì•„. í•œì”í•´~
ê·¸ë¦¬ê³  ë‹¤ì‹œ ìƒê°í•´ë³´ë‹ˆ, ì‚¬ì´í´ì„ ì´ë£¨ëŠ” ë²„í…ìŠ¤ ìˆ˜ê°€ í™€ìˆ˜ë©´ ì•ˆ ëœë‹¤. 
ì‚¬ì´í´ ìˆ˜ë¥¼ ì¸¡ì •í•˜ëŠ” ë°©ë²•ì€ ì—†ë‚˜?

Phase2.
í™•ì¸: colorì´ë¼ëŠ” ê±¸ ë§Œë“¤ì–´ì„œ ì„œë¡œ ì‚¬ì´í´ì„ í˜•ì„±í•˜ëŠ” ë…¸ë“œì˜ ë²ˆí˜¸ ì°¨ê°€ ì§ìˆ˜ë©´ ì´ë¶„ íŠ¸ë¦¬ ì•„ë‹Œ ê±¸ë¡œ ì‹œë„
ì‹œë„: 
for u in E[v]:
    if visited[u] == True: #ì´ê±¸ë¡œëŠ” ì‚¬ì´í´ í™•ì¸ ë¶ˆê°€
        # ì™œ? ë¬´ë°©í–¥ ê·¸ë˜í”„ì—ì„œëŠ” ì˜¨ ê¸¸ë„ Trueë¡œ ë³´ê²Œ ë¨.
        # ê·¸ëŸ¼ ì¶œë°œí•˜ê¸° ì „ì— ì—†ì• ë²„ë¦¬ë©´ ì•ˆ ë˜ë‚˜.
        # print(f'already visited {u}')
        # print(f'count map. {color[v]} meets {color[u]}')
        if (color[v] - color[u])%2 == 0:
            return False
    else: # not true
        # print(f'exploring {u}, {E[u]}, {v}')
        # ì´ë ‡ê²Œ.
        E[u].remove(v)
        visited[u] = True
        return dfs(u, cnt+1)
ë¶„ì„
ì‹¤íŒ¨.

"""

"""
ì´ìŠˆ: í”¼ë“œë°± ë°˜ì˜í•´ì„œ, ìˆœíšŒí•˜ë©° ìƒ‰ì„ ì§ì ‘ íƒìƒ‰í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ ì²˜ë¦¬. 46í”„ë¡œì—ì„œ ì˜¤ë‹µ ë°œìƒ

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: 
ìµœê·¼ ë³€ê²½ ì‚¬í•­: 

Phase2.
í™•ì¸: ë­˜ í™•ì¸í•´ì•¼ í•¨? 46í”„ë¡œì—ì„œ í‹€ë¦¬ëŠ”ë°... í•˜ ì§„ì§œ ë­ê°€ ë¬¸ì œì§€. 
ì‹œë„: 
ë¶„ì„: 
"""
```

# BFS: ë¯¸ë¡œì°¾ê¸° 

## Phase1. ì§ì ‘ í’€ê¸° - ì„±ê³µ

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 2178                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/2178                           #+#        #+#      #+#     #
#    Solved: 2025/03/28 18:05:32 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
import sys
from collections import deque

def in_range(x: int, y: int):
    return x >= 0 and x < n and y >= 0 and y < m

def can_go(x: int, y: int):
    if not in_range(x, y) or maze[x][y] == 0 or is_visited[x][y] != -1: 
        return False
    return True

def bfs(root: tuple):
    que = deque()
    dxs = [-1, 1, 0, 0]
    dys = [0, 0, -1, 1]
    que.appendleft(root)
    rx, ry = root
    is_visited[rx][ry] = 1
    cnt = 1
    while que:
        x, y = que.pop() # í
        for dx, dy in zip(dxs, dys): # ì‚¬ë°©ì„ ë³¸ ë‹¤ìŒ
            nx, ny = x + dx, y + dy

            if can_go(nx, ny): # ê°ˆ ìˆ˜ ìˆìœ¼ë©´ ì¶œë°œ.
                # print(f'moving to {nx, ny}')
                is_visited[nx][ny] = is_visited[x][y]+1
                que.appendleft((nx, ny))
            # else: 
            #     print(f'can not go to {nx, ny}')
            #     if not in_range(nx, ny): 
            #         print('out of range')
            #     else:
            #         if maze[nx][ny] == 0: 
            #             print('maze no way')
            #         if is_visited[nx][ny]: print('already visited')
                
    return cnt

if __name__ == '__main__':	
    input = sys.stdin.readline
    n, m = tuple(map(int, input().split()))
    maze = [
        tuple(map(int, tuple(input().strip())))
        for _ in range(n)
        ]
    is_visited = [[-1 for _ in range(m)] for _ in range(n)]
    mark_board = [[0 for _ in range(m)] for _ in range(n)]
    # for m_ in maze:
    #     print(m_)
    c = bfs((0,0))
    # print(c)
    # for v in is_visited:
    #     print(v)
    print(is_visited[n-1][m-1])
```

ê²©ì ì‚¬ì´ì¦ˆë¥¼ n, mìœ¼ë¡œ ê°€ì •í–ˆë‹¤ê°€ í•œì°¸ ì£½ ì’”ë‹¤. ì•„ë˜ ë¡œê·¸ë¥¼ ëª¨ë‘ ì°ì–´ë³¸ ëì— in range í•¨ìˆ˜ê°€ ë²”ì¸ì„ì„ ë°œê²¬í–ˆë‹¤.

# BFS: íŠ¹ì • ê±°ë¦¬ì˜ ë„ì‹œ ì°¾ê¸°

## Phase1. ì§ì ‘ í’€ê¸° - ì„±ê³µ

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 18352                             :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/18352                          #+#        #+#      #+#     #
#    Solved: 2025/03/29 10:34:11 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #

"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ë¯¸ë¡œ ë¬¸ì œì™€ëŠ” ê·¸ë˜í”„ ì…ë ¥ì´ ë‹¤ë¦„. ë”•ì…”ë„ˆë¦¬ë¥¼ ì‚¬ìš©í•œ ì¸ì ‘ë¦¬ìŠ¤íŠ¸ë¥¼ êµ¬í˜„í•´ì•¼ í•¨.
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys
from collections import deque

def bfs(root: int):
    que = deque()
    que.appendleft(root)
    visited = [-1 for _ in range(n+1)]
    visited[root] = 0
    ans = []
    while que:
        v = que.pop()
        # print(v)
        for u in E[v]:
            # print(f'u: {u}')
            if visited[u] == -1:
                visited[u] = visited[v]+1
                if visited[u] == k:
                    ans.append(u)
                que.appendleft(u)
    return sorted(ans)


if __name__ == '__main__':	
    input = sys.stdin.readline
    n, m, k, x = tuple(map(int, input().split()))
    E = {
        i: [] for i in range(n+1)
    }
    arr = [
        tuple(map(int, input().split()))
        for _ in range(m)
    ]
    for v, u in arr:
        E[v].append(u)
    result = bfs(x)
    if result:
        for r in result:
            print(r)
    else:
        print(-1)
```

# DFS or BFS: ì•„ì¹¨ ì‚°ì±…



## Phase1. ì§ì ‘ í’€ê¸° - ë¶€ë¶„ ì„±ê³µ

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 21606                             :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/21606                          #+#        #+#      #+#     #
#    Solved: 2025/03/28 21:44:55 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ê·¸ëƒ¥ ëª¨ë“  ë²„í…ë¥¼ ë£¨íŠ¸ë¡œ dfs ëŒë¦¬ë©´ ë˜ëŠ” ê±° ê°™ì€ë°

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys

def dfs(root: int):
    global cnt
    v = root
    for u in E[v]:
        if not visited[u] and A[u-1] != 1: # not visited and not inside
            visited[u] = True
            # print(f'moving to {u}')
            dfs(u)
        elif not visited[u] and A[u-1] == 1: # not visited and inside
            # stop the walk
            # print(f'stop at {u}')
            cnt += 1


if __name__ == '__main__':	
    input = sys.stdin.readline
    n = int(input().strip())
    # ë²„í…ìŠ¤ë¥¼ ë”•ì…”ë„ˆë¦¬ë¡œ ê´€ë¦¬í•´ì•¼ í•˜ë‚˜?
    A = tuple(map(int, tuple(input().strip()))) # idx - 1ë¡œ ì ‘ê·¼
    arr = [
        tuple(map(int, input().split()))
        for _ in range(n-1)
    ]
    E = {
        i:[] for i in range(n+1)
    }
    for v, u in arr:
        E[v].append(u)
        E[u].append(v)
    # is_inside = {} # V[vertex val] = 0 or 1
    # for idx, a in enumerate(A, 1):
    #     is_inside[idx] = a
    # print(is_inside)
    cnt = 0
    for v in range(1, n+1):
        if A[v-1] == 1: # ì¶œë°œì€ ì‹¤ë‚´ì—ì„œ
            visited = [False for _ in range(n+1)]
            # print(f'starting: {v}')
            visited[v] = True
            dfs(v)
    print(cnt)
```

# DFS: ì—°ì‚°ì ë¼ì›Œë„£ê¸°

## Phase1. ì§ì ‘ í’€ê¸° - ì„±ê³µ

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 14888                             :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/14888                          #+#        #+#      #+#     #
#    Solved: 2025/03/29 11:31:02 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
"""
1. ë¬¸ì œ ì½ê¸°
ì£¼ì–´ì§„ ìˆ«ì ìˆœì„œëŒ€ë¡œ ë…¸ë“œê³  
ê° ìˆ«ìì˜ ìˆœì„œëŒ€ë¡œ ìˆœíšŒí•˜ëŠ” ê·¸ë˜í”„ íƒìƒ‰?

2. ë¬¸ì œ í’€ê¸°
ì—°ì‚°ìê°€ ë²„í…ìŠ¤ì¸ê°€? ë²„í…ìŠ¤ íƒìƒ‰ ìˆœì„œë§Œ ì •í•´ì§€ë©´ ì—°ì‚° ë•Œë¦¬ë©´ ë˜ì–ìŠ´. ê·¸ëŸ¬ë„¤

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
""" 

import sys
MAX_INT = sys.maxsize
MIN_INT = -sys.maxsize

def dfs(op_list: list, current_val: int, num_idx: int):
    global max_ans, min_ans
    if len(op_list) == n-1: # ëª¨ë“  ì—°ì‚°ì„ ëëƒˆë‹¤ë©´
        max_ans = max(max_ans, current_val)
        min_ans = min(min_ans, current_val)
        return
    for i in range(len(visited)):
        if visited[i] > 0:
            op_list.append(i)
            visited[i] -= 1
            result = mapper[i]((current_val, A[num_idx]))
            dfs(op_list, result, num_idx+1)
            visited[i]+= 1
            op_list.remove(i)
mapper[0]((1,2)) 

if __name__ == '__main__':	
    input = sys.stdin.readline
    n = int(input().strip())
    A = tuple(map(int, input().split()))
    ops = list(map(int, input().split()))
    mapper = {0: lambda x: x[0]+x[1], 
              1: lambda x: x[0]-x[1], 
              2: lambda x: x[0]*x[1], 
              3: lambda x: x[0]//x[1] if x[0] > 0 else -(-x[0]//x[1])}
    max_ans = MIN_INT
    min_ans = MAX_INT
    for i in range(len(ops)): # ê°ê°ì˜ ì‹œì‘ì ì— ëŒ€í•´
        # ì•„ ì•Œê±° ê°™ê¸°ë„ í•˜ê³  ëª¨ë¥´ê² ë„¤. ì¼ë‹¨ ì—°ì‚°ì ìŒì„ ì¶œë ¥í•˜ëŠ” ê±°ë¥¼ ë§Œë“¤ì–´ ë³¼ê°€.
        visited = ops.copy()
        result = 0
        if ops[i] > 0: #ì—°ì‚°ìë¥¼ ì“¸ ìˆ˜ ìˆë‹¤ë©´
            visited[i] -= 1 
            result = mapper[i]((A[0], A[1])) # ìµœì´ˆ ì—°ì‚°ì„ í•œ ë‹¤ìŒ
            dfs([i], result, 2) # dfsë¡œ ë„˜ê¸°ê¸°.
    print(max_ans )
    print(min_ans)


## n ìµœëŒ€ê°’ì´ 11ì´ë¯€ë¡œ ë¸Œë£¨íŠ¸í¬ìŠ¤ ë§¤ìš° ê°€ëŠ¥í•¨.

```

## Phase2. í”¼ë“œë°±

### ê³ ë¯¼

ì–´ë ¤ìš´ ë¬¸ì œëŠ” ì•„ë‹ˆì§€ë§Œ ë¬¸ì œ ì„¤ê³„ê°€ ì—¬ëŸ¬ ë‹¨ê³„ë¡œ ë‚˜ë‰˜ì–´ ì‹œê°„ì´ ë§ì´ ê±¸ë ¸ë‹¤. ê·¸ë¦¬ê³  ëŒë‹¤ í‘œí˜„ì„ ì €ë ‡ê²Œ í•´ë„ ê´œì°®ì€ì§€, ë” ë‚˜ì€ í’€ì´ê°€ ì—†ëŠ”ì§€ ê¶ê¸ˆí•˜ë‹¤.

### ë‹µë³€

ì¢‹ì€ ë¬¸ì œ ì ‘ê·¼ê³¼ ë©‹ì§„ ì„±ê³µì´ì—ìš”! íŠ¹íˆ mapperë¥¼ í™œìš©í•´ì„œ ì—°ì‚°ìë¥¼ í•¨ìˆ˜ì²˜ëŸ¼ ë‹¤ë£¨ëŠ” ë°©ì‹ì´ êµ‰ì¥íˆ ê¹”ë”í•˜ê³  í•¨ìˆ˜í˜•ì ì…ë‹ˆë‹¤. ëŒë‹¤ + ë”•ì…”ë„ˆë¦¬ íŒ¨í„´ì€ íŒŒì´ì¬ì—ì„œ í”íˆ ì“°ì´ëŠ” ì¢‹ì€ ìŠµê´€ì´ê¸°ë„ í•´ìš”. ë‹¤ë§Œ ì•½ê°„ì˜ ë¦¬íŒ©í† ë§ìœ¼ë¡œ ë” ê°„ê²°í•˜ê³  ì½ê¸° ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆì–´ìš”.

âœ… ì½”ë“œ ìŠ¤íƒ€ì¼ í”¼ë“œë°± ë° ê°œì„  ì œì•ˆ

1. op_listëŠ” ì—†ì–´ë„ ë©ë‹ˆë‹¤!

â€¢	op_listëŠ” DFSì—ì„œ íƒìƒ‰ ê²½ë¡œë¥¼ ê¸°ë¡í•˜ê¸° ìœ„í•´ ë§Œë“  ê²ƒ ê°™ì§€ë§Œ, ì—°ì‚°ë§Œ í•˜ê³  ê·¸ ê²°ê³¼ë§Œ ë„˜ê¸°ë©´ ë˜ê¸° ë•Œë¬¸ì— ì—†ì–´ë„ ë¬´ë°©í•©ë‹ˆë‹¤.

â€¢	ëŒ€ì‹  visited ìƒíƒœë§Œ ì˜ ê´€ë¦¬í•˜ë©´ ë©ë‹ˆë‹¤.

2. ì‹œì‘ì  ë£¨í”„ëŠ” í•„ìš” ì—†ìŠµë‹ˆë‹¤

â€¢	ëª¨ë“  ì—°ì‚°ì ì¡°í•©ì„ DFSë¡œ íƒìƒ‰í•˜ë¯€ë¡œ, ì‹œì‘ ì—°ì‚°ìë¥¼ ê³ ë¥¼ í•„ìš” ì—†ì´ í•œ ë²ˆë§Œ DFSë¥¼ í˜¸ì¶œí•˜ë©´ ë©ë‹ˆë‹¤.

âœ¨ ë¦¬íŒ©í† ë§ ì˜ˆì‹œ ì½”ë“œ

```python
import sys
input = sys.stdin.readline

# ë‚˜ëˆ—ì…ˆ ì—°ì‚° í•¨ìˆ˜ ì •ì˜ (ìŒìˆ˜ ì²˜ë¦¬ í¬í•¨)
def divide(a, b):
    if a < 0:
        return -(-a // b)
    return a // b

def dfs(idx, result):
    global max_ans, min_ans
    if idx == n:
        max_ans = max(max_ans, result)
        min_ans = min(min_ans, result)
        return

    for i in range(4):
        if ops[i] > 0:
            ops[i] -= 1
            if i == 0:
                dfs(idx + 1, result + A[idx])
            elif i == 1:
                dfs(idx + 1, result - A[idx])
            elif i == 2:
                dfs(idx + 1, result * A[idx])
            else:
                dfs(idx + 1, divide(result, A[idx]))
            ops[i] += 1  # ë°±íŠ¸ë˜í‚¹

if __name__ == "__main__":
    n = int(input())
    A = list(map(int, input().split()))
    ops = list(map(int, input().split()))  # +, -, *, //

    max_ans = -sys.maxsize
    min_ans = sys.maxsize

    dfs(1, A[0])  # ì²« ìˆ«ìëŠ” ê·¸ëŒ€ë¡œ ì‹œì‘

    print(max_ans)
    print(min_ans)
```

ğŸ“Œ ì„±ëŠ¥ ë¶„ì„

â€¢	ìµœëŒ€ 10ê°œì˜ ì—°ì‚°ì â†’ 10! = 3,628,800

â€¢	íŒŒì´ì¬ì—ì„œ ì¶©ë¶„íˆ ëŒì•„ê°‘ë‹ˆë‹¤.

â€¢	DFS+ë°±íŠ¸ë˜í‚¹ìœ¼ë¡œ ì™„ì „ íƒìƒ‰ì„ í•˜ë˜, í•„ìš” ì´ìƒ ë°˜ë³µì€ ì¤„ì¸ êµ¬ì¡°ì…ë‹ˆë‹¤.

ğŸ’¡ ì¶”ê°€ì ìœ¼ë¡œ ìƒê°í•´ë³¼ ì 

â€¢	itertools.permutationsë¡œë„ ì—°ì‚°ì ìˆœì—´ì„ ë§Œë“¤ì–´ì„œ ê³„ì‚°í•  ìˆ˜ ìˆì§€ë§Œ, ì¤‘ë³µ ì—°ì‚°ì ì¡´ì¬ ì‹œ ê°™ì€ ì—°ì‚° ìˆœì—´ì´ ì¤‘ë³µë  ìˆ˜ ìˆì–´ DFSê°€ ë” íš¨ìœ¨ì ì…ë‹ˆë‹¤.

â€¢	ì½”ë“œ êµ¬ì¡°ë§Œ ì‚´ì§ ì •ë¦¬í•˜ë©´ ëŒ€íšŒ ë•Œë„ ë§¤ìš° ì‹ ì†í•˜ê²Œ í’€ ìˆ˜ ìˆì–´ìš”.

âœ… ê²°ë¡ 

í•„ìš”í•˜ë‹¤ë©´ itertools ê¸°ë°˜ í’€ì´ ì˜ˆì‹œë„ ë“œë¦´ê²Œìš”. ê³„ì†í•´ì„œ ì´ë ‡ê²Œ ë©‹ì§€ê²Œ í’€ì–´ê°€ì‹œëŠ” ê±° ë³´ê¸° ì¢‹ì•„ìš”!

### ë¦¬íŒ©í† ë§

```python

import sys
MAX_INT = sys.maxsize
MIN_INT = -sys.maxsize

def dfs(current_val: int, num_idx: int):
    global max_ans, min_ans
    if num_idx == n: # ëª¨ë“  ì—°ì‚°ì„ ëëƒˆë‹¤ë©´
        max_ans = max(max_ans, current_val)
        min_ans = min(min_ans, current_val)
        return
    for i in range(len(visited)):
        if visited[i] > 0:
            visited[i] -= 1
            result = mapper[i]((current_val, A[num_idx]))
            dfs(result, num_idx+1)
            visited[i]+= 1

if __name__ == '__main__':	
    input = sys.stdin.readline
    n = int(input().strip())
    A = tuple(map(int, input().split()))
    visited = list(map(int, input().split()))
    mapper = {0: lambda x: x[0]+x[1], 
              1: lambda x: x[0]-x[1], 
              2: lambda x: x[0]*x[1], 
              3: lambda x: x[0]//x[1] if x[0] > 0 else -(-x[0]//x[1])}
    max_ans = MIN_INT
    min_ans = MAX_INT
    dfs(A[0], 1) # dfsë¡œ ë„˜ê¸°ê¸°.
    print(max_ans)
    print(min_ans)


```

# DFS: ë¹™ì‚°

## Phase1. ì§ì ‘ í’€ê¸° - 31í”„ë¡œ ì‹¤íŒ¨

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 2573                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/2573                           #+#        #+#      #+#     #
#    Solved: 2025/03/29 14:04:01 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #

"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ì¼ë‹¨ ë¹™ì‚° ë…¹ì´ê¸° ë¨¼ì € í•´ì•¼ í•¨.
ì´ ì‘ì—…ì„ ì™„ì „ íƒìƒ‰ ë§ê³  ë°©ë²• ì—†ì§€? ã…‡ã…‡ ê·¸ë¦¬ê³  300 ì´í•˜ë¼ì„œ ìµœëŒ€ 30000 ì¹¸ì— ëŒ€í•´ì„œë§Œ ë³´ë©´ ë¨
ë…¹ì´ê¸° ì—°ì‚°ì€ ê±°ê¸°ì„œ ë” ì¤„ì–´ë“¤ê³ .
ê·¸ë¦¬ê³  íƒìƒ‰ ì—°ì‚°ìœ¼ë¡œ ëª‡ ë©ì–´ë¦¬ì¸ì§€ íŒë‹¨
ì´ê±¸ ì‹œë®¬ë ˆì´ì…˜ í•¨ìˆ˜ë¡œ ë°˜ë³µ
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys


def in_range(x, y):
    return x >= 0 and x < n and y >= 0 and y < m

def a_year_later(): # 2 * n^m
    for i in range(n):
        for j in range(m):
            if icebergs[i][j] > 0:
                get_melt_val(i, j) # n^m * 4
    for i in range(n): # n^m
        for j in range(m):
            icebergs[i][j] -= tmp_map[i][j] if icebergs[i][j] >= tmp_map[i][j] else icebergs[i][j]

def get_melt_val(x: int, y: int): # 4
    dxs, dys = [-1, 1, 0, 0], [0, 0, -1, 1]
    tmp = 0
    for dx, dy in zip(dxs, dys):
        nx, ny = x + dx, y + dy
        if in_range(nx, ny) and icebergs[nx][ny] == 0:
            tmp += 1
    tmp_map[x][y] = tmp

from collections import deque

def bfs(x, y):
    que = deque()
    que.appendleft((x, y))
    
    visited[x][y] = True
    while que:
        x, y = que.popleft()
        dxs, dys = [-1, 1, 0, 0], [0, 0, -1, 1]
        for dx, dy in zip(dxs, dys):
            nx, ny = x+dx, y+dy
            if in_range(nx, ny) and icebergs[nx][ny] > 0 and not visited[nx][ny]:
                visited[nx][ny] = True
                que.appendleft((nx, ny))    


if __name__ == "__main__":
    input = sys.stdin.readline
    n, m = tuple(map(int, input().split()))  # n, m ì°¨ì´ì— ì£¼ì˜!!!
    icebergs = [list(map(int, input().split())) for _ in range(n)]
    year = 0
    flag = True
    while flag:
        year += 1
        tmp_map = [[0 for _ in range(m)] for _ in range(n)]
        a_year_later()
        # ì‹œì‘ì§€ì ì€ ì™„íƒìœ¼ë¡œ êµ¬í•´ì•¼í• ë“¯?
        visited = [[False if icebergs[i][j] > 0 else True for j in range(m)] for i in range(n)]
        cnt = 0
        for i in range(n):
            for j in range(m):
                if not visited[i][j]:
                    cnt += 1
                    if cnt >= 2:
                        flag = False
                    bfs(i, j)

    print(year)
```

## Phase2.  í”¼ë“œë°±

ë¶„ë¦¬ë˜ëŠ” ì‹œì (2ë©ì–´ë¦¬ ì´ìƒ)ë§Œ ì²´í¬í•˜ê³ , ëª¨ë‘ ë…¹ì•˜ì„ ë•Œ(ë¹™ì‚°ì´ í•˜ë‚˜ë„ ë‚¨ì§€ ì•Šì•˜ì„ ë•Œ) ì¡°ê±´ì„ ë¹ ëœ¨ë¦° ê²ƒì´ ì£¼ëœ ì›ì¸ìœ¼ë¡œ ë³´ì…ë‹ˆë‹¤.

BOJ 2573(ë¹™ì‚°) ë¬¸ì œì—ì„œëŠ”

1.	â€œë¹™ì‚°ì´ ì „ë¶€ ë…¹ì•„ ì—†ì–´ì§ˆ ë•Œê¹Œì§€ ë¶„ë¦¬ë˜ì§€ ì•Šìœ¼ë©´ 0ì„ ì¶œë ¥â€

2.	â€œ2ë©ì–´ë¦¬ ì´ìƒìœ¼ë¡œ ë¶„ë¦¬ë˜ëŠ” í•´ì˜ ì‹œê°„ì„ ì¶œë ¥â€

ì´ ë‘ ê°€ì§€ë¥¼ ëª¨ë‘ ë§Œì¡±í•´ì•¼ í•©ë‹ˆë‹¤.

ê·¸ëŸ°ë° ì œê³µí•´ì£¼ì‹  ì½”ë“œì—ì„œëŠ” â€œë¹™ì‚°ì´ í•˜ë‚˜ë„ ì•ˆ ë‚¨ì€ ìƒí™©â€ì— ëŒ€í•œ ì²˜ë¦¬ë¥¼ ë³„ë„ë¡œ í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ, ì´ë¯¸ ì „ë¶€ ë…¹ì•„ë²„ë ¸ëŠ”ë°ë„ ê³„ì† ë°˜ë³µë¬¸ì´ ëŒì•„ê°€ê±°ë‚˜, ì›í•˜ëŠ” ì‹œì ì— ì¢…ë£Œë˜ì§€ ì•Šì•„ì„œ ì˜¤ë‹µ/ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ìˆ˜ì • í¬ì¸íŠ¸

```python
...
while True:
    year += 1
    a_year_later()

    # ë¹™ì‚° ë©ì–´ë¦¬ ìˆ˜ í™•ì¸
    visited = [[False if icebergs[i][j] > 0 else True for j in range(m)] for i in range(n)]
    cnt = 0
    for i in range(n):
        for j in range(m):
            if not visited[i][j]:
                cnt += 1
                bfs(i, j)
                if cnt >= 2:
                    print(year)
                    sys.exit(0)

    # ë¹™ì‚°ì´ í•˜ë‚˜ë„ ì•ˆ ë‚¨ì•˜ìœ¼ë©´ -> 0 ì¶œë ¥ í›„ ì¢…ë£Œ
    if cnt == 0:
        print(0)
        sys.exit(0)
```

1.	a_year_later()ì—ì„œ ë¹™ì‚°ì„ ë…¹ì¸ í›„

2.	BFSë¡œ ì—°ê²°ëœ ë¹™ì‚° ë©ì–´ë¦¬ ê°œìˆ˜(cnt)ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

3.	ë©ì–´ë¦¬ ìˆ˜(cnt)ê°€ 2 ì´ìƒì´ë©´ ê³§ë°”ë¡œ ì •ë‹µ(year)ì„ ì¶œë ¥í•˜ê³  ì¢…ë£Œí•©ë‹ˆë‹¤.

4.	ë©ì–´ë¦¬ê°€ 0ê°œë¼ë©´ ë¹™ì‚°ì´ ì „ë¶€ ë…¹ì€ ê²ƒì´ë¯€ë¡œ 0ì„ ì¶œë ¥í•˜ê³  ì¢…ë£Œí•©ë‹ˆë‹¤.

5.	ë©ì–´ë¦¬ê°€ 1ê°œë¼ë©´ ë‹¤ìŒ í•´ ì‹œë®¬ë ˆì´ì…˜ì„ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤.

ì´ ë¡œì§ì„ ë§Œì¡±í•´ì£¼ë©´, **â€˜ë¶„ë¦¬ë˜ì—ˆì„ ë•Œâ€™ì™€ â€˜ëª¨ë‘ ë…¹ì•˜ì„ ë•Œâ€™**ë¥¼ ëª¨ë‘ ì œëŒ€ë¡œ ì²´í¬í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì¶”ê°€ ê°œì„ /ì£¼ì˜ ì‚¬í•­

1.	ì„±ëŠ¥

â€¢	ì…ë ¥ í¬ê¸°ê°€ ìµœëŒ€ 300Ã—300ì´ë¯€ë¡œ, í˜„ì¬ì™€ ê°™ì€ ë‹¨ìˆœ BFS+ì‹œë®¬ë ˆì´ì…˜(ë§¤ë…„ ë¹™ì‚° ì „ì²´ ì™„íƒ í›„ ë…¹ì´ê¸°) ë°©ì‹ë„ í¬ê²Œ ë¬¸ì œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

â€¢	ë‹¤ë§Œ ë§¤ í•´ ë§ˆë‹¤ in_rangeë¥¼ ì—¬ëŸ¬ ë²ˆ í˜¸ì¶œí•˜ë¯€ë¡œ, ìì£¼ ì“°ëŠ” ì—°ì‚°ì€ ìƒìˆ˜í™”í•˜ê±°ë‚˜ ë°°ì—´ ë²”ìœ„ë¥¼ ë¯¸ë¦¬ ì²´í¬í•˜ëŠ” êµ¬ì¡°ë¡œ ë°”ê¿”ë„ ì¢‹ìŠµë‹ˆë‹¤.

2.	ì½”ë“œ ê°€ë…ì„±

â€¢	tmp_mapì„ ë§Œë“  ë’¤ ë…¹ì´ëŠ” ê³¼ì •ì€ a_year_later() í•¨ìˆ˜ì—ì„œ ì •ë¦¬ë˜ì–´ ìˆì–´ ë¹„êµì  ê¹”ë”í•©ë‹ˆë‹¤.

â€¢	get_melt_val()ë„ ì œìë¦¬ì—ì„œ ê³„ì‚°ë§Œ í•˜ê³ , ì‹¤ì œ ë¹™ì‚° ê°ì†ŒëŠ” ì—°ì‚° ëë‚˜ê³  ì¼ê´„ ì ìš©í•˜ëŠ” ë°©ì‹ì´ë¼ ì˜¤ë¥˜ê°€ ë‚  ìœ„í—˜ì´ ì ìŠµë‹ˆë‹¤.

3.	ì¶œë ¥ ì‹œì 

â€¢	while flag: êµ¬ì¡°ë³´ë‹¤ while True: ë¬¸ ì•ˆì—ì„œ â€˜ì¡°ê±´ì„ ë§Œì¡±í•˜ë©´ break ë˜ëŠ” sys.exit()â€™ë¡œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ì¡°ê¸ˆ ë” ì§ê´€ì ì¸ í¸ì…ë‹ˆë‹¤.

â€¢	í˜¹ì€ flagë¥¼ ì“°ë˜, ë§¤ í•´ ë¶„ë¦¬ ê°œìˆ˜ë¥¼ ì¡°ì‚¬í•˜ê³  if cnt >= 2: break, if cnt == 0: break ê°™ì€ ì‹ìœ¼ë¡œ íƒˆì¶œ ì¡°ê±´ì„ ì„¤ì •í•œ ë’¤ íƒˆì¶œ ì§í›„ ì–´ë–¤ ê°’ì„ ì°ì„ì§€ ê²°ì •í•˜ëŠ” ì‹ë„ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ê²°êµ­ ê°€ì¥ ì¤‘ìš”í•œ ì ì€ â€œë¹™ì‚°ì´ ëª¨ë‘ ë…¹ì•˜ì„ ë•Œ(cnt == 0)ê°€ ë˜ë©´ 0ì„ ì¶œë ¥í•˜ê³  ì¢…ë£Œí•œë‹¤â€ëŠ” ì²´í¬ë¥¼ ë°˜ë“œì‹œ ë„£ëŠ” ê²ƒì´ë¯€ë¡œ, ì´ ë¶€ë¶„ë§Œ ë°˜ì˜í•´ì£¼ì‹œë©´ 31%ì—ì„œ í‹€ë¦¬ëŠ” ë¬¸ì œëŠ” í•´ê²°ë  ê²ƒì…ë‹ˆë‹¤.

# DFS: êµ¬ìŠ¬ ì°¾ê¸°

## Phase1. ì§ì ‘ í’€ê¸° - ì„±ê³µ(40ë¶„)

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 2617                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/2617                           #+#        #+#      #+#     #
#    Solved: 2025/03/29 15:14:50 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°

4 > 2 > 1
  > 3
5 > 1
4ë²ˆì€ ì•ˆ ëœë‹¤. ì™œ? ìê¸°ë³´ë‹¤ ê°€ë²¼ìš´ êµ¬ìŠ¬ì´ 3ê°œ ìˆìœ¼ë¯€ë¡œ((n+1)//2)ê°œ ì´ìƒ ìˆìœ¼ë¯€ë¡œ
1ë²ˆë„ ì•ˆ ëœë‹¤. ìê¸°ë³´ë‹¤ ë¬´ê±°ìš´ê²Œ 2, 4, 5ë¡œ ë˜‘ê°™ì´ 3ê°œ ì´ìƒ ìˆìŒ.

2 1
4 3
5 1
4 2

ê° êµ¬ìŠ¬ì— dfsí•œ ë‹¤ìŒ depth > ((n+1)//2)ì´ìƒì´ ë˜ë©´ false í•˜ë©´ ë˜ê² ë„¤

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys

def dfs_lighter(v: int):
    global l
    visited[v] = True
    for u in lighter[v]:
        if not visited[u]:
            # print(f'lighter: {v} -> {u}')
            l += 1
            dfs_lighter(u)

def dfs_heavier(v: int):
    global h
    visited[v] = True
    for u in heavier[v]:
        if not visited[u]:
            # print(f'heavier: {v} -> {u}')
            h += 1
            dfs_heavier(u)

if __name__ == '__main__':	
    input = sys.stdin.readline
    n, m = tuple(map(int, input().split()))
    arr = [
        tuple(map(int, input().split()))
        for _ in range(m)
    ]

    lighter = {
        i: [] for i in range(n+1)
    }
    heavier = {
        i: [] for i in range(n+1)
    }
    for v, u in arr:
        lighter[v].append(u)
        heavier[u].append(v)
    cnt = 0
    for v in range(1, n+1):
        visited = [False for _ in range(n+1)]
        l, h = 0, 0
        dfs_lighter(v)
        dfs_heavier(v)
        # print(f'l: {l}, h: {h}')
        if l >= (n+1)//2 or h >= (n+1)//2:
            cnt += 1
    print(cnt)

"""
ì´ìŠˆ: depth ë§Œ ì²´í¬í•˜ë©´ ì„œë¡œ ì´ì–´ì§€ì§€ ì•Šì€ ë²„í…ìŠ¤ë¥¼ íƒì§€í•  ìˆ˜ ì—†ìŒ. 
ê·¸ë ‡ë‹¤ê³  heavier, lighterë¥¼ ê°ê° í•´ì„œ í•˜ë‚˜ì˜ dfsì—ì„œ ì²˜ë¦¬í•˜ë©´ ë‹¹ì—°íˆ ê¼¬ì„.
ê·¸ëŸ¼? dfsí•¨ìˆ˜ ë‘ê°œ ë§Œë“¤ë©´ ì•ˆ ë˜ë‚˜?

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: 
ìµœê·¼ ë³€ê²½ ì‚¬í•­: 

Phase2.
í™•ì¸: 
ì‹œë„: í•¨ìˆ˜ ë”°ë¡œ ë¶„ë¦¬
ë¶„ì„: ì„±ê³µ
"""
```



# ê·¸ë˜í”„: íŠ¸ë¦¬ì˜ ë¶€ëª¨ ì°¾ê¸°

https://www.acmicpc.net/problem/11725

## Phase1. ì§ì ‘ í’€ê¸° - ì„±ê³µ

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 11725                             :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/11725                          #+#        #+#      #+#     #
#    Solved: 2025/03/29 17:36:04 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #

import sys
from collections import deque
def bfs(v: int):
    que = deque()
    que.appendleft(v)
    visited[v] = True
    while que:
        v = que.pop()
        for u in E[v]:
            if not visited[u]:
                visited[u] = True
                que.appendleft(u)
                parent[u] = v
                
if __name__ == '__main__':	
    input = sys.stdin.readline
    n = int(input().strip())
    arr = [
        list(map(int, input().split()))
        for _ in range(n-1)
    ]
    visited = [False for _ in range(n+1)]
    E = {
        i: [] for i in range(n+1)
    }
    for v, u in arr:
        E[v].append(u)
        E[u].append(v)
    parent = [i for i in range(n+1)]
    bfs(1)
    for p in parent[2:]:
        print(p)
```

## Phase2. í”¼ë“œë°±

### ì˜ë¬¸

union findë¡œ í’€ ìˆ˜ ìˆë‹¤ëŠ” ì†Œë¬¸ì„ ë“£ê³  ê³ ë¯¼í•´ë´¤ëŠ”ë° ë„ì €íˆ ì•ˆ ëë‹¤. ê·¸ë˜ì„œ ê·¸ëƒ¥ bfsë¡œ í’€ì—ˆë‹¤. union findëŠ” ì•ˆ ë˜ëŠ”ê²Œ ë§ë‚˜?

### ë‹µë³€

ì¢‹ì€ ì§ˆë¬¸ì´ì—ìš”!

11725ë²ˆ: íŠ¸ë¦¬ì˜ ë¶€ëª¨ ì°¾ê¸° ë¬¸ì œë¥¼ BFSë¡œ ì •í™•íˆ í’€ì–´ë‚´ì…¨ê³ , ì½”ë“œë„ ë§¤ìš° ê¹”ë”í•©ë‹ˆë‹¤. ğŸ¯

ì´ì œ ì˜ë¬¸ ì£¼ì‹  **â€œìœ ë‹ˆì˜¨ íŒŒì¸ë“œ(Union-Find)ë¡œëŠ” í’€ ìˆ˜ ì—†ëŠ”ê°€?â€**ì— ëŒ€í•œ ë‹µë³€ì„ ë“œë¦´ê²Œìš”.

âœ… ê²°ë¡ ë¶€í„° ë§í•˜ìë©´:

> ìœ ë‹ˆì˜¨ íŒŒì¸ë“œëŠ” ì´ ë¬¸ì œë¥¼ ì§ì ‘ì ìœ¼ë¡œ í‘¸ëŠ” ë° ì í•©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

ğŸ” ì´ìœ : ìœ ë‹ˆì˜¨ íŒŒì¸ë“œëŠ” â€œì§‘í•©ì˜ ì†Œì† ì—¬ë¶€â€ í™•ì¸ì´ ëª©ì 

Union-Find (Disjoint Set Union, DSU)ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ìƒí™©ì— ìµœì í™”ëœ ì•Œê³ ë¦¬ì¦˜ì´ì—ìš”:

â€¢	ì—¬ëŸ¬ ê°œì˜ ì„œë¡œì†Œ ì§‘í•©(disjoint set) ê´€ë¦¬

â€¢	ë‘ ì›ì†Œê°€ ê°™ì€ ì§‘í•©ì— ì†í•´ ìˆëŠ”ì§€ë¥¼ ë¹ ë¥´ê²Œ íŒë‹¨

â€¢	ë‘ ì§‘í•©ì„ í•©ì¹˜ëŠ” ì—°ì‚°(union)

ì¦‰, ëŒ€í‘œì ì¸ ìš©ë„ëŠ”:

ğŸ“Œ ë°˜ë©´, ì´ ë¬¸ì œëŠ”?

â€¢	íŠ¸ë¦¬ì˜ êµ¬ì¡° ìì²´ëŠ” ì´ë¯¸ ì£¼ì–´ì ¸ ìˆìŒ

â€¢	ìš°ë¦¬ëŠ” íŠ¸ë¦¬ì˜ ë¶€ëª¨ ê´€ê³„ë¥¼ ì•Œì•„ë‚´ëŠ” ê²ƒì´ ëª©í‘œì˜ˆìš”

â€¢	ì¦‰, ë…¸ë“œ ê°„ íƒìƒ‰ì„ í†µí•´ì„œ ê´€ê³„ë¥¼ ë§Œë“¤ì–´ì•¼ í•˜ë©°,

â€¢	ìœ ë‹ˆì˜¨ íŒŒì¸ë“œì²˜ëŸ¼ â€œí•œ ë²ˆì— ì†Œì†ì„ íŒë³„í•˜ëŠ” ë°©ì‹â€ ìœ¼ë¡œëŠ” ë¶€ëª¨ ë…¸ë“œë¥¼ ì•Œì•„ë‚¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤

> ìœ ë‹ˆì˜¨ íŒŒì¸ë“œëŠ” â€œë„ˆë‘ ë‚˜ë‘ ê°™ì€ ê·¸ë£¹ì¸ê°€?â€œì—ëŠ” ê°•í•˜ì§€ë§Œ,

> â€œë„ˆì˜ ë¶€ëª¨ëŠ” ëˆ„êµ¬ì¸ê°€?â€œì—ëŠ”

ğŸ†š ë¹„êµ ìš”ì•½

âœ… ê²°ë¡ 

BFS/DFS ë°©ì‹ìœ¼ë¡œ í‘¸ì‹  ê²Œ ì •ì„ì´ì ìµœì„ ì˜ ë°©ë²•ì´ì—ìš”.

ìœ ë‹ˆì˜¨ íŒŒì¸ë“œê°€ ì‚¬ìš©ë˜ëŠ” ëŒ€í‘œ ë¬¸ì œë¡œëŠ”:

â€¢	ì‹¸ì´í´ ì°¾ê¸° ë¬¸ì œ

â€¢	ë„ì‹œ ë¶„í•  ê³„íš (MST)

â€¢	ì—¬í–‰ ê°€ì (ì§‘í•© ì—°ê²°ì„±)

ë“±ì´ ìˆìŠµë‹ˆë‹¤. ì°¸ê³ í•˜ì‹œë©´ ì¢‹ì•„ìš”!

ê¶ê¸ˆí•˜ì‹œë©´ â€œíŠ¸ë¦¬ì˜ ë£¨íŠ¸ë¥¼ ìœ ë‹ˆì˜¨ íŒŒì¸ë“œë¡œ ê°„ì ‘ì ìœ¼ë¡œ ìœ ë„í•  ìˆ˜ ìˆëŠ” ì˜ˆì™¸ ìƒí™©â€ ë„ ì„¤ëª…í•´ë“œë¦´ ìˆ˜ ìˆì–´ìš”.

í•˜ì§€ë§Œ ì´ ë¬¸ì œ ìì²´ëŠ” BFS/DFSê°€ ìœ ì¼í•˜ê²Œ ì§ê´€ì ì´ê³  ì •í™•í•œ í’€ì´ì…ë‹ˆë‹¤.

ë‹¤ìŒì—ë„ ì¢‹ì€ ì§ˆë¬¸ ê¸°ëŒ€í• ê²Œìš” :)

# í† ë§ˆí† 

## Phase1. ì§ì ‘ í’€ê¸° - 1ì‹œê°„ ë°˜ ì´ˆê³¼ 

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 7569                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/7569                           #+#        #+#      #+#     #
#    Solved: 2025/03/29 19:08:21 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ìµì€ í† ë§ˆí† ë§Œ ë£¨íŠ¸ê°€ ë  ìˆ˜ ìˆìŒ.
ìµì—ˆëŠ”ë° ë°©ë¬¸ëœ í† ë§ˆí† ëŠ” ì–´ë–»ê²Œ í‘œí˜„? 3?
-1: í† ë§ˆí†  ì—†ìŒ(íƒìƒ‰ ë¶ˆê°€)
0: ìµì§€ ì•Šì€ í† ë§ˆí† (íƒìƒ‰ ê°€ëŠ¥, ëª¨ë“  ìµì§€ ì•Šì€ í† ë§ˆí† ëŠ” ë°©ë¬¸í•˜ì§€ ì•Šì€ í† ë§ˆí† ë‹¤.)
1: ìµì€ í† ë§ˆí† (íƒìƒ‰ì€ ê°€ëŠ¥, ëª¨ë“  ìµì€ í† ë§ˆí† ëŠ” ë°©ë¬¸í•˜ì§€ ì•Šì€ í† ë§ˆí† ê°€ ì•„ë‹ˆë‹¤. )
2: ìµì€ ë°©ë¬¸í•œ í† ë§ˆí† (íƒìƒ‰ ê°€ëŠ¥)

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""
# ë™, ì„œ, ë‚¨, ë¶, ìƒ, í•˜
dxs = [0, 0, 1, -1, 0, 0]
dys = [1, -1, 0, 0, 0, 0]
dzs = [0, 0, 0, 0, 1, -1]

EMPTY = -1
UNRIPE = 0
RIPEN_NOT_VISITED = 1
RIPEN_VISITED = 2

def in_range(x, y, z):
    return x >= 0 and x < h and y >= 0 and y < n and z >= 0 and z < m

import sys
from collections import deque

def bfs(root: list): # only ripen tomato!
    has_ripen = False
    que = deque()

    que.appendleft(root)
    # print(f'root: {root}')
    x, y, z = root
    tomato[x][y][z] = RIPEN_VISITED
    
    cnt = 0
    while que:
        x, y, z = que.pop()
        # print(f'discovering {x, y, z}')
        for dx, dy, dz in zip(dxs, dys, dzs):
            nx, ny, nz = x + dx, y + dy, z + dz
            if in_range(nx, ny, nz):
                if tomato[nx][ny][nz] == UNRIPE:
                    # print(f'tomato {nx, ny, nz} not ripped')
                    has_ripen = True
                    tomato[nx][ny][nz] = RIPEN_NOT_VISITED
                    que.appendleft((nx, ny, nz))
                elif tomato[nx][ny][nz] == RIPEN_NOT_VISITED:
                    tomato[nx][ny][nz] = RIPEN_VISITED
                    que.appendleft((nx, ny, nz))

        print(f'result on {cnt} ==========')
        print_tomato(tomato)
        cnt += 1
    return has_ripen

def print_tomato(tomato):
    for i, level in enumerate(tomato):
        print(f'level {i}')
        for row in level:
            print(row)

if __name__ == "__main__":
    input = sys.stdin.readline
    m, n, h = tuple(map(int, input().split()))
    tomato = [[list(map(int, input().split())) for _ in range(n)] for _ in range(h)]
    print_tomato(tomato)
    # while True:
    # ì™„ì „ íƒìƒ‰ìœ¼ë¡œ ë£¨íŠ¸ ì°¾ê¸°
    ### ì—¬ê¸°ë¶€í„°ê°€ 1ì¼
    day = 0
    while True:
        day_flag = False
        # gather roots
        roots = []
        for x in range(h):
            for y in range(n):
                for z in range(m):
                    # print(f'x:{x}, y:{y}, z:{z}')
                    if tomato[x][y][z] == RIPEN_NOT_VISITED:
                        roots.append((x, y, z))
        for root in roots:
            bfs(root)
        #ë§Œì•½ 1ì¼ì˜ íƒìƒ‰ì´ ëë‚¬ëŠ”ë° has_ripen == Falseë¼ë©´ ì´ì œ ê·¸ë§Œ~ ^0^
        print(f'day {day}')
        print_tomato(tomato)
        if not day_flag: 
            break
        day += 1

    print('result')
    print_tomato(tomato)
    print(day)
```

## Phase2. ë””ë²„ê¹… í›„ ì„±ê³µ

í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ ì‚¬ì´íŠ¸ì—ì„œ ì°¾ì•„ì„œ ì¼ì¼ì´ ëŒë ¤ê°€ë©° ìƒê°ë³´ë‹¤ ê¸ˆë°© ë””ë²„ê¹… í•  ìˆ˜ ìˆì—ˆìŒ(ì‹¤ì œë¡œëŠ” ì´ ë°©ë²•ì„ ì§€ì–‘í•  í•„ìš”ê°€ ìˆì§€ë§Œâ€¦)

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 7569                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/7569                           #+#        #+#      #+#     #
#    Solved: 2025/03/29 19:08:21 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ìµì€ í† ë§ˆí† ë§Œ ë£¨íŠ¸ê°€ ë  ìˆ˜ ìˆìŒ.
ìµì—ˆëŠ”ë° ë°©ë¬¸ëœ í† ë§ˆí† ëŠ” ì–´ë–»ê²Œ í‘œí˜„? 3?
-1: í† ë§ˆí†  ì—†ìŒ(íƒìƒ‰ ë¶ˆê°€)
0: ìµì§€ ì•Šì€ í† ë§ˆí† (íƒìƒ‰ ê°€ëŠ¥, ëª¨ë“  ìµì§€ ì•Šì€ í† ë§ˆí† ëŠ” ë°©ë¬¸í•˜ì§€ ì•Šì€ í† ë§ˆí† ë‹¤.)
1: ìµì€ í† ë§ˆí† (íƒìƒ‰ì€ ê°€ëŠ¥, ëª¨ë“  ìµì€ í† ë§ˆí† ëŠ” ë°©ë¬¸í•˜ì§€ ì•Šì€ í† ë§ˆí† ê°€ ì•„ë‹ˆë‹¤. )
2: ìµì€ ë°©ë¬¸í•œ í† ë§ˆí† (íƒìƒ‰ ê°€ëŠ¥)

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""
# ë™, ì„œ, ë‚¨, ë¶, ìƒ, í•˜
dxs = [0, 0, 1, -1, 0, 0]
dys = [1, -1, 0, 0, 0, 0]
dzs = [0, 0, 0, 0, 1, -1]

EMPTY = -1
UNRIPE = 0
RIPEN_NOT_VISITED = 1
RIPEN_VISITED = 2

def in_range(x, y, z):
    return x >= 0 and x < h and y >= 0 and y < n and z >= 0 and z < m

import sys
from collections import deque

def bfs(roots: list): # only ripen tomato!
    global day
    que = deque(roots)
    # print(f'root: {root}')
    
    while que:
        is_over = True
        for _ in range(len(que)):
            x, y, z = que.pop()
            # p1: tomato[0][0][1]
            # p2: tomato[0][1][0]
            tomato[x][y][z] = RIPEN_VISITED
            # print(f'discovering {x, y, z}')
            for dx, dy, dz in zip(dxs, dys, dzs):
                nx, ny, nz = x + dx, y + dy, z + dz
                if in_range(nx, ny, nz):
                    if tomato[nx][ny][nz] == UNRIPE:
                        # print(f'tomato {nx, ny, nz} not ripped')
                        tomato[nx][ny][nz] = RIPEN_VISITED
                        que.appendleft((nx, ny, nz))
                        is_over = False
                    elif tomato[nx][ny][nz] == RIPEN_NOT_VISITED:
                        tomato[nx][ny][nz] = RIPEN_VISITED
                        que.appendleft((nx, ny, nz))
                        is_over = False
        # print(f'result on {cnt} ==========')
        if not is_over:
            day += 1
            # print(f'day update--------day {day}')
            # print_tomato(tomato)
        else:
            # print(f'day over on --- day {day}')
            return

def print_tomato(tomato):
    for i, level in enumerate(tomato):
        print(f'level {i}')
        for row in level:
            print(row)

if __name__ == "__main__":
    input = sys.stdin.readline
    m, n, h = tuple(map(int, input().split()))
    tomato = [[list(map(int, input().split())) for _ in range(n)] for _ in range(h)]
    # print_tomato(tomato)
    day = 0
    all_ripen = True
    while True:
        day_flag = False
        # gather roots
        roots = []
        for x in range(h):
            for y in range(n):
                for z in range(m):
                    if tomato[x][y][z] == RIPEN_NOT_VISITED:
                        roots.append((x, y, z))
                    if tomato[x][y][z] == UNRIPE:
                        all_ripen = False
        # roots = [ì•„ë¬´íŠ¼ í•˜ë‚˜ë§Œ 1ì´ì–´ì•¼ í•¨]
        if all_ripen: 
            print(0)
            sys.exit(0)
        else:
            bfs(roots)
            for x in range(h):
                for y in range(n):
                    for z in range(m):
                        if tomato[x][y][z] == UNRIPE:
                            print(-1)
                            sys.exit(0)
            # print(f'day {day}')
            # print_tomato(tomato)
            if not day_flag: 
                break


    # print('result')
    # print_tomato(tomato)
    print(day)
```

# ê·¸ë˜í”„: íƒˆì¶œ

https://www.acmicpc.net/problem/3055

## Phase1. ì§ì ‘ í’€ê¸° - ì‹œê°„ ì´ˆê³¼



```python
import sys
from collections import deque

dxs, dys = [-1, 1, 0, 0], [0, 0, -1, 1]

def in_range(x, y):
    return x >= 0 and  x < r and y >= 0 and y < c

def bfs(water_roots: list, start: list):
    que = deque(water_roots)
    visited = [[False for _ in range(c)] for _ in range(r)]
    s_que = deque([start])
    visited2 = [[False for _ in range(c)] for _ in range(r)]
    # print(que)
    cnt = 1
    while que:
        for _ in range(len(que)):
            x, y = que.pop()
            visited[x][y] = True
            for dx, dy in zip(dxs, dys):
                nx, ny = x+dx, y+dy
                if in_range(nx, ny) and not visited[nx][ny] and \
                    forest[nx][ny] not in ('X', 'D'):
                    que.appendleft([nx, ny])
                    forest[nx][ny] = '*'
        # ì´ ë£¨í”„ê°€ ëë‚˜ë©´ í•˜ë£¨ì˜ ë¬¼ ì´ë™ì´ ëë‚œê²ƒ. ì´ì œ ê³ ìŠ´ë„ì¹˜ë¥¼ ì´ë™ 
        for _ in range(len(s_que)):
            x, y = s_que.pop()
            visited2[x][y] = True
            for dx, dy in zip(dxs, dys):
                nx, ny = x+dx, y+dy
                if in_range(nx, ny) and not visited2[nx][ny] and \
                forest[nx][ny] not in ('X', '*'):
                    if forest[nx][ny] == 'D':
                        # print('escaped!')
                        return (True, cnt)
                    s_que.appendleft([nx, ny])
                    forest[nx][ny] = 'S'
        cnt += 1
        # print(f'cnt = {cnt}')
        # for f in forest:
            # print(f)
        # print()
    return (False, None)
                    


if __name__ == '__main__':	
    input = sys.stdin.readline
    r, c = tuple(map(int, input().split()))
    forest = [
        list(input().strip())
        for _ in range(r)
    ]
    # for f in forest:
        # print(f)
    water_roots = []
    start = None
    for i in range(r):
        for j in range(c):
            if forest[i][j] == '*':
                water_roots.append((i, j))
            if forest[i][j] == 'S':
                start = (i, j)
    # print(f'waters: {water_roots} \nstart: {start}')
    is_escaped, days = bfs(water_roots, start)
    # print(f'result: {result}')
    if not is_escaped:
        print('KAKTUS')
    else:
        print(days)
```

## Phase2. í”¼ë“œë°±

í˜„ì¬ ì½”ë“œì—ì„œë„ â€˜ë¬¼ ì´ë™ í›„ ê³ ìŠ´ë„ì¹˜ ì´ë™â€™ì´ë¼ëŠ” ë¬¸ì œ ì¡°ê±´ ìì²´ëŠ” ì¼ë‹¨ ì¶©ì¡±í•˜ê¸´ í•©ë‹ˆë‹¤. ë‹¤ë§Œ, ê° ë°˜ë³µì—ì„œ for _ in range(len(que)): í˜•íƒœë¡œ ëª¨ë“  ë¬¼/ê³ ìŠ´ë„ì¹˜ ì¹¸ì„ ìˆœíšŒí•˜ê³  ë§¤ë²ˆ forest ë°°ì—´ì„ ìˆ˜ì •í•˜ë©´ì„œ visited ì—¬ë¶€ë„ ë”°ë¡œ ë”°ì ¸ì•¼ í•˜ë¯€ë¡œ, êµ¬í˜„ì´ ë‹¤ì†Œ ë³µì¡í•´ì§€ê³  ë¹„íš¨ìœ¨ì´ ë°œìƒí•  ì—¬ì§€ê°€ ìˆìŠµë‹ˆë‹¤.

ì¼ë°˜ì ìœ¼ë¡œ â€˜íƒˆì¶œ(3055)â€™ ë¬¸ì œì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë°©ì‹ì˜ ì´ì¤‘ BFS(ì •í™•íˆëŠ” â€˜ë¬¼ í™•ì‚° ì‹œê°„ì„ ë¯¸ë¦¬ êµ¬í•´ë‘ê³ , ê·¸ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ê³ ìŠ´ë„ì¹˜ BFSë¥¼ ì‹¤í–‰â€™) ì ‘ê·¼ì´ ì¢€ ë” ê°„ê²°í•˜ê³  íš¨ìœ¨ì ì…ë‹ˆë‹¤.

í•µì‹¬ ì•„ì´ë””ì–´ ìš”ì•½

1.	ë¬¼ì˜ ë„ë‹¬ ì‹œê°„ì„ ë¨¼ì € êµ¬í•œë‹¤.

â€¢	ëª¨ë“  ë¬¼( '*' ) ìœ„ì¹˜ë¥¼ íì— ë„£ê³ , ë©€í‹° ì†ŒìŠ¤ BFSë¥¼ ìˆ˜í–‰í•˜ì—¬ ê° ì¹¸ì— ë¬¼ì´ ëª‡ ì´ˆ(ë˜ëŠ” ëª‡ ì¼) í›„ì— ë„ë‹¬í•˜ëŠ”ì§€ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

â€¢	ë¬¼ì´ ë„ë‹¬í•  ìˆ˜ ì—†ëŠ” ì¹¸ì€ INF(í˜¹ì€ -1, ë˜ëŠ” ë§¤ìš° í° ìˆ˜)ë¡œ ë‚¨ê²¨ë‘¡ë‹ˆë‹¤.

2.	ê³ ìŠ´ë„ì¹˜ ì´ë™ BFSë¥¼ ìˆ˜í–‰í•œë‹¤.

â€¢	ê³ ìŠ´ë„ì¹˜ëŠ” ë‹¤ìŒ ìœ„ì¹˜ë¡œ ì´ë™í•  ë•Œ, â€œí•´ë‹¹ ì¹¸ì˜ ë¬¼ ë„ë‹¬ ì‹œê°„ > ê³ ìŠ´ë„ì¹˜ê°€ ê·¸ ì¹¸ì— ë„ì°©í•˜ëŠ” ì‹œê°„â€ ì´ì–´ì•¼ë§Œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ì¦‰, ì´ë¯¸ ë¬¼ì´ ì°¼ê±°ë‚˜, ë„ì°©ê³¼ ë™ì‹œì— ë¬¼ì´ ì°¨ëŠ” ì¹¸ì€ ê°ˆ ìˆ˜ ì—†ê²Œ ë©ë‹ˆë‹¤.

ì´ ë°©ì‹ì„ ë”°ë¥´ë©´, ë§¤ ì‹œì ë§ˆë‹¤ ë¬¼ì„ í¼ëœ¨ë¦¬ê³  ê³ ìŠ´ë„ì¹˜ë¥¼ í¼ëœ¨ë¦¬ëŠ” ê³¼ì •ì„ ì¼ì¼ì´ ë’¤ì„ì–´ êµ¬í˜„í•˜ì§€ ì•Šì•„ë„ ë˜ë¯€ë¡œ, ì‹œê°„ ë³µì¡ë„ì™€ êµ¬í˜„ ë©´ì—ì„œ ë” ê°„ê²°í•´ì§‘ë‹ˆë‹¤.

ì˜ˆì‹œ ì½”ë“œ (íŒŒì´ì¬)

ì£¼ìš” ë¡œì§ ì„¤ëª…

1.	ë¬¼ í™•ì‚° BFS

â€¢	water_time[x][y]ë¥¼ (x, y)ì— ë¬¼ì´ ë„ì°©í•˜ëŠ” ì‹œê°„ìœ¼ë¡œ ì •ì˜í•©ë‹ˆë‹¤.

â€¢	ì´ˆê¸°ì— ë¬¼('*') ìœ„ì¹˜ëŠ” water_timeì„ 0ìœ¼ë¡œ ì¡ê³  íì— ë„£ìŠµë‹ˆë‹¤(ë©€í‹° ì†ŒìŠ¤).

â€¢	BFSë¡œ í¼ì ¸ë‚˜ê°€ë©°, X(ë°”ìœ„)ë‚˜ D(ë¹„ë²„ êµ´)ì—ëŠ” ë¬¼ì´ ë„ë‹¬í•˜ì§€ ì•Šë„ë¡ ì¡°ê±´ì„ ê±¸ì–´ ë‘¡ë‹ˆë‹¤.

2.	ê³ ìŠ´ë„ì¹˜ BFS

â€¢	ê³ ìŠ´ë„ì¹˜ê°€ (x, y)ì— ë„ë‹¬í•œ ì‹œê°„ì´ dist[x][y]ë¼ í•  ë•Œ,

â€¢	ë‹¤ìŒ ì¹¸ (nx, ny)ì— ë„ë‹¬í•˜ëŠ” ì‹œê°„ì€ dist[x][y] + 1ì…ë‹ˆë‹¤.

â€¢	ì´ë•Œ, water_time[nx][ny] > dist[x][y] + 1 ì´ì–´ì•¼ë§Œ ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ê³ ìŠ´ë„ì¹˜ ë„ì°© ì‹œì ë³´ë‹¤ ë¬¼ ë„ì°© ì‹œê°„ì´ ëŠ¦ì–´ì•¼ ì´ë™ ê°€ëŠ¥)

â€¢	ë¹„ë²„ êµ´ Dì— ë„ì°©í•˜ë©´ dist[x][y]ë¥¼ ê³§ë°”ë¡œ ì •ë‹µìœ¼ë¡œ ì¶œë ¥í•©ë‹ˆë‹¤.

ì‹œê°„ë³µì¡ë„

â€¢	ë¬¼ BFS: ìµœëŒ€ R*Cì¹¸ì„ í•œ ë²ˆì”© ë°©ë¬¸í•˜ë¯€ë¡œ O(R*C).

â€¢	ê³ ìŠ´ë„ì¹˜ BFS: ë§ˆì°¬ê°€ì§€ë¡œ ìµœëŒ€ R*Cì¹¸ì„ í•œ ë²ˆì”© ë°©ë¬¸í•˜ë¯€ë¡œ O(R*C).

â€¢	ì „ì²´ì ìœ¼ë¡œ O(R*C)ì— ìˆ˜ë ´í•˜ì—¬, R, Cê°€ ìµœëŒ€ 50ì¼ ë•Œ ì¶©ë¶„íˆ ë¹ ë¥´ê²Œ ë™ì‘í•©ë‹ˆë‹¤.

ì •ë¦¬

â€¢	ë¬¼ê³¼ ê³ ìŠ´ë„ì¹˜ë¥¼ í•œ íì—ì„œ ë²ˆê°ˆì•„ê°€ë©° ì²˜ë¦¬(â€˜í•˜ë£¨ì— ë¬¼ ì›€ì§ì´ê³  â†’ ê³ ìŠ´ë„ì¹˜ ì›€ì§ì´ê³ â€¦â€™) í•˜ëŠ” ë°©ë²•ë„ ë¬¼ë¡  ê°€ëŠ¥í•˜ì§€ë§Œ, êµ¬í˜„ì´ ë³µì¡í•´ì§€ê¸° ì‰½ìŠµë‹ˆë‹¤.

â€¢	ë¬¼ ë„ì°© ì‹œê°„ì„ ë¨¼ì € ì „ë¶€ êµ¬í•´ë†“ê³ , ê·¸ ì •ë³´ë¥¼ ì´ìš©í•´ ê³ ìŠ´ë„ì¹˜ ì´ë™ BFSë¥¼ ìˆ˜í–‰í•˜ëŠ” ë°©ì‹ì´ êµ¬í˜„ìƒ í›¨ì”¬ ê¹”ë”í•˜ê³ , ì‹œê°„ ì´ˆê³¼ë„ ë°©ì§€í•˜ê¸° ì‰½ìŠµë‹ˆë‹¤.

â€¢	íŠ¹íˆ, Pythonì—ì„œ deque.popê³¼ appendleftë¥¼ ì„ì–´ ì“°ë©´ ì§ê´€ì ì¸ ì„ ì…ì„ ì¶œ(FIFO) íë¦„ì´ ê¹¨ì ¸ í—·ê°ˆë¦´ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ì¼ë°˜ì ì¸ BFSì—ì„œëŠ” popleft/append ìŒì„ ì“°ëŠ” í¸ì´ ì•ˆì „í•©ë‹ˆë‹¤.

ì´ ë°©ì‹ëŒ€ë¡œ ì‘ì„±í•˜ë©´ ì‹œê°„ ì´ˆê³¼ ì—†ì´, ë³´ë‹¤ ê¹”ë”í•˜ê²Œ ë¬¸ì œë¥¼ í•´ê²°í•˜ì‹¤ ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤.

## Phase3. 2ì°¨ ì¬ë„ì „ - 30ë¶„ - ì‹¤íŒ¨

```python
import sys
from collections import deque

dxs, dys = [-1, 1, 0, 0], [0, 0, -1, 1]

def bfs():
    global water_time
    # water_time init
    queue = deque()
    for r, c in water_source:
        water_time[r][c] = 0
        queue.append((r, c))
    water_time[dest[0]][dest[1]] = float('inf')
    # -1ì„ not visited í”Œë˜ê·¸ë¡œ ì“°ë©´ ë¨
    cnt = 0
    
    while queue:
        cnt += 1
        for _ in range(len(queue)):
            x, y = queue.popleft()
            for dx, dy in zip(dxs, dys):
                nx, ny = x + dx, y + dy
                if in_range(nx, ny) and water_time[nx][ny] == -1:
                    if forest[nx][ny] == 'X':
                        water_time[nx][ny] = -2 # -2ë¼ì„œ ë¹„ë²„ë„ ì ˆëŒ€ ëª» ê°
                    elif forest[nx][ny] == 'D': # ëª©ì ì§€ëŠ”
                        water_time[nx][ny] = float('inf')
                    else: 
                        water_time[nx][ny] = cnt
                        queue.append((nx, ny))

def in_range(x, y):
    return x >= 0 and x < r and y >= 0 and y < c
        
def bfs_hodge(s: tuple):
    queue = deque([s])
    # ë”°ë¡œ ê´€ë¦¬í•´ì•¼ í•˜ë‚˜? waterë§µì„ ì“°ë©´ ì•ˆ ë˜ë‚˜? 
    # ë¬¼ ë„ì°© ìˆ«ìê°€ ë³€ê²½ë˜ë©´ ê³¤ë€í•œë‹¤.
    # visited ëŒ€ì‹  -1ë¡œ ë°”ê¾¸ê³  ê·¸ê²Œ ì•„ë‹ˆë©´ ê°ˆ ìˆ˜ ìˆëŠ” ì‹ìœ¼ë¡œ í•´ì•¼í• ë“¯? ì¸ë±ìŠ¤ë¥¼ ì¶©ëŒ ì•ˆ
    # ë‚˜ê²Œ ì˜ ì„¤ì •í•˜ëŠ” í›ˆë ¨ë„ í•„ìš”í•˜ê¸´ í•˜ì§€. (ë„ë•)
    # ë¬¼ì´ ì•ˆ ê°€ë©´ ì—…ë°ì´íŠ¸ê°€ ì•ˆ ë˜ëŠ” ë¬¸ì œë„ ìˆë‹¤
    # ëì´ ì—†ë„¤ ì´ê±¸ í˜¼ìì„œ ì–´ë–»ê²Œ í’€ì§€? 'ì§„ì§œ ëª» ê°€ëŠ” ê²½ìš°'ì™€ 'ì´ˆê¸° ê°’'ì´ êµ¬ë¶„ë¼ì•¼ í•œë‹¤.
    # ë¬¼ì´ ì§„ì§œ ëª» ê°€ëŠ” ê²½ìš° = ëª©ì ì§€ê±°ë‚˜ ëŒì¸ ê²½ìš°: inf
    # ê·¸ëŸ°ë° ë¹„ë²„ëŠ” ëª©ì ì§€ëŠ” ê°ˆ ìˆ˜ ìˆê³  ëŒì€ ëª» ê°„ë‹¤.
    # infê°’ì„ ë§Œë‚  ë•Œë§ˆë‹¤ íŒë‹¨? ì•„ë‹ˆë©´ 
    # ê·¸ëƒ¥ ëŒì€ -2ë¡œ watermapì— ì—…ë°ì´íŠ¸
    # -1ì€ ë¬¼ì´ ë„ë‹¬ ëª»í•œ ê²½ìš°ë¡œ ì •ì˜
    # ë¬¼ì´ ì‚¬ìš©í•˜ëŠ” ì´ˆê¸°ê°’: -1
    # ë¹„ë²„ëŠ” -2ë¥¼ ì ˆëŒ€ ëª» ê°€ëŠ” ê±¸ë¡œ.
    # ë¹„ë²„ëŠ” 
    water_time[s[0]][s[1]] = -2
    cnt  = 0 
    while queue:
        cnt += 1
        for _ in range(len(queue)):
            x, y = queue.popleft()
            for dx, dy in zip(dxs, dys):
                nx, ny = x + dx, y + dy
                if in_range(nx, ny) \
                and (water_time[nx][ny] > cnt\
                or water_time[nx][ny] == -1): # ë¬¼ì´ ë„ë‹¬í•˜ëŠ” ì‹œê°„ì´ ëŠë¦¬ê±°ë‚˜ (ëŒì€ -2ë¼ì„œ ë°°ì¬ë¨. -1ì´ë¼ì„œ ì•ˆ ì˜¤ê±°ë‚˜)
                    if (nx, ny) == dest:
                        print(cnt)
                        return
                    queue.append((nx, ny))
                    water_time[nx][ny] = -2
        # for wt in water_time:
        #     print(wt)
    print('KAKTUS')
    return

if __name__ == '__main__':	
    input = sys.stdin.readline
    r, c = tuple(map(int, input().split()))
    forest = [
        list(input().strip())
        for _ in range(r)
    ]

    water_time = [[-1 for _ in range(c)]for _ in range(r)]
    water_source = []
    for i in range(r):
        for j in range(c):
            if forest[i][j] == '*':
                water_source.append((i, j))
            if forest[i][j] == 'D':
                dest = (i, j)
            if forest[i][j] == 'S':
                start = (i, j)
    bfs()
    # for wt in water_time:
    #     print(wt)
    bfs_hodge(start)

# ê³ ìŠ´ë„ì¹˜ê°€ ì›€ì§ì¼ ìˆ˜ ìˆëŠ” ë°©ë²•. ê³ ìŠ´ë„ì¹˜ ë°ì´ê°€ ìˆê³ , 
# ê·¸ ê°’ë³´ë‹¤ ì´ë™í•˜ë ¤ëŠ” water_time ê°’ì´ ì»¤ì•¼ ì´ë™ ê°€ëŠ¥.
# -1ì€ ê·¸ëŸ¼ ë‚˜ìœ ë¹„êµê°€ ë˜ëŠ”ë°? ë¬´í•œìœ¼ë¡œ ë°”ê¿”ì„œ í•­ìƒ ì´ë™ ê°€ëŠ¥í•˜ê²Œ í•´ì•¼í•¨
# [-1, 3, 2, 1, 0, 1]
# [7, -1, 3, -1, 1, 2]
# [6, 5, 4, 3, 2, 3]
```

## Phase4. 2ì°¨ í”¼ë“œë°± (ì •ë‹µ ì œì™¸)

ì•„ë˜ëŠ” ì£¼ì–´ì§„ ì½”ë“œë¥¼ ê°„ë‹¨íˆ ì‚´í´ë³´ê³ , ì „í˜•ì ìœ¼ë¡œ â€œê³ ìŠ´ë„ì¹˜ ë¬¸ì œ(ë¬¼ì˜ í™•ì‚°ê³¼ ê³ ìŠ´ë„ì¹˜ì˜ ì´ë™ì„ ê°ê° BFSë¡œ ì²˜ë¦¬)â€ë¥¼ í’€ ë•Œ ìì£¼ í˜¼ë™í•˜ëŠ” í¬ì¸íŠ¸ ìœ„ì£¼ë¡œ ë¡œì§ìƒì˜ í”¼ë“œë°±ì„ ì •ë¦¬í•œ ê²ƒì…ë‹ˆë‹¤. (ì‹¤í–‰ ê²°ê³¼ë‚˜ ì •ë‹µ ì—¬ë¶€ ìì²´ëŠ” ì–¸ê¸‰í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.)

1. water_time ë°°ì—´ì˜ ì˜ë¯¸ ëª…í™•í™”

í˜„ì¬ ì½”ë“œì—ì„œ water_time ë°°ì—´ì€

â€¢	ë¬¼ì´ ë„ë‹¬í•˜ëŠ” ì‹œê°„ì„ ê¸°ë¡ (0, 1, 2, â€¦)

â€¢	í˜¹ì€ ì ˆëŒ€ ë¬¼ì´ ë„ë‹¬í•˜ì§€ ëª»í•˜ê±°ë‚˜(ëŒ, ë¹„ë²„ êµ´) íŠ¹ë³„í•œ ê°’(-2 ë˜ëŠ” inf)ìœ¼ë¡œ ì²˜ë¦¬

â€¢	ì•„ì§ ë¬¼ì´ ë„ë‹¬í•˜ì§€ ì•Šì€ ì¹¸ì€ -1ë¡œ ì²˜ë¦¬

ì²˜ëŸ¼ ë‹¤ì–‘í•œ ê°’ì„ ì„ì–´ì„œ ì“°ê³  ìˆìŠµë‹ˆë‹¤.

ì´ëŸ° ì‹ì˜ â€œí•œ ë°°ì—´ì— ì—¬ëŸ¬ ê°€ì§€ ì˜ë¯¸â€ë¥¼ ë‹´ëŠ” ë°©ë²• ìì²´ëŠ” ê°€ëŠ¥í•˜ì§€ë§Œ, ê°’ ì˜ë¯¸ê°€ ëª¨í˜¸í•´ì§€ë©´ ë””ë²„ê¹…í•  ë•Œ í—·ê°ˆë¦¬ê¸° ì‰½ìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ëŒ(X)ì„ -2ë¡œ, êµ´(D)ì„ infë¡œ, ì´ë¯¸ ë°©ë¬¸í•œ ì¹¸ì„ ë‹¤ì‹œ -2ë¡œ ë°”ê¾¸ëŠ” ê³¼ì •ì—ì„œ â€œì •ë§ ì˜ë„ëŒ€ë¡œ ë°ì´í„°ê°€ ì„¸íŒ…ëœ ê²ƒì¸ì§€â€ ê³„ì† ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤.

> ê°œì„  ì•„ì´ë””ì–´

> â€¢

> â€¢	ëŒ(X)ì´ë‚˜ ë¹„ë²„ êµ´(D)ì€ ë³„ë„ì˜ ê·¸ë˜í”„/ë§µì—ì„œ ë”°ë¡œ í™•ì¸(ë˜ëŠ” None, íŠ¹ìˆ˜í•œ markerë¡œ)í•˜ëŠ” ë°©ì‹ì„ ì“°ë©´ í•œê²° ëª…í™•í•´ì§‘ë‹ˆë‹¤.

> â€¢	í˜¹ì€ í˜„ì¬ì²˜ëŸ¼ í•œ ë°°ì—´ì— ëª¨ë‘ ë‹´ë˜, -2 ë“±ì˜ â€œíŠ¹ìˆ˜ê°’â€ì„ ì„¸ë¶„í™”í•´ì•¼ í•œë‹¤ë©´, ê·¸ì— ë§ëŠ”

2. ë¬¼ í™•ì‚° BFSì™€ ê³ ìŠ´ë„ì¹˜ BFSì˜ ì‹œê°„ ê´€ê³„

ì¼ë°˜ì ìœ¼ë¡œ â€œê³ ìŠ´ë„ì¹˜ ë¬¸ì œâ€ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë¡œì§ìœ¼ë¡œ í’€ë¦½ë‹ˆë‹¤.

1.	ë¬¼ ë¨¼ì € BFSë¡œ í™•ì‚° ì‹œê°„ì„ water_timeì— ì €ì¥.

â€¢	ë¬¼ì´ ë„ë‹¬í•  ìˆ˜ ì—†ëŠ” ì¹¸ì´ë©´ water_time[r][c] = float('inf').

2.	ê³ ìŠ´ë„ì¹˜ BFS

â€¢	ê³ ìŠ´ë„ì¹˜ê°€ ì‹œê°„ tì— ì¹¸ (x, y)ì— ë„ë‹¬í–ˆë‹¤ê³  ê°€ì •í•  ë•Œ,

â€¢	ë‹¤ìŒ ì¹¸ (nx, ny)ë¡œ ì´ë™ ê°€ëŠ¥í•˜ë ¤ë©´ â€œê³ ìŠ´ë„ì¹˜ê°€ t+1ì— ì´ë™í•œ ì‹œì  < ë¬¼ì´ ë„ë‹¬í•˜ëŠ” ì‹œì â€ ì´ì–´ì•¼ í•©ë‹ˆë‹¤. ì¦‰,

t + 1 < water\_time[nx][ny]

â€¢	ì´ë¥¼ ë§Œì¡±í•´ì•¼ ê³ ìŠ´ë„ì¹˜ê°€ ë¬¼ì— ì•ˆ ì ê¸°ê³  ì‚´ì•„ì„œ ì´ë™ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.

í•˜ì§€ë§Œ í˜„ì¬ ì½”ë“œë¥¼ ë³´ë©´, ê³ ìŠ´ë„ì¹˜ ìª½ì—ì„œ

```plain text
if in_range(nx, ny) and (water_time[nx][ny] > cnt or water_time[nx][ny] == -1):
    ...
```

ì´ëŸ° ì‹ìœ¼ë¡œ ì¡°ê±´ì„ ì£¼ê³  ìˆìŠµë‹ˆë‹¤.

â€¢	cntëŠ” ê³ ìŠ´ë„ì¹˜ BFSì—ì„œì˜ â€œë‹¨ê³„ ìˆ˜â€

â€¢	water_time[nx][ny] > cntì´ë©´ ê³ ìŠ´ë„ì¹˜ê°€ cnt ì‹œì ì— ê°ˆ ìˆ˜ ìˆë‹¤ê³  íŒë‹¨

ì´ ë¡œì§ ìì²´ëŠ” ì–¼í• ë³´ë©´ ë§ì„ ìˆ˜ë„ ìˆì§€ë§Œ, ë³´í†µì€ t+1 < water_time[nx][ny] í˜•íƒœë¡œ ë¹„êµí•´ì•¼ ì •í™•í•©ë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´,

â€¢	ê³ ìŠ´ë„ì¹˜ê°€ ì‹œê°„ t=2ì— (x, y)ì— ìˆê³ , ë‹¤ìŒ ìŠ¤í…ì— (nx, ny)ë¡œ ê°€ë ¤ í•©ë‹ˆë‹¤.

â€¢	ë¬¼ì´ (nx, ny)ì— t=3ì— ë„ì°©í•œë‹¤ë©´, ê³ ìŠ´ë„ì¹˜ëŠ” t=3ì— ê·¸ ì¹¸ì— ë“¤ì–´ê°€ê²Œ ë˜ëŠ”ë°, ì´ë•Œ â€œë™ì‹œì— ë„ì°©í•´ì„œ ì•ˆì „í•œì§€ / ë¬¼ì— ì ê¸°ëŠ”ì§€â€ ë¬¸ì œë¥¼ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ê³  ìˆëŠ”ì§€ê°€ ì¤‘ìš”í•©ë‹ˆë‹¤.

ê²°êµ­, ë¬¸ì œ ì„¤ëª…ì— ë”°ë¼

â€¢	â€œë¬¼ì´ t=3ì— ë„ì°©í•œë‹¤ë©´, ê³ ìŠ´ë„ì¹˜ëŠ” t=3ì— ë“¤ì–´ê°€ë©´ ì ê¸´ë‹¤â€ê³  ë³´ëŠ” ê²½ìš°ì—” t+1 < water_time[nx][ny] ë¼ëŠ” strict ë¹„êµê°€ í•„ìš”í•©ë‹ˆë‹¤.

â€¢	â€œë™ì‹œì— ë„ì°©í•˜ë©´ ê´œì°®ë‹¤â€ê³  ë³´ëŠ” ê²½ìš°ë¼ë©´ t+1 <= water_time[nx][ny] ì‹ë„ ê°€ëŠ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ëŠ” ë¬¸ì œì˜ ì¡°ê±´(â€œë¬¼ê³¼ ë™ì‹œì— ë„ì°© ì‹œ ì‚´ì•„ë‚¨ëŠëƒ?â€)ì— ë”°ë¼ ë‹¬ë¼ì§€ë¯€ë¡œ, ë¬¸ì œ ì›ë¬¸ ì˜ˆì‹œë‚˜ ê³µì‹ í•´ì„¤ì„ ê¼­ í™•ì¸í•˜ì—¬, ì •í™•í•œ ë¶€ë“±í˜¸ ì²˜ë¦¬ë¥¼ í•´ì•¼ í•©ë‹ˆë‹¤.

3. -2ë¡œì˜ ê°±ì‹  íƒ€ì´ë°

ì½”ë“œì—ì„œ

```plain text
water_time[nx][ny] = -2
...
water_time[s[0]][s[1]] = -2
```

ë“±ìœ¼ë¡œ ê°±ì‹ í•˜ê³  ìˆìŠµë‹ˆë‹¤.

â€¢	ê³ ìŠ´ë„ì¹˜ BFSì—ì„œ (nx, ny)ë¡œ ì´ë™ ì‹œì— water_time[nx][ny] = -2ë¡œ ê°±ì‹ 

â€¢	ëŒ(X)ë„ -2, ì´ë¯¸ ë°©ë¬¸í•œ ì¹¸ë„ -2

ë“± ì—¬ëŸ¬ ê³³ì—ì„œ -2ê°€ ì“°ì´ëŠ”ë°, ë‚˜ì¤‘ì— ì´ ì¹¸ì„ ë‹¤ì‹œ ë°©ë¬¸í•˜ë ¤ê³  í•  ë•Œ ì¡°ê±´ë¬¸ì—ì„œ -2ê°€ ì˜ë¯¸í•˜ëŠ” ê²Œ ë¬´ì—‡ì¸ì§€ ì¦‰ê° ì•Œì•„ë³´ê¸° ì–´ë ¤ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

> ê°œì„  ì•„ì´ë””ì–´

> â€¢	ê³ ìŠ´ë„ì¹˜ê°€ ë°©ë¬¸í–ˆë‹¤ë©´ â€œvisited_hedge[x][y] = Trueâ€ ì²˜ë¦¬ë¥¼ ë³„ë„ì˜ 2ì°¨ì› ë°°ì—´ë¡œ ë‘ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤.

> â€¢	ëŒ(X)ì„ êµ³ì´ water_timeì— -2ë¡œ ë„£ëŠ” ëŒ€ì‹ , ë¬¼ BFS ë¡œì§ì—ì„œ ì•„ì˜ˆ if forest[nx][ny] == 'X': continueë¡œ íŒ¨ìŠ¤ë§Œ í•˜ë©´ ë©ë‹ˆë‹¤.

> â€¢	â€œë¹„ë²„ êµ´(D)â€ì´ë‚˜ â€œê²½ê³„ ë°–â€ë„ ë§ˆì°¬ê°€ì§€ë¡œ ë¬¼ì´ í™•ì‚°ë  ìˆ˜ ì—†ëŠ” ëŒ€ìƒì´ë¯€ë¡œ â€œê·¸ëƒ¥ í™•ì‚° ë¡œì§ì—ì„œ ê±¸ëŸ¬ë‚´ê³ â€ water_timeì—ëŠ” ê¸°ë¡í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤(í˜¹ì€ infë¡œ ê¸°ë¡).

ì´ë ‡ê²Œ â€œë¬¼ í™•ì‚°â€ê³¼ â€œê³ ìŠ´ë„ì¹˜ ì´ë™â€ì—ì„œ ê°ì í•„ìš”í•œ visited/queue/ì¡°ê±´ì„ ë¶„ë¦¬í•˜ë©´ í›¨ì”¬ ë‹¨ìˆœí•´ì§‘ë‹ˆë‹¤.

4. BFS ë ˆë²¨(cnt) ì¦ê°€ ë°©ì‹

í˜„ì¬ bfs()ì—ì„œ

```plain text
while queue:
    cnt += 1
    for _ in range(len(queue)):
        x, y = queue.popleft()
        ...
```

ì´ëŸ° êµ¬ì¡°ë¥¼ ì“°ê³  ìˆìŠµë‹ˆë‹¤. ì „í˜•ì ì¸ â€œí•œ ë²ˆì˜ while ë£¨í”„ = 1ì´ˆ(ë˜ëŠ” 1ë‹¨ê³„) ê²½ê³¼â€ íŒ¨í„´ì…ë‹ˆë‹¤.

ì´ ë¡œì§ ìì²´ëŠ” ë¬¸ì œ ì—†ìŠµë‹ˆë‹¤ë§Œ, ë‹¤ìŒ ì‚¬í•­ì„ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤.

1.	cntë¥¼ 0ì—ì„œ ì‹œì‘í•˜ì—¬, ì²« ë ˆë²¨ì—ì„œ cnt=1ì´ ë˜ëŠ” êµ¬ì¡°.

â€¢	ê·¸ë ‡ë‹¤ë©´ â€œë¬¼ì€ ì‹œì‘ ì§€ì ì—ì„œ 0ì´ˆ ì‹œì ì— ìˆë‹¤ê°€, 1ì´ˆ í›„ì— ì¸ì ‘ ì¹¸ìœ¼ë¡œ ì´ë™â€ì´ë¼ëŠ” ì˜ë¯¸ê°€ ë©ë‹ˆë‹¤.

â€¢	í˜¹ì€ â€œì‹œì‘ì ì„ 0ë ˆë²¨, ì¸ì ‘ ì¹¸ì„ 1ë ˆë²¨â€ ì‹ìœ¼ë¡œë„ ë³¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ë¬¸ì œ ì˜ë„ì™€ë§Œ ì¼ì¹˜í•˜ë©´ ê´œì°®ìŠµë‹ˆë‹¤.

2.	ì´í›„ ê³ ìŠ´ë„ì¹˜ BFSì—ì„œë„ ê°™ì€ ë°©ì‹ì„ ì“°ë˜, â€œê³ ìŠ´ë„ì¹˜ê°€ tì— ìˆëŠ” ì¹¸ì—ì„œ t+1ì— ì¸ì ‘ ì¹¸ìœ¼ë¡œ ì´ë™â€ ì‹ìœ¼ë¡œ ë§ì¶°ì¤˜ì•¼, ì„œë¡œ ì‹œê°„ì´ ì •í™•íˆ ë¹„êµ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ë§Œì•½ ë¬¼ BFSì—ì„œ 1ë‹¨ê³„ ê²½ê³¼ ì‹œì ì„ cnt=1ë¡œ ê°„ì£¼í–ˆë‹¤ë©´, ê³ ìŠ´ë„ì¹˜ BFSì—ì„œë„ ë™ì¼í•œ ê¸°ì¤€ì„ ì¨ì¤˜ì•¼ í•©ë‹ˆë‹¤.

Tip: ë³´í†µì€

â€¢	ì‹œì‘ì (ë¬¼ í˜¹ì€ ê³ ìŠ´ë„ì¹˜)ì˜ time = 0 (queueì— ë„£ì„ ë•Œ)

â€¢	while í•œ ë°”í€´ ëŒ ë•Œë§ˆë‹¤ â€œí•´ë‹¹ ë ˆë²¨ì˜ ë…¸ë“œë“¤ ì „ë¶€ ì²˜ë¦¬ â†’ time + 1â€

ì´ëŸ° ì‹ìœ¼ë¡œ ë§ì¶¥ë‹ˆë‹¤.

5. ìš”ì•½

â€¢	ë°°ì—´ ê°’ë“¤ì˜ ì˜ë¯¸ë¥¼ ì§€ë‚˜ì¹˜ê²Œ â€œíŠ¹ìˆ˜ê°’â€ ì—¬ëŸ¬ ê°œë¡œ í˜¼í•©í•˜ê¸°ë³´ë‹¤,

â€¢	ë¬¼ ë„ë‹¬ ì‹œê°„ = ì •ìˆ˜(ë˜ëŠ” inf)

â€¢	ëŒ/ë¹„ë²„êµ´/ë°©ë¬¸ ë¶ˆê°€ = ë”°ë¡œ ì²˜ë¦¬

â€¢	ê³ ìŠ´ë„ì¹˜ ë°©ë¬¸ ì—¬ë¶€ = visited_hedge[][]

ì‹ìœ¼ë¡œ ë¶„ë¦¬í•˜ëŠ” ê²ƒì´ ë””ë²„ê¹…ì— í›¨ì”¬ ìœ ë¦¬í•©ë‹ˆë‹¤.

â€¢	ê³ ìŠ´ë„ì¹˜ê°€ ì´ë™ ê°€ëŠ¥ ì—¬ë¶€ë¥¼ ì²´í¬í•  ë•ŒëŠ” ë³´í†µ

\text{hedgehog\_time}[x][y] + 1 < \text{water\_time}[nx][ny]

ì™€ ê°™ì´ â€œê³ ìŠ´ë„ì¹˜ê°€ ê°€ë ¤ëŠ” ì‹œì ë³´ë‹¤ ë¬¼ì˜ ë„ë‹¬ ì‹œì ì´ ë” ëŠ¦ê±°ë‚˜(ë˜ëŠ” ë¬´í•œëŒ€)â€ì¸ì§€ ì •í™•íˆ ë¹„êµí•˜ëŠ” ë°©ì‹ì„ ë§ì´ ì‚¬ìš©í•©ë‹ˆë‹¤.

â€¢	BFSì—ì„œ ë ˆë²¨ ì¦ê°€(cnt) íƒ€ì´ë°ì´ ì„œë¡œ ë§ëŠ”ì§€(ë¬¼ í™•ì‚° BFS vs ê³ ìŠ´ë„ì¹˜ ì´ë™ BFS) ê¼¼ê¼¼íˆ ì±™ê²¨ì•¼ í•©ë‹ˆë‹¤.

â€¢	â€œëŒ(X)ì´ë‚˜ ë¹„ë²„ êµ´(D)ì„ ë§Œë‚¬ì„ ë•Œ ì–´ë–»ê²Œ ì²˜ë¦¬í•  ê±´ì§€â€ ë¡œì§ì„ ëª…í™•íˆ ë¶„ë¦¬í•˜ë©´ í›¨ì”¬ ë³´ê¸°ê°€ ì‰¬ì›Œì§‘ë‹ˆë‹¤.

ì´ëŸ° ë¶€ë¶„ë“¤ì„ ì •ë¦¬/ì¡°ì •í•˜ì‹œë©´, ì½”ë“œê°€ ì¢€ ë” ì§ê´€ì ì´ê³  ìœ ì§€ë³´ìˆ˜í•˜ê¸° ì‰¬ì›Œì§ˆ ê²ƒì…ë‹ˆë‹¤.

# DP: ë™ì „ 2

https://www.acmicpc.net/problem/2294

nê°€ì§€ ì¢…ë¥˜ì˜ ë™ì „ì´ ìˆë‹¤. ì´ ë™ì „ë“¤ì„ ì ë‹¹íˆ ì‚¬ìš©í•´ì„œ, ê·¸ ê°€ì¹˜ì˜ í•©ì´ kì›ì´ ë˜ë„ë¡ í•˜ê³  ì‹¶ë‹¤. ê·¸ëŸ¬ë©´ì„œ ë™ì „ì˜ ê°œìˆ˜ê°€ ìµœì†Œê°€ ë˜ë„ë¡ í•˜ë ¤ê³  í•œë‹¤. ê°ê°ì˜ ë™ì „ì€ ëª‡ ê°œë¼ë„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

## Phase1. ì§ì ‘ í’€ê¸° - ì´ˆê¸° ì¡°ê±´ ëª» ì¡ì•„ì„œ ì‹¤íŒ¨

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 2294                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/2294                           #+#        #+#      #+#     #
#    Solved: 2025/03/30 14:16:16 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ì›Œë‚™ ë§ì´ í’€ì–´ ë´¤ë˜ ê·¸ê±°ë¼ì„œ. ê¸°ì–µì„ ë”ë“¬ì–´ í’€ì–´ ë´…ì‹œë‹¤.
dp[n] = min(dp[n-A[0~]] + 1)
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys

def init():
    global dp
    dp[0] = 0
    for coin in coins:
        if coin <= k:   
            dp[coin] = 1

def make_dp():
    for i in range(1, k+1):
        min_val = sys.maxsize
        for coin in coins:
            if i - coin >= 0:
                min_val = min(min_val, dp[i-coin]+1)
                dp[i] = min_val


if __name__ == '__main__':	
    input = sys.stdin.readline
    n, k = tuple(map(int, input().split()))
    coins = [
        int(input().strip())
        for _ in range(n)
    ]
    # init
    dp = [-1 for _ in range(k+1)]
    init()
    make_dp()
    # print(dp)
    result = dp[k] if dp[k] != 0 else -1
    print(result)
```

## Phase2. í”¼ë“œë°±

ë™ì „ ë¬¸ì œ(íŠ¹íˆ ë™ì „ 2, 2294ë²ˆ)ì—ì„œëŠ” â€œDP ë°°ì—´ì„ í° ìˆ˜ë¡œ ì´ˆê¸°í™”í•˜ê³ , ìœ íš¨í•œ ìƒíƒœì— ëŒ€í•´ì„œë§Œ ê°±ì‹ â€ í•˜ëŠ” í‘œì¤€ ì ‘ê·¼ ë°©ì‹ì„ ì‚¬ìš©í•˜ë©´ êµ¬í˜„ì´ ë” ê°„ê²°í•´ì§€ê³ , -1 ì²˜ë¦¬ë¥¼ ë³„ë„ë¡œ ì‹ ê²½ ì“°ì§€ ì•Šì•„ë„ ë˜ëŠ” ì¥ì ì´ ìˆìŠµë‹ˆë‹¤.

ì•„ë˜ì—ì„œëŠ” (1) ì „í˜•ì ì¸ DP ì í™”ì‹ê³¼ (2) ì½”ë“œ êµ¬í˜„ ì‹œ ì£¼ì˜í•  ì ì„ ì§šì–´ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

1. ì „í˜•ì ì¸ DP ì ‘ê·¼

â€¢	dp[i] = ê°€ì¹˜ í•©ì´ iì›ì´ ë˜ë„ë¡ ë§Œë“œëŠ” ë° í•„ìš”í•œ ë™ì „ ê°œìˆ˜ì˜ ìµœì†Ÿê°’.

â€¢	ì´ˆê¸°ê°’:

â€¢	dp[0] = 0 (0ì›ì„ ë§Œë“œëŠ” ë° í•„ìš”í•œ ë™ì „ ê°œìˆ˜ = 0ê°œ)

â€¢	ê·¸ ì™¸ dp[i](1 â‰¤ i â‰¤ k)ëŠ” ë§¤ìš° í° ìˆ˜(ì˜ˆ: INF)ë¡œ ì„¤ì •

â€¢	ì í™”ì‹:

dp[i] = \min\bigl(dp[i],\, dp[i - \text{coin}] + 1\bigr)

â€¢	ë‹¨, i - coinì´ 0 ì´ìƒì´ê³ , dp[i - coin]ì´ ìœ íš¨í•œ ìƒíƒœ(= INFê°€ ì•„ë‹˜)ì´ì–´ì•¼ í•¨.

ì´ ë¡œì§ì— ë”°ë¼ O(nÃ—k) ì‹œê°„ì— ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

2. Python ì˜ˆì‹œ ì½”ë“œ

ì•„ë˜ ì½”ë“œëŠ” ê°€ì¥ í”íˆ ì“°ì´ëŠ” í˜•íƒœì˜ ë™ì „ 2 ë¬¸ì œ í’€ì´ ì˜ˆì‹œì…ë‹ˆë‹¤.

dp[k]ê°€ INFë¡œ ë‚¨ì•„ ìˆìœ¼ë©´ ë§Œë“¤ ìˆ˜ ì—†ëŠ” ê¸ˆì•¡ì´ë¯€ë¡œ -1ì„ ì¶œë ¥í•˜ê³ , ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ dp[k]ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.

ì£¼ìš” í¬ì¸íŠ¸

1.	ì¤‘ë³µ ì²´í¬ í•„ìš” X

â€¢	ë™ì¼í•œ ë™ì „ì„ ì—¬ëŸ¬ ê°œ ì‚¬ìš©í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, for coin in coins: ì•ˆì—ì„œ ë‹¤ì‹œ for i in range(coin, k+1):ë¥¼ ìˆœíšŒí•˜ë©° ê³„ì† ê°±ì‹ í•´ì£¼ë©´ ë©ë‹ˆë‹¤.

2.	-1 ëŒ€ì‹  INF

â€¢	â€œë§Œë“¤ ìˆ˜ ì—†ëŠ” ê¸ˆì•¡â€ì„ dp[i] = INFë¡œ ìœ ì§€í•œ ë’¤, ìµœì¢…ì— dp[k] == INFì¸ì§€ë¥¼ íŒë³„í•˜ì—¬ -1ì„ ì¶œë ¥í•˜ëŠ” ë°©ì‹ì„ ì“°ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤.

â€¢	ì´ë ‡ê²Œ í•˜ë©´ â€œì´ë¯¸ -1ì¸ ìƒíƒœì—ì„œ +1ì„ ë”í•˜ëŠ”â€ ë¬¸ì œë¥¼ ë”°ë¡œ ì²˜ë¦¬í•  í•„ìš”ê°€ ì—†ì–´ ì½”ë“œê°€ ë‹¨ìˆœí•´ì§‘ë‹ˆë‹¤.

3.	ì‹œê°„ ë³µì¡ë„

â€¢	ìµœëŒ€ n(ë™ì „ì˜ ì¢…ë¥˜) * k(ëª©í‘œ ê¸ˆì•¡)ë²ˆ ì—°ì‚°ì´ ì¼ì–´ë‚˜ë¯€ë¡œ, n, kê°€ 10^4 ì´í•˜ ì •ë„ë©´ ì¶©ë¶„íˆ ê°€ëŠ¥í•œ ë°©ì‹ì…ë‹ˆë‹¤. (BOJ 2294ì—ì„œ ì œí•œì€ n â‰¤ 100, k â‰¤ 10,000)

3. ê¸°ì¡´ ì½”ë“œì—ì„œì˜ ë¬¸ì œì 

ì§ˆë¬¸ì— ì˜¬ë ¤ì£¼ì‹  ì½”ë“œì—ì„œ ë°œìƒ ê°€ëŠ¥í•œ ë¬¸ì œì ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

1.	dp[i-coin]ì´ -1ì¸ ê²½ìš°ë¥¼ ì²´í¬í•˜ì§€ ì•ŠìŒ

```plain text
if i - coin >= 0:
    min_val = min(min_val, dp[i - coin] + 1)  # dp[i-coin]ì´ -1ì´ë©´?
```

â€¢	dp[i-coin]ì´ -1ì´ë¼ë©´ â€œi-coin ì›ì„ ë§Œë“¤ ìˆ˜ ì—†ë‹¤â€ëŠ” ëœ»ì¸ë°, ë‹¨ìˆœíˆ +1ì„ í•´ë²„ë¦¬ë©´ 0ì´ ë˜ì–´ ë²„ë ¤ ì˜ëª»ëœ ê°’ì„ ê°±ì‹ í•˜ê²Œ ë©ë‹ˆë‹¤.

â€¢	ë”°ë¼ì„œ â€œdp[i - coin] != -1â€ì¸ ê²½ìš°ì—ë§Œ ê°±ì‹ í•´ì•¼ í•©ë‹ˆë‹¤.

2.	dp[i]ê°€ -1ì¸ì§€, ì•„ë‹ˆë©´ 0 ì´ìƒì¸ì§€ ì²´í¬

â€¢	dp[i]ê°€ -1 ìƒíƒœë¼ë©´, ì•„ì§ iì›ì„ ë§Œë“¤ ìˆ˜ ì—†ë‹¤ëŠ” ëœ»ì´ë¯€ë¡œ ê°±ì‹  ì‹œì ì— dp[i] = min_val í˜•íƒœë¡œ ë°”ë¡œ ë°”ê¿”ì¤˜ì•¼ í•©ë‹ˆë‹¤.

â€¢	ë˜ëŠ” ìœ„ì—ì„œ ì–¸ê¸‰í•œ ê²ƒì²˜ëŸ¼ ì• ì´ˆì— INFë¡œ ì´ˆê¸°í™”í•˜ëŠ” ë°©ì‹ì„ íƒí•˜ë©´ ì´ì¤‘ì²˜ë¦¬ë¥¼ í”¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

3.	init()ì—ì„œ dp[coin] = 1ë¡œ ì„¸íŒ…

â€¢	ì‚¬ì‹¤ ëª¨ë“  ë™ì „ì— ëŒ€í•´ dp[coin] = 1ì„ ì§€ì •í•˜ëŠ” ê²ƒì€ í‹€ë¦° ê±´ ì•„ë‹ˆì§€ë§Œ, ìë™ìœ¼ë¡œ BFS/DPë¥¼ ëŒë¦¬ë©´ì„œ ìì—°ìŠ¤ëŸ½ê²Œ ê°±ì‹ ë˜ë¯€ë¡œ ìƒëµí•´ë„ ë¬´ë°©í•©ë‹ˆë‹¤.

â€¢	ë™ì „ì´ 1ê°œì¸ ê²½ìš°ì—ë§Œ ìœ íš¨í•˜ë‹¤ëŠ” ì ì€ DP ì í™”ì‹ì—ì„œë„ ê³§ë°”ë¡œ ë°˜ì˜ë©ë‹ˆë‹¤.

4. ê²°ë¡ 

â€¢	ê°€ì¥ ë‹¨ìˆœí•œ êµ¬í˜„ì€ â€œdp ì „ì²´ë¥¼ INFë¡œ ì´ˆê¸°í™” + dp[0] = 0â€ â†’ â€œë™ì „ì„ ëŒë©´ì„œ dp[i]ë¥¼ ê°±ì‹ â€ â†’ ê²°ê³¼ì ìœ¼ë¡œ dp[k]ê°€ INFì´ë©´ -1, ì•„ë‹ˆë©´ dp[k].

â€¢	ì´ë ‡ê²Œ í•˜ë©´ ì¤‘ê°„ì— -1 ì²˜ë¦¬ë¥¼ ë”°ë¡œ í•  í•„ìš”ê°€ ì—†ê³ , ì½”ë“œê°€ ì§§ê³  ì§ê´€ì ì…ë‹ˆë‹¤.

ìœ„ ì½”ë“œë¥¼ ì°¸ê³ í•´ì„œ ìˆ˜ì •í•´ë³´ì‹œë©´, ë” ê°„ê²°í•˜ê³  ì•ˆì „í•˜ê²Œ ë¬¸ì œë¥¼ í•´ê²°í•˜ì‹¤ ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤.

## í”¼ë“œë°± í›„ ì¬ë„ì „

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 2294                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/2294                           #+#        #+#      #+#     #
#    Solved: 2025/03/30 14:16:16 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ì›Œë‚™ ë§ì´ í’€ì–´ ë´¤ë˜ ê·¸ê±°ë¼ì„œ. ê¸°ì–µì„ ë”ë“¬ì–´ í’€ì–´ ë´…ì‹œë‹¤.
dp[n] = min(dp[n-A[0~]] + 1)
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys
INF = sys.maxsize


def make_dp():
    dp[0] = 0
    for i in range(1, k+1):
        for coin in coins:
            if i - coin >= 0:
                dp[i] = min(dp[i], dp[i-coin]+1)


if __name__ == '__main__':	
    input = sys.stdin.readline
    n, k = tuple(map(int, input().split()))
    coins = [
        int(input().strip())
        for _ in range(n)
    ]
    # init
    dp = [INF for _ in range(k+1)]
    make_dp()
    # print(dp)
    result = dp[k] if dp[k] != INF else -1
    print(result)
```

BFSë¡œë„ ì´ê±¸ í’€ ìˆ˜ ìˆìŒì„ ì•Œì•˜ë‹¤. ë¨¸ë¦¬ê°€ ë§ë‘ë§ë‘í•´ì ¸ì•¼ ê·¸ë ‡ê²Œ í•  ìˆ˜ ìˆì„í…ë°.

# ìœ„ìƒì •ë ¬: ì¥ë‚œê° ì¡°ë¦½



ìš°ë¦¬ëŠ” ì–´ë–¤ ì¥ë‚œê°ì„ ì—¬ëŸ¬ ê°€ì§€ ë¶€í’ˆìœ¼ë¡œ ì¡°ë¦½í•˜ì—¬ ë§Œë“¤ë ¤ê³  í•œë‹¤. ì´ ì¥ë‚œê°ì„ ë§Œë“œëŠ”ë°ëŠ” ê¸°ë³¸ ë¶€í’ˆê³¼ ê·¸ ê¸°ë³¸ ë¶€í’ˆìœ¼ë¡œ ì¡°ë¦½í•˜ì—¬ ë§Œë“  ì¤‘ê°„ ë¶€í’ˆì´ ì‚¬ìš©ëœë‹¤. ê¸°ë³¸ ë¶€í’ˆì€ ë‹¤ë¥¸ ë¶€í’ˆì„ ì‚¬ìš©í•˜ì—¬ ì¡°ë¦½ë  ìˆ˜ ì—†ëŠ” ë¶€í’ˆì´ë‹¤. ì¤‘ê°„ ë¶€í’ˆì€ ë˜ ë‹¤ë¥¸ ì¤‘ê°„ ë¶€í’ˆì´ë‚˜ ê¸°ë³¸ ë¶€í’ˆì„ ì´ìš©í•˜ì—¬ ë§Œë“¤ì–´ì§€ëŠ” ë¶€í’ˆì´ë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ë³´ì. ê¸°ë³¸ ë¶€í’ˆìœ¼ë¡œì„œ 1, 2, 3, 4ê°€ ìˆë‹¤. ì¤‘ê°„ ë¶€í’ˆ 5ëŠ” 2ê°œì˜ ê¸°ë³¸ ë¶€í’ˆ 1ê³¼ 2ê°œì˜ ê¸°ë³¸ ë¶€í’ˆ 2ë¡œ ë§Œë“¤ì–´ì§„ë‹¤. ê·¸ë¦¬ê³  ì¤‘ê°„ ë¶€í’ˆ 6ì€ 2ê°œì˜ ì¤‘ê°„ ë¶€í’ˆ 5, 3ê°œì˜ ê¸°ë³¸ ë¶€í’ˆ 3ê³¼ 4ê°œì˜ ê¸°ë³¸ ë¶€í’ˆ 4ë¡œ ë§Œë“¤ì–´ì§„ë‹¤. ë§ˆì§€ë§‰ìœ¼ë¡œ ì¥ë‚œê° ì™„ì œí’ˆ 7ì€ 2ê°œì˜ ì¤‘ê°„ ë¶€í’ˆ 5, 3ê°œì˜ ì¤‘ê°„ ë¶€í’ˆ 6ê³¼ 5ê°œì˜ ê¸°ë³¸ ë¶€í’ˆ 4ë¡œ ë§Œë“¤ì–´ì§„ë‹¤. ì´ëŸ° ê²½ìš°ì— ì¥ë‚œê° ì™„ì œí’ˆ 7ì„ ë§Œë“œëŠ”ë° í•„ìš”í•œ ê¸°ë³¸ ë¶€í’ˆì˜ ê°œìˆ˜ëŠ” 1ë²ˆ 16ê°œ, 2ë²ˆ 16ê°œ, 3ë²ˆ 9ê°œ, 4ë²ˆ 17ê°œì´ë‹¤.

ì´ì™€ ê°™ì´ ì–´ë–¤ ì¥ë‚œê° ì™„ì œí’ˆê³¼ ê·¸ì— í•„ìš”í•œ ë¶€í’ˆë“¤ ì‚¬ì´ì˜ ê´€ê³„ê°€ ì£¼ì–´ì ¸ ìˆì„ ë•Œ í•˜ë‚˜ì˜ ì¥ë‚œê° ì™„ì œí’ˆì„ ì¡°ë¦½í•˜ê¸° ìœ„í•˜ì—¬ í•„ìš”í•œ ê¸°ë³¸ ë¶€í’ˆì˜ ì¢…ë¥˜ë³„ ê°œìˆ˜ë¥¼ ê³„ì‚°í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì§ì ‘ í’€ê¸° - ì‹œê°„ì´ˆê³¼

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 2637                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/2637                           #+#        #+#      #+#     #
#    Solved: 2025/03/30 22:45:21 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
# ì•„ë‹ˆ ì´ê±°ëŠ” ê·¸ê±°ì–ì•„. 
#  ìœ„ìƒì •ë ¬ì„ í•˜ê³ , shortest path estimate ëŒ€ì‹  all paths estimateë¡œ ë…¸ë“œë¥¼ ì—…ë°ì´íŠ¸í•˜ë©´
# ë˜ì§€ ì•Šê² ë‚˜?

import sys
from collections import deque, defaultdict
# ê·¸ë˜í”„ í‘œí˜„ ì»¨ë²¤ì…˜ì„ ë„ˆë¬´ ì„ì–´ ì“°ëŠ” ê±° ê°™ë‹¤.
def topological_sort(V: int, E):
    in_degree = [0]*(V+1)
    adj = defaultdict(list)
    V_ = [i for i in range(V+1)]
    weights = defaultdict(int)
    for v, u, w in E:
        adj[u].append(v)
        in_degree[v] += 1
        weights[(u,v)] = w
    result = []
    initials = [v for v in V_ if in_degree[v] == 0]
    que = deque(initials)
    while que:
        u = que.popleft()
        result.append(u)
        for v in adj[u]:
            in_degree[v] -= 1
            if in_degree[v] == 0:
                que.append(v)
    return result[1:], adj, initials[1:], weights
    

def dag_shortest_path(s:int, adj: list, weights: list):
    """ë­ ì–´ë–»ê²Œ í•˜ë©´ ë˜ì§€? ì¼ë‹¨ í•˜ë‚˜ì˜ ë²„í…ìŠ¤ë¥¼ ê¸°ì¤€ìœ¼ë¡œ? ê·¸ëƒ¥ ëª¨ë“  ê°„ì„ ì„ ëŒë©´ì„œ?"""
    p[s] = 1
    que = deque([s])
    while que:
        u = que.popleft()
        for v in adj[u]:
            # tmp = p[v]
            p[v] += p[u]*weights[(u,v)]
            # print(f'p[{v}] = {tmp} + {p[u]} * {weights[(u, v)]} = {p[v]}')
            que.append(v)



if __name__ == '__main__':	
    input = sys.stdin.readline
    n = int(input().strip())
    m = int(input().strip())
    E = [ 
        tuple(map(int, input().split()))
        for _ in range(m)
    ]
    result, adj, initials, weights = topological_sort(n, E)
    for s in initials:
        p = [0 for _ in range(n+1)]
        dag_shortest_path(s, adj, weights)
        print(f'{s} {p[n]}')

"""
ì´ìŠˆ: ì‹œê°„ì´ˆê³¼

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: 
ìµœê·¼ ë³€ê²½ ì‚¬í•­: 

Phase2.
í™•ì¸: 
ì‹œë„: 
p ì´ˆê¸°í™” í•¨ìˆ˜ ì‚­ì œ,
relax í•¨ìˆ˜ ì‚­ì œ

ë¶„ì„: ì˜ë¯¸ ì—†ìŒ
"""
```

## Phase2. í”¼ë“œë°± (ì •ë‹µ ì œì‹œ ê¸ˆì§€)

1.	ê·¸ë˜í”„ êµ¬ì„± ë°©í–¥

â€¢	ì…ë ¥ì„ ë³´ë©´ â€œvë¥¼ ë§Œë“¤ê¸° ìœ„í•´ì„œëŠ” wê°œì˜ uê°€ í•„ìš”í•˜ë‹¤â€ë¼ê³  ì£¼ì–´ì§€ëŠ”ë°, í˜„ì¬ ì½”ë“œì—ì„œ adj[u].append(v) êµ¬ì¡°ë¡œ ê·¸ë˜í”„ë¥¼ ë§Œë“  ë’¤, in_degree[v]ë¥¼ ì˜¬ë ¤ì£¼ê³  ìˆìŠµë‹ˆë‹¤. ì¦‰, u -> v ë°©í–¥ìœ¼ë¡œ ê°„ì„ ì„ êµ¬ì„±í•˜ì‹  ê²ƒìœ¼ë¡œ ë³´ì…ë‹ˆë‹¤. ì´ë•Œë„ ìœ„ìƒì •ë ¬ ìì²´ëŠ” ë§ê²Œ ë™ì‘í•  ìˆ˜ ìˆì§€ë§Œ, ì´í›„ â€œì–´ë–¤ ë…¸ë“œ(ì œí’ˆ)ë¥¼ ë§Œë“œë ¤ë©´ ì´ì „ ë…¸ë“œ(ë¶€í’ˆ)ë“¤ì´ ì–´ë–»ê²Œ í•„ìš”í•˜ë‹¤â€ë¼ëŠ” ê°’ì„ ëˆ„ì í•  ë•Œì—ëŠ”, ê°„ì„  ë°©í–¥ì„ ì˜ í™œìš©í•˜ê±°ë‚˜(ì˜ˆ: uì—ì„œ vë¡œ ëˆ„ì ), í˜¹ì€ ë°˜ëŒ€ë¡œ ë’¤ì§‘ì€ ê·¸ë˜í”„ë¥¼ ì“¸ì§€(ì˜ˆ: vì—ì„œ uë¡œ ëˆ„ì ) ë¯¸ë¦¬ ê²°ì •í•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ë˜í”„ êµ¬ì„± ë°©í–¥ê³¼ ëˆ„ì  ë°©ì‹ì´ ì—‡ê°ˆë¦¬ë©´ ê°’ì´ ë§ì§€ ì•Šê±°ë‚˜, ì¤‘ë³µ ê³„ì‚°ì´ ìƒê¸¸ ê°€ëŠ¥ì„±ì´ ë†’ìŠµë‹ˆë‹¤.

2.	ìœ„ìƒ ì •ë ¬ í›„ ê³„ì‚° ë°©ì‹(ì¤‘ê°„ ë¶€í’ˆ â†’ ì™„ì œí’ˆ ëˆ„ì )

â€¢	ê¸°ë³¸ ì•„ì´ë””ì–´ëŠ” â€œ(ê¸°ë³¸ ë¶€í’ˆ) â†’ (ì¤‘ê°„ ë¶€í’ˆ) â†’ (ì™„ì œí’ˆ)â€ ìˆœìœ¼ë¡œ, ë¶€í’ˆë§ˆë‹¤ í•„ìš”í•œ ê¸°ë³¸ ë¶€í’ˆì˜ ê°œìˆ˜ë¥¼ ëˆ„ì í•˜ëŠ” ê³¼ì •ì´ í•„ìš”í•©ë‹ˆë‹¤.

â€¢	ì´ë¥¼ ìœ„í•´ ëŒ€ê°œ 2ì°¨ì› ë°°ì—´(ë˜ëŠ” ë”•ì…”ë„ˆë¦¬) í˜•íƒœë¡œ count[x][i] = x(ë¶€í’ˆ/ì™„ì œí’ˆ)ì„ ë§Œë“¤ ë•Œ í•„ìš”í•œ i(ê¸°ë³¸ ë¶€í’ˆ)ì˜ ê°œìˆ˜ë¥¼ ë³´ê´€í•˜ê³ , ìœ„ìƒ ì •ë ¬ ìˆœì„œëŒ€ë¡œ ì—…ë°ì´íŠ¸í•˜ê³¤ í•©ë‹ˆë‹¤.

â€¢	ì˜ˆë¥¼ ë“¤ì–´, vë¥¼ ë§Œë“¤ê¸° ìœ„í•´ wê°œì˜ uê°€ í•„ìš”í•˜ë‹¤ê³  í•  ë•Œ, count[v]ëŠ” count[u]ë¥¼ ì°¸ê³ í•˜ì—¬ count[v][i] += count[u][i] * w í˜•íƒœë¡œ ëˆ„ì í•©ë‹ˆë‹¤(ë§Œì•½ u ìì²´ê°€ ê¸°ë³¸ ë¶€í’ˆì´ë©´ ê±°ê¸°ì— ëŒ€í•´ì„œë„ ì§ì ‘ ë°˜ì˜).

3.	í•œ ë²ˆì˜ ìˆœíšŒë¡œ ëˆ„ì í•˜ê¸°

â€¢	í˜„ì¬ ì½”ë“œë¥¼ ë³´ë©´, initials(ì§„ì…ì°¨ìˆ˜ 0ì¸ ë…¸ë“œë“¤)ì— ëŒ€í•˜ì—¬ ë§¤ë²ˆ dag_shortest_pathë¥¼ í˜¸ì¶œí•˜ëŠ” êµ¬ì¡°ì²˜ëŸ¼ ë³´ì…ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ë…¸ë“œ ìˆ˜ê°€ ë§ì„ ë•Œ ë§¤ë²ˆ BFS/DFSë¥¼ ëŒê²Œ ë˜ì–´ ì‹œê°„ë³µì¡ë„ê°€ ì»¤ì ¸ì„œ ì‹œê°„ ì´ˆê³¼ê°€ ë‚  ê°€ëŠ¥ì„±ì´ í½ë‹ˆë‹¤.

â€¢	ë³´í†µì€ ìœ„ìƒì •ë ¬ë¡œ ì–»ì€ ìˆœì„œë¥¼ í•œ ë²ˆ ìˆœíšŒí•˜ë©´ì„œ, ì°¨ë¡€ëŒ€ë¡œ í•„ìš”í•œ ë¶€í’ˆë“¤ì„ ëˆ„ì í•´ë‚˜ê°€ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•´ì•¼ ì¤‘ë³µ ê³„ì‚°ì„ í”¼í•˜ê³ , ê° ê°„ì„ ë§ˆë‹¤ ë”± í•œ ë²ˆì”©ë§Œ ì—…ë°ì´íŠ¸ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆì–´ì„œ ì‹œê°„ ë³µì¡ë„ê°€ í¬ê²Œ ì¤„ì–´ë“­ë‹ˆë‹¤.

4.	relax í•¨ìˆ˜ ë¡œì§ ì ê²€

â€¢	relax(u, v, w)ì—ì„œ p[v] += p[u] * w í˜•íƒœë¡œ ëˆ„ì í•˜ê³  ìˆëŠ”ë°, ì´ëŠ” â€œvë¥¼ ë§Œë“¤ë ¤ë©´ u ë¶€í’ˆì´ ëª‡ ê°œ í•„ìš”í•œê°€?â€ë¥¼ ì €ì¥í•˜ê³  ì‹¶ì€ ì˜ë„ë¡œ ë³´ì…ë‹ˆë‹¤.

â€¢	ë‹¤ë§Œ, p[v]ê°€ í•œ ê°œì˜ ìŠ¤ì¹¼ë¼ê°’ì´ë¼ë©´, ì—¬ëŸ¬ ê¸°ë³¸ ë¶€í’ˆì´ ì„ì—¬ ìˆëŠ” ê²½ìš°ë¥¼ ì œëŒ€ë¡œ í‘œí˜„í•˜ì§€ ëª»í•©ë‹ˆë‹¤. ê²°êµ­ uê°€ ê¸°ë³¸ ë¶€í’ˆì¸ì§€, ì¤‘ê°„ ë¶€í’ˆì¸ì§€ì— ë”°ë¼ â€œê¸°ë³¸ ë¶€í’ˆë³„ ê°¯ìˆ˜â€ë¡œ í™•ì¥í•´ì„œ ê´€ë¦¬í•´ ì£¼ì–´ì•¼ í•©ë‹ˆë‹¤(ì¦‰, pë¥¼ ë‹¨ìˆœ ë°°ì—´ì´ ì•„ë‹ˆë¼, ê° ê¸°ë³¸ ë¶€í’ˆë§ˆë‹¤ì˜ ìš”êµ¬ëŸ‰ì„ ë‹´ëŠ” êµ¬ì¡°ë¡œ ë°”ê¿”ì•¼ í•  ê°€ëŠ¥ì„±ì´ í½ë‹ˆë‹¤).

5.	ê¸°ë³¸ ë¶€í’ˆ íŒë³„

â€¢	ë¬¸ì œì—ì„œ â€œê¸°ë³¸ ë¶€í’ˆì€ ë‹¤ë¥¸ ë¶€í’ˆì„ ì‚¬ìš©í•˜ì—¬ ë§Œë“¤ ìˆ˜ ì—†ëŠ” ë¶€í’ˆâ€ì´ë¼ê³  í–ˆìŠµë‹ˆë‹¤. ì¦‰, ê°„ì„ ì´ ë‚˜ê°€ëŠ” ê³³ì´ ì „í˜€ ì—†ëŠ”(= â€˜Aë¥¼ ë§Œë“¤ê¸° ìœ„í•´ì„  Bê°€ í•„ìš”í•˜ë‹¤â€™ì—ì„œ Bë¡œ ë“±ì¥í•œ ì ì´ ì—†ëŠ”) ë…¸ë“œê°€ ê¸°ë³¸ ë¶€í’ˆì´ë¼ëŠ” ì˜ë¯¸ê°€ ë©ë‹ˆë‹¤.

â€¢	ìœ„ìƒ ì •ë ¬ ê³¼ì •ì—ì„œ ì§„ì¶œ ê°„ì„ ì´ ì—†ê±°ë‚˜, í˜¹ì€ ì…ë ¥ì„ ë‹¤ ì½ì€ ë’¤ â€œì–´ë–¤ ë¶€í’ˆì„ ë§Œë“¤ê¸° ìœ„í•´ ë“±ì¥í•œ ì ì´ ì—†ë‹¤â€ë¡œ êµ¬ë¶„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ê¸°ë³¸ ë¶€í’ˆì¸ì§€ ì—¬ë¶€ë¥¼ ì •í™•íˆ íŒŒì•…í•˜ê³ , ê¸°ë³¸ ë¶€í’ˆì¸ ê²½ìš°ì—ëŠ” count[ê¸°ë³¸ë¶€í’ˆ][ê¸°ë³¸ë¶€í’ˆ] = 1ë¡œ ì‹œì‘í•˜ì‹œë©´, ì¤‘ê°„ ë¶€í’ˆ ë…¸ë“œì— ëŒ€í•´ì„œëŠ” ìœ„ìƒì •ë ¬ ìˆœì„œì— ë§ì¶° ëˆ„ì í•˜ëŠ” ì‹ìœ¼ë¡œ ì§„í–‰ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ìœ„ ì‚¬í•­ë“¤ì„ ì°¸ê³ í•´ì„œ,

â€¢	ê·¸ë˜í”„ ë°©í–¥ì„ ì–´ë–»ê²Œ ì„¤ì •í•˜ê³ ,

â€¢	ê¸°ë³¸ ë¶€í’ˆë¶€í„° ì‹œì‘í•´ ì¤‘ê°„ ë¶€í’ˆ, ìµœì¢… ë¶€í’ˆ ìˆœìœ¼ë¡œ â€œê¸°ë³¸ ë¶€í’ˆì˜ í•„ìš” ê°œìˆ˜â€ë¥¼ í•œ ë²ˆì˜ ìœ„ìƒ ì •ë ¬ ìˆœíšŒì—ì„œ ëˆ„ì **,

â€¢	â€œê¸°ë³¸ ë¶€í’ˆë³„ ì¹´ìš´íŠ¸ë¥¼ ì €ì¥í•  ìë£Œêµ¬ì¡°â€ë¥¼ êµ¬ì¶•

ì´ë ‡ê²Œ ì„¸ ê°€ì§€ë¥¼ ì¤‘ì ìœ¼ë¡œ ë¡œì§ì„ ë‹¤ë“¬ì–´ ë³´ì‹œë©´ ì¢‹ì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤. (ì •ë‹µ ì½”ë“œë¥¼ ì œì‹œí•˜ì§€ ì•Šê³  ê°œë…ì ì¸ í”¼ë“œë°±ë§Œ ë“œë ¸ìŠµë‹ˆë‹¤.)

### pë¥¼ ë²¡í„°ë¡œ ë°”ê¾¸ê³  ì´ˆê¸° ë¶€í’ˆì— ëŒ€í•´ ëª¨ë‘ DAG shortest paths ê³„ì‚°ì„ í•´ì•¼ í•˜ë‚˜? ê·¸ê²Œ ë§ì„ ê±° ê°™ë‹¤.

## Phase3. ë””ë²„ê¹… í›„ í’€ì´ - ì„±ê³µ

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 2637                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/2637                           #+#        #+#      #+#     #
#    Solved: 2025/03/30 22:45:21 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
# ì•„ë‹ˆ ì´ê±°ëŠ” ê·¸ê±°ì–ì•„. 
#  ìœ„ìƒì •ë ¬ì„ í•˜ê³ , shortest path estimate ëŒ€ì‹  all paths estimateë¡œ ë…¸ë“œë¥¼ ì—…ë°ì´íŠ¸í•˜ë©´
# ë˜ì§€ ì•Šê² ë‚˜?

import sys
from collections import deque, defaultdict
# ê·¸ë˜í”„ í‘œí˜„ ì»¨ë²¤ì…˜ì„ ë„ˆë¬´ ì„ì–´ ì“°ëŠ” ê±° ê°™ë‹¤.
def topological_sort(V: int, E):
    # ë‚´ì  ì´ˆê¸°í™”
    # e. in_degree = [0, 0, 0, 0, 0, ]
    in_degree = [0]*(V+1)
    # ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”
    adj = defaultdict(list)
    # v ì´ˆê¸°í™”
    V_ = [i for i in range(V+1)]
    # ê°€ì¤‘ì¹˜
    weights = defaultdict(int)
    
    # p1. 5, 1, 2
    # p2. 5, 2, 2
    # p3. ...
    for v, u, w in E:
        adj[u].append(v)
        in_degree[v] += 1
        weights[(u,v)] = w
    result = []
    # ë‚´ì ì´ 0ì¸ ë²„í…ìŠ¤ ì´ˆê¸°í™”
    
    initials = [v for v in V_ if in_degree[v] == 0]
    # initials = [1, 2, 3, 4]
    for i in initials:
        p[i-1][i-1] = 1 # ìê¸°ìì‹ ì„ ë§Œë“¤ ë•Œ í•˜ë‚˜ì”© í•„ìš”

    que = deque(initials)
    que.popleft() # 0 ì œê±°
    # que = deque([1, 2, 3, 4])
    while que:
        # p1. u = 1
        u = que.popleft()
        # p1. result = [1]
        result.append(u)
        # ë‚´ì ì„ ì œê±°í•˜ê³  ìœ„ìƒì •ë ¬. vë¥¼ ë§Œë“œëŠ”ë° uê°€ ê°€ì¤‘ì¹˜ë§Œí¼ í•„ìš”í•  ê²ƒ.
        # pick: u = 6
        for v in adj[u]:
            # v ë‚´ì  ì œê±°
            # v ë¶€í’ˆ ë§Œë“¤ë•Œ í•„ìš”í•œ ì •ë³´ ì—…ë°ì´íŠ¸. uë²ˆì§¸ ë¶€í’ˆì´ ëª‡ ê°œ í•„ìš”í•œê°€?
            # ê¸°ì¡´ uì˜ ë‚´ì ê°’...ì•„ ì—¬ê¸°ì„œ ëª¨ë“  ë¶€í’ˆì— ëŒ€í•œ ì´í„°ë ˆì´ì…˜ í•„ìš”
            # p1. i = 0 
            # p2. i = 1
            # n = 7
            # 6ë²ˆ ë¶€í’ˆì´ 7ë²ˆë¶€í’ˆ ë§Œë“¤ ë•Œ ëª‡ê°œ í•„ìš”í•œì§€ ë°˜ì˜ì´ ì•ˆ ë¨
            # pick: 
            for i in range(n):
                # i = 0
                # p[v-1=6][0~6] += p[5][0~6]*weight
                p[v-1][i] += p[u-1][i]*weights[(u,v)]
            
            in_degree[v] -= 1
            if in_degree[v] == 0:
                que.append(v)

    for i in initials:
        if i != 0:
            print(i, p[n-1][i-1] )

def dag_shortest_path(s:int, adj: list, weights: list):
    """ë­ ì–´ë–»ê²Œ í•˜ë©´ ë˜ì§€? ì¼ë‹¨ í•˜ë‚˜ì˜ ë²„í…ìŠ¤ë¥¼ ê¸°ì¤€ìœ¼ë¡œ? ê·¸ëƒ¥ ëª¨ë“  ê°„ì„ ì„ ëŒë©´ì„œ?"""
    p[s] = 1
    que = deque([s])
    while que:
        u = que.popleft()
        for v in adj[u]:
            
            que.append(v)



if __name__ == '__main__':	
    input = sys.stdin.readline
    # n = 7
    n = int(input().strip()) 
    # m = 8
    m = int(input().strip())
    # E = [(5, 1, 2), ...]
    # 
    E = [ 
        tuple(map(int, input().split()))
        for _ in range(m)
    ]
    # pëŠ”? ië²ˆì§¸ ë¶€í’ˆì„ ë§Œë“œëŠ”ë° më²ˆì§¸ ë¶€í’ˆì´ ëª‡ ê°œ í•„ìš”í•œì§€ ê³„ì‚°.
    """
    p = [ 
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
    ]
    """
    p = [[0 for j in range(n)] for _ in range(n)]
    topological_sort(n, E)
    # for s in p:
    #     print(s)
    # for s in initials:
    #     p = [0 for _ in range(n+1)]
    #     dag_shortest_path(s, adj, weights)
    #     print(f'{s} {p[n]}')

"""
ì´ìŠˆ: ì‹œê°„ì´ˆê³¼

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: 
ìµœê·¼ ë³€ê²½ ì‚¬í•­: 

Phase2.
í™•ì¸: 
ì‹œë„: 
p ì´ˆê¸°í™” í•¨ìˆ˜ ì‚­ì œ,
relax í•¨ìˆ˜ ì‚­ì œ

ë¶„ì„: ì˜ë¯¸ ì—†ìŒ
"""
```

ë””ë²„ê¹…ì„ í•˜ë©° ê¸°ëŒ€ê°’ì„ ì£¼ì„ì— ì ê³ , step intoë¥¼ ì ê·¹ í™œìš©í–ˆë‹¤. ì‘ì€ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ì— ëŒ€í•´ ì°¨ê·¼ì°¨ê·¼ ì§„í–‰í•˜ë©´ ìƒê°ë³´ë‹¤ ê¸ˆë°© ìœ ì˜ë¯¸í•œ ìˆ˜ì •ì„ í•  ìˆ˜ ìˆë‹¤!

### ì‘ì€ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ì— ëŒ€í•´ ì°¨ê·¼ì°¨ê·¼ ì§„í–‰í•˜ë©´ ìƒê°ë³´ë‹¤ ê¸ˆë°© ìœ ì˜ë¯¸í•œ ìˆ˜ì •ì„ í•  ìˆ˜ ìˆë‹¤!

# ë‹¤ìµìŠ¤íŠ¸ë¼: ìµœì†Œ ë¹„ìš© êµ¬í•˜ê¸°

https://www.acmicpc.net/problem/2665

## Phase0. ë¬¸ì œ ì´í•´

![](./images/IMG_0463.png)

ê·¸ë¦¼ì´ ìˆì–´ì„œ ì¢€ ê² ë¨¹ì—ˆì—ˆì§€ë§Œ, ìƒê°ë³´ë‹¤ ì–´ë µì§€ëŠ” ì•Šì•˜ìŒ. ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ dx, dy í…Œí¬ë‹‰ì„ ì´ìš©í•´ bfsì²˜ëŸ¼ í™œìš©í•  ìˆ˜ ìˆëŠ”ì§€ ë¬»ëŠ”, ìƒê°ë³´ë‹¤ ê°„ë‹¨í•œ ë¬¸ì œ.

## Phase1. ì§ì ‘ í’€ê¸°

ê·¸ëƒ¥ ë‹¤ìµìŠ¤íŠ¸ë¼ ë³´ê³  êµ¬í˜„í•˜ëŠ” ê±°ë¼â€¦ì½”ë“œë¥¼ ì™¸ìš°ê³  ë„˜ì–´ê°€ì•¼ ì˜ë¯¸ê°€ ìˆê¸´ í•¨. 

ë‹¤ìŒ ë¬¸ì œë„ ë‹¤ìµìŠ¤íŠ¸ë¼ë‹ˆê¹Œ, ì•ˆ ë³´ê³  ì§œë³´ë„ë¡ í•˜ì„¸ìš”.

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 1916                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/1916                           #+#        #+#      #+#     #
#    Solved: 2025/03/29 10:54:48 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
"""
1. ë¬¸ì œ ì½ê¸°
Nê°œì˜ ë„ì‹œê°€ ìˆë‹¤. 
ê·¸ë¦¬ê³  í•œ ë„ì‹œì—ì„œ ì¶œë°œí•˜ì—¬ ë‹¤ë¥¸ ë„ì‹œì— ë„ì°©í•˜ëŠ” Mê°œì˜ ë²„ìŠ¤ê°€ ìˆë‹¤. 
ìš°ë¦¬ëŠ” Aë²ˆì§¸ ë„ì‹œì—ì„œ Bë²ˆì§¸ ë„ì‹œê¹Œì§€ ê°€ëŠ”ë° ë“œëŠ” ë²„ìŠ¤ ë¹„ìš©ì„ ìµœì†Œí™” ì‹œí‚¤ë ¤ê³  í•œë‹¤. 
Aë²ˆì§¸ ë„ì‹œì—ì„œ Bë²ˆì§¸ ë„ì‹œê¹Œì§€ ê°€ëŠ”ë° ë“œëŠ” ìµœì†Œë¹„ìš©ì„ ì¶œë ¥í•˜ì—¬ë¼. 
ë„ì‹œì˜ ë²ˆí˜¸ëŠ” 1ë¶€í„° Nê¹Œì§€ì´ë‹¤.

2. ë¬¸ì œ í’€ê¸°
ì´ê±° ë‹¤ìµìŠ¤íŠ¸ë¼ì¸ë°... ë¨¼ì € ì´ë¡ ì„ ì§šê³  ë„˜ì–´ê°€ì•¼ í•©ë‹ˆë‹¤.

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import heapq, sys
from collections import defaultdict

def dijkstra(G, n ,s):
    # ê±°ë¦¬ ì •ë³´ë¥¼ ë¬´í•œìœ¼ë¡œ ì´ˆê¸°í™”
    distances = [float('inf') for _ in range(n+1)]
    # ê·¸ë¦¬ê³ ? ìŠ¤íƒ€íŠ¸ ì¸ë±ìŠ¤ ì´ˆê¸°í™” í•˜ê³  ìš°ì„ ìˆœìœ„ íì— ì§‘ì–´ ë„£ê¸°
    distances[s] = 0
    queue = [(s, 0)]
    while queue:
        # current_node, current_distance
        current_node, current_distance = heapq.heappop(queue)
        if distances[current_node] < current_distance:
            continue

        for neighbor, weight in G[current_node]:
            distance = current_distance + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(queue, (neighbor, distance))
    # print(distances)
    return distances

if __name__ == '__main__':	
    input = sys.stdin.readline
    n = int(input().strip())
    m = int(input().strip())
    buses = [
        tuple(map(int, input().split()))
        for _ in range(m)
    ]
    G = defaultdict(list)
    for u, v, w in buses:
        G[u].append((v, w))
        # G[v].append((u, w))
    start, end = tuple(map(int, input().split()))
    # print(n, m, G, start, end)
    distances = dijkstra(G, n, start)
    print(distances[end])
    
```

if distances[current_node] < current_distance: continue ë¶€ë¶„ì—ì„œ ë¶€ë“±í˜¸ë¥¼ ê±°ê¾¸ë¡œ í•´ì„œ ì‹œê°„ ì´ˆê³¼ê°€ ë‚¬ë‹¤. ì´ ë¶€ë¶„ì€ ì–´ë–»ê²Œ ì¨ë„ ì—ëŸ¬ëŠ” ì•ˆ ë‚˜ì§€ë§Œ, ì‹œê°„ ë³µì¡ë„ì— ìƒë‹¹íˆ ê¸°ì—¬í•˜ëŠ” ë¶€ë¶„ì´ë‹ˆ ì£¼ì˜. 

# ë‹¤ìµìŠ¤íŠ¸ë¼:  ë¯¸ë¡œ ë§Œë“¤ê¸°

## Phase1. ì§ì ‘í’€ê¸° - ì„±ê³µ

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 2665                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/2665                           #+#        #+#      #+#     #
#    Solved: 2025/03/31 21:16:37 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
import sys, heapq
from collections import deque

dxs, dys = [-1, 1, 0, 0], [0, 0, -1, 1]

def in_range(x, y):
    return x >= 0 and x < n and y >= 0 and y < n

def bfs_var():
    # init starting point
    maze_time[0][0] = 0
    queue = [[0, 0, 0]]

    while queue:
        _, x, y = heapq.heappop(queue)
        for dx, dy in zip(dxs, dys):
            nx, ny = x + dx, y + dy
            # ì—¬ê¸°ì„œ ê·¸ ìµœì í™”ë¥¼ í•´ì¤„ ìˆ˜ ìˆë‹¤. 
            if in_range(nx, ny):
                if maze[nx][ny] == 0: w = 1
                else: w = 0
                if maze_time[x][y] + w > maze_time[nx][ny]:
                    continue
                distance = maze_time[x][y]+w
                if distance < maze_time[nx][ny]:
                    maze_time[nx][ny] = distance
                    heapq.heappush(queue, (distance, nx, ny))
    # print('-'*10)
    # for mt in maze_time:
    #     print(mt)

if __name__ == '__main__':	
    input = sys.stdin.readline
    n = int(input().strip())
    maze = [
        tuple(map(int, list(input().strip())))
        for _ in range(n)
    ]
    # for m in maze:
    #     print(m)
    maze_time = [
        [float('inf') for _ in range(n)]
        for _ in range(n)
    ]
    bfs_var()
    print(maze_time[n-1][n-1])

"""
8
11100110
11010010
10011010
11101100
01100111
00110001
11011100
11000111
"""
```

### ë””ë²„ê·¸ ë…¸íŠ¸

```python

def bfs_var():
    # init starting point
    maze_time[0][0] = 0
    queue = [[0, 0, 0]]

    while queue:
        _, x, y = heapq.heappop(queue)
        for dx, dy in zip(dxs, dys):
            nx, ny = x + dx, y + dy
            # ì—¬ê¸°ì„œ ê·¸ ìµœì í™”ë¥¼ í•´ì¤„ ìˆ˜ ìˆë‹¤. 

            if in_range(nx, ny):
                if maze_time[x][y] + 1 > maze_time[nx][ny]:
                    continue
                # update shortest path estimate of nx, ny
                # if nx, ny belongs to grey one
                if maze[nx][ny] == 0:
                    distance = maze_time[x][y]+1
                else:
                    distance = maze_time[x][y]
                if distance < maze_time[nx][ny]:
                    maze_time[nx][ny] = distance
                heapq.heappush(queue, (distance, nx, ny))
```

í•¨ìˆ˜ë¥¼ ì´ë ‡ê²Œ ì‘ì„±í–ˆì„ ë•Œ 83í”„ë¡œì—ì„œ ì‹œê°„ì´ˆê³¼ ë°œìƒí–ˆë‹¤. ì¼ë‹¨ ë¬¸ì œì ì´ ë­ì˜€ëƒë©´, 

1. heapq.heappush êµ¬ë¬¸ì´ shortest path estimateê°€ ê°±ì‹ ë˜ì§€ ì•Šì€ ì‹œì ì—ë„ ì—…ë°ì´íŠ¸ ë˜ê³  ìˆì—ˆê³ (íì— ê³¼ë„í•œ í‘¸ì‰¬ ì—°ì‚° ë°œìƒí–ˆì„ ê²ƒ)(ì´ê²Œ í•µì‹¬)
1. ì´ˆê¸° ë¹„êµì—ì„œ ê°€ì¤‘ì¹˜ë¥¼ ì¼ê´„ì ìœ¼ë¡œ 1ë¡œ ê°€ì •í•´ì„œ ì—…ë°ì´íŠ¸í•˜ì§€ ì•Šì•„ë„ ë˜ëŠ” ê²½ìš°ë¥¼ íŒ¨ìŠ¤í–ˆëŠ”ë°,
2ë²ˆì€ ê·¸ë‹¤ì§€ ë¬¸ì œê°€ ì•„ë‹ˆì—ˆê³ (ì°¨ì´ê°€ ì¢€ ìˆì—ˆì„ ê±° ê°™ê¸´ í•œë°, ì§ì ‘ ë¹„êµí•œ ìˆ˜í–‰ ì‹œê°„ì€ 64msë¡œ ë™ì¼) heapq.heappush ì—°ì‚° ìœ„ì¹˜ê°€ ë¬¸ì œì˜€ë‹¤.

ì•„ë¬´íŠ¼ ì˜ í•´ê²°í•´ì„œ í’€ì´ ì„±ê³µ. ì¬ë¯¸ìˆëŠ” ë‹¤ìµìŠ¤íŠ¸ë¼ í™œìš© ë¬¸ì œì˜€ë‹¤. 

# ìœ„ìƒì •ë ¬: ê·¸ë˜í”„ ìˆ˜ì •

## Phase1. ì²« ë²ˆì§¸ ì‹œë„

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 1432                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/1432                           #+#        #+#      #+#     #
#    Solved: 2025/04/02 10:45:06 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ì¼ë‹¨ ìœ„ìƒì •ë ¬í•´ì„œ ì°¨ë¡€ë¡œ ë§¤ê¸´ ë²ˆí˜¸ë¥¼ ì›ë˜ ë²ˆí˜¸ ìˆœì„œëŒ€ë¡œ ì¶œë ¥í•˜ë©´ ë¨.
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys, heapq
from collections import defaultdict


# ìœ„ìƒ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜
def topological_sort(n: int, graph):
    in_degree = [0 for _ in range(n)]
    for u in range(n):
        for v in graph[u]:
            in_degree[v] += 1
    cnt = 1
    que = [u for u in range(n) if in_degree[u] == 0]
    if not que:
        print(-1)
        return
    result = [0 for _ in range(n)]
    while que:
        for _ in range(len(que)):
            u = heapq.heappop(que)
            result[u] = cnt
            cnt += 1
            for v in graph[u]:
                in_degree[v] -= 1
                if in_degree[v] == 0:
                    heapq.heappush(que, v) 
    if not que and sum(in_degree) > 0:
        print(-1)
        return
    else:
        for r in result:
            print(r, end=' ')


if __name__ == '__main__':	
    input = sys.stdin.readline
    n = int(input().strip())
    arr = [
        tuple(map(int, list(input().strip())))
        for _ in range(n)
    ]   
    graph = defaultdict(list)
    for i in range(n):
        for j in range(n):
            if arr[i][j] == 1:
                graph[i].append(j)
    topological_sort(n, graph)
    # print(graph)



```

## Phase2. 

ì‚¬ì „ìˆœìœ¼ë¡œ ì¶œë ¥ì´ ì•ˆ ë¼ì„œ ë‚´ì  ê¸°ì¤€ ëŒ€ì‹  ì™¸ì  ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ì„ í•¨. 

â€˜ì‚¬ì „ ì—­ìˆœâ€™ ì¶œë ¥ì¼ ê²½ìš° ë‚´ì  ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ë©´ ë¨. 

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 1432                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/1432                           #+#        #+#      #+#     #
#    Solved: 2025/04/02 10:45:06 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ì¼ë‹¨ ìœ„ìƒì •ë ¬í•´ì„œ ì°¨ë¡€ë¡œ ë§¤ê¸´ ë²ˆí˜¸ë¥¼ ì›ë˜ ë²ˆí˜¸ ìˆœì„œëŒ€ë¡œ ì¶œë ¥í•˜ë©´ ë¨.
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys, heapq
from collections import defaultdict


# ìœ„ìƒ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜
def topological_sort(n: int, graph):
    # ë‚´ì  ì´ˆê¸°í™”
    # out_degree = [0, 0, 0, 0]
    out_degree = [0 for _ in range(n)]
    graph_reverse = defaultdict(list)
    for u in range(n):
        for v in graph[u]:
            out_degree[u] += 1
            graph_reverse[v].append(u)
    # out_degree = [2, 0, 0, 1]
    # ë‚´ì ì´ 0ì¸ ë²„í…ìŠ¤ê°’ë“¤ ë¨¼ì € íì— ì‚½ì…
    # que = [0]
    que = [-u for u in range(n) if out_degree[u] == 0]
    heapq.heapify(que)
    cnt = n
    result = [0 for _ in range(n)]
    while que:
        for _ in range(len(que)):
            # u = 0
            u = -heapq.heappop(que)
            result[u] = cnt
            cnt -= 1
            for v in graph_reverse[u]:
                out_degree[v] -= 1
                if out_degree[v] == 0:
                    heapq.heappush(que, -v) 
    if not que and sum(out_degree) > 0:
        print(-1)
        return
    else:
        for r in result:
            print(r, end=' ')


if __name__ == '__main__':	
    input = sys.stdin.readline
    n = int(input().strip())
    arr = [
        tuple(map(int, list(input().strip())))
        for _ in range(n)
    ]   
    graph = defaultdict(list)
    for i in range(n):
        for j in range(n):
            if arr[i][j] == 1:
                graph[i].append(j)
    topological_sort(n, graph)
    # print(graph)



```

# ìœ„ìƒì •ë ¬: ì„ê³„ê²½ë¡œ

## Phase1. 

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 1948                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/1948                           #+#        #+#      #+#     #
#    Solved: 2025/04/02 17:12:36 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
import sys
from collections import defaultdict, deque
sys.setrecursionlimit(10**8)

def topology_sort(arr: list, n: int):
    # in_degree
    graph = defaultdict(list)
    graph_reversed = defaultdict(list)
    in_degree = [0 for _ in range(n+1)]
    cost = [0 for _ in range(n+1)]
    for u, v, w in arr:
        graph[u].append((v, w))
        in_degree[v] += 1
        graph_reversed[v].append((u, w))
    queue = deque([u for u in range(n+1) if in_degree[u] == 0 ])
    result = []
    while queue:
        u = queue.popleft()
        result.append(u)
        for v, w in graph[u]:
            in_degree[v] -= 1
            cost[v] = max(cost[v], cost[u]+w)
            if in_degree[v] == 0:
                queue.append(v)
    return cost, graph, graph_reversed

def back_prop(v: int, graph_reversed: defaultdict, path: list):
    global visited, critical_path
    # ì—­ ì¶”ì ê°’ êµ¬í•˜ê¸°
    if v == start:
        # print(path)
        for p in path:
            critical_path.add(p)

    for u, w in graph_reversed[v]:
        if cost[u] >= cost[v] - w: # í˜„ì¬ ê°€ì¤‘ì¹˜ë¥¼ ëº€ ê°’ê³¼ ì¼ì¹˜ ??
            # visited[u] = True
            path.append((u, v))
            back_prop(u, graph_reversed, path)
            path.remove((u, v))
            # visited[u] = False


if __name__ == '__main__':	
    input = sys.stdin.readline
    n = int(input().strip())
    m = int(input().strip())
    arr = [
        tuple(map(int, input().split()))
        for _ in range(m)
    ]
    start, end = tuple(map(int, input().split()))
    # print(n, m, arr, start, end)
    cost, graph, graph_reversed = topology_sort(arr, n)
    visited = [False for _ in range(n+1)]
    critical_path = set()
    back_prop(end, graph_reversed, [])
    print(cost[end])
    
    print(len(critical_path))

```

## Phase2. ë‹¤ë¥¸ ì‹œë„

```python
#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 1948                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: joho54 <boj.kr/u/joho54>                    +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/1948                           #+#        #+#      #+#     #
#    Solved: 2025/04/02 17:12:36 by joho54        ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
import sys
from collections import defaultdict, deque
sys.setrecursionlimit(10**8)

def topology_sort(arr: list, n: int):
    global test
    # in_degree
    graph = defaultdict(list)
    graph_reversed = defaultdict(list)
    in_degree = [0 for _ in range(n+1)]
    cost = [0 for _ in range(n+1)]
    for u, v, w in arr:
        graph[u].append((v, w))
        in_degree[v] += 1
        graph_reversed[v].append((u, w))
    queue = deque([u for u in range(n+1) if in_degree[u] == 0 ])
    result = []
    while queue:
        u = queue.popleft()
        result.append(u)
        for v, w in graph[u]:
            in_degree[v] -= 1
            if cost[v] <= cost[u] + w:
                # ê·¸ë¦¬ê³ ? vë¡œ ê°€ê¸° ìœ„í•´ì„œëŠ” uë¡œ ê¼­ ê±°ì³ì•¼ í•¨ì„ ê²½ë¡œì— ì €ì¥.
                if cost[v] == cost[u]+w:
                    test[v].append(u)
                else: 
                    test[v] = [u]
                cost[v] = cost[u] + w
            if in_degree[v] == 0:
                queue.append(v)
    return cost, graph, graph_reversed

def dfs(v: int, paths: list):
    global test
    if v == start:
        # print('pippip', v)
        for p in paths:
            critical_path.add(p)
        return
    for u in test[v]:
        # print(f'getting into {u}')
        paths.append((u, v))
        dfs(u, paths)
        paths.remove((u, v))



if __name__ == '__main__':	
    input = sys.stdin.readline
    n = int(input().strip())
    m = int(input().strip())
    arr = [
        tuple(map(int, input().split()))
        for _ in range(m)
    ]
    start, end = tuple(map(int, input().split()))
    # print(n, m, arr, start, end)
    test = defaultdict(list)
    cost, graph, graph_reversed = topology_sort(arr, n)
    critical_path = set()
    dfs(end, [])
    print(cost[end])
    # print('critical path test', test)
    print(len(critical_path))


```

back-propagation/dfs ì—­ì¶”ì  ê´€ê³„ ì—†ì´ ì‹œê°„ ì´ˆê³¼ ì˜¤ë¥˜ ë°œìƒ. ë¬¸ì œëŠ” topology_sortì— ìˆìŒ.

