# [Essey] 정글 일지



> 개념과 이슈 트래킹을 조합해서 “복기 가능한” 자료를 만들도록 합니다.

> 이슈 트래킹 작성 원칙: Phase1(환경, 로그, 최근 변경사항), Phase2(확인, 시도, 결과분석) 형식으로 정리하세요. (Phase2는 최대 3회까지 반복하고 해결 안 되면 아예 처음부터 시작(불가능할 경우 도움 요청))

> #: 질문, 일기, 목표



# 일기: 1주차 프로젝트를 마친 소회 2025.03.13.

## 개발자라는 직무의 복잡성에 대해

개발자는 극도로 복잡한 소프트웨어를 생산 관리하는 직업이다. 인문학적인 용어로 치환하면, 혼돈 속에서 질서를 건져내야 하는 사람들이다. 결국에는 이 질서 유지 능력이 있는 사람과 없는 사람으로 나뉠거다. 그 능력이 있다면, 개발자는 경영인이 되려 할 거다. 크래프톤 정글의 OT에서 크래프톤 의장님의 이야기를 들으면서 든 생각이기도 하다. 본인의 성장 과정은 어떤 면에서 혼돈의 기억으로 남을 수도 있었다. 하지만 그렇게 놔두는 대신 분석하고 통찰해서 정글의 5개월 과정에 그 혼돈을 ‘커리큘럼’이라는 이름으로 정리했다. 

‘커리큘럼’이란 뭔가. 누군가 먼저 걸은 길을 재구성한 거다. 지식의 대물림을 위한 체계화다. 크래프톤 정글은 그 체계화를 내가 봤을 땐 아주 잘 한 편이다. 

크래프톤 정글의 방식에서는 넛지도 빼놓을 수 없다.

기숙사에는 의자가 없다. 침대와 화장대만 있다. 이건 더 말해봤자 입만 아픈 훌륭한 넛지다. 사람들은 깨어 있는 동안에는 교육장에 오도록 아주 강한 넛지를 받는다. 

# 질문: 취업 산업 도메인을 콘텐츠 말고 물류 같은 분야로 가고 싶은데 진로 설정을 어떻게 해야할지 잘 모르겠어요

## Phase1. 답

# 일지: 2025.03.14. 

## 알고리즘

백준 풀고 리뷰하기

## CSAPP 읽기

책 읽어야 할 곳: WEEK01 ~1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다. 이까지 읽고 정리하면 된다 이거지? 오케이.

## JWT 복습

## 목표: 일단 쉬운 백준 문제는 다 풀었다. 이제 할 일 정리

사실, 쉬운 문제가 아니라 생각하지 않고 풀어도 되는 문제들이었다. 그러니까, 이제 머리를 쓰기 시작해야 한다. 30분 동안 머리를 쓰고 문제를 풀어본다. 30분 후에 가닥이 안 잡히면 책을 본다. 책이 없을 경우는 일단 보류. 이것도 시간이 많이 걸릴 거 같으니까. 

## 아포리즘

- 앉아 있을 때 허리 쪽을 손으로 짚으면 허리 근육에 힘을 줄 수 있어서 허리가 덜 아프고 자세가 유지된다.
- 절박함을 모방할 수는 없지만, 조장할 수는 있을 거 같다. ‘전쟁’을 머릿속으로 되뇌이면 된다. 전쟁 전쟁 전쟁.
# 일지: 2025.03.15. 

## 목표 환기

> 첫 4주에 여러분들이 익혀 주셔야 하는 것은 현실의 문제를 컴퓨터에게 효율적으로 빠르게 떠넘기는 능력입니다. 컴퓨터에게 일을 시키기 위해서 자료구조와 알고리즘의 공부는 필수입니다.

일단 큰 갈래 세 개가 남았다. 문제 부분에서는: 재귀, 정렬, 완전탐색. 

정렬은 일단 문제를 탑다운으로 더 풀어보고, 해결 안 되면 공부를 좀 하자. 재귀는 공부 할 만큼 했는데, 문제를 혼자 풀 수 있기 전까지는 끝낼 수 없다. 완전탐색은 그냥 문제가 어려운게 둘 있어서 고민. 일단 정렬 하고 나서 생각하기.

오후 5시, 일단 내 지식으로 주어진 문제는 리미트까지 푼 거 같다. 이제 공부하자.

으아 지루해. 문제풀고 싶다. 재귀 문제 다시 구현해보자. 

# 일지: 2025.03.15. 일

## 공부 계획

1. 키워드들
  1. 배열, 문자열
  1. 반복문과 재귀함수
  1. 복잡도(BigO, 시간, 공간)
  1. 정렬
  1. 완전탐색
1. 알고리즘 책
  1. 키워드 중심으로 볼 필요가 있습니다.
  1. 그냥 든 아이디어인데, 어려운 문제들을 놓고 수도코드 → 구현 연습을 반복하는 것도 좋을 거 같아요.
  1. 그러면 있잖아요, 일단 반복문이랑 재귀함수는 그럭저럭 된 거 같은데, 뭘 더 볼까요? 정렬? 정렬을 보면서, 수도코드 → 구현 연습을 하는 것도 좋을 거 같습니다. 
  1. 체계: 개구코, 수구(수도코드→구현)로 합시다.
1. CSAPP
  1. 이거는 그냥 버텀 업 방식으로
  1. 그리고 이런 교제들은 이제 homework가 있으니까 참조할 것.
1. 퀴즈
  1. 일단 남은 퀴즈 3개는 내가 30분도 안 풀어봤던 것들이라, 일단 고민하는 시간 필요
## 느낀점: 재귀와 스택의 관계를 이해하는게 좋다! 

그림으로 각 구현의 콜스택을 트래킹 해보고, 재귀 코드를 스택 코드로 바꿔보는 연습을 할 것.

# 일지: 2025.03.15.

## 공부 계획

1. CSAPP
  1. 일단은 다 읽었는데 더 할게 있을라나
1. Introduction to Algorithm
  1. 키워드 중심: 배열/문자열, 반복문과 재귀함수, 복잡도(BigO, 시간, 공간), 정렬, 완전탐색
  1. 체계: 개구코, 수구(수도코드→구현)로 합시다.
1. Do IT! 자료구조로 배우는 알고리즘
  1. 키워드 중심: 배열/문자열, 반복문과 재귀함수, 복잡도(BigO, 시간, 공간), 정렬, 완전탐색
  1. 체계: 개구코, 수구(수도코드→구현)로 합시다.
1. 퀴즈
  1. 위에거 다 하면 다시 풀어보는 것도 좋을듯.


건의사항: 맨 양 끝 자리가 화이트보드가 바로 뒤에 있어서 바로바로 이용하기가 좋고, 그만큼 의견 나누는 분위기가 쉽게 조성이 되는데 지금 한 쪽은 이용을 안 하고 있어서 아쉬운 거 같습니다. → 근데 뭐 그냥…바로바로 보여줘. 내가 좀 멀리 있는 거지 뭐

공부가 좀 늘어지는 거 같다. 일단 오늘 내일의 목표는 정렬을 전부 구현할 수 있게 되는 거다. 수도코드로 다 작성하고, 구현까지. 

## 아포리즘

알람을 7시 반에 고정해놓는게 좋겠다. 그리고 전쟁 경보 같은 소리로 설정해 놔야 일어난다. 아침에는 30분 조깅을 한 다음 씻고 8시 30분까지 교육장에 나오자.

그러면 오전 3시간 반

오후 5시간

저녁에 11시까지 하면? 4시간

12시간 반. 

11시까지 공부하고, 바로 30분 근력운동 하고 씻고 12시까지 눕고. 한 시간 더 일찍 일어나면? 6시 반에 일어나야 함.

13시간 반. 그럼 실질적으로 14시간은 하는 걸로 생각할 수 있겠다. 점심 먹고 바로 공부하는데 일괄적으로 2시간 빼고 뜨니까. 그럼 난 13시간 반 채우는 걸 목표로 해야겠다.  하 쉽지 않네. 오늘도 8시 반에 일어났는데. 

# 일지: 2025.03.16. 화

## 공부계획

### 어제 정리한 recur()와 partitioning() 스택으로 구현하는 과정 화이트보드에 다시 정리하고 사진 찍으세요!



![](./images/IMG_9924.heic)

![](./images/IMG_9924.heic?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466TEAXNGPY%2F20250319%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250319T003742Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA0aCXVzLXdlc3QtMiJHMEUCIC5ZMxl8FDBrjgINkmtp%2Bm%2FsAOUMh0aromFnQrJuR3GPAiEAyIQ2jlzW6iQdvuRYB8xiMDelqfnBSqga1tF4hgfHzocq%2FwMIZhAAGgw2Mzc0MjMxODM4MDUiDP7zd89mYiBjlmdf5SrcA3gcbyNzqRrocLLKHLCsqbe553deK1JOXISICBQOyAbGiNEpqd6kcYQWZ58%2BfbVwvGo%2FWLra0LAyIeP5Z5GoReM%2BPZeyjYgPP8Jjcb%2Fx1Qy6hoScpDOsZY7QIxokwMTDpMOFMSsJCW1MWD6jvYefsMY5avTBeOM0x78EE1b%2FL4MLA40MW1ACJpFGuSfzOlrIICIipzNmt%2BJHnQ%2BWz%2FhIJ1oFCIvBqOPPVcoX0zH0XYAIcDTdG3Rwq4kyGYlEcX019LbFWrz5Vlii%2FVS2t1PRVQjlatz5mBh0oWpZA0Y51Y87Iye%2FcTPTTcPdiEr20ZVHNLXHLXvVcrPRUB3oWMW94WuKWW2LnnAysDyrVzCa5LeYqzSeDTDPUFQmVv85eBMj5xMpNmnAiiHSBdtQFDXHDjsKdTs6IanBsAYZPfSY3gFWhzGEVabJId%2F6jEnN1vHANmiKVngSn8Go%2BsR%2FbqBvD0djIBJ1h4I80vHLloJTYHDx5tDRstLBMrhAwOyBwuu1BTEx5tN5StLHceUDpY7G3e%2BtVaPFLiLtb39rf0y7fBenjllZYvnQGw1cvVeJ24OWXNqjaNHSG9W8kv%2BgtNtwj2SjRUiI4v1pCQkzzVH54TznWbyH7TJGLj%2FeE5wZMMWw574GOqUBEuAYB5jUNZ%2FuJh7ZX8p4hzWkJeMgxO9aDVLKog77ndIa7w3C%2FDJvKwx2IY5d9ogN7qHv%2FXutcsIa5iLZPXfNMq3%2BtxINmrrWvioVViCN1lJTDuOwE%2BTYD1WbxZqfGkg%2FyyLmgifUd%2BwR7KZAzp0Gi0YclMuRSb5q5LFxLKOvKggbT73ppiSrs3S4dM9UCT62ymr6jvW7OT40okbi5cRbWgBtNRKm&X-Amz-Signature=906b95b1fe85feb7e25581d6b0d52c2de68ba2db6be02981676e3e06e5fe61aa&X-Amz-SignedHeaders=host&x-id=GetObject)

![](./images/IMG_9925.heic)

![](./images/IMG_9925.heic?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466TEAXNGPY%2F20250319%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250319T003742Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA0aCXVzLXdlc3QtMiJHMEUCIC5ZMxl8FDBrjgINkmtp%2Bm%2FsAOUMh0aromFnQrJuR3GPAiEAyIQ2jlzW6iQdvuRYB8xiMDelqfnBSqga1tF4hgfHzocq%2FwMIZhAAGgw2Mzc0MjMxODM4MDUiDP7zd89mYiBjlmdf5SrcA3gcbyNzqRrocLLKHLCsqbe553deK1JOXISICBQOyAbGiNEpqd6kcYQWZ58%2BfbVwvGo%2FWLra0LAyIeP5Z5GoReM%2BPZeyjYgPP8Jjcb%2Fx1Qy6hoScpDOsZY7QIxokwMTDpMOFMSsJCW1MWD6jvYefsMY5avTBeOM0x78EE1b%2FL4MLA40MW1ACJpFGuSfzOlrIICIipzNmt%2BJHnQ%2BWz%2FhIJ1oFCIvBqOPPVcoX0zH0XYAIcDTdG3Rwq4kyGYlEcX019LbFWrz5Vlii%2FVS2t1PRVQjlatz5mBh0oWpZA0Y51Y87Iye%2FcTPTTcPdiEr20ZVHNLXHLXvVcrPRUB3oWMW94WuKWW2LnnAysDyrVzCa5LeYqzSeDTDPUFQmVv85eBMj5xMpNmnAiiHSBdtQFDXHDjsKdTs6IanBsAYZPfSY3gFWhzGEVabJId%2F6jEnN1vHANmiKVngSn8Go%2BsR%2FbqBvD0djIBJ1h4I80vHLloJTYHDx5tDRstLBMrhAwOyBwuu1BTEx5tN5StLHceUDpY7G3e%2BtVaPFLiLtb39rf0y7fBenjllZYvnQGw1cvVeJ24OWXNqjaNHSG9W8kv%2BgtNtwj2SjRUiI4v1pCQkzzVH54TznWbyH7TJGLj%2FeE5wZMMWw574GOqUBEuAYB5jUNZ%2FuJh7ZX8p4hzWkJeMgxO9aDVLKog77ndIa7w3C%2FDJvKwx2IY5d9ogN7qHv%2FXutcsIa5iLZPXfNMq3%2BtxINmrrWvioVViCN1lJTDuOwE%2BTYD1WbxZqfGkg%2FyyLmgifUd%2BwR7KZAzp0Gi0YclMuRSb5q5LFxLKOvKggbT73ppiSrs3S4dM9UCT62ymr6jvW7OT40okbi5cRbWgBtNRKm&X-Amz-Signature=956d016129a405660d951d1a872abbe3bff432f5b8cc4f3999ad664a02beffdd&X-Amz-SignedHeaders=host&x-id=GetObject)

저녁에 다시 했는데 또 까먹었다. 그래서 다시 복습.

![](./images/IMG_9934.heic)

![](./images/IMG_9934.heic?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466TEAXNGPY%2F20250319%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250319T003742Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA0aCXVzLXdlc3QtMiJHMEUCIC5ZMxl8FDBrjgINkmtp%2Bm%2FsAOUMh0aromFnQrJuR3GPAiEAyIQ2jlzW6iQdvuRYB8xiMDelqfnBSqga1tF4hgfHzocq%2FwMIZhAAGgw2Mzc0MjMxODM4MDUiDP7zd89mYiBjlmdf5SrcA3gcbyNzqRrocLLKHLCsqbe553deK1JOXISICBQOyAbGiNEpqd6kcYQWZ58%2BfbVwvGo%2FWLra0LAyIeP5Z5GoReM%2BPZeyjYgPP8Jjcb%2Fx1Qy6hoScpDOsZY7QIxokwMTDpMOFMSsJCW1MWD6jvYefsMY5avTBeOM0x78EE1b%2FL4MLA40MW1ACJpFGuSfzOlrIICIipzNmt%2BJHnQ%2BWz%2FhIJ1oFCIvBqOPPVcoX0zH0XYAIcDTdG3Rwq4kyGYlEcX019LbFWrz5Vlii%2FVS2t1PRVQjlatz5mBh0oWpZA0Y51Y87Iye%2FcTPTTcPdiEr20ZVHNLXHLXvVcrPRUB3oWMW94WuKWW2LnnAysDyrVzCa5LeYqzSeDTDPUFQmVv85eBMj5xMpNmnAiiHSBdtQFDXHDjsKdTs6IanBsAYZPfSY3gFWhzGEVabJId%2F6jEnN1vHANmiKVngSn8Go%2BsR%2FbqBvD0djIBJ1h4I80vHLloJTYHDx5tDRstLBMrhAwOyBwuu1BTEx5tN5StLHceUDpY7G3e%2BtVaPFLiLtb39rf0y7fBenjllZYvnQGw1cvVeJ24OWXNqjaNHSG9W8kv%2BgtNtwj2SjRUiI4v1pCQkzzVH54TznWbyH7TJGLj%2FeE5wZMMWw574GOqUBEuAYB5jUNZ%2FuJh7ZX8p4hzWkJeMgxO9aDVLKog77ndIa7w3C%2FDJvKwx2IY5d9ogN7qHv%2FXutcsIa5iLZPXfNMq3%2BtxINmrrWvioVViCN1lJTDuOwE%2BTYD1WbxZqfGkg%2FyyLmgifUd%2BwR7KZAzp0Gi0YclMuRSb5q5LFxLKOvKggbT73ppiSrs3S4dM9UCT62ymr6jvW7OT40okbi5cRbWgBtNRKm&X-Amz-Signature=2cd27f3acba10d7ace3921e150a2f455e242147286519d23ac5249149700d31e&X-Amz-SignedHeaders=host&x-id=GetObject)

## 아포리즘: 키워드는 구체화된 질문으로 치환해서 날 몰아붙여야 한다.

배열/문자열

1.	배열 회전을 최소한의 공간으로 수행하는 방법은 무엇인가?

2.	주어진 문자열에서 가장 긴 회문(팰린드롬) 부분 문자열을 찾는 알고리즘을 구현할 수 있나요?

3.	두 개의 정렬된 배열을 추가적인 공간 없이 하나의 정렬된 배열로 병합하는 방법은 무엇인가?

반복문과 재귀함수

1.	팩토리얼을 반복문과 재귀로 각각 구현하고, 성능 차이를 비교할 수 있나요?

2.	하노이 탑 문제를 재귀로 해결하고, 그 과정에서 이동 순서를 출력할 수 있나요?

3.	재귀 호출을 반복문으로 변환할 때의 기준과 적용 사례는 무엇인가?

복잡도 (Big-O, 시간, 공간)

1.	O(n log n) 시간 복잡도를 갖는 알고리즘을 설계하고, 그 이유를 설명할 수 있나요?

2.	공간 복잡도를 O(1)로 유지하면서 중복 없는 가장 긴 부분 문자열을 찾을 수 있나요?

3.	최악의 경우 O(n²) 알고리즘을 O(n log n)으로 최적화할 수 있는 방법은 무엇인가?

정렬

1.	퀵 정렬과 병합 정렬의 차이를 설명하고, 각각의 최적 및 최악의 경우를 비교할 수 있나요?

2.	계수 정렬(Counting Sort)을 활용하여 중복된 숫자가 포함된 배열을 정렬할 수 있나요?

3.	힙 정렬을 구현하고, 그 과정에서 힙이 어떻게 유지되는지 설명할 수 있나요?

완전탐색

1.	백트래킹을 활용하여 N-Queen 문제를 해결할 수 있나요?

2.	모든 가능한 문자열 조합을 생성하는 알고리즘을 구현하고, 중복을 제거할 수 있나요?

3.	0-1 배낭 문제를 완전탐색으로 해결한 후, 동적 프로그래밍으로 최적화할 수 있나요?



## 오늘 퀴즈 복습

또 뭐 하실까요. 또? 퀴즈 복습합시다. 

일단 피보나치 반복문은 의외로 맞췄고, 재귀는 수열 구하는 문제가 생각해본 적이 없어서 잘 모르겠다. ‘수열’을 구해야 하는 문제에서 그냥 요소 값을 리턴하는 함수를 짜버렸다. 그냥 매개변수로 n을 주면 되지 않나? 그렇게도 구현할 수 있고, print를 차례로 찍도록 구현할 수도 있을거 같은데

```python

def fibo_recur(n):
    if n == 1: return 1
    if n == 0: return 1
    return fibo_recur(n-1) + fibo_recur(n-2)
    
```

# 이슈: 재귀 형식으로 피보나치 '수열’을 저장하는 법

## Phase1. 

### 환경: 파이썬

### 로그

[2, 3, 2, 5, 2, 3, 8, 2, 3, 2, 5, 13, 2, 3, 2, 5, 2, 3, 8, 21, 2, 3, 2, 5, 2, 3, 8, 2, 3, 2, 5, 13, 34, 2, 3, 2, 5, 2, 3, 8, 2, 3, 2, 5, 13, 2, 3, 2, 5, 2, 3, 8, 21, 55, 2, 3, 2, 5, 2, 3, 8, 2, 3, 2, 5, 13, 2, 3, 2, 5, 2, 3, 8, 21, 2, 3, 2, 5, 2, 3, 8, 2, 3, 2, 5, 13, 34, 89]

### 최근 변경 사항

```python

def fibo_recur(n):
    global a
    if n == 1:
        return 1
    if n == 0:
        return 1
    val = fibo_recur(n-1)  + fibo_recur(n-2)
    a.append(val)
    return val
```

## Phase2-1

### 확인

배열에 추가하는 타이밍과 리턴하는 타이밍을 잘 모르겠다. 

추가는 결국 피보나치 항이 완성된 시점에 해야 한다. 그런데 항을 완성하기 위해 재귀를 할 때 추가하게 된다. 

→ 플래그를 쓰면 해결될듯

### 시도

```python

a = []
# 
def fibo_recur(n):
    global a, flag
    if n == 1:
        return 1
    if n == 0:
        return 1
    val = fibo_recur(n-1)  + fibo_recur(n-2)
    if flag[n] == False:
        a.append(val)
        print(f'appending {val}')
        flag[n] == True
    return val
    
    
```

### 결과분석: 실패인줄 알았으나 오타 수정 후 해결

실패. 

```python
[2, 3, 2, 5, 2, 3, 8, 2, 3, 2, 5, 13, 2, 3, 2, 5, 2, 3, 8, 21, 2, 3, 2, 5, 2, 3, 8, 2, 3, 2, 5, 13, 34, 2, 3, 2, 5, 2, 3, 8, 2, 3, 2, 5, 13, 2, 3, 2, 5, 2, 3, 8, 21, 55, 2, 3, 2, 5, 2, 3, 8, 2, 3, 2, 5, 13, 2, 3, 2, 5, 2, 3, 8, 21, 2, 3, 2, 5, 2, 3, 8, 2, 3, 2, 5, 13, 34, 89]
```

결과 값이 완전히 같다. 왜지?  플래그가 의미가 없나? 중단점 찍으면서 플래그가 업데이트 되는 모습을 봐야겠다.

아 진짜 대입 연산자를 왜 짜꾸 쩌렇게 쓰세요! 오타 수정 후 바로 해결 됐음.

```python
[2, 3, 5, 8, 13, 21, 34, 55, 89]
```

1, 1이 나오지 않아서 수열의 앞 부분에서 1, 1로 시작하는 코드 추가

```python
def fibo_recur(n):
    global a, flag
    if n == 1 or n == 0:
        if flag[n] == False:
            a.append(1)
            flag[n] = True
        return 1
    val = fibo_recur(n-1)  + fibo_recur(n-2)
    if flag[n] == False:
        a.append(val)
        flag[n] = True
    return val
```

수열 전체를 출력하려니, 생각보다 재귀로는 작성해야 하는 코드가 많다. 원래 이랬던가?

> 재귀로 피보나치 수열을 저장하는 것은 가능하지만, 재귀의 특성상 중복 호출이 많아지고, 추가적인 관리 코드가 필요해지는 경우가 많습니다. 특히 중복된 계산을 피하기 위해 메모이제이션이 필수적이고, 리스트에 값을 저장하는 타이밍을 신경 써야 합니다.

메모이제이션을 활용할 줄 알긴 해야하는데…



