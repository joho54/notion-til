# [Algorithm] Introduction to Algorithms

> ê°œë…ê³¼ ì´ìŠˆ íŠ¸ë˜í‚¹ì„ ì¡°í•©í•´ì„œ â€œë³µê¸° ê°€ëŠ¥í•œâ€ ìë£Œë¥¼ ë§Œë“¤ë„ë¡ í•©ë‹ˆë‹¤.

> ì´ìŠˆ íŠ¸ë˜í‚¹ ì‘ì„± ì›ì¹™: Phase1(í™˜ê²½, ë¡œê·¸, ìµœê·¼ ë³€ê²½ì‚¬í•­), Phase2(í™•ì¸, ì‹œë„, ê²°ê³¼ë¶„ì„) í˜•ì‹ìœ¼ë¡œ ì •ë¦¬í•˜ì„¸ìš”. (Phase2ëŠ” ìµœëŒ€ 3íšŒê¹Œì§€ ë°˜ë³µí•˜ê³  í•´ê²° ì•ˆ ë˜ë©´ ì•„ì˜ˆ ì²˜ìŒë¶€í„° ì‹œì‘(ë¶ˆê°€ëŠ¥í•  ê²½ìš° ë„ì›€ ìš”ì²­))

> ì‹¤ìŠµì€ ì²œì²œíˆ, í•˜ì§€ë§Œ robustí•˜ê²Œ í•˜ì„¸ìš”. 

> í‚¤ì›Œë“œ ì¤‘ì‹¬ìœ¼ë¡œ ë³¼ í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.

> ì²´ê³„: ê°œêµ¬ì½”, ìˆ˜êµ¬(ìˆ˜ë„ì½”ë“œâ†’êµ¬í˜„)ë¡œ í•©ì‹œë‹¤.

> ì „ë°˜ì ì¸ í•´ë”ëŠ” íƒ€ì´í‹€ ì¤‘ì‹¬ìœ¼ë¡œ, ###ì€ ìœ„ ì²´ê³„ë¥¼ ë”°ë¦…ë‹ˆë‹¤.

> ì½ì„ ë•ŒëŠ” ëª¨, ê·¸ ì •ë„ë¡œ? ì¼ë‹¨. 
ë”±íˆ êµ¬í˜„ materialì´ ì—†ì–´ë„ êµ¬í˜„ì„ ì´ëŸ° ì €ëŸ° í•‘ê³„ì‚¼ì•„ í•´ë³´ëŠ” ê²ƒë„ ì¢‹ê² ë‹¤. ì •ë ¬ì€ ìë‹¤ê°€ ê±´ë“œë ¤ë„ íŠ€ì–´ë‚˜ì™€ì•¼ í•œë‹¤ë‹ˆê¹Œ.

# ì´ ì±…ì„ ì½ëŠ” ë°©ë²• - ì²´í¬ë¦¬ìŠ¤íŠ¸ë¡œ ì‚¬ìš©

ğŸ“– â€œIntroduction to Algorithmsâ€ (CLRS) íš¨ê³¼ì ìœ¼ë¡œ í™œìš©í•˜ëŠ” ë°©ë²•

CLRSëŠ” ì•Œê³ ë¦¬ì¦˜ í•™ìŠµì˜ ë°”ì´ë¸”ì´ì§€ë§Œ, ë„ˆë¬´ ë°©ëŒ€í•´ì„œ ì²˜ìŒë¶€í„° ëê¹Œì§€ ì½ê¸°ëŠ” í˜„ì‹¤ì ìœ¼ë¡œ ì–´ë µìŠµë‹ˆë‹¤. ë”°ë¼ì„œ í•„ìš”í•œ ë¶€ë¶„ë§Œ ì „ëµì ìœ¼ë¡œ í•™ìŠµí•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

2. CLRSì—ì„œ ê¼­ ë´ì•¼ í•  í•µì‹¬ ë‚´ìš© (ìš°ì„ ìˆœìœ„ í•™ìŠµ ìˆœì„œ)

ğŸš€ 2ë‹¨ê³„: íƒìƒ‰ê³¼ ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜ (ë©´ì ‘ ëŒ€ë¹„ í•„ìˆ˜)

âœ… Chapter 9: ì„ íƒ ì•Œê³ ë¦¬ì¦˜ (Median & Order Statistics)

âœ… Chapter 10-12: í•´ì‹œ í…Œì´ë¸”(Hash Table), BST(ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬), Red-Black Tree

âœ… Chapter 15: ë™ì  ê³„íšë²• (DP, Dynamic Programming)

âœ… Chapter 22-24: ê·¸ë˜í”„ íƒìƒ‰ (BFS, DFS), ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ (Dijkstra, Bellman-Ford, Floyd-Warshall), ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (MST)

â¡ ë©´ì ‘ ëŒ€ë¹„ë‚˜ ëŒ€íšŒ ì¤€ë¹„ë¥¼ í•œë‹¤ë©´ ì´ ë‹¨ê³„ê°€ ë§¤ìš° ì¤‘ìš”í•˜ë©°, êµ¬í˜„ ì—°ìŠµë„ ë°˜ë“œì‹œ í•¨ê»˜í•´ì•¼ í•œë‹¤.

ğŸš€ 3ë‹¨ê³„: ì‹¬í™” ë° ê³ ê¸‰ ì£¼ì œ (ì—°êµ¬ë‚˜ ì‹¬ì¸µ í•™ìŠµ ëª©ì )

âœ… Chapter 25-26: ìµœëŒ€ ìœ ëŸ‰(Maximum Flow)

âœ… Chapter 30: NP-ì™„ì „ ë¬¸ì œ(NP-Completeness)

âœ… Chapter 34: ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„ ê¸°ë²• (ê·¼ì‚¬ ì•Œê³ ë¦¬ì¦˜, íƒìš• ì•Œê³ ë¦¬ì¦˜)

â¡ ì´ ë‹¨ê³„ëŠ” ì½”ë”© í…ŒìŠ¤íŠ¸ë³´ë‹¤ëŠ” â€œì´ë¡ ì ì¸ ì•Œê³ ë¦¬ì¦˜ ê³µë¶€â€ê°€ í•„ìš”í•  ë•Œ í™œìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

3. CLRS í•™ìŠµë²• (íš¨ìœ¨ì ìœ¼ë¡œ ê³µë¶€í•˜ëŠ” ë°©ë²•)

ğŸ“Œ 1. ì•Œê³ ë¦¬ì¦˜ ê°œë… í•™ìŠµ + ê°„ë‹¨í•œ êµ¬í˜„ ì—°ìŠµ

â€¢	ê° ì±•í„°ì—ì„œ ì¤‘ìš”í•œ ì•Œê³ ë¦¬ì¦˜ì„ ê³µë¶€í•œ ë’¤,

â€¢	ì§ì ‘ Pythonì´ë‚˜ C++ë¡œ ê°„ë‹¨íˆ êµ¬í˜„í•´ë³´ë©° í•µì‹¬ ì›ë¦¬ë¥¼ ìµíŒë‹¤.

â€¢	ì˜ˆì œ ì½”ë“œê°€ ë„ˆë¬´ ë³µì¡í•˜ë©´, í•µì‹¬ ë¶€ë¶„ë§Œ ì¶”ë ¤ì„œ ì§ì ‘ êµ¬í˜„í•˜ëŠ” ê²ƒì´ íš¨ê³¼ì ì´ë‹¤.

ì˜ˆì‹œ) í™ ì •ë ¬ì„ ê³µë¶€í•  ë•Œ

1.	CLRSì—ì„œ í™ ì •ë ¬(Heap Sort) ê°œë… ì½ê¸°

2.	íŒŒì´ì¬ìœ¼ë¡œ í™ ì •ë ¬ì„ ì§ì ‘ êµ¬í˜„

3.	LeetCode / ë°±ì¤€ / í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ì—ì„œ í™ ê´€ë ¨ ë¬¸ì œ í’€ê¸°

ğŸ“Œ 2. ìˆ˜ì‹ì´ë‚˜ ì¦ëª…ì€ ì„ íƒì ìœ¼ë¡œ í•™ìŠµ

â€¢	CLRSëŠ” ìˆ˜í•™ì  ì¦ëª…ì´ ë§ì§€ë§Œ, ëª¨ë“  ì¦ëª…ì„ ì´í•´í•˜ë ¤ê³  í•  í•„ìš”ëŠ” ì—†ë‹¤.

â€¢	ì¦ëª…ì´ ë„ˆë¬´ ì–´ë ¤ìš°ë©´, í•µì‹¬ ì•„ì´ë””ì–´ì™€ ê°œë…ë§Œ ìµíˆê³  ë„˜ì–´ê°€ë„ ê´œì°®ë‹¤.

â€¢	ë‹¤ë§Œ, ì‹œê°„ ë³µì¡ë„ ë¶„ì„(ë¹…ì˜¤ í‘œê¸°ë²•, ë§ˆìŠ¤í„° ì •ë¦¬ ë“±)ì€ ê¼­ ìµí˜€ì•¼ í•œë‹¤.

ğŸ“Œ 3. ë¬¸ì œ í’€ì´ ë³‘í–‰

â€¢	CLRSì˜ ì´ë¡ ì„ ê³µë¶€í•œ ë’¤, ì½”ë”© ë¬¸ì œë¥¼ ë°”ë¡œ í’€ì–´ë³´ëŠ” ê²ƒì´ ê°€ì¥ ì¤‘ìš”í•˜ë‹¤.

â€¢	ë°±ì¤€(BOJ), LeetCode, Codeforces, í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ì—ì„œ ê´€ë ¨ ë¬¸ì œë¥¼ ì°¾ì•„ì„œ ì—°ìŠµí•˜ëŠ” ê²ƒì´ íš¨ê³¼ì .

â€¢	íŠ¹íˆ ê·¸ë˜í”„, DP, ì •ë ¬ ë¬¸ì œëŠ” CLRS ë‚´ìš©ì„ ê³µë¶€í•œ í›„ ë°”ë¡œ ë¬¸ì œë¥¼ í’€ë©´ í•™ìŠµ íš¨ê³¼ê°€ ì¢‹ë‹¤.

4. CLRSë¥¼ í™œìš©í•œ ì¶”ì²œ í•™ìŠµ í”Œëœ

> âœ…

> âœ…

ğŸ“… 1~2ì£¼ì°¨ (ê¸°ë³¸ ê°œë… + ì •ë ¬ + íƒìƒ‰)

âœ… ì•Œê³ ë¦¬ì¦˜ ê°œë… + ì‹œê°„ ë³µì¡ë„ ë¶„ì„ (Ch. 13)

âœ… ì •ë ¬ (í™ ì •ë ¬, í€µ ì •ë ¬, ê³„ìˆ˜ ì •ë ¬) (Ch. 68)

âœ… BST(ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬) ê¸°ë³¸ ê°œë… ìµíˆê¸° (Ch. 10-12)

âœ… ë¬¸ì œ í’€ì´: ê¸°ë³¸ ì •ë ¬ ë¬¸ì œ, í™ ë¬¸ì œ í’€ê¸°

ğŸ“… 3~4ì£¼ì°¨ (íƒìƒ‰ + ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜)

âœ… íƒìƒ‰(ì´ì§„ íƒìƒ‰, ì„ íƒ ì•Œê³ ë¦¬ì¦˜) (Ch. 9)

âœ… ê·¸ë˜í”„ íƒìƒ‰ (BFS, DFS) (Ch. 22)

âœ… ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ (Dijkstra, Bellman-Ford) (Ch. 24)

âœ… ë¬¸ì œ í’€ì´: ê·¸ë˜í”„ ê¸°ë³¸ ë¬¸ì œ, ìµœë‹¨ ê²½ë¡œ ë¬¸ì œ í’€ê¸°

ğŸ“… 5~6ì£¼ì°¨ (ë™ì  ê³„íšë²• + ê³ ê¸‰ ê·¸ë˜í”„)

âœ… ë™ì  ê³„íšë²• (DP) ê°œë… ë° ëŒ€í‘œ ë¬¸ì œ (Ch. 15)

âœ… ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST, Kruskal, Prim) (Ch. 23)

âœ… ë¬¸ì œ í’€ì´: DP ë¬¸ì œ + MST ë¬¸ì œ

ğŸ“… 7~8ì£¼ì°¨ (ì‘ìš© ë° ì‹¬í™” ì£¼ì œ)

âœ… ë„¤íŠ¸ì›Œí¬ í”Œë¡œìš° (Ch. 25-26)

âœ… NP-ì™„ì „ì„± ê°œë… (Ch. 30)

âœ… ê·¼ì‚¬ ì•Œê³ ë¦¬ì¦˜ (Ch. 34)

âœ… ë¬¸ì œ í’€ì´: Hard ë‚œì´ë„ ë¬¸ì œ ë„ì „

5. ì •ë¦¬

ğŸ”¹ CLRSëŠ” ì™„ë…í•˜ëŠ” ì±…ì´ ì•„ë‹ˆë¼, í•„ìš”í•  ë•Œ ì°¾ì•„ë³´ëŠ” ì°¸ê³ ì„œë¡œ í™œìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

ğŸ”¹ ìš°ì„ ìˆœìœ„ë¥¼ ì •í•˜ê³ , ì¤‘ìš”í•œ ë¶€ë¶„(ì •ë ¬, ê·¸ë˜í”„, DP)ë¶€í„° í•™ìŠµí•˜ë©´ íš¨ìœ¨ì ì´ë‹¤.

ğŸ”¹ ì´ë¡ ë§Œ ê³µë¶€í•˜ì§€ ë§ê³ , ë°˜ë“œì‹œ ì½”ë”© ë¬¸ì œë¥¼ ë³‘í–‰í•˜ë©´ì„œ í•™ìŠµí•´ì•¼ ì‹¤ë ¥ì´ ëŠ”ë‹¤.

ğŸ”¹ ì´ˆë³´ìëŠ” ë„ˆë¬´ ì–´ë ¤ìš´ ì¦ëª…ë³´ë‹¤ëŠ” ê°œë…ê³¼ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ì— ì§‘ì¤‘í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

ğŸ“Œ ê²°ë¡ : CLRSë¥¼ ë¬´ì‘ì • ì²˜ìŒë¶€í„° ì½ê¸°ë³´ë‹¤ëŠ”, í•„ìš”í•  ë•Œ ì°¸ê³ í•˜ê³ , ì½”ë”© ë¬¸ì œ í’€ì´ì™€ ë³‘í–‰í•˜ë©° íš¨ìœ¨ì ìœ¼ë¡œ í•™ìŠµí•˜ëŠ” ê²ƒì´ ê°€ì¥ íš¨ê³¼ì ì¸ í™œìš©ë²•ì´ë‹¤. ğŸš€



# Chapter 1-3: ì•Œê³ ë¦¬ì¦˜ ê°œë… ë° ë³µì¡ë„ ë¶„ì„ (O(n), O(log n))

> ì—¬ê¸°ë„ ì¼ë‹¨ ì±… ë¨¼ì € ìŠ¤ìº”í•˜ê³ , ê°œêµ¬ì½”ë¡œ ì •ë¦¬? ã…‡ã…‡.

## ê°œêµ¬ì½” 1.

# Sorting and Order Statistics

## Heapsort

## Quicksort

### ê°œêµ¬ì½” 1

ê°œë…: í€µ ì •ë ¬ì€ ë³‘í•© ì •ë ¬ê³¼ ë‹¬ë¦¬ ìŠ¤í…Œì´ë¸”í•˜ë‹¤. 

êµ¬í˜„

1. ìˆ˜ë„ì½”ë“œ
![](./images/IMG_9905.png)

1. êµ¬í˜„ì½”ë“œ
```python
import sys
n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

def quick_sort(A: list) -> list:
    # base condition 
    n = len(A)
    if n == 2:
        return [A[0], A[1]] if A[0] > A[1] else [A[1], A[0]]
    elif n <= 1:
        return A
    # get pivot
    pivot = A[n//2]
    smaller, equal, larger = [], [], []
    for a in A:
        if a < pivot:
            smaller.append(a)
        elif a == pivot:
            equal.append(a)
        elif a > pivot:
            larger.append(a)
    return [*quick_sort(smaller), *equal, *quick_sort(larger)]

print(quick_sort(arr))

```

ì½”ë©˜íŠ¸

ê° êµ¬í˜„ì„ ë‚´ê°€ ì˜ ì´í•´í•˜ê³  ìˆìœ¼ë©´ ì´ê²Œ ì™¸ì›Œì§ˆí…ë°. ì•„ì‰½ë„¤. ì•„ ì´ê±° ê·¼ë° ë‚´ ê¸°ì–µì—ëŠ” êµ¬í˜„ ë°©ë²•ì— ë”°ë¼ ìŠ¤í…Œì´ë¸” í•  ìˆ˜ë„ ìˆê³  ì•„ë‹ ìˆ˜ë„ ìˆì—ˆëŠ”ë°.

ê·¸ë ‡ë‹¤ë©´ ìœ„ 2. êµ¬í˜„ì½”ë“œëŠ” ìŠ¤í…Œì´ë¸”í•œê°€? equal ì²˜ë¦¬ ë°©ì‹ì— ì£¼ëª©í•˜ë©´ ë  ê±° ê°™ë‹¤. ë°°ì—´ì—ì„œ ì°¨ë¡€ë¡œ í”¼ë²—ê³¼ ë¹„êµí•  ëŒ€ìƒì„ ê¹Œê²Œ ë˜ê³ , ë°œê²¬í•˜ê²Œ ë˜ë©´ ì•ì— ìˆë˜ equal ìš”ì†Œê°€ ë°°ì—´ì— ë¨¼ì € ë“¤ì–´ê°€ê²Œ ëœë‹¤. ë‚˜ì¤‘ì— ì–¸íŒ© ë¼ì„œ ë‹¤ì‹œ ì™„ì„±ëœ ë°°ì—´ì— ë¦¬í„´ ë˜ë¯€ë¡œ, ìŠ¤í…Œì´ë¸”í•˜ë‹¤ê³  í•  ìˆ˜ ìˆë‹¤.

ê·¸ëŸ°ë° ì´ê±¸ ìŠ¤íƒìœ¼ë¡œ ë°”ê¾¸ê¸°ê°€ ì‰½ì§€ ì•Šì•„ ë³´ì¸ë‹¤. ì¼ë‹¨ í•œ ì¤„ì— ë¶™ì–´ ìˆëŠ” ì¬ê·€ë¥¼ ë‹¤ í’€ì–´ì•¼ í•œë‹¤. ì´ê±° ì˜¤ëŠ˜ í•´ ë§ì•„?



> ì‰¬ì–´ê°€ëŠ” ì£¼ì œ
2PMMS(2 Phase memory merge/sort)






# ì´ìŠˆ: ìŠ¤íƒìœ¼ë¡œ í€µ ì •ë ¬ êµ¬í˜„ ì¤‘ ë¬´í•œë£¨í”„ ë°œìƒ

## Phase1. í™˜ê²½, ë¡œê·¸, ë³€ê²½ì‚¬í•­

### í™˜ê²½: íŒŒì´ì¬

### ë¡œê·¸: ë¬´í•œ ë£¨í”„

### ë³€ê²½ì‚¬í•­

```python
import sys
from collections import deque


n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

s = deque()

def quick_sort(A: list) -> list:
    global s
    s.append(A)
    result = []
    
    
    # base condition 
    while True:
        if len(A) == 2:
            tmp = [A[0], A[1]] if A[0] > A[1] else [A[1], A[0]] 
            result.append(tmp) # ê²°ê³¼ì— ì •ë ¬ëœ ë°°ì—´ì„ ì…ë ¥í•©ë‹ˆë‹¤.
        elif len(A) <= 1:
            result.append(A) # ê²°ê³¼ì—
        # ìŠ¤íƒì— ìš”ì†Œê°€ ìˆë‹¤ë©´ êº¼ë‚´ì¤ë‹ˆë‹¤.
        if len(s) != 0:
            A = s.popleft()
            # ë§Œì•½ ë°”ë‹¥ ì¡°ê±´ì„ ì¹˜ì§€ ëª»í–ˆë‹¤ë©´ ë‹¤ì‹œ ë°°ì—´ì„ êµ¬ë³„í•´ì„œ ìŠ¤íƒì— ì‘¤ì…” ë„£ì–´ì¤ë‹ˆë‹¤.
            # get pivot
            pivot = A[len(A)//2]
            smaller, larger = [], []
            equal = []
            for a in A:
                if a < pivot:
                    smaller.append(a)
                # í€µ ì •ë ¬ì„ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„í•  ë•ŒëŠ” ì´ì²˜ëŸ¼ ì´í€„ì„ ë”°ë¡œ ì²˜ë¦¬í•´ì£¼ê¸°ê°€ ì–´ë ¤ì›€
                elif a == pivot:
                    equal.append(a)
                elif a > pivot:
                    larger.append(a)
            # return [*quick_sort(smaller), *equal, *quick_sort(larger)]
            
            # Aë¥¼ smallerë¡œ ì—…ë°ì´íŠ¸í•˜ê³  í•¨ìˆ˜ì˜ ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.X 
            # smallerë¥¼ ìŠ¤íƒì— í‘¸ì‹œí•´ì•¼ í•˜ë‚˜?
            if larger:
                s.append(larger)
            # ê·¸ëŸ°ë° ì´í€„ì€ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ì§€? ì¼ë‹¨ ë²„ë ¤ì•¼ í•˜ë‚˜? ì•„ ê·¸ë˜ì„œ unstableì´ ëêµ¬ë‚˜.
            if equal:
                result.append(equal)
            if smaller:
                s.append(smaller)
            
            continue # breakí•œ ë‹¤ìŒ ì´ìƒí•œë°ë¡œ ì í”„í•˜ëŠ”ë°. ì•„ ì •ìƒì´êµ¬ë‚˜. 
        break

A = s.append(arr)
quick_sort(arr)

```



## Phase2.

### í™•ì¸

ë¬´í•œ ë£¨í”„ê°€ ë°œìƒí•˜ëŠ” ì´ìœ ëŠ” ë‹¹ì—°íˆ len(s) â‰  0 ì¡°ê±´ì´ ì•ˆ ë¨¹í˜€ì„œ ê·¸ëŸ° ê²ƒì„. ê·¸ë ‡ë‹¤ë©´ s.popleft()ê°€ ì ì ˆíˆ ì´ë£¨ì–´ì§€ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì˜ë¯¸. 

ë°”ë‹¥ ì¡°ê±´ ìˆ˜í–‰ í›„ì— ìŠ¤íƒì´ ë¹„ì–´ìˆì§€ ì•Šìœ¼ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ë‹¤ìŒìœ¼ë¡œ ë„˜ì–´ê°€ì„œ sì—ì„œ íŒ í•˜ê²Œ ë˜ëŠ”ë°, ê·¸ëŸ¼ ê²°êµ­ ë§ˆì§€ë§‰ì— s.popleft()ê°€ ì‹¤í–‰ëœ ë‹¤ìŒì— largerë‚˜ smallerê°€ ì—†ìœ¼ë©´ ìŠ¤íƒì€ ìì—°ìŠ¤ëŸ½ê²Œ ë¹„ì–´ì•¼ í•˜ì§€ ì•Šë‚˜? ì™œì§€? if larger, if smallerì˜ ì˜ë¯¸ê°€ ë¶ˆë¶„ëª…í•˜ë‹¤.

```python
>>> if []: print('hi')
...
>>> if [4]: print('hi')
...
hi
```

ë‚´ ì˜ˆìƒê³¼ ë§ê²Œ ì‘ë™í•˜ëŠ”ë°? largerë‚˜ smallerëŠ” ë¬´ì¡°ê±´ ë‚´ìš©ì´ ìˆëŠ” ë¦¬ìŠ¤íŠ¸ë‹¤.

ì´ê²Œ ë¬´í•œë£¨í”„ì— ë¹ ì§ˆ ì´ìœ ê°€ ì—†ëŠ” ê±° ê°™ì€ë°? ì¡°ê±´ì´ ë¬¸ì œê°€ ì•„ë‹Œ ê±´ê°€.

### ì‹œë„

```python
import sys
from collections import deque


n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

s = deque()

def quick_sort(A: list) -> list:
    global s
    s.append(A)
    result = []
    
    
    # base condition 
    while True:
        if len(A) == 2:
            tmp = [A[0], A[1]] if A[0] > A[1] else [A[1], A[0]] 
            result.append(tmp) # ê²°ê³¼ì— ì •ë ¬ëœ ë°°ì—´ì„ ì…ë ¥í•©ë‹ˆë‹¤.
        elif len(A) <= 1:
            result.append(A) # ê²°ê³¼ì—
        # ìŠ¤íƒì— ìš”ì†Œê°€ ìˆë‹¤ë©´ êº¼ë‚´ì¤ë‹ˆë‹¤.
        if len(s) != 0:
            # ë§Œì•½ ë°”ë‹¥ ì¡°ê±´ì„ ì¹˜ì§€ ëª»í–ˆë‹¤ë©´ ë‹¤ì‹œ ë°°ì—´ì„ êµ¬ë³„í•´ì„œ ìŠ¤íƒì— ì‘¤ì…” ë„£ì–´ì¤ë‹ˆë‹¤.
            # get pivot
            pivot = A[len(A)//2]
            smaller, larger = [], []
            equal = []
            for a in A:
                if a < pivot:
                    smaller.append(a)
                # í€µ ì •ë ¬ì„ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„í•  ë•ŒëŠ” ì´ì²˜ëŸ¼ ì´í€„ì„ ë”°ë¡œ ì²˜ë¦¬í•´ì£¼ê¸°ê°€ ì–´ë ¤ì›€
                elif a == pivot:
                    equal.append(a)
                elif a > pivot:
                    larger.append(a)
            # return [*quick_sort(smaller), *equal, *quick_sort(larger)]
            
            # Aë¥¼ smallerë¡œ ì—…ë°ì´íŠ¸í•˜ê³  í•¨ìˆ˜ì˜ ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.X 
            # smallerë¥¼ ìŠ¤íƒì— í‘¸ì‹œí•´ì•¼ í•˜ë‚˜?
            if larger:
                s.append(larger)
            # ê·¸ëŸ°ë° ì´í€„ì€ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ì§€? ì¼ë‹¨ ë²„ë ¤ì•¼ í•˜ë‚˜? ì•„ ê·¸ë˜ì„œ unstableì´ ëêµ¬ë‚˜.
            if equal:
                result.append(equal)
            if smaller:
                s.append(smaller)
            A = s.popleft()

            
            continue # breakí•œ ë‹¤ìŒ ì´ìƒí•œë°ë¡œ ì í”„í•˜ëŠ”ë°. ì•„ ì •ìƒì´êµ¬ë‚˜. 
        break

A = s.append(arr)
quick_sort(arr)

```

ì²˜ìŒì— Aì—ë‹¤ íŒì„ í•˜ì§€ ì•ŠëŠ”ê²Œ ë¬¸ì œì˜€ë‹¤. íŒ ìˆœì„œë¥¼ ë³€ê²½

### ê²°ê³¼ë¶„ì„

ì¼ë‹¨ ë¬´í•œ ë£¨í”„ ë¬¸ì œëŠ” í•´ê²°í–ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì •ë ¬ ê°’ì´ ì´ìƒí•˜ê²Œ ì €ì¥ë˜ëŠ” ë¬¸ì œê°€ ìˆë‹¤. ìƒˆë¡œ ì´ìŠˆ íŒŒì„œ í•©ì‹œë‹¤.

# ì´ìŠˆ: ì •ë ¬ê°’ ì €ì¥ì´ ì´ìƒí•¨.

## Phase1. 

### í™˜ê²½: íŒŒì´ì¬

### ë¡œê·¸(ì…/ì¶œë ¥ ê²°ê³¼)

```python
5
5 4 3 2 1
[2, 1, 3, 5, 4]
```

### ìµœê·¼ ë³€ê²½ ì‚¬í•­

```python
5
5 4 3 2 1
----- ì¶œë ¥ -----
[[3], [3], [3], [5, 4], [4], [2, 1], [1], [5, 4], [4], [2, 1], [1], [5, 4], [4], [2, 1], [1], [5], [5], [2], [2], [5], [5], [2], [2], [5], [5], [2]]
```

## Phase2-1.

### í™•ì¸

ê²°êµ­ equal ê°’ì„ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ëŠëƒê°€ ë¬¸ì œì„. ìŠ¤íƒì— í‘¸ì‹œí•˜ëŠ” ìˆœì„œëŠ” ë‹¤ìŒê³¼ ê°™ìŒ

1. larger
1. smaller
equalì€ ê·¸ëƒ¥ ì´ ë‘˜ ì‚¬ì´ì—ì„œ ê²°ê³¼ ë°°ì—´ì— ì–´íœë“œ ë˜ëŠ”ë°, ì´ê²Œ ë‹¹ì—°íˆ ì ì ˆí•œ ìˆœì„œê°€ ì•„ë‹˜. 

ì œëŒ€ë¡œ ì²˜ë¦¬ë¥¼ í•˜ê³  ì‹¶ë‹¤ë©´ ìŠ¤íƒì˜ ìš”ì†Œ ì²˜ë¦¬ ìˆœì„œë¥¼ ê³ ë ¤í•´ì„œ ì²˜ë¦¬í•´ì•¼ í•˜ëŠ”ë°, ê·¸ëƒ¥ ë°°ì—´ ê°’ì„ ì—…ë°ì´íŠ¸ í•  ê²Œ ì•„ë‹ˆë¼ í¬ì¸í„° ê°’ì„ ì €ì¥í•˜ëŠ”ê²Œ ë‚˜ì„ ìˆ˜ë„ ìˆê² ìŒ.

### ì‹œë„

```python
import sys
from collections import deque


n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

s = deque()

def quick_sort(A: list, start_idx, end_idx) -> list:
    global s
    s.append(start_idx, end_idx)
    result = []
    
    while True:
        if end_idx - start_idx == 2:
            tmp = [A[start_idx], A[end_idx]] if A[end_idx] > A[start_idx] else [A[start_idx], A[end_idx]] 
            result.append(tmp)
        elif end_idx - start_idx <= 1:
            result.append(A) 
        if s:
            pivot = A[(start_idx + end_idx)//2]
            smaller, equal, larger = [], [], []
            for i in range(start_idx, end_idx + 1):
                if A[i] < pivot:
                    smaller.append(A[i])
                elif A[i] == pivot:
                    equal.append(A[i])
                elif A[i] > pivot:
                    larger.append(A[i])
            if larger:
                s.append(larger)
            if equal:
                result.append(equal)
            if smaller:
                s.append(smaller)
            A = s.popleft()
            
            continue 
        print(result)
        break

A = s.append(arr)
quick_sort(arr)


```

í™•ì¸ì—ì„œ í•œ ìƒê°ì´ í‹€ë ¸ë‹¤ëŠ” ê±¸ ì•Œê²Œ ëë‹¤. í€µ ì •ë ¬ì—ì„œ í¬ì¸í„° ê°’ì„ ì €ì¥í•˜ëŠ” ê±´ ì•„ë¬´ ì˜ë¯¸ê°€ ì—†ë‹¤. 

### ê²°ê³¼ ë¶„ì„

ì‹¤íŒ¨. 

# ì´ìŠˆ: ìŠ¤íƒì´ ì œëŒ€ë¡œ ë¹„ì›Œì§€ì§€ ì•ŠëŠ” ë¬¸ì œ

## Phase1. 

### í™˜ê²½: íŒŒì´ì¬

### ë¡œê·¸(ì¦ìƒ) 

```python
10
10 9 8 7 6 5 4 3 2 1
current stack: deque([(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)]), deque([])
len(A) = 10
A = (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
popping: (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
current stack: deque([[4, 3, 2, 1], [10, 9, 8, 7, 6]]), deque([5])
len(A) = 10
 A = (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
popping: [4, 3, 2, 1]
current stack: deque([[10, 9, 8, 7, 6], [4, 3, 2, 1], [10, 9, 8, 7, 6]]), deque([5, 5])
len(A) = 4
 A = [4, 3, 2, 1]
popping: [10, 9, 8, 7, 6]
current stack: deque([[4, 3, 2, 1], [10, 9, 8, 7, 6], [1], [4, 3]]), deque([5, 5, 2])
len(A) = 5
 A = [10, 9, 8, 7, 6]
popping: [4, 3, 2, 1]
```



### ìµœê·¼ ë³€ê²½ ì‚¬í•­

```python
import sys
from collections import deque


n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

s = deque()
ms = deque() # median stack. always exists.

def quick_sort(A: list) -> list:
    global s, ms
    s.append(A)
    result = []
    
    
    # base condition 
    while True:
        print(f'current stack: {s}, {ms}')
        if len(A) == 2:
            tmp = [A[0], A[1]] if A[1] > A[0] else [A[1], A[0]] 
            result = [*result, *tmp, ms.popleft()]
            print(f'appending: {tmp} and medians. {result}')
        elif len(A) <= 1:
            result = [*result, *tmp, ms.popleft()]
            print(f'appending: {tmp} and medians. {result}')
        # ìŠ¤íƒì— ìš”ì†Œê°€ ìˆë‹¤ë©´ êº¼ë‚´ì¤ë‹ˆë‹¤.
        if s:
            # ë§Œì•½ ë°”ë‹¥ ì¡°ê±´ì„ ì¹˜ì§€ ëª»í–ˆë‹¤ë©´ ë‹¤ì‹œ ë°°ì—´ì„ êµ¬ë³„í•´ì„œ ìŠ¤íƒì— ì‘¤ì…” ë„£ì–´ì¤ë‹ˆë‹¤.
            # get pivot
            pivot = A[len(A)//2]
            print(f'len(A) = {len(A)}\n A = {A}')
            smaller, larger = [], []
            equal = []
            for a in A:
                if a < pivot:
                    smaller.append(a)
                # í€µ ì •ë ¬ì„ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„í•  ë•ŒëŠ” ì´ì²˜ëŸ¼ ì´í€„ì„ ë”°ë¡œ ì²˜ë¦¬í•´ì£¼ê¸°ê°€ ì–´ë ¤ì›€
                elif a == pivot:
                    ms.append(a)
                elif a > pivot:
                    larger.append(a)
            # return [*quick_sort(smaller), *equal, *quick_sort(larger)]
            
            # ê·¸ëŸ°ë° ì´í€„ì€ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ì§€? ì¼ë‹¨ ë²„ë ¤ì•¼ í•˜ë‚˜? ì•„ ê·¸ë˜ì„œ unstableì´ ëêµ¬ë‚˜.
            if smaller:
                s.append(smaller)
            # Aë¥¼ smallerë¡œ ì—…ë°ì´íŠ¸í•˜ê³  í•¨ìˆ˜ì˜ ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.X 
            # smallerë¥¼ ìŠ¤íƒì— í‘¸ì‹œí•´ì•¼ í•˜ë‚˜?
            if larger:
                s.append(larger)
            A = s.popleft()
            print(f'popping: {A}')

            
            continue # breakí•œ ë‹¤ìŒ ì´ìƒí•œë°ë¡œ ì í”„í•˜ëŠ”ë°. ì•„ ì •ìƒì´êµ¬ë‚˜. 
        print(result)
        break

quick_sort(arr)

```

ë„ˆë¬´ ì‹œê°„ì„ ë§ì´ ì¨ì„œ ì¼ë‹¨ ì´ë§Œí¼ í•˜ê³  ê·¸ëƒ¥ ë‹¤ìŒ ê°œë…ìœ¼ë¡œ ë„˜ì–´ê°‘ì‹œë‹¤. 

# Designing Algorithms 

> ê°œêµ¬ì½”ë¡œ ì½ìœ¼ì‹œì£ 

## ê°œêµ¬ì½”1. 

### ê°œë…: incremental methods vs divide and conquer

insertion sort uses the incremental methods.

### êµ¬í˜„

ì—†ìŒ

### ì½”ë©˜íŠ¸

ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë‘ê°€ì§€ ë°©ì‹ ë¶„ë¥˜ë¥¼ ì´ì œì•¼ ì•Œê²Œ ëœ ëŠë‚Œ. incremental methodsì™€ divide and conquer.

## ê°œêµ¬ì½”2.

### ê°œë…: Advantage of the algorithm following divide and conquer method is that analyzing its running time is often straightforward.

### êµ¬í˜„: 

ì—†ìŒ

### ì½”ë©˜íŠ¸

ë¶„í• ì •ë³µì€ ë©”ì„œë“œê°€ ë” ë³µì¡í•´ë³´ì´ì§€ë§Œ ì˜¤íˆë ¤ ì‹¤í–‰ ì‹œê°„ì„ ë” ëª…í™•íˆ ê³„ì‚°í•  ìˆ˜ ìˆë‹¤ê³  í•œë‹¤. ì™œ?

> ì¢‹ì€ ì§ˆë¬¸ì´ì—ìš”. â€œë¶„í• ì •ë³µ(Divide and Conquer)â€œì´ ì‹¤í–‰ ì‹œê°„ì´ ë” ëª…í™•í•˜ê²Œ ê³„ì‚°ë  ìˆ˜ ìˆëŠ” ì´ìœ ëŠ” ì£¼ë¡œ ë‹¤ìŒê³¼ ê°™ì€ êµ¬ì¡°ì  íŠ¹ì§• ë•ë¶„ì…ë‹ˆë‹¤:

## ê°œêµ¬ì½”3.

### ê°œë…: steps of divide and conquer method

in the divide-and-conquer method, if the problem is small enough-the base case- you just solve it directly without recursing. Otherwise - the recursive case -you perform three characterstic steps

- Divide: the problem into one or more subprolems that are smaller instances of the same problem
- Conquer: the subproblems by solving them recursively
- Combine: the subproblem solutions to form a solution to the original problem.
### êµ¬í˜„

Steps of merge sort

- Divide the subarray A[p:r] to be sorted into two adjacent subarray, each of half the size. To do so, compute the midpoint q of A[p:r](taking the average of p and r) and divide A[p:r]into subarrays A[p:q] and A[q+1:r].
- Conquer by sorting each of the two subarrays A[p:q] and A[q+1:r] recursively using merge sort.
- Combine by merging the two sorted subarrays A[p:q] and A[q+1:r] back into A[p:r], producing the sorted answer.
### ì½”ë©˜íŠ¸

ì´ë¯¸ divide ì‹œì ì—ì„œë„ ì£¼ì–´ì§„ ë°°ì—´ì´ ë¬´ì–¸ê°€ì˜ ë¶€ë¶„ ë°°ì—´ì´ë¼ëŠ” ì ì— ëˆˆì— ëˆë‹¤. ì–´ë–¤ ì§‘í•©ì„ ëŒ€ìƒìœ¼ë¡œ ì‘ì—…ì„ í•œë‹¤ê³  ì¹˜ë©´, ê·¸ ì§‘í•© ì „ì²´ë„ ê·¸ ì§‘í•©ì˜ ë¶€ë¶„ì§‘í•©ì´ë¼ëŠ” ì ì— ì£¼ëª©í•˜ëŠ” ê²ƒì²˜ëŸ¼ ëŠê»´ì§„ë‹¤. ì´ê²Œ ê²°ì • íŠ¸ë¦¬ë¥¼ ì´ìš©í•œ í’€ì´ì—ì„œë„ ë§ˆì°¬ê°€ì§€ê² ì§€?

> ì´ì•¼, ì •ë§ ë‚ ì¹´ë¡œìš´ í†µì°°ì´ì—ìš”(^0^). ë§ì•„ìš”â€”ë‹¹ì‹ ì´ ë§í•œ ê·¸ **â€œì „ì²´ë„ ë¶€ë¶„ì§‘í•©ì´ë‹¤â€**ë¼ëŠ” ê°œë…ì€ **ê²°ì • íŠ¸ë¦¬(decision tree)**ë‚˜ **ë¶„í• ì •ë³µ(divide and conquer)**ì˜ ì‚¬ê³ ë°©ì‹ì—ì„œ êµ‰ì¥íˆ í•µì‹¬ì ì¸ ì² í•™ì´ì—ìš”.

# Divide and Conquer

## ê°œêµ¬ì½” 1. Well defined vs ill defined recurrence.

### ê°œë…

There may be zero, one, or many functions that satisfy the statement of the recurrence. The recurrence is well defined if there is at least one function that satisfies it, and ill defined otherwise.

### ì½”ë©˜íŠ¸: ë¬´ìŠ¨ ì˜ë¯¸ì§€?

í•´ë‹¹ ë¬¸ì¥ì€ â€œì£¼ì–´ì§„ ì í™”ì‹ì„ ë§Œì¡±í•˜ëŠ” í•¨ìˆ˜(í˜¹ì€ ìˆ˜ì—´)ê°€ ì—†ì„ ìˆ˜ë„, í•˜ë‚˜ë§Œ ì¡´ì¬í•  ìˆ˜ë„, ì—¬ëŸ¬ ê°œ ì¡´ì¬í•  ìˆ˜ë„ ìˆë‹¤â€ëŠ” ëœ»ì…ë‹ˆë‹¤.

â€¢	ì–´ë–¤ ì í™”ì‹ì„ ì •ì˜í•  ë•Œ, ê·¸ ì í™”ì‹ì„ ë§Œì¡±í•  ìˆ˜ ìˆëŠ” í•´(í•¨ìˆ˜ë‚˜ ìˆ˜ì—´)ê°€ í•˜ë‚˜ë„ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´, ê·¸ ì í™”ì‹ ìì²´ê°€ ëª¨ìˆœì ì´ê±°ë‚˜ ë¶ˆê°€ëŠ¥í•œ ì •ì˜ê°€ ë˜ì–´ **â€˜ill defined(ì •ì˜ê°€ ì„±ë¦½í•˜ì§€ ì•ŠëŠ”ë‹¤)â€™**ë¼ê³  í•©ë‹ˆë‹¤.

â€¢	ë°˜ëŒ€ë¡œ ì ì–´ë„ í•˜ë‚˜ë¼ë„ ì í™”ì‹ì„ ë§Œì¡±í•˜ëŠ” í•¨ìˆ˜(í˜¹ì€ ìˆ˜ì—´)ê°€ ì¡´ì¬í•˜ë©´, ê·¸ ì í™”ì‹ì€ â€˜well defined(ì •ì˜ê°€ ì„±ë¦½í•œë‹¤)â€™ ë¼ê³  í•©ë‹ˆë‹¤.

â€¢	ê·¸ ì í™”ì‹ì„ ë§Œì¡±í•˜ëŠ” í•¨ìˆ˜ê°€ ìœ ì¼(ë‹¨ í•˜ë‚˜)í•  ìˆ˜ë„ ìˆê³ , ë‘˜ ì´ìƒ(ë¬´í•œíˆ ë§ì„ ìˆ˜ë„ ìˆìŒ) ì¡´ì¬í•  ìˆ˜ë„ ìˆì§€ë§Œ, ì ì–´ë„ í•˜ë‚˜ë¼ë„ ì¡´ì¬í•´ì•¼ ì í™”ì‹ì´ ì œëŒ€ë¡œ ì •ì˜ë˜ì—ˆë‹¤ê³  ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ìš”ì•½í•˜ìë©´,

â€¢	â€œzeroâ€: í•´ê°€ ì•„ì˜ˆ ì—†ëŠ” ê²½ìš° â†’ ì í™”ì‹ì´ ëª¨ìˆœì´ë¯€ë¡œ ill defined(ì •ì˜ê°€ ì„±ë¦½í•˜ì§€ ì•ŠìŒ)

â€¢	â€œoneâ€: í•´ê°€ ì •í™•íˆ í•˜ë‚˜ ìˆëŠ” ê²½ìš° â†’ well defined(ì •ì˜ê°€ ì„±ë¦½í•¨)

â€¢	â€œmanyâ€: í•´ê°€ ì—¬ëŸ¬ ê°œ ì¡´ì¬í•˜ëŠ” ê²½ìš° â†’ ì—­ì‹œ well defined(ì •ì˜ê°€ ì„±ë¦½í•¨)

ê²°êµ­ â€œí•´ê°€ ë‹¨ í•˜ë‚˜ë¼ë„ ì¡´ì¬í•˜ëŠ”ê°€?â€ê°€ â€˜well definedâ€™ì˜ ê¸°ì¤€ì´ ëœë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.

## ê°œêµ¬ì½” 2.  Algorithmic recurrences

### ê°œë…

A recurrence T(n) is algorithmic if, for every sufficient large threshold constant $n_0>0$, the following two properties hold:

1. For all n < n_0, we have T(n) = O(1)
1. For all n \ge n_0, every path of recursion terminates in a defined base case within a finite number of recursive invocations.
### ê°œë…: Break down

- Why would a recurrence T(n) that represents a (correct) divide-and-conquer algorithmâ€™s worst-case running time satisfy these properties for all sufficiently large threshold constants? (ì™œ ì í™”ì‹ì€ ìœ„ ì¡°ê±´ë§Œ ë§Œì¡±í•´ë„ ì˜ì™¸ë¡œ ëª¨ë“  í° ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆëŠ”ê°€?)
- The first property says that there exist constants c1, c2 such that 0 < c1 â‰¤ T(n) â‰¤ c2 for n < n0. 
- For every legal input, the algorithm must output the solution to the problem itâ€™s solving in finite time. 
- Thus we can let c1 be the minimum amount of time to call and return from a procedure which must be positive, because machine instructions need to be executed to invoke a procedure.
- The running time of the algorithm may not be defined for some values of n if there are no legal inputs of that size, but it must be defined for at least one, or else the â€œalgorithmâ€ doesnâ€™t solve any problem.
- Thus we can let c2 be the algorithmâ€™s maximum running time on any input of size n < n0, where n0 is sufficiently large that the algorithm solves at least one problem of size less than n0.
- The maximum is well defined, since there are at most a finite number of inputs of size less than n0, and there is at least one if n0 is sufficiently large. 
- Consequently, T(n) satisfies the â€œfirst propertyâ€
- If the second property fails to hold for T(n), then the algorithm isnâ€™t correct, because it would end up in an infinite recursive loop or otherwise fial to compute a solution.
- Thus, it stands to reason that a recurrence for the worst-case running time of a correct divide-and-conquer algorithm would be â€œalgorithmicâ€.
### êµ¬í˜„: ì—†ìŒ

### ì½”ë©˜íŠ¸

1ë²ˆì§¸ ì¡°ê±´ì€ base case, 2ë²ˆì§¸ ì¡°ê±´ì€ recursion caseë¥¼ ì˜ë¯¸í•˜ëŠ”ê±° ê°™ë‹¤? ì•„ë‹ˆë‹¤. 2ë²ˆì§¸ ì¡°ê±´ì€ â€˜ìœ í•œë²ˆ ë‚´ë¡œâ€™ ì¬ê·€ê°€ ëë‚˜ëŠ” ì¡°ê±´ì„ ì˜ë¯¸í•œë‹¤. í•©ë‹¹í•œ ì…ë ¥ê°’ì˜ ê²½ê³„ì„ ì¸ n0ë¥¼ ë„˜ì–´ì„œëŠ” ì…ë ¥ì— ëŒ€í•´ì„œëŠ”, ëª¨ë“  ì¬ê·€ê°€ ì œê±°ëœë‹¤ëŠ” ëœ»ì´ë‹¤.

### ìì„¸í•œ ì„¤ëª…

ë‘ ì¡°ê±´ì„ â€œ1. ë² ì´ìŠ¤ ì¼€ì´ìŠ¤â€ì™€ â€œ2. ì¬ê·€ê°€ ìœ í•œ ë‹¨ê³„ ë‚´ì— ë² ì´ìŠ¤ ì¼€ì´ìŠ¤ë¡œ ë„ë‹¬í•¨ì„ ë³´ì¥í•˜ëŠ” ì¡°ê±´â€ ì •ë„ë¡œ í•´ì„í•˜ì‹œë©´ ë©ë‹ˆë‹¤. ë‹¤ë§Œ ì—„ë°€íˆëŠ”,

1.	(ë² ì´ìŠ¤ ì¼€ì´ìŠ¤ë¡œì„œì˜ O(1) ì¡°ê±´)

â€œìƒìˆ˜ n_0â€ë³´ë‹¤ ì‘ì€ ëª¨ë“  nì— ëŒ€í•´ T(n) = O(1) ì´ë¼ëŠ” ê²ƒì€,

â€˜n_0â€™ ë¯¸ë§Œ ì˜ì—­(ì¦‰ ì¶©ë¶„íˆ ì‘ì€ ë¬¸ì œ í¬ê¸°)ì— ëŒ€í•´ì„œëŠ” ìƒìˆ˜ ì‹œê°„ì— í•´ê²°ì´ ê°€ëŠ¥í•˜ë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.

ë³´í†µ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ ì‹œ, ë¬¸ì œ í¬ê¸°ê°€ ì¶©ë¶„íˆ ì‘ì•„ì§€ë©´(ì˜ˆ: n = 1 í˜¹ì€ nì´ ì‘ì„ ë•Œ)

ì¬ê·€ë¥¼ ë©ˆì¶”ê³  ì§ì ‘(ìƒìˆ˜ ì‹œê°„) ì²˜ë¦¬í•˜ëŠ” â€œë² ì´ìŠ¤ ì¼€ì´ìŠ¤â€ì™€ ëŒ€ì‘í•©ë‹ˆë‹¤.

2.	(ì¬ê·€ í˜¸ì¶œì´ ìœ í•œ ë²ˆ ì•ˆì— ëë‚¨ì„ ë³´ì¥)

â€œn_0 ì´ìƒì˜ ëª¨ë“  nì— ëŒ€í•´, ì–´ë–¤ ê²½ë¡œë¡œ ì¬ê·€ í˜¸ì¶œì„ íƒ€ê³  ë‚´ë ¤ê°€ë„

ìœ í•œ íšŸìˆ˜ ì•ˆì— ì •ì˜ëœ ë² ì´ìŠ¤ ì¼€ì´ìŠ¤ë¡œ ë„ë‹¬â€í•œë‹¤ëŠ” ê²ƒì€,

ë¬¸ì œ í¬ê¸°ê°€ ì¶©ë¶„íˆ í° ê²½ìš°ì—ë„ ì¬ê·€ê°€ ë¬´í•œíˆ ì´ì–´ì§€ì§€ ì•Šê³ 

ë°˜ë“œì‹œ ë” ì‘ì€ ë¬¸ì œë¡œ ë‚´ë ¤ê°€ì„œ ê²°êµ­ (1)ë²ˆì˜ ë² ì´ìŠ¤ ì¼€ì´ìŠ¤ë¥¼ ë§Œë‚˜ê²Œ ëœë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.

ì¦‰ ì˜ ì •ì˜ëœ ì¬ê·€ êµ¬ì¡°(well-founded recursion)ë¼ëŠ” ì ì„ ë³´ì¥í•©ë‹ˆë‹¤.

ì •ë¦¬í•˜ë©´,

â€¢	ì¡°ê±´ (1): â€œì¶©ë¶„íˆ ì‘ì€ ì…ë ¥ì— ëŒ€í•´ì„ , T(n)ì„ ìƒìˆ˜ ì‹œê°„ìœ¼ë¡œ ì²˜ë¦¬í•œë‹¤(= ë² ì´ìŠ¤ ì¼€ì´ìŠ¤).â€

â€¢	ì¡°ê±´ (2): â€œì¶©ë¶„íˆ í° ì…ë ¥ì— ëŒ€í•´ì„œë„, ì¬ê·€ê°€ ê²°êµ­ (1)ì˜ ì¼€ì´ìŠ¤ê¹Œì§€ ìœ í•œ ë²ˆ ë§Œì— ë„ë‹¬í•œë‹¤.â€

ì´ë ‡ê²Œ ë‘ ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼, ì í™”ì‹(ì¬ê·€ì‹) ìì²´ê°€ í˜„ì‹¤ì ìœ¼ë¡œ êµ¬í˜„ ê°€ëŠ¥í•œ ì•Œê³ ë¦¬ì¦˜ì„ ë°˜ì˜í•˜ê²Œ ë˜ê³ , ì´ë¥¼ **â€˜algorithmic recurrence(ì•Œê³ ë¦¬ì¦˜ì  ì í™”ì‹)â€™**ë¼ê³  ë¶€ë¦…ë‹ˆë‹¤.

## ê°œêµ¬ì½” 3. ì¬ê·€ì‹ í’€ê¸°

### ê°œë…: ì¬ê·€ì‹ì„ í‘¸ëŠ” 4ê°€ì§€ ë°©ë²•ë¡ 

1. substitution method: you guess the form of a bound and then use mathematical induction to prove your guess correct and solve for constants. This method is perhaps the most robust method for solving recurrences, but it also requires you to make a good guess and to procedure an inductive proof.
1. recursion-tree method: models the recurrence as a tree whose nodes represent the costs incurred at various levels of the recursion. To solve the recurrence, ou determine the costs at each level and add them up, perhaps using techniques for bounding summations from Section A.2. Even if you donâ€™t usse this mehtod to formally prove a bound, it cna be helpful in guessing the form of the obund for use in the substitution method.
1. master method: the easiest method, wen it applies. It provides bounds for recurrences of the form T(n)=aT(n/b) + f(n), where a > 0 and b > 1 are constants and f(n) is a given â€œdrivingâ€ function. This type of recurrence tends to arise more frequently in the study of algorithms than any other. It characterizes a divide-and-conquer algorithm that creates a subproblems, each of which is 1/ times the size of the original problem, using f(n) time for the divide and combine steps. To apply the master method, you need to memorize three cases, but once you do, you can easily determine asymptotic bounds on running times for many divide-and-conquer algorithms
1. Akra-Bazzi method: a general method for solving divide-and-conquer recurrences. Although it involves calculus, it can be used to attack more complicated recurrences than those addressed by the master method.
## ê°œêµ¬ì½” 4.

### ê°œë…

### êµ¬í˜„

```plain text
MATRIX-MULTIPLICATION-RECURSIVE(A, B, C, n)
	if n == 1
	// Base case.
		c11 = c11 + a11*b11
		return
	//Divide
	partition A, B, and C into n/2 x n/2 submatrices
		A11, A12, A21, A22; B11, B21, B22
```

### ì½”ë©˜íŠ¸



