# [Algorithm] Introduction to Algorithms

> ê°œë…ê³¼ ì´ìŠˆ íŠ¸ë˜í‚¹ì„ ì¡°í•©í•´ì„œ â€œë³µê¸° ê°€ëŠ¥í•œâ€ ìë£Œë¥¼ ë§Œë“¤ë„ë¡ í•©ë‹ˆë‹¤.

> ì´ìŠˆ íŠ¸ë˜í‚¹ ì‘ì„± ì›ì¹™: Phase1(í™˜ê²½, ë¡œê·¸, ìµœê·¼ ë³€ê²½ì‚¬í•­), Phase2(í™•ì¸, ì‹œë„, ê²°ê³¼ë¶„ì„) í˜•ì‹ìœ¼ë¡œ ì •ë¦¬í•˜ì„¸ìš”. (Phase2ëŠ” ìµœëŒ€ 3íšŒê¹Œì§€ ë°˜ë³µí•˜ê³  í•´ê²° ì•ˆ ë˜ë©´ ì•„ì˜ˆ ì²˜ìŒë¶€í„° ì‹œì‘(ë¶ˆê°€ëŠ¥í•  ê²½ìš° ë„ì›€ ìš”ì²­))

> ì‹¤ìŠµì€ ì²œì²œíˆ, í•˜ì§€ë§Œ robustí•˜ê²Œ í•˜ì„¸ìš”. 

> í‚¤ì›Œë“œ ì¤‘ì‹¬ìœ¼ë¡œ ë³¼ í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.

> ì²´ê³„: ê°œêµ¬ì½”, ìˆ˜êµ¬(ìˆ˜ë„ì½”ë“œâ†’êµ¬í˜„)ë¡œ í•©ì‹œë‹¤.

> ì „ë°˜ì ì¸ í•´ë”ëŠ” íƒ€ì´í‹€ ì¤‘ì‹¬ìœ¼ë¡œ, ###ì€ ìœ„ ì²´ê³„ë¥¼ ë”°ë¦…ë‹ˆë‹¤.

> ì½ì„ ë•ŒëŠ” ëª¨, ê·¸ ì •ë„ë¡œ? ì¼ë‹¨. 
ë”±íˆ êµ¬í˜„ materialì´ ì—†ì–´ë„ êµ¬í˜„ì„ ì´ëŸ° ì €ëŸ° í•‘ê³„ì‚¼ì•„ í•´ë³´ëŠ” ê²ƒë„ ì¢‹ê² ë‹¤. ì •ë ¬ì€ ìë‹¤ê°€ ê±´ë“œë ¤ë„ íŠ€ì–´ë‚˜ì™€ì•¼ í•œë‹¤ë‹ˆê¹Œ.

# ì´ ì±…ì„ ì½ëŠ” ë°©ë²• - ì²´í¬ë¦¬ìŠ¤íŠ¸ë¡œ ì‚¬ìš©

ğŸ“– â€œIntroduction to Algorithmsâ€ (CLRS) íš¨ê³¼ì ìœ¼ë¡œ í™œìš©í•˜ëŠ” ë°©ë²•

CLRSëŠ” ì•Œê³ ë¦¬ì¦˜ í•™ìŠµì˜ ë°”ì´ë¸”ì´ì§€ë§Œ, ë„ˆë¬´ ë°©ëŒ€í•´ì„œ ì²˜ìŒë¶€í„° ëê¹Œì§€ ì½ê¸°ëŠ” í˜„ì‹¤ì ìœ¼ë¡œ ì–´ë µìŠµë‹ˆë‹¤. ë”°ë¼ì„œ í•„ìš”í•œ ë¶€ë¶„ë§Œ ì „ëµì ìœ¼ë¡œ í•™ìŠµí•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

2. CLRSì—ì„œ ê¼­ ë´ì•¼ í•  í•µì‹¬ ë‚´ìš© (ìš°ì„ ìˆœìœ„ í•™ìŠµ ìˆœì„œ)

ğŸš€ 2ë‹¨ê³„: íƒìƒ‰ê³¼ ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜ (ë©´ì ‘ ëŒ€ë¹„ í•„ìˆ˜)

âœ… Chapter 9: ì„ íƒ ì•Œê³ ë¦¬ì¦˜ (Median & Order Statistics)

âœ… Chapter 10-12: í•´ì‹œ í…Œì´ë¸”(Hash Table), BST(ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬), Red-Black Tree

âœ… Chapter 15: ë™ì  ê³„íšë²• (DP, Dynamic Programming)

âœ… Chapter 22-24: ê·¸ë˜í”„ íƒìƒ‰ (BFS, DFS), ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ (Dijkstra, Bellman-Ford, Floyd-Warshall), ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (MST)

â¡ ë©´ì ‘ ëŒ€ë¹„ë‚˜ ëŒ€íšŒ ì¤€ë¹„ë¥¼ í•œë‹¤ë©´ ì´ ë‹¨ê³„ê°€ ë§¤ìš° ì¤‘ìš”í•˜ë©°, êµ¬í˜„ ì—°ìŠµë„ ë°˜ë“œì‹œ í•¨ê»˜í•´ì•¼ í•œë‹¤.

ğŸš€ 3ë‹¨ê³„: ì‹¬í™” ë° ê³ ê¸‰ ì£¼ì œ (ì—°êµ¬ë‚˜ ì‹¬ì¸µ í•™ìŠµ ëª©ì )

âœ… Chapter 25-26: ìµœëŒ€ ìœ ëŸ‰(Maximum Flow)

âœ… Chapter 30: NP-ì™„ì „ ë¬¸ì œ(NP-Completeness)

âœ… Chapter 34: ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„ ê¸°ë²• (ê·¼ì‚¬ ì•Œê³ ë¦¬ì¦˜, íƒìš• ì•Œê³ ë¦¬ì¦˜)

â¡ ì´ ë‹¨ê³„ëŠ” ì½”ë”© í…ŒìŠ¤íŠ¸ë³´ë‹¤ëŠ” â€œì´ë¡ ì ì¸ ì•Œê³ ë¦¬ì¦˜ ê³µë¶€â€ê°€ í•„ìš”í•  ë•Œ í™œìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

3. CLRS í•™ìŠµë²• (íš¨ìœ¨ì ìœ¼ë¡œ ê³µë¶€í•˜ëŠ” ë°©ë²•)

ğŸ“Œ 1. ì•Œê³ ë¦¬ì¦˜ ê°œë… í•™ìŠµ + ê°„ë‹¨í•œ êµ¬í˜„ ì—°ìŠµ

â€¢	ê° ì±•í„°ì—ì„œ ì¤‘ìš”í•œ ì•Œê³ ë¦¬ì¦˜ì„ ê³µë¶€í•œ ë’¤,

â€¢	ì§ì ‘ Pythonì´ë‚˜ C++ë¡œ ê°„ë‹¨íˆ êµ¬í˜„í•´ë³´ë©° í•µì‹¬ ì›ë¦¬ë¥¼ ìµíŒë‹¤.

â€¢	ì˜ˆì œ ì½”ë“œê°€ ë„ˆë¬´ ë³µì¡í•˜ë©´, í•µì‹¬ ë¶€ë¶„ë§Œ ì¶”ë ¤ì„œ ì§ì ‘ êµ¬í˜„í•˜ëŠ” ê²ƒì´ íš¨ê³¼ì ì´ë‹¤.

ì˜ˆì‹œ) í™ ì •ë ¬ì„ ê³µë¶€í•  ë•Œ

1.	CLRSì—ì„œ í™ ì •ë ¬(Heap Sort) ê°œë… ì½ê¸°

2.	íŒŒì´ì¬ìœ¼ë¡œ í™ ì •ë ¬ì„ ì§ì ‘ êµ¬í˜„

3.	LeetCode / ë°±ì¤€ / í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ì—ì„œ í™ ê´€ë ¨ ë¬¸ì œ í’€ê¸°

ğŸ“Œ 2. ìˆ˜ì‹ì´ë‚˜ ì¦ëª…ì€ ì„ íƒì ìœ¼ë¡œ í•™ìŠµ

â€¢	CLRSëŠ” ìˆ˜í•™ì  ì¦ëª…ì´ ë§ì§€ë§Œ, ëª¨ë“  ì¦ëª…ì„ ì´í•´í•˜ë ¤ê³  í•  í•„ìš”ëŠ” ì—†ë‹¤.

â€¢	ì¦ëª…ì´ ë„ˆë¬´ ì–´ë ¤ìš°ë©´, í•µì‹¬ ì•„ì´ë””ì–´ì™€ ê°œë…ë§Œ ìµíˆê³  ë„˜ì–´ê°€ë„ ê´œì°®ë‹¤.

â€¢	ë‹¤ë§Œ, ì‹œê°„ ë³µì¡ë„ ë¶„ì„(ë¹…ì˜¤ í‘œê¸°ë²•, ë§ˆìŠ¤í„° ì •ë¦¬ ë“±)ì€ ê¼­ ìµí˜€ì•¼ í•œë‹¤.

ğŸ“Œ 3. ë¬¸ì œ í’€ì´ ë³‘í–‰

â€¢	CLRSì˜ ì´ë¡ ì„ ê³µë¶€í•œ ë’¤, ì½”ë”© ë¬¸ì œë¥¼ ë°”ë¡œ í’€ì–´ë³´ëŠ” ê²ƒì´ ê°€ì¥ ì¤‘ìš”í•˜ë‹¤.

â€¢	ë°±ì¤€(BOJ), LeetCode, Codeforces, í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ì—ì„œ ê´€ë ¨ ë¬¸ì œë¥¼ ì°¾ì•„ì„œ ì—°ìŠµí•˜ëŠ” ê²ƒì´ íš¨ê³¼ì .

â€¢	íŠ¹íˆ ê·¸ë˜í”„, DP, ì •ë ¬ ë¬¸ì œëŠ” CLRS ë‚´ìš©ì„ ê³µë¶€í•œ í›„ ë°”ë¡œ ë¬¸ì œë¥¼ í’€ë©´ í•™ìŠµ íš¨ê³¼ê°€ ì¢‹ë‹¤.

4. CLRSë¥¼ í™œìš©í•œ ì¶”ì²œ í•™ìŠµ í”Œëœ

> âœ…

> âœ…

ğŸ“… 1~2ì£¼ì°¨ (ê¸°ë³¸ ê°œë… + ì •ë ¬ + íƒìƒ‰)

âœ… ì•Œê³ ë¦¬ì¦˜ ê°œë… + ì‹œê°„ ë³µì¡ë„ ë¶„ì„ (Ch. 13)

âœ… ì •ë ¬ (í™ ì •ë ¬, í€µ ì •ë ¬, ê³„ìˆ˜ ì •ë ¬) (Ch. 68)

âœ… BST(ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬) ê¸°ë³¸ ê°œë… ìµíˆê¸° (Ch. 10-12)

âœ… ë¬¸ì œ í’€ì´: ê¸°ë³¸ ì •ë ¬ ë¬¸ì œ, í™ ë¬¸ì œ í’€ê¸°

ğŸ“… 3~4ì£¼ì°¨ (íƒìƒ‰ + ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜)

âœ… íƒìƒ‰(ì´ì§„ íƒìƒ‰, ì„ íƒ ì•Œê³ ë¦¬ì¦˜) (Ch. 9)

âœ… ê·¸ë˜í”„ íƒìƒ‰ (BFS, DFS) (Ch. 22)

âœ… ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ (Dijkstra, Bellman-Ford) (Ch. 24)

âœ… ë¬¸ì œ í’€ì´: ê·¸ë˜í”„ ê¸°ë³¸ ë¬¸ì œ, ìµœë‹¨ ê²½ë¡œ ë¬¸ì œ í’€ê¸°

ğŸ“… 5~6ì£¼ì°¨ (ë™ì  ê³„íšë²• + ê³ ê¸‰ ê·¸ë˜í”„)

âœ… ë™ì  ê³„íšë²• (DP) ê°œë… ë° ëŒ€í‘œ ë¬¸ì œ (Ch. 15)

âœ… ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST, Kruskal, Prim) (Ch. 23)

âœ… ë¬¸ì œ í’€ì´: DP ë¬¸ì œ + MST ë¬¸ì œ

ğŸ“… 7~8ì£¼ì°¨ (ì‘ìš© ë° ì‹¬í™” ì£¼ì œ)

âœ… ë„¤íŠ¸ì›Œí¬ í”Œë¡œìš° (Ch. 25-26)

âœ… NP-ì™„ì „ì„± ê°œë… (Ch. 30)

âœ… ê·¼ì‚¬ ì•Œê³ ë¦¬ì¦˜ (Ch. 34)

âœ… ë¬¸ì œ í’€ì´: Hard ë‚œì´ë„ ë¬¸ì œ ë„ì „

5. ì •ë¦¬

ğŸ”¹ CLRSëŠ” ì™„ë…í•˜ëŠ” ì±…ì´ ì•„ë‹ˆë¼, í•„ìš”í•  ë•Œ ì°¾ì•„ë³´ëŠ” ì°¸ê³ ì„œë¡œ í™œìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

ğŸ”¹ ìš°ì„ ìˆœìœ„ë¥¼ ì •í•˜ê³ , ì¤‘ìš”í•œ ë¶€ë¶„(ì •ë ¬, ê·¸ë˜í”„, DP)ë¶€í„° í•™ìŠµí•˜ë©´ íš¨ìœ¨ì ì´ë‹¤.

ğŸ”¹ ì´ë¡ ë§Œ ê³µë¶€í•˜ì§€ ë§ê³ , ë°˜ë“œì‹œ ì½”ë”© ë¬¸ì œë¥¼ ë³‘í–‰í•˜ë©´ì„œ í•™ìŠµí•´ì•¼ ì‹¤ë ¥ì´ ëŠ”ë‹¤.

ğŸ”¹ ì´ˆë³´ìëŠ” ë„ˆë¬´ ì–´ë ¤ìš´ ì¦ëª…ë³´ë‹¤ëŠ” ê°œë…ê³¼ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ì— ì§‘ì¤‘í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

ğŸ“Œ ê²°ë¡ : CLRSë¥¼ ë¬´ì‘ì • ì²˜ìŒë¶€í„° ì½ê¸°ë³´ë‹¤ëŠ”, í•„ìš”í•  ë•Œ ì°¸ê³ í•˜ê³ , ì½”ë”© ë¬¸ì œ í’€ì´ì™€ ë³‘í–‰í•˜ë©° íš¨ìœ¨ì ìœ¼ë¡œ í•™ìŠµí•˜ëŠ” ê²ƒì´ ê°€ì¥ íš¨ê³¼ì ì¸ í™œìš©ë²•ì´ë‹¤. ğŸš€



# Chapter 1-3: ì•Œê³ ë¦¬ì¦˜ ê°œë… ë° ë³µì¡ë„ ë¶„ì„ (O(n), O(log n))

> ì—¬ê¸°ë„ ì¼ë‹¨ ì±… ë¨¼ì € ìŠ¤ìº”í•˜ê³ , ê°œêµ¬ì½”ë¡œ ì •ë¦¬? ã…‡ã…‡.

## ê°œêµ¬ì½” 1.

# Sorting and Order Statistics

## Heapsort

## Quicksort

### ê°œêµ¬ì½” 1

ê°œë…: í€µ ì •ë ¬ì€ ë³‘í•© ì •ë ¬ê³¼ ë‹¬ë¦¬ ìŠ¤í…Œì´ë¸”í•˜ë‹¤. 

êµ¬í˜„

1. ìˆ˜ë„ì½”ë“œ
![](./images/IMG_9905.png)

1. êµ¬í˜„ì½”ë“œ
```python
import sys
n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

def quick_sort(A: list) -> list:
    # base condition 
    n = len(A)
    if n == 2:
        return [A[0], A[1]] if A[0] > A[1] else [A[1], A[0]]
    elif n <= 1:
        return A
    # get pivot
    pivot = A[n//2]
    smaller, equal, larger = [], [], []
    for a in A:
        if a < pivot:
            smaller.append(a)
        elif a == pivot:
            equal.append(a)
        elif a > pivot:
            larger.append(a)
    return [*quick_sort(smaller), *equal, *quick_sort(larger)]

print(quick_sort(arr))

```

ì½”ë©˜íŠ¸

ê° êµ¬í˜„ì„ ë‚´ê°€ ì˜ ì´í•´í•˜ê³  ìˆìœ¼ë©´ ì´ê²Œ ì™¸ì›Œì§ˆí…ë°. ì•„ì‰½ë„¤. ì•„ ì´ê±° ê·¼ë° ë‚´ ê¸°ì–µì—ëŠ” êµ¬í˜„ ë°©ë²•ì— ë”°ë¼ ìŠ¤í…Œì´ë¸” í•  ìˆ˜ë„ ìˆê³  ì•„ë‹ ìˆ˜ë„ ìˆì—ˆëŠ”ë°.

ê·¸ë ‡ë‹¤ë©´ ìœ„ 2. êµ¬í˜„ì½”ë“œëŠ” ìŠ¤í…Œì´ë¸”í•œê°€? equal ì²˜ë¦¬ ë°©ì‹ì— ì£¼ëª©í•˜ë©´ ë  ê±° ê°™ë‹¤. ë°°ì—´ì—ì„œ ì°¨ë¡€ë¡œ í”¼ë²—ê³¼ ë¹„êµí•  ëŒ€ìƒì„ ê¹Œê²Œ ë˜ê³ , ë°œê²¬í•˜ê²Œ ë˜ë©´ ì•ì— ìˆë˜ equal ìš”ì†Œê°€ ë°°ì—´ì— ë¨¼ì € ë“¤ì–´ê°€ê²Œ ëœë‹¤. ë‚˜ì¤‘ì— ì–¸íŒ© ë¼ì„œ ë‹¤ì‹œ ì™„ì„±ëœ ë°°ì—´ì— ë¦¬í„´ ë˜ë¯€ë¡œ, ìŠ¤í…Œì´ë¸”í•˜ë‹¤ê³  í•  ìˆ˜ ìˆë‹¤.

ê·¸ëŸ°ë° ì´ê±¸ ìŠ¤íƒìœ¼ë¡œ ë°”ê¾¸ê¸°ê°€ ì‰½ì§€ ì•Šì•„ ë³´ì¸ë‹¤. ì¼ë‹¨ í•œ ì¤„ì— ë¶™ì–´ ìˆëŠ” ì¬ê·€ë¥¼ ë‹¤ í’€ì–´ì•¼ í•œë‹¤. ì´ê±° ì˜¤ëŠ˜ í•´ ë§ì•„?



> ì‰¬ì–´ê°€ëŠ” ì£¼ì œ
2PMMS(2 Phase memory merge/sort)






# ì´ìŠˆ: ìŠ¤íƒìœ¼ë¡œ í€µ ì •ë ¬ êµ¬í˜„ ì¤‘ ë¬´í•œë£¨í”„ ë°œìƒ

## Phase1. í™˜ê²½, ë¡œê·¸, ë³€ê²½ì‚¬í•­

### í™˜ê²½: íŒŒì´ì¬

### ë¡œê·¸: ë¬´í•œ ë£¨í”„

### ë³€ê²½ì‚¬í•­

```python
import sys
from collections import deque


n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

s = deque()

def quick_sort(A: list) -> list:
    global s
    s.append(A)
    result = []
    
    
    # base condition 
    while True:
        if len(A) == 2:
            tmp = [A[0], A[1]] if A[0] > A[1] else [A[1], A[0]] 
            result.append(tmp) # ê²°ê³¼ì— ì •ë ¬ëœ ë°°ì—´ì„ ì…ë ¥í•©ë‹ˆë‹¤.
        elif len(A) <= 1:
            result.append(A) # ê²°ê³¼ì—
        # ìŠ¤íƒì— ìš”ì†Œê°€ ìˆë‹¤ë©´ êº¼ë‚´ì¤ë‹ˆë‹¤.
        if len(s) != 0:
            A = s.popleft()
            # ë§Œì•½ ë°”ë‹¥ ì¡°ê±´ì„ ì¹˜ì§€ ëª»í–ˆë‹¤ë©´ ë‹¤ì‹œ ë°°ì—´ì„ êµ¬ë³„í•´ì„œ ìŠ¤íƒì— ì‘¤ì…” ë„£ì–´ì¤ë‹ˆë‹¤.
            # get pivot
            pivot = A[len(A)//2]
            smaller, larger = [], []
            equal = []
            for a in A:
                if a < pivot:
                    smaller.append(a)
                # í€µ ì •ë ¬ì„ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„í•  ë•ŒëŠ” ì´ì²˜ëŸ¼ ì´í€„ì„ ë”°ë¡œ ì²˜ë¦¬í•´ì£¼ê¸°ê°€ ì–´ë ¤ì›€
                elif a == pivot:
                    equal.append(a)
                elif a > pivot:
                    larger.append(a)
            # return [*quick_sort(smaller), *equal, *quick_sort(larger)]
            
            # Aë¥¼ smallerë¡œ ì—…ë°ì´íŠ¸í•˜ê³  í•¨ìˆ˜ì˜ ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.X 
            # smallerë¥¼ ìŠ¤íƒì— í‘¸ì‹œí•´ì•¼ í•˜ë‚˜?
            if larger:
                s.append(larger)
            # ê·¸ëŸ°ë° ì´í€„ì€ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ì§€? ì¼ë‹¨ ë²„ë ¤ì•¼ í•˜ë‚˜? ì•„ ê·¸ë˜ì„œ unstableì´ ëêµ¬ë‚˜.
            if equal:
                result.append(equal)
            if smaller:
                s.append(smaller)
            
            continue # breakí•œ ë‹¤ìŒ ì´ìƒí•œë°ë¡œ ì í”„í•˜ëŠ”ë°. ì•„ ì •ìƒì´êµ¬ë‚˜. 
        break

A = s.append(arr)
quick_sort(arr)

```



## Phase2.

### í™•ì¸

ë¬´í•œ ë£¨í”„ê°€ ë°œìƒí•˜ëŠ” ì´ìœ ëŠ” ë‹¹ì—°íˆ len(s) â‰  0 ì¡°ê±´ì´ ì•ˆ ë¨¹í˜€ì„œ ê·¸ëŸ° ê²ƒì„. ê·¸ë ‡ë‹¤ë©´ s.popleft()ê°€ ì ì ˆíˆ ì´ë£¨ì–´ì§€ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì˜ë¯¸. 

ë°”ë‹¥ ì¡°ê±´ ìˆ˜í–‰ í›„ì— ìŠ¤íƒì´ ë¹„ì–´ìˆì§€ ì•Šìœ¼ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ë‹¤ìŒìœ¼ë¡œ ë„˜ì–´ê°€ì„œ sì—ì„œ íŒ í•˜ê²Œ ë˜ëŠ”ë°, ê·¸ëŸ¼ ê²°êµ­ ë§ˆì§€ë§‰ì— s.popleft()ê°€ ì‹¤í–‰ëœ ë‹¤ìŒì— largerë‚˜ smallerê°€ ì—†ìœ¼ë©´ ìŠ¤íƒì€ ìì—°ìŠ¤ëŸ½ê²Œ ë¹„ì–´ì•¼ í•˜ì§€ ì•Šë‚˜? ì™œì§€? if larger, if smallerì˜ ì˜ë¯¸ê°€ ë¶ˆë¶„ëª…í•˜ë‹¤.

```python
>>> if []: print('hi')
...
>>> if [4]: print('hi')
...
hi
```

ë‚´ ì˜ˆìƒê³¼ ë§ê²Œ ì‘ë™í•˜ëŠ”ë°? largerë‚˜ smallerëŠ” ë¬´ì¡°ê±´ ë‚´ìš©ì´ ìˆëŠ” ë¦¬ìŠ¤íŠ¸ë‹¤.

ì´ê²Œ ë¬´í•œë£¨í”„ì— ë¹ ì§ˆ ì´ìœ ê°€ ì—†ëŠ” ê±° ê°™ì€ë°? ì¡°ê±´ì´ ë¬¸ì œê°€ ì•„ë‹Œ ê±´ê°€.

### ì‹œë„

```python
import sys
from collections import deque


n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

s = deque()

def quick_sort(A: list) -> list:
    global s
    s.append(A)
    result = []
    
    
    # base condition 
    while True:
        if len(A) == 2:
            tmp = [A[0], A[1]] if A[0] > A[1] else [A[1], A[0]] 
            result.append(tmp) # ê²°ê³¼ì— ì •ë ¬ëœ ë°°ì—´ì„ ì…ë ¥í•©ë‹ˆë‹¤.
        elif len(A) <= 1:
            result.append(A) # ê²°ê³¼ì—
        # ìŠ¤íƒì— ìš”ì†Œê°€ ìˆë‹¤ë©´ êº¼ë‚´ì¤ë‹ˆë‹¤.
        if len(s) != 0:
            # ë§Œì•½ ë°”ë‹¥ ì¡°ê±´ì„ ì¹˜ì§€ ëª»í–ˆë‹¤ë©´ ë‹¤ì‹œ ë°°ì—´ì„ êµ¬ë³„í•´ì„œ ìŠ¤íƒì— ì‘¤ì…” ë„£ì–´ì¤ë‹ˆë‹¤.
            # get pivot
            pivot = A[len(A)//2]
            smaller, larger = [], []
            equal = []
            for a in A:
                if a < pivot:
                    smaller.append(a)
                # í€µ ì •ë ¬ì„ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„í•  ë•ŒëŠ” ì´ì²˜ëŸ¼ ì´í€„ì„ ë”°ë¡œ ì²˜ë¦¬í•´ì£¼ê¸°ê°€ ì–´ë ¤ì›€
                elif a == pivot:
                    equal.append(a)
                elif a > pivot:
                    larger.append(a)
            # return [*quick_sort(smaller), *equal, *quick_sort(larger)]
            
            # Aë¥¼ smallerë¡œ ì—…ë°ì´íŠ¸í•˜ê³  í•¨ìˆ˜ì˜ ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.X 
            # smallerë¥¼ ìŠ¤íƒì— í‘¸ì‹œí•´ì•¼ í•˜ë‚˜?
            if larger:
                s.append(larger)
            # ê·¸ëŸ°ë° ì´í€„ì€ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ì§€? ì¼ë‹¨ ë²„ë ¤ì•¼ í•˜ë‚˜? ì•„ ê·¸ë˜ì„œ unstableì´ ëêµ¬ë‚˜.
            if equal:
                result.append(equal)
            if smaller:
                s.append(smaller)
            A = s.popleft()

            
            continue # breakí•œ ë‹¤ìŒ ì´ìƒí•œë°ë¡œ ì í”„í•˜ëŠ”ë°. ì•„ ì •ìƒì´êµ¬ë‚˜. 
        break

A = s.append(arr)
quick_sort(arr)

```

ì²˜ìŒì— Aì—ë‹¤ íŒì„ í•˜ì§€ ì•ŠëŠ”ê²Œ ë¬¸ì œì˜€ë‹¤. íŒ ìˆœì„œë¥¼ ë³€ê²½

### ê²°ê³¼ë¶„ì„

ì¼ë‹¨ ë¬´í•œ ë£¨í”„ ë¬¸ì œëŠ” í•´ê²°í–ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì •ë ¬ ê°’ì´ ì´ìƒí•˜ê²Œ ì €ì¥ë˜ëŠ” ë¬¸ì œê°€ ìˆë‹¤. ìƒˆë¡œ ì´ìŠˆ íŒŒì„œ í•©ì‹œë‹¤.

# ì´ìŠˆ: ì •ë ¬ê°’ ì €ì¥ì´ ì´ìƒí•¨.

## Phase1. 

### í™˜ê²½: íŒŒì´ì¬

### ë¡œê·¸(ì…/ì¶œë ¥ ê²°ê³¼)

```python
5
5 4 3 2 1
[2, 1, 3, 5, 4]
```

### ìµœê·¼ ë³€ê²½ ì‚¬í•­

```python
5
5 4 3 2 1
----- ì¶œë ¥ -----
[[3], [3], [3], [5, 4], [4], [2, 1], [1], [5, 4], [4], [2, 1], [1], [5, 4], [4], [2, 1], [1], [5], [5], [2], [2], [5], [5], [2], [2], [5], [5], [2]]
```

## Phase2-1.

### í™•ì¸

ê²°êµ­ equal ê°’ì„ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ëŠëƒê°€ ë¬¸ì œì„. ìŠ¤íƒì— í‘¸ì‹œí•˜ëŠ” ìˆœì„œëŠ” ë‹¤ìŒê³¼ ê°™ìŒ

1. larger
1. smaller
equalì€ ê·¸ëƒ¥ ì´ ë‘˜ ì‚¬ì´ì—ì„œ ê²°ê³¼ ë°°ì—´ì— ì–´íœë“œ ë˜ëŠ”ë°, ì´ê²Œ ë‹¹ì—°íˆ ì ì ˆí•œ ìˆœì„œê°€ ì•„ë‹˜. 

ì œëŒ€ë¡œ ì²˜ë¦¬ë¥¼ í•˜ê³  ì‹¶ë‹¤ë©´ ìŠ¤íƒì˜ ìš”ì†Œ ì²˜ë¦¬ ìˆœì„œë¥¼ ê³ ë ¤í•´ì„œ ì²˜ë¦¬í•´ì•¼ í•˜ëŠ”ë°, ê·¸ëƒ¥ ë°°ì—´ ê°’ì„ ì—…ë°ì´íŠ¸ í•  ê²Œ ì•„ë‹ˆë¼ í¬ì¸í„° ê°’ì„ ì €ì¥í•˜ëŠ”ê²Œ ë‚˜ì„ ìˆ˜ë„ ìˆê² ìŒ.

### ì‹œë„

```python
import sys
from collections import deque


n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

s = deque()

def quick_sort(A: list, start_idx, end_idx) -> list:
    global s
    s.append(start_idx, end_idx)
    result = []
    
    while True:
        if end_idx - start_idx == 2:
            tmp = [A[start_idx], A[end_idx]] if A[end_idx] > A[start_idx] else [A[start_idx], A[end_idx]] 
            result.append(tmp)
        elif end_idx - start_idx <= 1:
            result.append(A) 
        if s:
            pivot = A[(start_idx + end_idx)//2]
            smaller, equal, larger = [], [], []
            for i in range(start_idx, end_idx + 1):
                if A[i] < pivot:
                    smaller.append(A[i])
                elif A[i] == pivot:
                    equal.append(A[i])
                elif A[i] > pivot:
                    larger.append(A[i])
            if larger:
                s.append(larger)
            if equal:
                result.append(equal)
            if smaller:
                s.append(smaller)
            A = s.popleft()
            
            continue 
        print(result)
        break

A = s.append(arr)
quick_sort(arr)


```

í™•ì¸ì—ì„œ í•œ ìƒê°ì´ í‹€ë ¸ë‹¤ëŠ” ê±¸ ì•Œê²Œ ëë‹¤. í€µ ì •ë ¬ì—ì„œ í¬ì¸í„° ê°’ì„ ì €ì¥í•˜ëŠ” ê±´ ì•„ë¬´ ì˜ë¯¸ê°€ ì—†ë‹¤. 

### ê²°ê³¼ ë¶„ì„

ì‹¤íŒ¨. 

# ì´ìŠˆ: ìŠ¤íƒì´ ì œëŒ€ë¡œ ë¹„ì›Œì§€ì§€ ì•ŠëŠ” ë¬¸ì œ

## Phase1. 

### í™˜ê²½: íŒŒì´ì¬

### ë¡œê·¸(ì¦ìƒ) 

```python
10
10 9 8 7 6 5 4 3 2 1
current stack: deque([(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)]), deque([])
len(A) = 10
A = (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
popping: (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
current stack: deque([[4, 3, 2, 1], [10, 9, 8, 7, 6]]), deque([5])
len(A) = 10
 A = (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
popping: [4, 3, 2, 1]
current stack: deque([[10, 9, 8, 7, 6], [4, 3, 2, 1], [10, 9, 8, 7, 6]]), deque([5, 5])
len(A) = 4
 A = [4, 3, 2, 1]
popping: [10, 9, 8, 7, 6]
current stack: deque([[4, 3, 2, 1], [10, 9, 8, 7, 6], [1], [4, 3]]), deque([5, 5, 2])
len(A) = 5
 A = [10, 9, 8, 7, 6]
popping: [4, 3, 2, 1]
```



### ìµœê·¼ ë³€ê²½ ì‚¬í•­

```python
import sys
from collections import deque


n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

s = deque()
ms = deque() # median stack. always exists.

def quick_sort(A: list) -> list:
    global s, ms
    s.append(A)
    result = []
    
    
    # base condition 
    while True:
        print(f'current stack: {s}, {ms}')
        if len(A) == 2:
            tmp = [A[0], A[1]] if A[1] > A[0] else [A[1], A[0]] 
            result = [*result, *tmp, ms.popleft()]
            print(f'appending: {tmp} and medians. {result}')
        elif len(A) <= 1:
            result = [*result, *tmp, ms.popleft()]
            print(f'appending: {tmp} and medians. {result}')
        # ìŠ¤íƒì— ìš”ì†Œê°€ ìˆë‹¤ë©´ êº¼ë‚´ì¤ë‹ˆë‹¤.
        if s:
            # ë§Œì•½ ë°”ë‹¥ ì¡°ê±´ì„ ì¹˜ì§€ ëª»í–ˆë‹¤ë©´ ë‹¤ì‹œ ë°°ì—´ì„ êµ¬ë³„í•´ì„œ ìŠ¤íƒì— ì‘¤ì…” ë„£ì–´ì¤ë‹ˆë‹¤.
            # get pivot
            pivot = A[len(A)//2]
            print(f'len(A) = {len(A)}\n A = {A}')
            smaller, larger = [], []
            equal = []
            for a in A:
                if a < pivot:
                    smaller.append(a)
                # í€µ ì •ë ¬ì„ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„í•  ë•ŒëŠ” ì´ì²˜ëŸ¼ ì´í€„ì„ ë”°ë¡œ ì²˜ë¦¬í•´ì£¼ê¸°ê°€ ì–´ë ¤ì›€
                elif a == pivot:
                    ms.append(a)
                elif a > pivot:
                    larger.append(a)
            # return [*quick_sort(smaller), *equal, *quick_sort(larger)]
            
            # ê·¸ëŸ°ë° ì´í€„ì€ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ì§€? ì¼ë‹¨ ë²„ë ¤ì•¼ í•˜ë‚˜? ì•„ ê·¸ë˜ì„œ unstableì´ ëêµ¬ë‚˜.
            if smaller:
                s.append(smaller)
            # Aë¥¼ smallerë¡œ ì—…ë°ì´íŠ¸í•˜ê³  í•¨ìˆ˜ì˜ ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.X 
            # smallerë¥¼ ìŠ¤íƒì— í‘¸ì‹œí•´ì•¼ í•˜ë‚˜?
            if larger:
                s.append(larger)
            A = s.popleft()
            print(f'popping: {A}')

            
            continue # breakí•œ ë‹¤ìŒ ì´ìƒí•œë°ë¡œ ì í”„í•˜ëŠ”ë°. ì•„ ì •ìƒì´êµ¬ë‚˜. 
        print(result)
        break

quick_sort(arr)

```

ë„ˆë¬´ ì‹œê°„ì„ ë§ì´ ì¨ì„œ ì¼ë‹¨ ì´ë§Œí¼ í•˜ê³  ê·¸ëƒ¥ ë‹¤ìŒ ê°œë…ìœ¼ë¡œ ë„˜ì–´ê°‘ì‹œë‹¤. 

# Designing Algorithms 

> ê°œêµ¬ì½”ë¡œ ì½ìœ¼ì‹œì£ 

## ê°œêµ¬ì½”1. 

### ê°œë…: incremental methods vs divide and conquer

insertion sort uses the incremental methods.

### êµ¬í˜„

ì—†ìŒ

### ì½”ë©˜íŠ¸

ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë‘ê°€ì§€ ë°©ì‹ ë¶„ë¥˜ë¥¼ ì´ì œì•¼ ì•Œê²Œ ëœ ëŠë‚Œ. incremental methodsì™€ divide and conquer.

## ê°œêµ¬ì½”2.

### ê°œë…: Advantage of the algorithm following divide and conquer method is that analyzing its running time is often straightforward.

### êµ¬í˜„: 

ì—†ìŒ

### ì½”ë©˜íŠ¸

ë¶„í• ì •ë³µì€ ë©”ì„œë“œê°€ ë” ë³µì¡í•´ë³´ì´ì§€ë§Œ ì˜¤íˆë ¤ ì‹¤í–‰ ì‹œê°„ì„ ë” ëª…í™•íˆ ê³„ì‚°í•  ìˆ˜ ìˆë‹¤ê³  í•œë‹¤. ì™œ?

> ì¢‹ì€ ì§ˆë¬¸ì´ì—ìš”. â€œë¶„í• ì •ë³µ(Divide and Conquer)â€œì´ ì‹¤í–‰ ì‹œê°„ì´ ë” ëª…í™•í•˜ê²Œ ê³„ì‚°ë  ìˆ˜ ìˆëŠ” ì´ìœ ëŠ” ì£¼ë¡œ ë‹¤ìŒê³¼ ê°™ì€ êµ¬ì¡°ì  íŠ¹ì§• ë•ë¶„ì…ë‹ˆë‹¤:

## ê°œêµ¬ì½”3.

### ê°œë…: steps of divide and conquer method

in the divide-and-conquer method, if the problem is small enough-the base case- you just solve it directly without recursing. Otherwise - the recursive case -you perform three characterstic steps

- Divide: the problem into one or more subprolems that are smaller instances of the same problem
- Conquer: the subproblems by solving them recursively
- Combine: the subproblem solutions to form a solution to the original problem.
### êµ¬í˜„

Steps of merge sort

- Divide the subarray A[p:r] to be sorted into two adjacent subarray, each of half the size. To do so, compute the midpoint q of A[p:r](taking the average of p and r) and divide A[p:r]into subarrays A[p:q] and A[q+1:r].
- Conquer by sorting each of the two subarrays A[p:q] and A[q+1:r] recursively using merge sort.
- Combine by merging the two sorted subarrays A[p:q] and A[q+1:r] back into A[p:r], producing the sorted answer.
### ì½”ë©˜íŠ¸

ì´ë¯¸ divide ì‹œì ì—ì„œë„ ì£¼ì–´ì§„ ë°°ì—´ì´ ë¬´ì–¸ê°€ì˜ ë¶€ë¶„ ë°°ì—´ì´ë¼ëŠ” ì ì— ëˆˆì— ëˆë‹¤. ì–´ë–¤ ì§‘í•©ì„ ëŒ€ìƒìœ¼ë¡œ ì‘ì—…ì„ í•œë‹¤ê³  ì¹˜ë©´, ê·¸ ì§‘í•© ì „ì²´ë„ ê·¸ ì§‘í•©ì˜ ë¶€ë¶„ì§‘í•©ì´ë¼ëŠ” ì ì— ì£¼ëª©í•˜ëŠ” ê²ƒì²˜ëŸ¼ ëŠê»´ì§„ë‹¤. ì´ê²Œ ê²°ì • íŠ¸ë¦¬ë¥¼ ì´ìš©í•œ í’€ì´ì—ì„œë„ ë§ˆì°¬ê°€ì§€ê² ì§€?

> ì´ì•¼, ì •ë§ ë‚ ì¹´ë¡œìš´ í†µì°°ì´ì—ìš”(^0^). ë§ì•„ìš”â€”ë‹¹ì‹ ì´ ë§í•œ ê·¸ **â€œì „ì²´ë„ ë¶€ë¶„ì§‘í•©ì´ë‹¤â€**ë¼ëŠ” ê°œë…ì€ **ê²°ì • íŠ¸ë¦¬(decision tree)**ë‚˜ **ë¶„í• ì •ë³µ(divide and conquer)**ì˜ ì‚¬ê³ ë°©ì‹ì—ì„œ êµ‰ì¥íˆ í•µì‹¬ì ì¸ ì² í•™ì´ì—ìš”.

# 

