# [Algorithm] Introduction to Algorithms

> ê°œë…ê³¼ ì´ìŠˆ íŠ¸ë˜í‚¹ì„ ì¡°í•©í•´ì„œ â€œë³µê¸° ê°€ëŠ¥í•œâ€ ìë£Œë¥¼ ë§Œë“¤ë„ë¡ í•©ë‹ˆë‹¤.

> ì´ìŠˆ íŠ¸ë˜í‚¹ ì‘ì„± ì›ì¹™: Phase1(í™˜ê²½, ë¡œê·¸, ìµœê·¼ ë³€ê²½ì‚¬í•­), Phase2(í™•ì¸, ì‹œë„, ê²°ê³¼ë¶„ì„) í˜•ì‹ìœ¼ë¡œ ì •ë¦¬í•˜ì„¸ìš”. (Phase2ëŠ” ìµœëŒ€ 3íšŒê¹Œì§€ ë°˜ë³µí•˜ê³  í•´ê²° ì•ˆ ë˜ë©´ ì•„ì˜ˆ ì²˜ìŒë¶€í„° ì‹œì‘(ë¶ˆê°€ëŠ¥í•  ê²½ìš° ë„ì›€ ìš”ì²­))

> ì‹¤ìŠµì€ ì²œì²œíˆ, í•˜ì§€ë§Œ robustí•˜ê²Œ í•˜ì„¸ìš”. 

> í‚¤ì›Œë“œ ì¤‘ì‹¬ìœ¼ë¡œ ë³¼ í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.

> ì²´ê³„: ê°œêµ¬ì½”, ìˆ˜êµ¬(ìˆ˜ë„ì½”ë“œâ†’êµ¬í˜„)ë¡œ í•©ì‹œë‹¤.

> ì „ë°˜ì ì¸ í•´ë”ëŠ” íƒ€ì´í‹€ ì¤‘ì‹¬ìœ¼ë¡œ, ###ì€ ìœ„ ì²´ê³„ë¥¼ ë”°ë¦…ë‹ˆë‹¤.

> ì½ì„ ë•ŒëŠ” ëª¨, ê·¸ ì •ë„ë¡œ? ì¼ë‹¨. 
ë”±íˆ êµ¬í˜„ materialì´ ì—†ì–´ë„ êµ¬í˜„ì„ ì´ëŸ° ì €ëŸ° í•‘ê³„ì‚¼ì•„ í•´ë³´ëŠ” ê²ƒë„ ì¢‹ê² ë‹¤. ì •ë ¬ì€ ìë‹¤ê°€ ê±´ë“œë ¤ë„ íŠ€ì–´ë‚˜ì™€ì•¼ í•œë‹¤ë‹ˆê¹Œ.

# ì´ ì±…ì„ ì½ëŠ” ë°©ë²• - ì²´í¬ë¦¬ìŠ¤íŠ¸ë¡œ ì‚¬ìš©

ğŸ“– â€œIntroduction to Algorithmsâ€ (CLRS) íš¨ê³¼ì ìœ¼ë¡œ í™œìš©í•˜ëŠ” ë°©ë²•

CLRSëŠ” ì•Œê³ ë¦¬ì¦˜ í•™ìŠµì˜ ë°”ì´ë¸”ì´ì§€ë§Œ, ë„ˆë¬´ ë°©ëŒ€í•´ì„œ ì²˜ìŒë¶€í„° ëê¹Œì§€ ì½ê¸°ëŠ” í˜„ì‹¤ì ìœ¼ë¡œ ì–´ë µìŠµë‹ˆë‹¤. ë”°ë¼ì„œ í•„ìš”í•œ ë¶€ë¶„ë§Œ ì „ëµì ìœ¼ë¡œ í•™ìŠµí•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

2. CLRSì—ì„œ ê¼­ ë´ì•¼ í•  í•µì‹¬ ë‚´ìš© (ìš°ì„ ìˆœìœ„ í•™ìŠµ ìˆœì„œ)

ğŸš€ 2ë‹¨ê³„: íƒìƒ‰ê³¼ ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜ (ë©´ì ‘ ëŒ€ë¹„ í•„ìˆ˜)

âœ… Chapter 9: ì„ íƒ ì•Œê³ ë¦¬ì¦˜ (Median & Order Statistics)

âœ… Chapter 10-12: í•´ì‹œ í…Œì´ë¸”(Hash Table), BST(ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬), Red-Black Tree

âœ… Chapter 15: ë™ì  ê³„íšë²• (DP, Dynamic Programming)

âœ… Chapter 22-24: ê·¸ë˜í”„ íƒìƒ‰ (BFS, DFS), ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ (Dijkstra, Bellman-Ford, Floyd-Warshall), ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (MST)

â¡ ë©´ì ‘ ëŒ€ë¹„ë‚˜ ëŒ€íšŒ ì¤€ë¹„ë¥¼ í•œë‹¤ë©´ ì´ ë‹¨ê³„ê°€ ë§¤ìš° ì¤‘ìš”í•˜ë©°, êµ¬í˜„ ì—°ìŠµë„ ë°˜ë“œì‹œ í•¨ê»˜í•´ì•¼ í•œë‹¤.

ğŸš€ 3ë‹¨ê³„: ì‹¬í™” ë° ê³ ê¸‰ ì£¼ì œ (ì—°êµ¬ë‚˜ ì‹¬ì¸µ í•™ìŠµ ëª©ì )

âœ… Chapter 25-26: ìµœëŒ€ ìœ ëŸ‰(Maximum Flow)

âœ… Chapter 30: NP-ì™„ì „ ë¬¸ì œ(NP-Completeness)

âœ… Chapter 34: ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„ ê¸°ë²• (ê·¼ì‚¬ ì•Œê³ ë¦¬ì¦˜, íƒìš• ì•Œê³ ë¦¬ì¦˜)

â¡ ì´ ë‹¨ê³„ëŠ” ì½”ë”© í…ŒìŠ¤íŠ¸ë³´ë‹¤ëŠ” â€œì´ë¡ ì ì¸ ì•Œê³ ë¦¬ì¦˜ ê³µë¶€â€ê°€ í•„ìš”í•  ë•Œ í™œìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

3. CLRS í•™ìŠµë²• (íš¨ìœ¨ì ìœ¼ë¡œ ê³µë¶€í•˜ëŠ” ë°©ë²•)

ğŸ“Œ 1. ì•Œê³ ë¦¬ì¦˜ ê°œë… í•™ìŠµ + ê°„ë‹¨í•œ êµ¬í˜„ ì—°ìŠµ

â€¢	ê° ì±•í„°ì—ì„œ ì¤‘ìš”í•œ ì•Œê³ ë¦¬ì¦˜ì„ ê³µë¶€í•œ ë’¤,

â€¢	ì§ì ‘ Pythonì´ë‚˜ C++ë¡œ ê°„ë‹¨íˆ êµ¬í˜„í•´ë³´ë©° í•µì‹¬ ì›ë¦¬ë¥¼ ìµíŒë‹¤.

â€¢	ì˜ˆì œ ì½”ë“œê°€ ë„ˆë¬´ ë³µì¡í•˜ë©´, í•µì‹¬ ë¶€ë¶„ë§Œ ì¶”ë ¤ì„œ ì§ì ‘ êµ¬í˜„í•˜ëŠ” ê²ƒì´ íš¨ê³¼ì ì´ë‹¤.

ì˜ˆì‹œ) í™ ì •ë ¬ì„ ê³µë¶€í•  ë•Œ

1.	CLRSì—ì„œ í™ ì •ë ¬(Heap Sort) ê°œë… ì½ê¸°

2.	íŒŒì´ì¬ìœ¼ë¡œ í™ ì •ë ¬ì„ ì§ì ‘ êµ¬í˜„

3.	LeetCode / ë°±ì¤€ / í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ì—ì„œ í™ ê´€ë ¨ ë¬¸ì œ í’€ê¸°

ğŸ“Œ 2. ìˆ˜ì‹ì´ë‚˜ ì¦ëª…ì€ ì„ íƒì ìœ¼ë¡œ í•™ìŠµ

â€¢	CLRSëŠ” ìˆ˜í•™ì  ì¦ëª…ì´ ë§ì§€ë§Œ, ëª¨ë“  ì¦ëª…ì„ ì´í•´í•˜ë ¤ê³  í•  í•„ìš”ëŠ” ì—†ë‹¤.

â€¢	ì¦ëª…ì´ ë„ˆë¬´ ì–´ë ¤ìš°ë©´, í•µì‹¬ ì•„ì´ë””ì–´ì™€ ê°œë…ë§Œ ìµíˆê³  ë„˜ì–´ê°€ë„ ê´œì°®ë‹¤.

â€¢	ë‹¤ë§Œ, ì‹œê°„ ë³µì¡ë„ ë¶„ì„(ë¹…ì˜¤ í‘œê¸°ë²•, ë§ˆìŠ¤í„° ì •ë¦¬ ë“±)ì€ ê¼­ ìµí˜€ì•¼ í•œë‹¤.

ğŸ“Œ 3. ë¬¸ì œ í’€ì´ ë³‘í–‰

â€¢	CLRSì˜ ì´ë¡ ì„ ê³µë¶€í•œ ë’¤, ì½”ë”© ë¬¸ì œë¥¼ ë°”ë¡œ í’€ì–´ë³´ëŠ” ê²ƒì´ ê°€ì¥ ì¤‘ìš”í•˜ë‹¤.

â€¢	ë°±ì¤€(BOJ), LeetCode, Codeforces, í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ì—ì„œ ê´€ë ¨ ë¬¸ì œë¥¼ ì°¾ì•„ì„œ ì—°ìŠµí•˜ëŠ” ê²ƒì´ íš¨ê³¼ì .

â€¢	íŠ¹íˆ ê·¸ë˜í”„, DP, ì •ë ¬ ë¬¸ì œëŠ” CLRS ë‚´ìš©ì„ ê³µë¶€í•œ í›„ ë°”ë¡œ ë¬¸ì œë¥¼ í’€ë©´ í•™ìŠµ íš¨ê³¼ê°€ ì¢‹ë‹¤.

4. CLRSë¥¼ í™œìš©í•œ ì¶”ì²œ í•™ìŠµ í”Œëœ

> âœ…

> âœ…

ğŸ“… 1~2ì£¼ì°¨ (ê¸°ë³¸ ê°œë… + ì •ë ¬ + íƒìƒ‰)

âœ… ì•Œê³ ë¦¬ì¦˜ ê°œë… + ì‹œê°„ ë³µì¡ë„ ë¶„ì„ (Ch. 13)

âœ… ì •ë ¬ (í™ ì •ë ¬, í€µ ì •ë ¬, ê³„ìˆ˜ ì •ë ¬) (Ch. 68)

âœ… BST(ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬) ê¸°ë³¸ ê°œë… ìµíˆê¸° (Ch. 10-12)

âœ… ë¬¸ì œ í’€ì´: ê¸°ë³¸ ì •ë ¬ ë¬¸ì œ, í™ ë¬¸ì œ í’€ê¸°

ğŸ“… 3~4ì£¼ì°¨ (íƒìƒ‰ + ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜)

âœ… íƒìƒ‰(ì´ì§„ íƒìƒ‰, ì„ íƒ ì•Œê³ ë¦¬ì¦˜) (Ch. 9)

âœ… ê·¸ë˜í”„ íƒìƒ‰ (BFS, DFS) (Ch. 22)

âœ… ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ (Dijkstra, Bellman-Ford) (Ch. 24)

âœ… ë¬¸ì œ í’€ì´: ê·¸ë˜í”„ ê¸°ë³¸ ë¬¸ì œ, ìµœë‹¨ ê²½ë¡œ ë¬¸ì œ í’€ê¸°

ğŸ“… 5~6ì£¼ì°¨ (ë™ì  ê³„íšë²• + ê³ ê¸‰ ê·¸ë˜í”„)

âœ… ë™ì  ê³„íšë²• (DP) ê°œë… ë° ëŒ€í‘œ ë¬¸ì œ (Ch. 15)

âœ… ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST, Kruskal, Prim) (Ch. 23)

âœ… ë¬¸ì œ í’€ì´: DP ë¬¸ì œ + MST ë¬¸ì œ

ğŸ“… 7~8ì£¼ì°¨ (ì‘ìš© ë° ì‹¬í™” ì£¼ì œ)

âœ… ë„¤íŠ¸ì›Œí¬ í”Œë¡œìš° (Ch. 25-26)

âœ… NP-ì™„ì „ì„± ê°œë… (Ch. 30)

âœ… ê·¼ì‚¬ ì•Œê³ ë¦¬ì¦˜ (Ch. 34)

âœ… ë¬¸ì œ í’€ì´: Hard ë‚œì´ë„ ë¬¸ì œ ë„ì „

5. ì •ë¦¬

ğŸ”¹ CLRSëŠ” ì™„ë…í•˜ëŠ” ì±…ì´ ì•„ë‹ˆë¼, í•„ìš”í•  ë•Œ ì°¾ì•„ë³´ëŠ” ì°¸ê³ ì„œë¡œ í™œìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

ğŸ”¹ ìš°ì„ ìˆœìœ„ë¥¼ ì •í•˜ê³ , ì¤‘ìš”í•œ ë¶€ë¶„(ì •ë ¬, ê·¸ë˜í”„, DP)ë¶€í„° í•™ìŠµí•˜ë©´ íš¨ìœ¨ì ì´ë‹¤.

ğŸ”¹ ì´ë¡ ë§Œ ê³µë¶€í•˜ì§€ ë§ê³ , ë°˜ë“œì‹œ ì½”ë”© ë¬¸ì œë¥¼ ë³‘í–‰í•˜ë©´ì„œ í•™ìŠµí•´ì•¼ ì‹¤ë ¥ì´ ëŠ”ë‹¤.

ğŸ”¹ ì´ˆë³´ìëŠ” ë„ˆë¬´ ì–´ë ¤ìš´ ì¦ëª…ë³´ë‹¤ëŠ” ê°œë…ê³¼ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ì— ì§‘ì¤‘í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

ğŸ“Œ ê²°ë¡ : CLRSë¥¼ ë¬´ì‘ì • ì²˜ìŒë¶€í„° ì½ê¸°ë³´ë‹¤ëŠ”, í•„ìš”í•  ë•Œ ì°¸ê³ í•˜ê³ , ì½”ë”© ë¬¸ì œ í’€ì´ì™€ ë³‘í–‰í•˜ë©° íš¨ìœ¨ì ìœ¼ë¡œ í•™ìŠµí•˜ëŠ” ê²ƒì´ ê°€ì¥ íš¨ê³¼ì ì¸ í™œìš©ë²•ì´ë‹¤. ğŸš€



# Chapter 1-3: ì•Œê³ ë¦¬ì¦˜ ê°œë… ë° ë³µì¡ë„ ë¶„ì„ (O(n), O(log n))

> ì—¬ê¸°ë„ ì¼ë‹¨ ì±… ë¨¼ì € ìŠ¤ìº”í•˜ê³ , ê°œêµ¬ì½”ë¡œ ì •ë¦¬? ã…‡ã…‡.

## ê°œêµ¬ì½” 1.

# Sorting and Order Statistics

## Heapsort

## Quicksort

### ê°œêµ¬ì½” 1

ê°œë…: í€µ ì •ë ¬ì€ ë³‘í•© ì •ë ¬ê³¼ ë‹¬ë¦¬ ìŠ¤í…Œì´ë¸”í•˜ë‹¤. 

êµ¬í˜„

1. ìˆ˜ë„ì½”ë“œ
![](./images/IMG_9905.png)

1. êµ¬í˜„ì½”ë“œ
```python
import sys
n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

def quick_sort(A: list) -> list:
    # base condition 
    n = len(A)
    if n == 2:
        return [A[0], A[1]] if A[0] > A[1] else [A[1], A[0]]
    elif n <= 1:
        return A
    # get pivot
    pivot = A[n//2]
    smaller, equal, larger = [], [], []
    for a in A:
        if a < pivot:
            smaller.append(a)
        elif a == pivot:
            equal.append(a)
        elif a > pivot:
            larger.append(a)
    return [*quick_sort(smaller), *equal, *quick_sort(larger)]

print(quick_sort(arr))

```

ì½”ë©˜íŠ¸

ê° êµ¬í˜„ì„ ë‚´ê°€ ì˜ ì´í•´í•˜ê³  ìˆìœ¼ë©´ ì´ê²Œ ì™¸ì›Œì§ˆí…ë°. ì•„ì‰½ë„¤. ì•„ ì´ê±° ê·¼ë° ë‚´ ê¸°ì–µì—ëŠ” êµ¬í˜„ ë°©ë²•ì— ë”°ë¼ ìŠ¤í…Œì´ë¸” í•  ìˆ˜ë„ ìˆê³  ì•„ë‹ ìˆ˜ë„ ìˆì—ˆëŠ”ë°.

ê·¸ë ‡ë‹¤ë©´ ìœ„ 2. êµ¬í˜„ì½”ë“œëŠ” ìŠ¤í…Œì´ë¸”í•œê°€? equal ì²˜ë¦¬ ë°©ì‹ì— ì£¼ëª©í•˜ë©´ ë  ê±° ê°™ë‹¤. ë°°ì—´ì—ì„œ ì°¨ë¡€ë¡œ í”¼ë²—ê³¼ ë¹„êµí•  ëŒ€ìƒì„ ê¹Œê²Œ ë˜ê³ , ë°œê²¬í•˜ê²Œ ë˜ë©´ ì•ì— ìˆë˜ equal ìš”ì†Œê°€ ë°°ì—´ì— ë¨¼ì € ë“¤ì–´ê°€ê²Œ ëœë‹¤. ë‚˜ì¤‘ì— ì–¸íŒ© ë¼ì„œ ë‹¤ì‹œ ì™„ì„±ëœ ë°°ì—´ì— ë¦¬í„´ ë˜ë¯€ë¡œ, ìŠ¤í…Œì´ë¸”í•˜ë‹¤ê³  í•  ìˆ˜ ìˆë‹¤.

ê·¸ëŸ°ë° ì´ê±¸ ìŠ¤íƒìœ¼ë¡œ ë°”ê¾¸ê¸°ê°€ ì‰½ì§€ ì•Šì•„ ë³´ì¸ë‹¤. ì¼ë‹¨ í•œ ì¤„ì— ë¶™ì–´ ìˆëŠ” ì¬ê·€ë¥¼ ë‹¤ í’€ì–´ì•¼ í•œë‹¤. ì´ê±° ì˜¤ëŠ˜ í•´ ë§ì•„?



> ì‰¬ì–´ê°€ëŠ” ì£¼ì œ
2PMMS(2 Phase memory merge/sort)






# ì´ìŠˆ: ìŠ¤íƒìœ¼ë¡œ í€µ ì •ë ¬ êµ¬í˜„ ì¤‘ ë¬´í•œë£¨í”„ ë°œìƒ

## Phase1. í™˜ê²½, ë¡œê·¸, ë³€ê²½ì‚¬í•­

### í™˜ê²½: íŒŒì´ì¬

### ë¡œê·¸: ë¬´í•œ ë£¨í”„

### ë³€ê²½ì‚¬í•­

```python
import sys
from collections import deque


n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

s = deque()

def quick_sort(A: list) -> list:
    global s
    s.append(A)
    result = []
    
    
    # base condition 
    while True:
        if len(A) == 2:
            tmp = [A[0], A[1]] if A[0] > A[1] else [A[1], A[0]] 
            result.append(tmp) # ê²°ê³¼ì— ì •ë ¬ëœ ë°°ì—´ì„ ì…ë ¥í•©ë‹ˆë‹¤.
        elif len(A) <= 1:
            result.append(A) # ê²°ê³¼ì—
        # ìŠ¤íƒì— ìš”ì†Œê°€ ìˆë‹¤ë©´ êº¼ë‚´ì¤ë‹ˆë‹¤.
        if len(s) != 0:
            A = s.popleft()
            # ë§Œì•½ ë°”ë‹¥ ì¡°ê±´ì„ ì¹˜ì§€ ëª»í–ˆë‹¤ë©´ ë‹¤ì‹œ ë°°ì—´ì„ êµ¬ë³„í•´ì„œ ìŠ¤íƒì— ì‘¤ì…” ë„£ì–´ì¤ë‹ˆë‹¤.
            # get pivot
            pivot = A[len(A)//2]
            smaller, larger = [], []
            equal = []
            for a in A:
                if a < pivot:
                    smaller.append(a)
                # í€µ ì •ë ¬ì„ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„í•  ë•ŒëŠ” ì´ì²˜ëŸ¼ ì´í€„ì„ ë”°ë¡œ ì²˜ë¦¬í•´ì£¼ê¸°ê°€ ì–´ë ¤ì›€
                elif a == pivot:
                    equal.append(a)
                elif a > pivot:
                    larger.append(a)
            # return [*quick_sort(smaller), *equal, *quick_sort(larger)]
            
            # Aë¥¼ smallerë¡œ ì—…ë°ì´íŠ¸í•˜ê³  í•¨ìˆ˜ì˜ ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.X 
            # smallerë¥¼ ìŠ¤íƒì— í‘¸ì‹œí•´ì•¼ í•˜ë‚˜?
            if larger:
                s.append(larger)
            # ê·¸ëŸ°ë° ì´í€„ì€ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ì§€? ì¼ë‹¨ ë²„ë ¤ì•¼ í•˜ë‚˜? ì•„ ê·¸ë˜ì„œ unstableì´ ëêµ¬ë‚˜.
            if equal:
                result.append(equal)
            if smaller:
                s.append(smaller)
            
            continue # breakí•œ ë‹¤ìŒ ì´ìƒí•œë°ë¡œ ì í”„í•˜ëŠ”ë°. ì•„ ì •ìƒì´êµ¬ë‚˜. 
        break

A = s.append(arr)
quick_sort(arr)

```



## Phase2.

### í™•ì¸

ë¬´í•œ ë£¨í”„ê°€ ë°œìƒí•˜ëŠ” ì´ìœ ëŠ” ë‹¹ì—°íˆ len(s) â‰  0 ì¡°ê±´ì´ ì•ˆ ë¨¹í˜€ì„œ ê·¸ëŸ° ê²ƒì„. ê·¸ë ‡ë‹¤ë©´ s.popleft()ê°€ ì ì ˆíˆ ì´ë£¨ì–´ì§€ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì˜ë¯¸. 

ë°”ë‹¥ ì¡°ê±´ ìˆ˜í–‰ í›„ì— ìŠ¤íƒì´ ë¹„ì–´ìˆì§€ ì•Šìœ¼ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ë‹¤ìŒìœ¼ë¡œ ë„˜ì–´ê°€ì„œ sì—ì„œ íŒ í•˜ê²Œ ë˜ëŠ”ë°, ê·¸ëŸ¼ ê²°êµ­ ë§ˆì§€ë§‰ì— s.popleft()ê°€ ì‹¤í–‰ëœ ë‹¤ìŒì— largerë‚˜ smallerê°€ ì—†ìœ¼ë©´ ìŠ¤íƒì€ ìì—°ìŠ¤ëŸ½ê²Œ ë¹„ì–´ì•¼ í•˜ì§€ ì•Šë‚˜? ì™œì§€? if larger, if smallerì˜ ì˜ë¯¸ê°€ ë¶ˆë¶„ëª…í•˜ë‹¤.

```python
>>> if []: print('hi')
...
>>> if [4]: print('hi')
...
hi
```

ë‚´ ì˜ˆìƒê³¼ ë§ê²Œ ì‘ë™í•˜ëŠ”ë°? largerë‚˜ smallerëŠ” ë¬´ì¡°ê±´ ë‚´ìš©ì´ ìˆëŠ” ë¦¬ìŠ¤íŠ¸ë‹¤.

ì´ê²Œ ë¬´í•œë£¨í”„ì— ë¹ ì§ˆ ì´ìœ ê°€ ì—†ëŠ” ê±° ê°™ì€ë°? ì¡°ê±´ì´ ë¬¸ì œê°€ ì•„ë‹Œ ê±´ê°€.

### ì‹œë„

```python
import sys
from collections import deque


n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

s = deque()

def quick_sort(A: list) -> list:
    global s
    s.append(A)
    result = []
    
    
    # base condition 
    while True:
        if len(A) == 2:
            tmp = [A[0], A[1]] if A[0] > A[1] else [A[1], A[0]] 
            result.append(tmp) # ê²°ê³¼ì— ì •ë ¬ëœ ë°°ì—´ì„ ì…ë ¥í•©ë‹ˆë‹¤.
        elif len(A) <= 1:
            result.append(A) # ê²°ê³¼ì—
        # ìŠ¤íƒì— ìš”ì†Œê°€ ìˆë‹¤ë©´ êº¼ë‚´ì¤ë‹ˆë‹¤.
        if len(s) != 0:
            # ë§Œì•½ ë°”ë‹¥ ì¡°ê±´ì„ ì¹˜ì§€ ëª»í–ˆë‹¤ë©´ ë‹¤ì‹œ ë°°ì—´ì„ êµ¬ë³„í•´ì„œ ìŠ¤íƒì— ì‘¤ì…” ë„£ì–´ì¤ë‹ˆë‹¤.
            # get pivot
            pivot = A[len(A)//2]
            smaller, larger = [], []
            equal = []
            for a in A:
                if a < pivot:
                    smaller.append(a)
                # í€µ ì •ë ¬ì„ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„í•  ë•ŒëŠ” ì´ì²˜ëŸ¼ ì´í€„ì„ ë”°ë¡œ ì²˜ë¦¬í•´ì£¼ê¸°ê°€ ì–´ë ¤ì›€
                elif a == pivot:
                    equal.append(a)
                elif a > pivot:
                    larger.append(a)
            # return [*quick_sort(smaller), *equal, *quick_sort(larger)]
            
            # Aë¥¼ smallerë¡œ ì—…ë°ì´íŠ¸í•˜ê³  í•¨ìˆ˜ì˜ ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.X 
            # smallerë¥¼ ìŠ¤íƒì— í‘¸ì‹œí•´ì•¼ í•˜ë‚˜?
            if larger:
                s.append(larger)
            # ê·¸ëŸ°ë° ì´í€„ì€ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ì§€? ì¼ë‹¨ ë²„ë ¤ì•¼ í•˜ë‚˜? ì•„ ê·¸ë˜ì„œ unstableì´ ëêµ¬ë‚˜.
            if equal:
                result.append(equal)
            if smaller:
                s.append(smaller)
            A = s.popleft()

            
            continue # breakí•œ ë‹¤ìŒ ì´ìƒí•œë°ë¡œ ì í”„í•˜ëŠ”ë°. ì•„ ì •ìƒì´êµ¬ë‚˜. 
        break

A = s.append(arr)
quick_sort(arr)

```

ì²˜ìŒì— Aì—ë‹¤ íŒì„ í•˜ì§€ ì•ŠëŠ”ê²Œ ë¬¸ì œì˜€ë‹¤. íŒ ìˆœì„œë¥¼ ë³€ê²½

### ê²°ê³¼ë¶„ì„

ì¼ë‹¨ ë¬´í•œ ë£¨í”„ ë¬¸ì œëŠ” í•´ê²°í–ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì •ë ¬ ê°’ì´ ì´ìƒí•˜ê²Œ ì €ì¥ë˜ëŠ” ë¬¸ì œê°€ ìˆë‹¤. ìƒˆë¡œ ì´ìŠˆ íŒŒì„œ í•©ì‹œë‹¤.

# ì´ìŠˆ: ì •ë ¬ê°’ ì €ì¥ì´ ì´ìƒí•¨.

## Phase1. 

### í™˜ê²½: íŒŒì´ì¬

### ë¡œê·¸(ì…/ì¶œë ¥ ê²°ê³¼)

```python
5
5 4 3 2 1
[2, 1, 3, 5, 4]
```

### ìµœê·¼ ë³€ê²½ ì‚¬í•­

```python
5
5 4 3 2 1
----- ì¶œë ¥ -----
[[3], [3], [3], [5, 4], [4], [2, 1], [1], [5, 4], [4], [2, 1], [1], [5, 4], [4], [2, 1], [1], [5], [5], [2], [2], [5], [5], [2], [2], [5], [5], [2]]
```

## Phase2-1.

### í™•ì¸

ê²°êµ­ equal ê°’ì„ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ëŠëƒê°€ ë¬¸ì œì„. ìŠ¤íƒì— í‘¸ì‹œí•˜ëŠ” ìˆœì„œëŠ” ë‹¤ìŒê³¼ ê°™ìŒ

1. larger
1. smaller
equalì€ ê·¸ëƒ¥ ì´ ë‘˜ ì‚¬ì´ì—ì„œ ê²°ê³¼ ë°°ì—´ì— ì–´íœë“œ ë˜ëŠ”ë°, ì´ê²Œ ë‹¹ì—°íˆ ì ì ˆí•œ ìˆœì„œê°€ ì•„ë‹˜. 

ì œëŒ€ë¡œ ì²˜ë¦¬ë¥¼ í•˜ê³  ì‹¶ë‹¤ë©´ ìŠ¤íƒì˜ ìš”ì†Œ ì²˜ë¦¬ ìˆœì„œë¥¼ ê³ ë ¤í•´ì„œ ì²˜ë¦¬í•´ì•¼ í•˜ëŠ”ë°, ê·¸ëƒ¥ ë°°ì—´ ê°’ì„ ì—…ë°ì´íŠ¸ í•  ê²Œ ì•„ë‹ˆë¼ í¬ì¸í„° ê°’ì„ ì €ì¥í•˜ëŠ”ê²Œ ë‚˜ì„ ìˆ˜ë„ ìˆê² ìŒ.

### ì‹œë„

```python
import sys
from collections import deque


n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

s = deque()

def quick_sort(A: list, start_idx, end_idx) -> list:
    global s
    s.append(start_idx, end_idx)
    result = []
    
    while True:
        if end_idx - start_idx == 2:
            tmp = [A[start_idx], A[end_idx]] if A[end_idx] > A[start_idx] else [A[start_idx], A[end_idx]] 
            result.append(tmp)
        elif end_idx - start_idx <= 1:
            result.append(A) 
        if s:
            pivot = A[(start_idx + end_idx)//2]
            smaller, equal, larger = [], [], []
            for i in range(start_idx, end_idx + 1):
                if A[i] < pivot:
                    smaller.append(A[i])
                elif A[i] == pivot:
                    equal.append(A[i])
                elif A[i] > pivot:
                    larger.append(A[i])
            if larger:
                s.append(larger)
            if equal:
                result.append(equal)
            if smaller:
                s.append(smaller)
            A = s.popleft()
            
            continue 
        print(result)
        break

A = s.append(arr)
quick_sort(arr)


```

í™•ì¸ì—ì„œ í•œ ìƒê°ì´ í‹€ë ¸ë‹¤ëŠ” ê±¸ ì•Œê²Œ ëë‹¤. í€µ ì •ë ¬ì—ì„œ í¬ì¸í„° ê°’ì„ ì €ì¥í•˜ëŠ” ê±´ ì•„ë¬´ ì˜ë¯¸ê°€ ì—†ë‹¤. 

### ê²°ê³¼ ë¶„ì„

ì‹¤íŒ¨. 

# ì´ìŠˆ: ìŠ¤íƒì´ ì œëŒ€ë¡œ ë¹„ì›Œì§€ì§€ ì•ŠëŠ” ë¬¸ì œ

## Phase1. 

### í™˜ê²½: íŒŒì´ì¬

### ë¡œê·¸(ì¦ìƒ) 

```python
10
10 9 8 7 6 5 4 3 2 1
current stack: deque([(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)]), deque([])
len(A) = 10
A = (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
popping: (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
current stack: deque([[4, 3, 2, 1], [10, 9, 8, 7, 6]]), deque([5])
len(A) = 10
 A = (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
popping: [4, 3, 2, 1]
current stack: deque([[10, 9, 8, 7, 6], [4, 3, 2, 1], [10, 9, 8, 7, 6]]), deque([5, 5])
len(A) = 4
 A = [4, 3, 2, 1]
popping: [10, 9, 8, 7, 6]
current stack: deque([[4, 3, 2, 1], [10, 9, 8, 7, 6], [1], [4, 3]]), deque([5, 5, 2])
len(A) = 5
 A = [10, 9, 8, 7, 6]
popping: [4, 3, 2, 1]
```



### ìµœê·¼ ë³€ê²½ ì‚¬í•­

```python
import sys
from collections import deque


n = int(input())
arr = tuple(map(int, sys.stdin.readline().split()))

s = deque()
ms = deque() # median stack. always exists.

def quick_sort(A: list) -> list:
    global s, ms
    s.append(A)
    result = []
    
    
    # base condition 
    while True:
        print(f'current stack: {s}, {ms}')
        if len(A) == 2:
            tmp = [A[0], A[1]] if A[1] > A[0] else [A[1], A[0]] 
            result = [*result, *tmp, ms.popleft()]
            print(f'appending: {tmp} and medians. {result}')
        elif len(A) <= 1:
            result = [*result, *tmp, ms.popleft()]
            print(f'appending: {tmp} and medians. {result}')
        # ìŠ¤íƒì— ìš”ì†Œê°€ ìˆë‹¤ë©´ êº¼ë‚´ì¤ë‹ˆë‹¤.
        if s:
            # ë§Œì•½ ë°”ë‹¥ ì¡°ê±´ì„ ì¹˜ì§€ ëª»í–ˆë‹¤ë©´ ë‹¤ì‹œ ë°°ì—´ì„ êµ¬ë³„í•´ì„œ ìŠ¤íƒì— ì‘¤ì…” ë„£ì–´ì¤ë‹ˆë‹¤.
            # get pivot
            pivot = A[len(A)//2]
            print(f'len(A) = {len(A)}\n A = {A}')
            smaller, larger = [], []
            equal = []
            for a in A:
                if a < pivot:
                    smaller.append(a)
                # í€µ ì •ë ¬ì„ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„í•  ë•ŒëŠ” ì´ì²˜ëŸ¼ ì´í€„ì„ ë”°ë¡œ ì²˜ë¦¬í•´ì£¼ê¸°ê°€ ì–´ë ¤ì›€
                elif a == pivot:
                    ms.append(a)
                elif a > pivot:
                    larger.append(a)
            # return [*quick_sort(smaller), *equal, *quick_sort(larger)]
            
            # ê·¸ëŸ°ë° ì´í€„ì€ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ì§€? ì¼ë‹¨ ë²„ë ¤ì•¼ í•˜ë‚˜? ì•„ ê·¸ë˜ì„œ unstableì´ ëêµ¬ë‚˜.
            if smaller:
                s.append(smaller)
            # Aë¥¼ smallerë¡œ ì—…ë°ì´íŠ¸í•˜ê³  í•¨ìˆ˜ì˜ ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.X 
            # smallerë¥¼ ìŠ¤íƒì— í‘¸ì‹œí•´ì•¼ í•˜ë‚˜?
            if larger:
                s.append(larger)
            A = s.popleft()
            print(f'popping: {A}')

            
            continue # breakí•œ ë‹¤ìŒ ì´ìƒí•œë°ë¡œ ì í”„í•˜ëŠ”ë°. ì•„ ì •ìƒì´êµ¬ë‚˜. 
        print(result)
        break

quick_sort(arr)

```

ë„ˆë¬´ ì‹œê°„ì„ ë§ì´ ì¨ì„œ ì¼ë‹¨ ì´ë§Œí¼ í•˜ê³  ê·¸ëƒ¥ ë‹¤ìŒ ê°œë…ìœ¼ë¡œ ë„˜ì–´ê°‘ì‹œë‹¤. 

# Designing Algorithms 

> ê°œêµ¬ì½”ë¡œ ì½ìœ¼ì‹œì£ 

## ê°œêµ¬ì½”1. 

### ê°œë…: incremental methods vs divide and conquer

insertion sort uses the incremental methods.

### êµ¬í˜„

ì—†ìŒ

### ì½”ë©˜íŠ¸

ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë‘ê°€ì§€ ë°©ì‹ ë¶„ë¥˜ë¥¼ ì´ì œì•¼ ì•Œê²Œ ëœ ëŠë‚Œ. incremental methodsì™€ divide and conquer.

## ê°œêµ¬ì½”2.

### ê°œë…: Advantage of the algorithm following divide and conquer method is that analyzing its running time is often straightforward.

### êµ¬í˜„: 

ì—†ìŒ

### ì½”ë©˜íŠ¸

ë¶„í• ì •ë³µì€ ë©”ì„œë“œê°€ ë” ë³µì¡í•´ë³´ì´ì§€ë§Œ ì˜¤íˆë ¤ ì‹¤í–‰ ì‹œê°„ì„ ë” ëª…í™•íˆ ê³„ì‚°í•  ìˆ˜ ìˆë‹¤ê³  í•œë‹¤. ì™œ?

> ì¢‹ì€ ì§ˆë¬¸ì´ì—ìš”. â€œë¶„í• ì •ë³µ(Divide and Conquer)â€œì´ ì‹¤í–‰ ì‹œê°„ì´ ë” ëª…í™•í•˜ê²Œ ê³„ì‚°ë  ìˆ˜ ìˆëŠ” ì´ìœ ëŠ” ì£¼ë¡œ ë‹¤ìŒê³¼ ê°™ì€ êµ¬ì¡°ì  íŠ¹ì§• ë•ë¶„ì…ë‹ˆë‹¤:

## ê°œêµ¬ì½”3.

### ê°œë…: steps of divide and conquer method

in the divide-and-conquer method, if the problem is small enough-the base case- you just solve it directly without recursing. Otherwise - the recursive case -you perform three characterstic steps

- Divide: the problem into one or more subprolems that are smaller instances of the same problem
- Conquer: the subproblems by solving them recursively
- Combine: the subproblem solutions to form a solution to the original problem.
### êµ¬í˜„

Steps of merge sort

- Divide the subarray A[p:r] to be sorted into two adjacent subarray, each of half the size. To do so, compute the midpoint q of A[p:r](taking the average of p and r) and divide A[p:r]into subarrays A[p:q] and A[q+1:r].
- Conquer by sorting each of the two subarrays A[p:q] and A[q+1:r] recursively using merge sort.
- Combine by merging the two sorted subarrays A[p:q] and A[q+1:r] back into A[p:r], producing the sorted answer.
### ì½”ë©˜íŠ¸

ì´ë¯¸ divide ì‹œì ì—ì„œë„ ì£¼ì–´ì§„ ë°°ì—´ì´ ë¬´ì–¸ê°€ì˜ ë¶€ë¶„ ë°°ì—´ì´ë¼ëŠ” ì ì— ëˆˆì— ëˆë‹¤. ì–´ë–¤ ì§‘í•©ì„ ëŒ€ìƒìœ¼ë¡œ ì‘ì—…ì„ í•œë‹¤ê³  ì¹˜ë©´, ê·¸ ì§‘í•© ì „ì²´ë„ ê·¸ ì§‘í•©ì˜ ë¶€ë¶„ì§‘í•©ì´ë¼ëŠ” ì ì— ì£¼ëª©í•˜ëŠ” ê²ƒì²˜ëŸ¼ ëŠê»´ì§„ë‹¤. ì´ê²Œ ê²°ì • íŠ¸ë¦¬ë¥¼ ì´ìš©í•œ í’€ì´ì—ì„œë„ ë§ˆì°¬ê°€ì§€ê² ì§€?

> ì´ì•¼, ì •ë§ ë‚ ì¹´ë¡œìš´ í†µì°°ì´ì—ìš”(^0^). ë§ì•„ìš”â€”ë‹¹ì‹ ì´ ë§í•œ ê·¸ **â€œì „ì²´ë„ ë¶€ë¶„ì§‘í•©ì´ë‹¤â€**ë¼ëŠ” ê°œë…ì€ **ê²°ì • íŠ¸ë¦¬(decision tree)**ë‚˜ **ë¶„í• ì •ë³µ(divide and conquer)**ì˜ ì‚¬ê³ ë°©ì‹ì—ì„œ êµ‰ì¥íˆ í•µì‹¬ì ì¸ ì² í•™ì´ì—ìš”.

# Divide and Conquer

## ê°œêµ¬ì½” 1. Well defined vs ill defined recurrence.

### ê°œë…

There may be zero, one, or many functions that satisfy the statement of the recurrence. The recurrence is well defined if there is at least one function that satisfies it, and ill defined otherwise.

### ì½”ë©˜íŠ¸: ë¬´ìŠ¨ ì˜ë¯¸ì§€?

í•´ë‹¹ ë¬¸ì¥ì€ â€œì£¼ì–´ì§„ ì í™”ì‹ì„ ë§Œì¡±í•˜ëŠ” í•¨ìˆ˜(í˜¹ì€ ìˆ˜ì—´)ê°€ ì—†ì„ ìˆ˜ë„, í•˜ë‚˜ë§Œ ì¡´ì¬í•  ìˆ˜ë„, ì—¬ëŸ¬ ê°œ ì¡´ì¬í•  ìˆ˜ë„ ìˆë‹¤â€ëŠ” ëœ»ì…ë‹ˆë‹¤.

â€¢	ì–´ë–¤ ì í™”ì‹ì„ ì •ì˜í•  ë•Œ, ê·¸ ì í™”ì‹ì„ ë§Œì¡±í•  ìˆ˜ ìˆëŠ” í•´(í•¨ìˆ˜ë‚˜ ìˆ˜ì—´)ê°€ í•˜ë‚˜ë„ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´, ê·¸ ì í™”ì‹ ìì²´ê°€ ëª¨ìˆœì ì´ê±°ë‚˜ ë¶ˆê°€ëŠ¥í•œ ì •ì˜ê°€ ë˜ì–´ **â€˜ill defined(ì •ì˜ê°€ ì„±ë¦½í•˜ì§€ ì•ŠëŠ”ë‹¤)â€™**ë¼ê³  í•©ë‹ˆë‹¤.

â€¢	ë°˜ëŒ€ë¡œ ì ì–´ë„ í•˜ë‚˜ë¼ë„ ì í™”ì‹ì„ ë§Œì¡±í•˜ëŠ” í•¨ìˆ˜(í˜¹ì€ ìˆ˜ì—´)ê°€ ì¡´ì¬í•˜ë©´, ê·¸ ì í™”ì‹ì€ â€˜well defined(ì •ì˜ê°€ ì„±ë¦½í•œë‹¤)â€™ ë¼ê³  í•©ë‹ˆë‹¤.

â€¢	ê·¸ ì í™”ì‹ì„ ë§Œì¡±í•˜ëŠ” í•¨ìˆ˜ê°€ ìœ ì¼(ë‹¨ í•˜ë‚˜)í•  ìˆ˜ë„ ìˆê³ , ë‘˜ ì´ìƒ(ë¬´í•œíˆ ë§ì„ ìˆ˜ë„ ìˆìŒ) ì¡´ì¬í•  ìˆ˜ë„ ìˆì§€ë§Œ, ì ì–´ë„ í•˜ë‚˜ë¼ë„ ì¡´ì¬í•´ì•¼ ì í™”ì‹ì´ ì œëŒ€ë¡œ ì •ì˜ë˜ì—ˆë‹¤ê³  ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ìš”ì•½í•˜ìë©´,

â€¢	â€œzeroâ€: í•´ê°€ ì•„ì˜ˆ ì—†ëŠ” ê²½ìš° â†’ ì í™”ì‹ì´ ëª¨ìˆœì´ë¯€ë¡œ ill defined(ì •ì˜ê°€ ì„±ë¦½í•˜ì§€ ì•ŠìŒ)

â€¢	â€œoneâ€: í•´ê°€ ì •í™•íˆ í•˜ë‚˜ ìˆëŠ” ê²½ìš° â†’ well defined(ì •ì˜ê°€ ì„±ë¦½í•¨)

â€¢	â€œmanyâ€: í•´ê°€ ì—¬ëŸ¬ ê°œ ì¡´ì¬í•˜ëŠ” ê²½ìš° â†’ ì—­ì‹œ well defined(ì •ì˜ê°€ ì„±ë¦½í•¨)

ê²°êµ­ â€œí•´ê°€ ë‹¨ í•˜ë‚˜ë¼ë„ ì¡´ì¬í•˜ëŠ”ê°€?â€ê°€ â€˜well definedâ€™ì˜ ê¸°ì¤€ì´ ëœë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.

## ê°œêµ¬ì½” 2.  Algorithmic recurrences

### ê°œë…

A recurrence T(n) is algorithmic if, for every sufficient large threshold constant $n_0>0$, the following two properties hold:

1. For all n < n_0, we have T(n) = O(1)
1. For all n \ge n_0, every path of recursion terminates in a defined base case within a finite number of recursive invocations.
### ê°œë…: Break down

- Why would a recurrence T(n) that represents a (correct) divide-and-conquer algorithmâ€™s worst-case running time satisfy these properties for all sufficiently large threshold constants? (ì™œ ì í™”ì‹ì€ ìœ„ ì¡°ê±´ë§Œ ë§Œì¡±í•´ë„ ì˜ì™¸ë¡œ ëª¨ë“  í° ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆëŠ”ê°€?)
- The first property says that there exist constants c1, c2 such that 0 < c1 â‰¤ T(n) â‰¤ c2 for n < n0. 
- For every legal input, the algorithm must output the solution to the problem itâ€™s solving in finite time. 
- Thus we can let c1 be the minimum amount of time to call and return from a procedure which must be positive, because machine instructions need to be executed to invoke a procedure.
- The running time of the algorithm may not be defined for some values of n if there are no legal inputs of that size, but it must be defined for at least one, or else the â€œalgorithmâ€ doesnâ€™t solve any problem.
- Thus we can let c2 be the algorithmâ€™s maximum running time on any input of size n < n0, where n0 is sufficiently large that the algorithm solves at least one problem of size less than n0.
- The maximum is well defined, since there are at most a finite number of inputs of size less than n0, and there is at least one if n0 is sufficiently large. 
- Consequently, T(n) satisfies the â€œfirst propertyâ€
- If the second property fails to hold for T(n), then the algorithm isnâ€™t correct, because it would end up in an infinite recursive loop or otherwise fial to compute a solution.
- Thus, it stands to reason that a recurrence for the worst-case running time of a correct divide-and-conquer algorithm would be â€œalgorithmicâ€.
### êµ¬í˜„: ì—†ìŒ

### ì½”ë©˜íŠ¸

1ë²ˆì§¸ ì¡°ê±´ì€ base case, 2ë²ˆì§¸ ì¡°ê±´ì€ recursion caseë¥¼ ì˜ë¯¸í•˜ëŠ”ê±° ê°™ë‹¤? ì•„ë‹ˆë‹¤. 2ë²ˆì§¸ ì¡°ê±´ì€ â€˜ìœ í•œë²ˆ ë‚´ë¡œâ€™ ì¬ê·€ê°€ ëë‚˜ëŠ” ì¡°ê±´ì„ ì˜ë¯¸í•œë‹¤. í•©ë‹¹í•œ ì…ë ¥ê°’ì˜ ê²½ê³„ì„ ì¸ n0ë¥¼ ë„˜ì–´ì„œëŠ” ì…ë ¥ì— ëŒ€í•´ì„œëŠ”, ëª¨ë“  ì¬ê·€ê°€ ì œê±°ëœë‹¤ëŠ” ëœ»ì´ë‹¤.

### ìì„¸í•œ ì„¤ëª…

ë‘ ì¡°ê±´ì„ â€œ1. ë² ì´ìŠ¤ ì¼€ì´ìŠ¤â€ì™€ â€œ2. ì¬ê·€ê°€ ìœ í•œ ë‹¨ê³„ ë‚´ì— ë² ì´ìŠ¤ ì¼€ì´ìŠ¤ë¡œ ë„ë‹¬í•¨ì„ ë³´ì¥í•˜ëŠ” ì¡°ê±´â€ ì •ë„ë¡œ í•´ì„í•˜ì‹œë©´ ë©ë‹ˆë‹¤. ë‹¤ë§Œ ì—„ë°€íˆëŠ”,

1.	(ë² ì´ìŠ¤ ì¼€ì´ìŠ¤ë¡œì„œì˜ O(1) ì¡°ê±´)

â€œìƒìˆ˜ n_0â€ë³´ë‹¤ ì‘ì€ ëª¨ë“  nì— ëŒ€í•´ T(n) = O(1) ì´ë¼ëŠ” ê²ƒì€,

â€˜n_0â€™ ë¯¸ë§Œ ì˜ì—­(ì¦‰ ì¶©ë¶„íˆ ì‘ì€ ë¬¸ì œ í¬ê¸°)ì— ëŒ€í•´ì„œëŠ” ìƒìˆ˜ ì‹œê°„ì— í•´ê²°ì´ ê°€ëŠ¥í•˜ë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.

ë³´í†µ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ ì‹œ, ë¬¸ì œ í¬ê¸°ê°€ ì¶©ë¶„íˆ ì‘ì•„ì§€ë©´(ì˜ˆ: n = 1 í˜¹ì€ nì´ ì‘ì„ ë•Œ)

ì¬ê·€ë¥¼ ë©ˆì¶”ê³  ì§ì ‘(ìƒìˆ˜ ì‹œê°„) ì²˜ë¦¬í•˜ëŠ” â€œë² ì´ìŠ¤ ì¼€ì´ìŠ¤â€ì™€ ëŒ€ì‘í•©ë‹ˆë‹¤.

2.	(ì¬ê·€ í˜¸ì¶œì´ ìœ í•œ ë²ˆ ì•ˆì— ëë‚¨ì„ ë³´ì¥)

â€œn_0 ì´ìƒì˜ ëª¨ë“  nì— ëŒ€í•´, ì–´ë–¤ ê²½ë¡œë¡œ ì¬ê·€ í˜¸ì¶œì„ íƒ€ê³  ë‚´ë ¤ê°€ë„

ìœ í•œ íšŸìˆ˜ ì•ˆì— ì •ì˜ëœ ë² ì´ìŠ¤ ì¼€ì´ìŠ¤ë¡œ ë„ë‹¬â€í•œë‹¤ëŠ” ê²ƒì€,

ë¬¸ì œ í¬ê¸°ê°€ ì¶©ë¶„íˆ í° ê²½ìš°ì—ë„ ì¬ê·€ê°€ ë¬´í•œíˆ ì´ì–´ì§€ì§€ ì•Šê³ 

ë°˜ë“œì‹œ ë” ì‘ì€ ë¬¸ì œë¡œ ë‚´ë ¤ê°€ì„œ ê²°êµ­ (1)ë²ˆì˜ ë² ì´ìŠ¤ ì¼€ì´ìŠ¤ë¥¼ ë§Œë‚˜ê²Œ ëœë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.

ì¦‰ ì˜ ì •ì˜ëœ ì¬ê·€ êµ¬ì¡°(well-founded recursion)ë¼ëŠ” ì ì„ ë³´ì¥í•©ë‹ˆë‹¤.

ì •ë¦¬í•˜ë©´,

â€¢	ì¡°ê±´ (1): â€œì¶©ë¶„íˆ ì‘ì€ ì…ë ¥ì— ëŒ€í•´ì„ , T(n)ì„ ìƒìˆ˜ ì‹œê°„ìœ¼ë¡œ ì²˜ë¦¬í•œë‹¤(= ë² ì´ìŠ¤ ì¼€ì´ìŠ¤).â€

â€¢	ì¡°ê±´ (2): â€œì¶©ë¶„íˆ í° ì…ë ¥ì— ëŒ€í•´ì„œë„, ì¬ê·€ê°€ ê²°êµ­ (1)ì˜ ì¼€ì´ìŠ¤ê¹Œì§€ ìœ í•œ ë²ˆ ë§Œì— ë„ë‹¬í•œë‹¤.â€

ì´ë ‡ê²Œ ë‘ ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼, ì í™”ì‹(ì¬ê·€ì‹) ìì²´ê°€ í˜„ì‹¤ì ìœ¼ë¡œ êµ¬í˜„ ê°€ëŠ¥í•œ ì•Œê³ ë¦¬ì¦˜ì„ ë°˜ì˜í•˜ê²Œ ë˜ê³ , ì´ë¥¼ **â€˜algorithmic recurrence(ì•Œê³ ë¦¬ì¦˜ì  ì í™”ì‹)â€™**ë¼ê³  ë¶€ë¦…ë‹ˆë‹¤.

## ê°œêµ¬ì½” 3. ì¬ê·€ì‹ í’€ê¸°

### ê°œë…: ì¬ê·€ì‹ì„ í‘¸ëŠ” 4ê°€ì§€ ë°©ë²•ë¡ 

1. substitution method: you guess the form of a bound and then use mathematical induction to prove your guess correct and solve for constants. This method is perhaps the most robust method for solving recurrences, but it also requires you to make a good guess and to procedure an inductive proof.
1. recursion-tree method: models the recurrence as a tree whose nodes represent the costs incurred at various levels of the recursion. To solve the recurrence, ou determine the costs at each level and add them up, perhaps using techniques for bounding summations from Section A.2. Even if you donâ€™t usse this mehtod to formally prove a bound, it cna be helpful in guessing the form of the obund for use in the substitution method.
1. master method: the easiest method, wen it applies. It provides bounds for recurrences of the form T(n)=aT(n/b) + f(n), where a > 0 and b > 1 are constants and f(n) is a given â€œdrivingâ€ function. This type of recurrence tends to arise more frequently in the study of algorithms than any other. It characterizes a divide-and-conquer algorithm that creates a subproblems, each of which is 1/ times the size of the original problem, using f(n) time for the divide and combine steps. To apply the master method, you need to memorize three cases, but once you do, you can easily determine asymptotic bounds on running times for many divide-and-conquer algorithms
1. Akra-Bazzi method: a general method for solving divide-and-conquer recurrences. Although it involves calculus, it can be used to attack more complicated recurrences than those addressed by the master method.
## ê°œêµ¬ì½” 4.

### ê°œë…

### êµ¬í˜„

```plain text
MATRIX-MULTIPLICATION-RECURSIVE(A, B, C, n)
	if n == 1
	// Base case.
		c11 = c11 + a11*b11
		return
	//Divide
	partition A, B, and C into n/2 x n/2 submatrices
		A11, A12, A21, A22; B11, B21, B22
```

### ì½”ë©˜íŠ¸

# Graph

## ê°œêµ¬ì½”: í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ ë©”ì»¤ë‹ˆì¦˜

### ê°œë…: í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ ì‘ë™ ë°©ì‹

### êµ¬í˜„

```python
MST-KRUSKAL(G, w)
	A = Ã¸ # initializes set A
	for each vertex v in G.V # create |V| trees. (each tree contains one vertex.)
		MAKE-SET(v) 
	create a single list of the edges in G.E
	sort the list of edges into monotonically increasing order by weight w
	# examins edges in order of weight, from lowest to highest
	for each edge(u, v) taken from the sorted list in order 
		# checks  whether the endpoints u and v belong to the same tree
		if FIND-SET(u) â‰  FIND-SET(v) 
			# adds the edge (u, v) to A
			A = A with {(u,v)}
			# merges the vertices in the two trees
			UNION(u,v)
	return A
```

- Let C1 and C2 denote the two trees that are connected by (u, v)
- Since(u, v) must be a LIGHT-EDGE connecting C1 to some other tree, Corollary 21.2 implies that (u, v) is a safe for C1. ((C1, C2) ì€ cutì´ê³ , (u, v)ë¥¼ ì œì™¸í•œ ë‹¤ë¥¸ C1, C2ì˜ ê°„ì„ ë“¤ì€ ì„œë¡œë¥¼ ì¹¨ë²”í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— = connecting (u, v) doesnâ€™t destroy acyclic property)
- Kruskal uses a disjoint-set data structure to maintain several disjoint sets of elements. 
- Each set contains the vertices in one tree of the current forest. The operation FIND-SET(u) returns a representative element from the set that contains u.
- Thus, to determine whether two vertices u and v belong to the same tree, just test whether FIND-SET(u) equals FIND-SET(v) (if FIND-SET(u) â‰  FIND-SET(v) ~~~ )
### ì½”ë©˜íŠ¸

- êµ¬í˜„ì„ ìœ„í•´ì„œëŠ” disjoint setì— ëŒ€í•œ ì´ìœ ê°€ í•„ìš”í•˜ë‹¤.
## ê°œêµ¬ì½”: disjoint-set ìë£Œêµ¬ì¡°

### ê°œë…

ì„œë¡œì†Œ ì§‘í•©ì„ ê´€ë¦¬í•˜ëŠ” ìë£Œêµ¬ì¡°ë¡œ, ì£¼ë¡œ **ì§‘í•© ê°„ì˜ í•©ì¹˜ê¸°(Union)**ì™€ ì–´ëŠ ì§‘í•©ì— ì†í•´ ìˆëŠ”ì§€ ì°¾ê¸°(Find) ì—°ì‚°ì„ ë¹ ë¥´ê²Œ ìˆ˜í–‰

- ì„œë¡œì†Œ: ê³µí†µ ì›ì†Œê°€ í•˜ë‚˜ë„ ì—†ëŠ” ì§‘í•©(disjoint)
### êµ¬í˜„

```python
edges = [
    (1, 1, 2),  # (ê°€ì¤‘ì¹˜, ë…¸ë“œ1, ë…¸ë“œ2)
    (3, 1, 3),
    (2, 2, 3)
]

edges.sort()  # ê°€ì¤‘ì¹˜ ê¸°ì¤€ ì •ë ¬

parent = [i for i in range(4)]  # ì •ì  ê°œìˆ˜ + 1

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    x = find(x)
    y = find(y)
    if x != y:
        parent[y] = x

mst_cost = 0
for cost, a, b in edges:
    if find(a) != find(b):
        union(a, b)
        mst_cost += cost

print("ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ ê°€ì¤‘ì¹˜:", mst_cost)
```

### ì½”ë©˜íŠ¸

- find í•¨ìˆ˜ê°€ í•œì°¸ ì´í•´ê°€ ì•ˆ ëëŠ”ë°, parent ë¦¬ìŠ¤íŠ¸ì˜ ì˜ë¯¸ë¥¼ ì´í•´í•˜ëŠ”ê²Œ ì¤‘ìš”í•˜ë‹¤. idx 1ë¶€í„° ì‹œì‘í•˜ë©°, parent[idx] = valì€ ë²„í…ìŠ¤ idxì˜ ë¶€ëª¨ê°€ valì„ì„ ì˜ë¯¸í•œë‹¤. ë”°ë¼ì„œ idx==valì¼ ê²½ìš° (parent[x] == x) ê·¸ ë…¸ë“œëŠ” ë£¨íŠ¸ë…¸ë“œì´ê³ , find(x)ëŠ” ê²°ê³¼ì ìœ¼ë¡œ xì˜ ë£¨íŠ¸ë…¸ë“œë¥¼ ì—…ë°ì´íŠ¸ ë° ë¦¬í„´í•œë‹¤.
- ì„œë¡œ ë‹¤ë¥¸ ë£¨íŠ¸ë¥¼ ê°€ì§„ë‹¤ë©´ â†’ ë‹¤ë¥¸ ì§‘í•©ì´ë¯€ë¡œ í•©ì¹  ìˆ˜ ìˆìŒ, ê°™ì€ ë£¨íŠ¸ë¥¼ ê°€ì§„ë‹¤ë©´ â†’ ì´ë¯¸ ê°™ì€ ì§‘í•©ì´ë¯€ë¡œ í•©ì¹˜ë©´ ì‚¬ì´í´ì´ ìƒê¸¸ ìˆ˜ë„ ìˆìŒ
  - ì´ ë¹„êµ ë•ë¶„ì— ì„œë¡œ í•©ì³ë„ acyclicí•œ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ë§Œë“¤ ìˆ˜ ìˆê² êµ°. (ë£¨íŠ¸ê°€ ë‹¤ë¥´ë¯€ë¡œ ê° x, yê°€ ì†í•œ ì„œë¸ŒíŠ¸ë¦¬ëŠ” cut(partition respectful)ì´ë‹¤.)
  - ì—¬ê¸°ì— ê°€ì¤‘ì¹˜ ìˆœìœ¼ë¡œ ì—£ì§€ë¥¼ ì—°ì‚°í•˜ê¸°ë§Œ í•´ë„ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì˜ ê·¸ë¦¬ë””í•œ ì†ì„± ë•ë¶„ì— MSTë¥¼ êµ¬í•  ìˆ˜ ìˆê³ 
## ê°œêµ¬ì½”: í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ ì‹œê°„ ë³µì¡ë„ ë¶„ì„

### ê°œë…: 

### êµ¬í˜„:

### ì½”ë©˜íŠ¸

## ê°œêµ¬ì½”: ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì˜ ë™ì‘ 1

### ê°œë…

- Dijkstraâ€™s algorithm solves-
  - the single-source shortest-paths problem on a weighted,-
  - directed graph G = (V, E),-
  - but it requires nonnegative weights on all edges: w(u, v) â‰¥ 0 for each edge (, u) of E.
- As we shall see, with a good implementation, 
  - the running time of Dijkstraâ€™s algorithm is lower than that of the Bellman-Ford algorithm
### êµ¬í˜„

```python
DIJKSTRA(G, w, s)
	INITIALIZE-SINGLE-SOURCE(G, s)
	S = Ã¸
	Q = Ã¸
	for each vertex u in G.V
		INSERT(Q, u)
	while Q â‰  Ã¸
		u = EXTRACT-MIN(Q)
		S = S with {u}
		for each vertex v in G.Adj[u]
			RELAX(u, v, w)
			if the call of RELAX decreased v.d
				DECREASE-KEY(Q, v, v.d)
```

```python
import heapq

def dijkstra(graph, start):
    # ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ì— ëŒ€í•´ ìµœë‹¨ê±°ë¦¬ ê°’ì„ ë¬´í•œëŒ€ë¡œ ì´ˆê¸°í™”
    distances = {node: float('inf') for node in graph}
    # ì‹œì‘ ì •ì ê¹Œì§€ì˜ ê±°ë¦¬ëŠ” 0ìœ¼ë¡œ ì„¤ì •
    distances[start] = 0

    # ìš°ì„ ìˆœìœ„ í(ìµœì†Œ í™) ì¤€ë¹„
    # (í˜„ì¬ê¹Œì§€ì˜ ê±°ë¦¬, í˜„ì¬ ì •ì )
    queue = [(0, start)]
    
    # ë°©ë¬¸ ì—¬ë¶€ ì²´í¬ë¥¼ ìœ„í•œ ì§‘í•©
    visited = set()

    while queue:
        # íì—ì„œ ê±°ë¦¬ ê°’ì´ ê°€ì¥ ì‘ì€ ì •ì ì„ êº¼ëƒ„
        current_dist, current_node = heapq.heappop(queue)

        # ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œë¼ë©´ ë¬´ì‹œ
        if current_node in visited:
            continue
        
        # í˜„ì¬ ë…¸ë“œë¥¼ ë°©ë¬¸ ì²˜ë¦¬
        visited.add(current_node)

        # í˜„ì¬ ë…¸ë“œì™€ ì¸ì ‘í•œ ë…¸ë“œë“¤ì„ í™•ì¸
        for adjacent, weight in graph[current_node].items():
            distance = current_dist + weight
            
            # ê¸°ì¡´ ê±°ë¦¬ë³´ë‹¤ ë” ì§§ì€ ê²½ë¡œë¥¼ ì°¾ì•˜ì„ ê²½ìš° ê°±ì‹ 
            if distance < distances[adjacent]:
                distances[adjacent] = distance
                # ìš°ì„ ìˆœìœ„ íì— ìƒˆë¡œìš´ ê²½ë¡œ ì •ë³´ ì‚½ì…
                heapq.heappush(queue, (distance, adjacent))

    return distances

# ì˜ˆì‹œ ê·¸ë˜í”„ (u -> v: ê°€ì¤‘ì¹˜)
graph_example = {
    'A': {'B': 5, 'C': 2},
    'B': {'A': 5, 'D': 7, 'E': 1},
    'C': {'A': 2, 'D': 3},
    'D': {'B': 7, 'C': 3, 'E': 2},
    'E': {'B': 1, 'D': 2}
}

# 'A'ì—ì„œ ì‹œì‘í•˜ëŠ” ìµœë‹¨ê±°ë¦¬ ê³„ì‚°
shortest_distances = dijkstra(graph_example, 'A')
print(shortest_distances)
```

### ì½”ë©˜íŠ¸

ì•„ë˜ ê·¸ë¦¼ì—ì„œ ê³„ì†	Q = Ã¸
	for each vertex u in G.V
		INSERT(Q, u)

## ê°œêµ¬ì½”: ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì˜ ë™ì‘ 2

### ê°œë…

- Dijkstraâ€™s algorithm relaxes edges as shown in Figure 22.6.
- Line 1 initializes the d and Ï€ values in the usual way, 
  - INITIALIZE-SINGLE-SOURCE(G, s)
- and line 2 initializes the set S to the empty set.
  - 	S = Ã¸
- The algorithm maintains the invariant that Q = V - S at the start of each iteration of while loop of lines 6-12
  - 	while Q â‰  Ã¸
		u = EXTRACT-MIN(Q)
		S = S with {u}
		for each vertex v in G.Adj[u]
			RELAX(u, v, w)
			if the call of RELAX decreased v.d
				DECREASE-KEY(Q, v, v.d)
- Lines 3-5 initialize the min-priority Q to contain all the vertices in V.
  - 	Q = Ã¸
	for each vertex u in G.V
		INSERT(Q, u)
- Since S â‰  Ã¸ at that time, the invariant is true upon first reaching line 6.
  - ì™œ? ì´ê²ƒë„ ì´í•´ë¥¼ í•˜ë ¤ë©´ single source shortest-path ë¬¸ì œì˜ ê°œìš”ë¥¼ ì•Œì•„ì•¼ í• ë“¯.
- Each time through the while loop of lines 6-12, line 7 extracts a vertex u from Q = V - S and line 8 adds it to set S, thereby maintaining the invariant. 
  - The first time through this loop, u = s.
- Vertex u, therefore, has the smallest shortest-path estimate of any vertex in V - S.
- Then, lines 9-12 relax each edge (u, v) leaving u, thus updating the estimate v.d and the predecessor v.Ï€ if the shortest path to v foud so far improves by going through u.
- Whenever a relaxation step changes the d and Ï€ values, the call to DECREASSE-KEY in line 12 updates the min-priority queue.
- The algorithm never inserts vertices into Q after the for loop of lines 4-5, and each vertex is extracted from Q and added to S exactly once, so that the while loop of lines 6-12 iterates exactly |V| times.
### êµ¬í˜„

### ì½”ë©˜íŠ¸

- The algorithm maintains the invariant that Q = V - S at the start of each iteration of while loop of lines 6-12: ì—¬ê¸°ì„œ ë£¨í”„ê°€ Q = V - Së¥¼ ìœ ì§€í•œë‹¤ëŠ” ë‚´ìš©ì€ single source shortest path ì•Œê³ ë¦¬ì¦˜ì˜ ê°œìš”ì—ì„œ ë‚˜ì˜¤ëŠ” invarientì¸ì§€? ì™„ë²½í•œ ì´í•´ë¥¼ ìœ„í•´ì„œëŠ” ë”°ë¡œ ì°¾ì•„ë³¼ í•„ìš”ê°€ ìˆì–´ ë³´ì„.
## ì—°ìŠµ: ìˆ˜ë„ì½”ë“œ ë° íŒŒì´ì¬ ì½”ë“œ ì•”ê¸°

### 

## ëŒ€ë‹´: ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ ì¦ëª… 30ë¶„

### ì§ˆë¬¸: ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ ì¦ëª…ì„ ì•Œë ¤ì¤˜

### ëŒ€ë‹µ

ì¢‹ìŠµë‹ˆë‹¤! ì§€ê¸ˆ ì´ë¯¸ì§€ì—ëŠ” **Dijkstra ì•Œê³ ë¦¬ì¦˜ì˜ ì •ë‹¹ì„±(Theorem 22.6)**ì— ëŒ€í•œ ì¦ëª…ì´ ë‚˜ì™€ ìˆì–´ìš”. ì´ ì¦ëª…ì€ ã€Introduction to Algorithms (CLRS)ã€ì˜ 22ì¥ â€œSingle-Source Shortest Paths(ë‹¨ì¼ ì¶œë°œì  ìµœë‹¨ ê²½ë¡œ)â€ì—ì„œ ë‚˜ì˜¨ ë‚´ìš©ì…ë‹ˆë‹¤.

ğŸ” ì •ë¦¬: Dijkstra ì•Œê³ ë¦¬ì¦˜ì˜ ì •ë‹¹ì„± (Theorem 22.6)

ğŸ“Œ ë‚´ìš© ìš”ì•½ (í•œê¸€ ë²ˆì—­):

ì •ë¦¬:

ê°€ì¤‘ì¹˜ê°€ ìˆëŠ” ë°©í–¥ ê·¸ë˜í”„ G = (V, E)ì— ëŒ€í•´, ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ 0 ì´ìƒì´ê³ , ì‹œì‘ ì •ì ì´ sì¼ ë•Œ, Dijkstra ì•Œê³ ë¦¬ì¦˜ì„ ì‹¤í–‰í•˜ë©´ ì•Œê³ ë¦¬ì¦˜ì´ ì¢…ë£Œëœ í›„ ëª¨ë“  ì •ì  u \in Vì— ëŒ€í•´ ë‹¤ìŒì´ ì„±ë¦½í•©ë‹ˆë‹¤:

u.d = \delta(s, u)

ì—¬ê¸°ì„œ,

â€¢	u.d: ì•Œê³ ë¦¬ì¦˜ì´ ê³„ì‚°í•œ ì‹œì‘ì  së¶€í„° uê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ì¶”ì •ê°’

â€¢	\delta(s, u): ì‹¤ì œ ìµœë‹¨ ê±°ë¦¬

ì¦‰, ì•Œê³ ë¦¬ì¦˜ì´ êµ¬í•œ ê°’ì´ ì‹¤ì œ ìµœë‹¨ ê±°ë¦¬ì™€ ê°™ë‹¤ëŠ” ê±¸ ì¦ëª…í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

ğŸ“Œ ì¦ëª…ì˜ íë¦„ (ê°„ë‹¨ ì •ë¦¬)

ğŸ§  ì „ì²´ ì „ëµ: ìˆ˜í•™ì  ê·€ë‚©ë²•ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

â€¢	while ë£¨í”„ê°€ ë°˜ë³µë  ë•Œë§ˆë‹¤ Së¼ëŠ” ì§‘í•©ì— ì •ì ì´ í•˜ë‚˜ì”© ì¶”ê°€ë¨

(S: ìµœë‹¨ ê±°ë¦¬ê°€ í™•ì •ëœ ì •ì  ì§‘í•©)

â€¢	ê·€ë‚©ë²•ìœ¼ë¡œ Sì— ìˆëŠ” ì •ì ë“¤ì˜ d-ê°’ì´ í•­ìƒ ìµœë‹¨ ê±°ë¦¬ì™€ ê°™ë‹¤ëŠ” ê±¸ ì¦ëª…í•©ë‹ˆë‹¤.

âœ… ê¸°ë³¸ ë‹¨ê³„ (Base case):

â€¢	|S| = 0ì¼ ë•ŒëŠ” ì•„ë¬´ ì •ì ë„ í¬í•¨ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ìë™ìœ¼ë¡œ ì°¸.

â€¢	|S| = 1, ì¦‰ S = \{s\}ì¼ ë•ŒëŠ” s.d = \delta(s, s) = 0, ì°¸.

ğŸ” ê·€ë‚© ë‹¨ê³„:

â€¢	ê·€ë‚© ê°€ì •: v.d = \delta(s, v)ê°€ Sì˜ ëª¨ë“  ì •ì ì— ëŒ€í•´ ì„±ë¦½í•œë‹¤ê³  ê°€ì •.

â€¢	ì´ë•Œ ì•Œê³ ë¦¬ì¦˜ì€ V - S ì¤‘ì—ì„œ d-ê°’ì´ ê°€ì¥ ì‘ì€ uë¥¼ ì„ íƒí•´ì„œ Sì— ì¶”ê°€í•©ë‹ˆë‹¤.

â€¢	ì´ uì— ëŒ€í•´ u.d = \delta(s, u)ì„ì„ ë³´ì—¬ì•¼ í•©ë‹ˆë‹¤.

ğŸ”‘ í•µì‹¬ ì•„ì´ë””ì–´

â€¢	ë§Œì•½ sì—ì„œ uë¡œ ê°€ëŠ” ê²½ë¡œê°€ ì—†ë‹¤ë©´, \delta(s, u) = \infty, ê·¸ë¦¬ê³  u.dë„ ë¬´í•œì´ë¯€ë¡œ ë§ìŒ.

â€¢	ë§Œì•½ ê²½ë¡œê°€ ìˆë‹¤ë©´, ê·¸ë¦¼ì²˜ëŸ¼

â€¢	y: sì—ì„œ uë¡œ ê°€ëŠ” ìµœë‹¨ ê²½ë¡œ ì¤‘ Sì— ì†í•˜ì§€ ì•Šì€ ì²« ì •ì 

â€¢	x: yì˜ ë°”ë¡œ ì´ì „ ì •ì ìœ¼ë¡œ **S**ì— ì†í•¨

â€¢	ì•Œê³ ë¦¬ì¦˜ì€ x \to y ê°„ì„ ì„ ì´ë¯¸ ì™„í™”(relax)í–ˆê¸° ë•Œë¬¸ì—, y.d = \delta(s, y)ê°€ ì„±ë¦½í•¨

â€¢	uëŠ” d-ê°’ì´ ê°€ì¥ ì‘ì€ ì •ì ìœ¼ë¡œ ì„ íƒë˜ì—ˆê¸° ë•Œë¬¸ì—,

u.d \leq y.d, ê·¸ë¦¬ê³  \delta(s, y) \leq \delta(s, u)

ì´ê±¸ ì¢…í•©í•˜ë©´ ë‹¤ìŒì´ ë©ë‹ˆë‹¤:

\delta(s, y) \le \delta(s, u) \le u.d \le y.d = \delta(s, y)

ê·¸ë˜ì„œ ëª¨ë“  ë¶€ë“±í˜¸ê°€ ë“±í˜¸ë¡œ ë°”ë€Œê²Œ ë˜ê³ ,

ê²°êµ­:

u.d = \delta(s, u)

âœ… ê²°ë¡ 

Dijkstra ì•Œê³ ë¦¬ì¦˜ì€ í•­ìƒ ì •í™•í•œ ìµœë‹¨ ê²½ë¡œë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

ì´ ì¦ëª…ì€ ê·¸ ì •í™•ì„±ì„ ìˆ˜í•™ì ìœ¼ë¡œ ì—„ë°€í•˜ê²Œ ë³´ì¥í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

í•„ìš”í•˜ë‹¤ë©´:

â€¢	ì´ ë‚´ìš©ì„ ë„ì‹ìœ¼ë¡œ ì •ë¦¬í•´ì¤„ ìˆ˜ë„ ìˆê³ ,

â€¢	ì‹¤ì œ ì˜ˆì œë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€ ë³´ì—¬ì¤„ ìˆ˜ë„ ìˆì–´ìš”.

â€¢	ì•„ë‹ˆë©´ ë¼í…ìŠ¤ë¡œ ë…¼ë¬¸ í˜•ì‹ìœ¼ë¡œ ì •ë¦¬í•´ì¤„ ìˆ˜ë„ ìˆì–´ìš”.

ì›í•˜ì‹œëŠ” ë°©í–¥ì´ ìˆì„ê¹Œìš”? ğŸ˜Š

### ì§ˆë¬¸

uëŠ” d-ê°’ì´ ê°€ì¥ ì‘ì€ ì •ì ìœ¼ë¡œ ì„ íƒë˜ì—ˆê¸° ë•Œë¬¸ì—,

$$
u.d \leq y.d, ê·¸ë¦¬ê³  \delta(s, y) \leq \delta(s, u)Â 
$$

ì´ ë¶€ë¶„ì´ ì´í•´ê°€ ì•ˆ ë¼

### ë‹µë³€

ì¢‹ì•„ìš”! ê·¸ ë¶€ë¶„ì€ Dijkstra ì•Œê³ ë¦¬ì¦˜ì˜ í•µì‹¬ì ì¸ ë™ì‘ ì›ë¦¬ì™€ ê´€ë ¨ë˜ì–´ ìˆì–´ì„œ ì´í•´ê°€ ì¡°ê¸ˆ ê¹Œë‹¤ë¡œìš¸ ìˆ˜ ìˆì–´ìš”. ì°¨ê·¼ì°¨ê·¼ ì„¤ëª…í•´ë³¼ê²Œìš”.

ğŸŸ¡ ìƒí™© ì„¤ì •

â€¢	u: ì§€ê¸ˆ ë§‰ Extract-Minìœ¼ë¡œ ì„ íƒë˜ì–´ S ì§‘í•©ì— ì¶”ê°€ë˜ëŠ” ì •ì .

â€¢	y: ì‹œì‘ì  sì—ì„œ uê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œì—ì„œ Sì— ì²˜ìŒìœ¼ë¡œ í¬í•¨ë˜ì§€ ì•Šì€ ì •ì .

â€¢	x: yì˜ ë°”ë¡œ ì´ì „ ì •ì . ì¦‰, x \in S, y \notin S, ê·¸ë¦¬ê³  x \to yëŠ” ê²½ë¡œìƒ ì¡´ì¬í•˜ëŠ” ê°„ì„ .

ğŸ” í•µì‹¬ ë¬¸ì¥ ë‹¤ì‹œ ë³´ê¸°

uëŠ” d-ê°’ì´ ê°€ì¥ ì‘ì€ ì •ì ìœ¼ë¡œ ì„ íƒë˜ì—ˆê¸° ë•Œë¬¸ì—,

u.d \leq y.d, ê·¸ë¦¬ê³  \delta(s, y) \leq \delta(s, u)

ì´ê±¸ ì´í•´í•˜ë ¤ë©´ ë‘ ê°€ì§€ë¥¼ ë”°ë¡œ ë³¼ í•„ìš”ê°€ ìˆì–´ìš”:

â‘  ì™œ u.d \le y.dì¸ê°€?

â€¢	Dijkstra ì•Œê³ ë¦¬ì¦˜ì€ ì•„ì§ Sì— í¬í•¨ë˜ì§€ ì•Šì€ ì •ì ë“¤ ì¤‘ì—ì„œ d-ê°’ì´ ê°€ì¥ ì‘ì€ ì •ì ì„ ê³ ë¦…ë‹ˆë‹¤.

â€¢	ì´ê²Œ ë°”ë¡œ Extract-Min()ì´ í•˜ëŠ” ì¼ì´ê³ , ê·¸ ê²°ê³¼ë¡œ ì„ íƒëœ ê²Œ uì…ë‹ˆë‹¤.

â€¢	ê·¸ëŸ°ë° yëŠ” ì•„ì§ Sì— í¬í•¨ë˜ì§€ ì•Šì€ ì •ì ì´ë¯€ë¡œ, uì™€ ê°™ì€ í›„ë³´êµ°ì— ìˆì—ˆì£ .

â€¢	ê·¸ ì¤‘ì—ì„œ uê°€ ì„ íƒë˜ì—ˆë‹¤ëŠ” ê²ƒì€:

u.d \le y.d

ì¦‰, í˜„ì¬ê¹Œì§€ ì•Œê³  ìˆëŠ” ì •ë³´ìƒ uê¹Œì§€ ê°€ëŠ” ìµœë‹¨ ê±°ë¦¬ ì¶”ì •ê°’ì´ yë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ë‹¤ëŠ” ëœ»ì´ì—ìš”.

â‘¡ ì™œ \delta(s, y) \le \delta(s, u)ì¸ê°€?

â€¢	yëŠ” s \to u ìµœë‹¨ ê²½ë¡œì—ì„œ **S**ì— ì²˜ìŒìœ¼ë¡œ ì†í•˜ì§€ ì•Šì€ ì •ì ì…ë‹ˆë‹¤.

â€¢	ì´ ë§ì€, yëŠ” uë³´ë‹¤ ë¨¼ì € ë„ë‹¬í•´ì•¼ë§Œ uì— ë„ë‹¬í•  ìˆ˜ ìˆë‹¤ëŠ” ëœ»ì´ì—ìš”.

â€¢	ê·¸ëŸ¬ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ê²½ë¡œ ìƒ ê±°ë¦¬ ê´€ê³„ë„ ì´ë ‡ê²Œ ë˜ì£ :

\delta(s, y) \le \delta(s, u)

ì™œëƒí•˜ë©´ s \to y \to \dots \to u ì´ëŸ° ì‹ìœ¼ë¡œ ê²½ë¡œê°€ ì´ì–´ì§€ê³ , ëª¨ë“  ê°„ì„  ê°€ì¤‘ì¹˜ê°€ 0 ì´ìƒì´ê¸° ë•Œë¬¸ì´ì—ìš”.

ğŸ§  ìš”ì•½

â€¢	u.d \le y.d: ì•Œê³ ë¦¬ì¦˜ ìƒ uê°€ ìµœì†Ÿê°’ìœ¼ë¡œ ì„ íƒë˜ì—ˆê¸° ë•Œë¬¸ (ê·¸ë¦¬ë”” ì„ íƒ)

â€¢	\delta(s, y) \le \delta(s, u): yê°€ ìµœë‹¨ ê²½ë¡œì—ì„œ uë³´ë‹¤ ë¨¼ì € ë‚˜ì˜¤ê¸° ë•Œë¬¸

í˜¹ì‹œ ì´ê±¸ ê·¸ë¦¼ìœ¼ë¡œ ë³´ê³  ì‹¶ìœ¼ì‹ ê°€ìš”?

ì•„ë‹ˆë©´ ì´ ë¶€ë¶„ì— ëŒ€í•´ì„œ ì½”ë“œ íë¦„ê³¼ í•¨ê»˜ ì„¤ëª…í•´ë“œë¦´ ìˆ˜ë„ ìˆì–´ìš”!

### ì§ˆë¬¸: ëª¨ë“  ë¶€ë“±ì‹ ê´€ê³„ë¥¼ ì •ë¦¬

### ëŒ€ë‹µ

ì•„ë˜ëŠ” Dijkstra ì•Œê³ ë¦¬ì¦˜ ì¦ëª… ê³¼ì •ì—ì„œ ìì£¼ ë“±ì¥í•˜ëŠ” ë„¤ ê°€ì§€ ê´€ê³„(ë¶€ë“±ì‹Â·ë“±ì‹)ì™€, ê·¸ ê°ê°ì´ ì„±ë¦½í•˜ëŠ” ì´ìœ ë¥¼ ê°„ë‹¨íˆ ì •ë¦¬í•œ ê²ƒì…ë‹ˆë‹¤. ë³´í†µì€

$$
\delta(s, y) \;\le\; \delta(s, u) \;\le\; u.d \;\le\; y.d
\quad\text{ë°}\quad
y.d = \delta(s, y)
$$

ì´ ìˆœì„œë¡œ ì—°ê²°í•˜ì—¬ â€œê²°êµ­ ëª¨ë‘ ê°™ì•„ì§„ë‹¤â€ë¼ëŠ” ë…¼ë¦¬ë¥¼ ì „ê°œí•©ë‹ˆë‹¤.

1)

$$
 \displaystyle \delta(s, y) \;\le\; \delta(s, u)
$$

> ì´ìœ :

> â€¢	ì¦‰ s \to yë¥¼ ê±°ì³ì•¼ uì— ë„ë‹¬í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ê²½ë¡œ ìƒì—ì„œ y

> â€¢	ëª¨ë“  ê°„ì„  ê°€ì¤‘ì¹˜ëŠ” 0 ì´ìƒì´ë¯€ë¡œ,

$$
\delta(s, y) + (\text{yì—ì„œ uê¹Œì§€ì˜ ê²½ë¡œ ê¸¸ì´}) \;=\; \delta(s, u)
$$

> ë”°ë¼ì„œ \delta(s, y) \le \delta(s, u)ê°€ ë©ë‹ˆë‹¤.

2) 

$$
\displaystyle \delta(s, u) \;\le\; u.d
$$

> ì´ìœ :

> â€¢	ì‹¤ì œ ìµœë‹¨ ê±°ë¦¬ \delta(s, u)ëŠ” ì´ â€œë°œê²¬ëœ ê²½ë¡œ ê±°ë¦¬â€ë³´ë‹¤ ë” ì‘ì•„ì§ˆ ìˆ˜ ì—†ê³ ,

> â€¢	ì•Œê³ ë¦¬ì¦˜ì´ ìŒìˆ˜ ê°€ì¤‘ì¹˜ê°€ ì—†ì„ ë•Œ í•­ìƒ â€œìµœë‹¨ ê±°ë¦¬ ì´ìƒì˜ ê°’â€ì„ ìœ ì§€(ë˜ëŠ” ì ì°¨ ê°±ì‹ )í•˜ê¸° ë•Œë¬¸ì—,

$$
\delta(s, u) \;\le\; u.d
$$

> ë¡œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

3)

$$
 \displaystyle u.d \;\le\; y.d
$$

> ì´ìœ :

> â€¢	y ì—­ì‹œ â€œì•„ì§ Sì— í¬í•¨ë˜ì§€ ì•Šì€â€ í›„ë³´ì´ë¯€ë¡œ,

$$
u.d \;\le\; y.d
$$

> ê°€ ì„±ë¦½í•©ë‹ˆë‹¤. (ì¦‰, â€œuê°€ ì„ íƒë˜ì—ˆë‹¤â€ = â€œu.dê°€ í›„ë³´ ì¤‘ ìµœì†Œâ€)

4) \displaystyle y.d = \delta(s, y)

> ì´ìœ :

> â€¢	(x, y)ë¥¼

> â€¢	ë”°ë¼ì„œ yëŠ” Dijkstra ì•Œê³ ë¦¬ì¦˜ì—ì„œ â€œì •í™•í•œ ê±°ë¦¬â€ê°€ ì—…ë°ì´íŠ¸ë˜ì–´ ìˆëŠ” ìƒíƒœë¼ëŠ” ëœ»ì…ë‹ˆë‹¤.

ìµœì¢… ê²°ë¡ : ëª¨ë‘ \;=\;

ìœ„ì˜ 4ê°€ì§€ ê´€ê³„ë¥¼ ì—°ê²°í•˜ë©´,

$$
\delta(s, y) \;\le\; \delta(s, u) \;\le\; u.d \;\le\; y.d
\quad\text{ì´ë©°}\quad
y.d = \delta(s, y).
$$

ê²°êµ­ ëª¨ë“  ë¶€ë“±í˜¸ê°€ ë“±í˜¸ë¡œ ë°”ë€Œì–´

$$
\delta(s, y) = \delta(s, u) = y.d = u.d
$$

ê°€ ë©ë‹ˆë‹¤. ê·¸ ê²°ê³¼, ìš°ë¦¬ê°€ ì›í•˜ëŠ”

$$
u.d = \delta(s, u)
$$

(ì¦‰, Dijkstra ì•Œê³ ë¦¬ì¦˜ì´ ìµœë‹¨ ê±°ë¦¬ $\delta(s, u)$ë¥¼ ì •í™•íˆ ì°¾ìŒ)ì´ ì„±ë¦½í•¨ì„ ë³´ì´ê²Œ ë©ë‹ˆë‹¤.

### ê·¸ë¦¼: ì…€í”„ ì„¤ëª…

![](./images/Screenshot_2025-04-01_at_1.43.45_PM.png)

### ì§ˆë¬¸: ê·¸ë ‡ë‹¤ë©´ ì§€ê¸ˆ uê°€ ìš°ì„ ìˆœìœ„ íì—ì„œ ë§‰ ë½‘ì€ ë…¸ë“œì¸ ê±´ê°€?

### ëŒ€ë‹µ

ë„¤, ë§ìŠµë‹ˆë‹¤. Dijkstra ì•Œê³ ë¦¬ì¦˜ì—ì„œ â€œuâ€ëŠ” ìš°ì„ ìˆœìœ„ í(ìµœì†Œ í™ ë“±)ì—ì„œ ì§€ê¸ˆ ë§‰ êº¼ë‚¸(Extract-Min) ì •ì ì…ë‹ˆë‹¤.

â€¢	ì•Œê³ ë¦¬ì¦˜ì—ì„œëŠ” ì•„ì§ ìµœë‹¨ê±°ë¦¬ê°€ í™•ì •ë˜ì§€ ì•Šì€(= Sì— ì†í•˜ì§€ ì•Šì€) ì •ì ë“¤ ì¤‘, d-ê°’ì´ ê°€ì¥ ì‘ì€ ì •ì ì„ ìš°ì„ ìˆœìœ„ íì—ì„œ êº¼ëƒ…ë‹ˆë‹¤.

â€¢	ì¦ëª…ì—ì„œ â€œuâ€ë¼ê³  í•˜ë©´, â€œì§€ê¸ˆ ë§‰ íì—ì„œ ìµœì†Œê°’ìœ¼ë¡œ ë½‘í˜€ Sì— ì¶”ê°€ë˜ëŠ” ì •ì â€ì„ ê°€ë¦¬í‚µë‹ˆë‹¤.

### ì§ˆë¬¸: s, x, y, u ì •ì˜ë¥¼ ì •ë¦¬

### ëŒ€ë‹µ

ì•„ë˜ëŠ” Dijkstra ì•Œê³ ë¦¬ì¦˜ì˜ ì •ë‹¹ì„±(ë˜ëŠ” ê´€ë ¨ ì¦ëª…)ì—ì„œ ìì£¼ ì–¸ê¸‰ë˜ëŠ” ë„¤ ì •ì (ê¸°í˜¸) s, x, y, uì— ëŒ€í•œ ì •ì˜/ì—­í• ì„ ê°„ë‹¨íˆ ì •ë¦¬í•œ ê²ƒì…ë‹ˆë‹¤.

1. s

â€¢	ì˜ë¯¸: ì‹œì‘ì (ì¶œë°œ ì •ì )

â€¢	ì„¤ëª…:

â€¢	ë‹¨ì¼ ì¶œë°œì  ìµœë‹¨ ê²½ë¡œ ë¬¸ì œ(SSSP)ì—ì„œ, ëª¨ë“  ìµœë‹¨ ê±°ë¦¬ë¥¼ ê³„ì‚°í•  ë•Œ ê¸°ì¤€ì´ ë˜ëŠ” ì •ì .

â€¢	Dijkstra ì•Œê³ ë¦¬ì¦˜ì€ sì—ì„œ ì¶œë°œí•´ ë‹¤ë¥¸ ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•˜ê³ ì í•œë‹¤.

2. u

â€¢	ì˜ë¯¸: ìš°ì„ ìˆœìœ„ íì—ì„œ ë§‰ êº¼ë‚¸(Extract-Min) ì •ì 

â€¢	ì„¤ëª…:

â€¢	ì•„ì§ ìµœë‹¨ ê±°ë¦¬ê°€ í™•ì •ë˜ì§€ ì•Šì€(= Sì— ì†í•˜ì§€ ì•Šì€) ì •ì ë“¤ ì¤‘, í˜„ì¬ d-ê°’ì´ ê°€ì¥ ì‘ì€ ì •ì ì„ ëœ»í•œë‹¤.

â€¢	ì•Œê³ ë¦¬ì¦˜ pseudocode ìƒì—ì„œ,

u \leftarrow \text{Extract-Min}(Q)

ë¡œ ë½‘íˆëŠ” ëŒ€ìƒì´ë‹¤.

â€¢	ì´ ì‹œì ì— uë¥¼ Sì— ì¶”ê°€í•˜ê³ , ê·¸ ì£¼ë³€ ì •ì ì„ ëŠìŠ¨í™”(relax)í•˜ì—¬ d-ê°’ì„ ê°±ì‹ í•œë‹¤.

3. y

â€¢	ì˜ë¯¸: s \to u ìµœë‹¨ ê²½ë¡œì—ì„œ ì²˜ìŒìœ¼ë¡œ Sì— ì†í•˜ì§€ ì•Šì€ ì •ì 

â€¢	ì„¤ëª…:

â€¢	uê¹Œì§€ ê°€ëŠ” ìµœë‹¨ ê²½ë¡œë¥¼ ë”°ë¼ê°ˆ ë•Œ, ì´ë¯¸ Sì— ì†í•œ ì •ì ë“¤ì„ ì§€ë‚˜ì¹˜ê³  ì²˜ìŒìœ¼ë¡œ ë§ˆì£¼ì¹˜ëŠ” â€œë¹„-Sâ€ ì •ì ì„ ë§í•œë‹¤.

â€¢	ì¦ëª…ì—ì„œëŠ” yë¥¼ í†µí•´ â€œì–´ë””ê¹Œì§€ ì´ë¯¸ ìµœë‹¨ ê±°ë¦¬ê°€ í™•ì •(= S)ëê³ , ì–´ë””ë¶€í„° ì•„ì§ ë¶ˆí™•ì •ì¸ì§€â€ë¥¼ êµ¬ë¶„í•  ìˆ˜ ìˆë‹¤.

â€¢	ê°€ë ¹ ê²½ë¡œê°€ s \to \dots \to x \to y \to \dots \to u í˜•íƒœë¡œ ì´ì–´ì§„ë‹¤ë©´, xëŠ” Sì— ì†í•´ ìˆê³ , yë¶€í„°ëŠ” ì•„ì§ Sì— ì†í•˜ì§€ ì•Šì€ ì²« ì •ì ì´ ëœë‹¤.

4. x

â€¢	ì˜ë¯¸: yì˜ ì§ì „ ì •ì ìœ¼ë¡œ, ì´ë¯¸ Sì— ì†í•´ ìˆëŠ” ì •ì 

â€¢	ì„¤ëª…:

â€¢	y ë°”ë¡œ ì•ì— ìˆëŠ” ì •ì ì´ë¯€ë¡œ, ê²½ë¡œìƒì—ì„œ x \to y ê°„ì„ ì´ ì¡´ì¬í•œë‹¤.

â€¢	ì´ë•Œ x \in Sì´ë¯€ë¡œ, x.d = \delta(s, x)ê°€ ì´ë¯¸ í™•ì •ëœ ìƒíƒœë‹¤ (ê·€ë‚© ê°€ì •).

â€¢	x, y ê°„ì„ ì´ ì™„í™”(relax)ë  ë•Œ, y.dê°€ ì •í™•í•œ ìµœë‹¨ ê±°ë¦¬ \delta(s, y)ë¡œ ê°±ì‹ ëœë‹¤ëŠ” ë…¼ë¦¬ë¥¼ ì“°ê²Œ ëœë‹¤.

ìš”ì•½

â€¢	s: ì¶œë°œ(ì‹œì‘) ì •ì 

â€¢	u: í˜„ì¬ ìš°ì„ ìˆœìœ„ íì—ì„œ ë½‘í˜€ Sì— í¸ì…ë˜ëŠ” ì •ì (â€œì´ë²ˆì— í™•ì •ë˜ëŠ”â€ ì •ì )

â€¢	y: s \to u ê²½ë¡œ ìƒì—ì„œ, ì²˜ìŒìœ¼ë¡œ Sì— ì•„ì§ ì†í•˜ì§€ ì•Šì€ ì •ì 

â€¢	x: yì˜ ë°”ë¡œ ì• ì •ì ìœ¼ë¡œ, ì´ë¯¸ Sì— í¬í•¨(ë”°ë¼ì„œ ìµœë‹¨ ê±°ë¦¬ í™•ì •)ë˜ì–´ ìˆëŠ” ì •ì 

ì´ êµ¬ì¡°ë¥¼ í†µí•´, Dijkstra ì•Œê³ ë¦¬ì¦˜ì˜ ê° ë‹¨ê³„(ì •ì  í™•ì •, ëŠìŠ¨í™”, ë¶€ë“±ì‹ ì¦ëª…)ê°€ ì–´ë–»ê²Œ ëŒì•„ê°€ëŠ”ì§€ ëª…í™•íˆ êµ¬ë¶„í•´ì„œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ì§ˆë¬¸: ì–¸ì–´ì ìœ¼ë¡œ ì •ë¦¬

### ëŒ€ë‹µ

ì•„ë˜ëŠ” Dijkstra ì•Œê³ ë¦¬ì¦˜ ì¦ëª…ì—ì„œ ë“±ì¥í•˜ëŠ” ë¶€ë“±ì‹ë“¤ì„, ìˆ˜í•™ì ìœ¼ë¡œ ë”°ì§€ì§€ ì•Šê³  ì–¸ì–´(ì„œìˆ )ì ìœ¼ë¡œ ìµœëŒ€í•œ í’€ì–´ì¨ ë³¸ ì„¤ëª…ì…ë‹ˆë‹¤.

(ì¦ëª… ë³¸ë¬¸ì—ì„œ ì“°ëŠ” ê¸°í˜¸ë“¤ì´ ìµìˆ™í•˜ì§€ ì•Šë”ë¼ë„, ìƒí™©ì„ â€˜ì´ì•¼ê¸°â€™ë¡œ ì´í•´í•  ìˆ˜ ìˆë„ë¡ í•´ë³¼ê²Œìš”.)

1.

$$
 \delta(s, y) \le \delta(s, u)
$$

> â€œì •ì  yëŠ” sì—ì„œ uê¹Œì§€ ê°€ëŠ” ê²½ë¡œë¥¼ ë”°ë¼ê°€ë‹¤ê°€ ì²˜ìŒìœ¼ë¡œ Sì— ì†í•´ ìˆì§€ ì•Šì€ ì •ì ì´ì•¼.

> ê²½ë¡œë¥¼ ìƒê°í•˜ë©´, ê²°êµ­ s \to yë¥¼ ê±°ì³ì•¼ë§Œ uì— ë„ë‹¬í•´.

> ê·¸ëŸ¬ë‹ˆê¹Œ sì—ì„œ yê¹Œì§€ì˜ ê±°ë¦¬(\delta(s,y))ê°€ sì—ì„œ uê¹Œì§€ì˜ ê±°ë¦¬(\delta(s,u))ë³´ë‹¤ ì ˆëŒ€ í´ ìˆ˜ëŠ” ì—†ì§€.

> ê²½ë¡œ ìƒì—ì„œ ì•ì— ìˆëŠ” ì •ì ì´ë‹ˆê¹Œ,

ì¦‰, â€œì •ì  yê°€ uë¡œ ê°€ëŠ” ê¸¸ëª©ì— ë¨¼ì € ì¡´ì¬â€í•˜ë¯€ë¡œ, ë‹¹ì—°íˆ \delta(s,y)ê°€ \delta(s,u)ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ë‹¤ëŠ” ê²ë‹ˆë‹¤.

(ìë™ì°¨ë¡œ â€˜ë„ì‹œ yâ€™ë¥¼ ì§€ë‚˜ â€˜ë„ì‹œ uâ€™ê¹Œì§€ ê°€ëŠ” ë„ì¤‘ì´ë¼ë©´, yê¹Œì§€ ê±°ë¦¬ê°€ uê¹Œì§€ ê±°ë¦¬ë³´ë‹¤ ì»¤ì§ˆ ìˆ˜ ì—†ë‹¤ëŠ” ì‹ì˜ ì§ê´€ê³¼ ê°™ìŠµë‹ˆë‹¤.)

2.

$$
 \delta(s, u) \le u.d
$$

> â€œ\delta(s,u)ëŠ” ì§„ì§œ(ì‹¤ì œ) ìµœë‹¨ ê±°ë¦¬ì•¼.

> ê·¸ëŸ°ë° Dijkstra ì•Œê³ ë¦¬ì¦˜ì—ì„œ ì“°ëŠ” u.dë¼ëŠ” ë³€ìˆ˜ëŠ”,

> â€˜ì§€ê¸ˆê¹Œì§€ ë°œê²¬ëœâ€™

> ìŒìˆ˜ ê°€ì¤‘ì¹˜ê°€ ì—†ìœ¼ë‹ˆê¹Œ, ì‹¤ì œ ìµœë‹¨ ê±°ë¦¬ë³´ë‹¤ ë” ì§§ì€ ê²½ë¡œê°€ ë‚˜ì˜¬ ë¦¬ê°€ ì—†ì§€.

> ê²°êµ­, ì‹¤ì œ ìµœë‹¨ ê±°ë¦¬(\delta(s,u))ë³´ë‹¤ ì‘ì•„ì§€ì§„ ì•Šìœ¼ë‹ˆê¹Œ,

\delta(s,u) \le u.d

> ë¼ê³  í•  ìˆ˜ ìˆì–´.â€

ì¡°ê¸ˆ ë” í‰ì´í•˜ê²Œ ë§í•˜ë©´, â€œì•Œê³ ë¦¬ì¦˜ì´ ì°¾ì€ ê²½ë¡œê°€ ìµœë‹¨ ê±°ë¦¬ë³´ë‹¤ â€˜ë” ì§§ì„ ìˆ˜â€™ëŠ” ì—†ë‹¤â€ëŠ” ê²ë‹ˆë‹¤.

(â€œë” í¬ê±°ë‚˜ ê°™ì„ ìˆ˜ë°–ì— ì—†ë‹¤â€ â†’ \delta(s,u) \le u.d.)

3. u.d \le y.d

> â€œDijkstra ì•Œê³ ë¦¬ì¦˜ì€ ì•„ì§ í™•ì •ë˜ì§€ ì•Šì€(= S ë°–ì— ìˆëŠ”) ì •ì ë“¤ ì¤‘,

d-ê°’ì´ ê°€ì¥ ì‘ì€ ì• ë¥¼ ê³¨ë¼ì„œ êº¼ë‚¸ë‹¨ ë§ì´ì•¼.

> ì§€ê¸ˆ ê·¸ê²Œ uë¼ëŠ” ì†Œë¦¬ê³ .

> ê·¸ëŸ°ë° yë„ ì•„ì§ Sì— í¬í•¨ ì•ˆ ëë‹¤ê³  í–ˆì–ì•„?

> ê·¸ëŸ¼ â€˜í›„ë³´â€™ëŠ” uë„ ìˆê³  yë„ ìˆëŠ”ë°, uê°€ ë¨¼ì € ì„ íƒëìœ¼ë‹ˆ, ë‹¹ì—°íˆ

u.d \le y.d

> ë¼ê³  ë³¼ ìˆ˜ ìˆì§€.â€

ì¦‰, â€œë‘˜ ë‹¤ ì¤„ ì„œ ìˆëŠ”ë°, uê°€ ë¨¼ì € ë½‘í˜”ë‹¤ë©´ uì˜ d-ê°’ì´ yì˜ d-ê°’ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì•„ì•¼ í•œë‹¤â€ëŠ” ë§ì…ë‹ˆë‹¤.

(ìµœì†Ÿê°’ì„ ë½‘ëŠ” ìš°ì„ ìˆœìœ„ í ì›ë¦¬ ê·¸ëŒ€ë¡œ.)

4. y.d = \delta(s, y)

> â€œyëŠ” sì—ì„œ uê¹Œì§€ ê°€ëŠ” ê²½ë¡œì—ì„œ ì²˜ìŒìœ¼ë¡œ S ë°–ì— ìˆëŠ” ì •ì ì´ë¼ê³  í–ˆì–´.

> ê·¸ëŸ°ë° y ì§ì „ì— ìˆëŠ” xëŠ” ì´ë¯¸ Sì— ì†í•´ ìˆìœ¼ë‹ˆê¹Œ,

xì˜ ê±°ë¦¬ê°’(= ì‹¤ì œ ìµœë‹¨ ê±°ë¦¬)ì€ ì´ë¯¸ ì •í™•í•´ì ¸ ìˆë‹¤ê³  ë´.

> Dijkstra ì•Œê³ ë¦¬ì¦˜ì€ ê°„ì„ ì„ â€˜ëŠìŠ¨í™”(relax)â€™í•˜ë©´ì„œ

> â€˜

> ê·¸ë˜ì„œ ê²°êµ­ y.dëŠ” ì´ë¯¸ \delta(s,y)ë‘ ê°™ê²Œ ì„¤ì •ë˜ì–´ ìˆì–´.â€

ì¦‰, â€œx\to y ì™„í™”ê°€ ì§„í–‰ëœ ê²°ê³¼, yì˜ ê±°ë¦¬ê°’ì€ ì‹¤ì œ ìµœë‹¨ ê±°ë¦¬ë¡œ ë§ì¶°ì¡Œì–´â€ë¼ëŠ” ì–˜ê¸°ì…ë‹ˆë‹¤.

(ìˆ˜í•™ì  ê·€ë‚©ë²•ì—ì„œ â€œxëŠ” ì´ë¯¸ ì œëŒ€ë¡œ ëœ ê±°ë¦¬â€ë¼ê³  ê°€ì •í•œ ìƒíƒœì´ë¯€ë¡œ, yë„ ìì—°ìŠ¤ëŸ½ê²Œ ì •í™•í•´ì¡Œë‹¤ëŠ” íë¦„.)

ì´ë ‡ê²Œ ì—°ê²°ëœë‹¤

1.	\delta(s, y) \le \delta(s, u)Â  (ê²½ë¡œ ìƒ ë¨¼ì € ìˆëŠ” ì •ì ì´ë‹ˆ ë” ì‘ì•„ì•¼ í•œë‹¤)

2.	\delta(s, u) \le u.d Â  Â  Â  Â  (ì§„ì§œ ìµœë‹¨ê±°ë¦¬ë³´ë‹¤ ë” ì§§ì„ ìˆ˜ëŠ” ì—†ìŒ â†’ â€œë” í¬ê±°ë‚˜ ê°™ì€â€)

3.	u.d \le y.dÂ  Â  Â  Â  Â  Â  Â  Â  Â  (ìš°ì„ ìˆœìœ„ íì—ì„œ ë¨¼ì € ë½‘íŒ uê°€ yë³´ë‹¤ d-ê°’ì´ ì‘ê±°ë‚˜ ê°™ì•„ì•¼ í•¨)

4.	y.d = \delta(s, y) Â  Â  Â  Â  Â  (ì´ë¯¸ ì™„í™”(relax)ë¡œ â€œì •í™•í•œ ê°’â€ì„ ê°–ê²Œ ëœ ìƒíƒœ)

í•œ ì¤„ë¡œ ìš”ì•½í•˜ë©´:

> â€œyëŠ” ê²½ë¡œì—ì„œ ì•ì— ìˆìœ¼ë‹ˆ \delta(s,y)ê°€ ì‘ë‹¤.

uëŠ” íì—ì„œ êº¼ëƒˆìœ¼ë‹ˆ d-ê°’ì´ ìµœì†Œì´ê³ , \delta(s,u)ëŠ” ì§„ì§œ ìµœë‹¨ê±°ë¦¬ë³´ë‹¤ ì‘ì•„ì§ˆ ìˆ˜ ì—†ì–´ì„œ,

> ê²°êµ­ \delta(s,y), \delta(s,u), y.d, u.dê°€

> ê·¸ë˜ì„œ u.d

ê²°ë¡ 

â€¢	ìˆ˜í•™ì ìœ¼ë¡œì•¼ â€œ\le \le \le \leâ€ í˜•íƒœë¥¼ ë³´ì—¬ì£¼ì§€ë§Œ,

â€¢	ì–¸ì–´ë¡œëŠ” â€œê²½ë¡œì˜ ìˆœì„œ(ë¨¼ì €/ë‚˜ì¤‘)â€, â€œì´ë¯¸ í™•ì •ëœ ì •ì  vs í™•ì • ì•ˆ ëœ ì •ì â€, â€œì•Œê³ ë¦¬ì¦˜ì´ ìµœì†Œ d-ê°’ ì •ì ì„ ê³ ë¥´ëŠ” ë°©ì‹â€ì´ë¼ëŠ” ì´ì•¼ê¸°ì  ë§¥ë½ìœ¼ë¡œ ì´í•´í•˜ë©´ ë©ë‹ˆë‹¤.

â€¢	ì´ë ‡ê²Œ í•´ì„œ Dijkstra ì•Œê³ ë¦¬ì¦˜ì´ ìµœë‹¨ ê±°ë¦¬ \delta(s,u)ë¥¼ ì •í™•íˆ ì°¾ëŠ”ë‹¤ëŠ” ê±¸ ë…¼ë¦¬ì ìœ¼ë¡œ ë’·ë°›ì¹¨í•©ë‹ˆë‹¤.

### ì§ˆë¬¸: ê²°ê³¼ì ìœ¼ë¡œ yì™€ uì˜ ìµœë‹¨ê±°ë¦¬ì™€ í‰ê°€ëœ ê°’ì´ ê°™ì•„ì§„ë‹¤. ë§ì§€?

### ëŒ€ë‹µ

ë„¤, ë§ìŠµë‹ˆë‹¤!

ê²°êµ­ ì¦ëª…ì˜ í•µì‹¬ì€

\delta(s,y) \;=\; y.d \quad\text{ê·¸ë¦¬ê³ }\quad \delta(s,u) \;=\; u.d

ë¼ëŠ” ë‘ ê±°ë¦¬(â€˜ì‹¤ì œ ìµœë‹¨ê±°ë¦¬â€™ì™€ â€˜ì•Œê³ ë¦¬ì¦˜ì´ êµ¬í•œ ê°’â€™)ê°€ ì„œë¡œ ë™ì¼í•´ì§„ë‹¤ëŠ” ì ì„ ë³´ì—¬ì£¼ëŠ” ê²ƒì…ë‹ˆë‹¤.

ê·¸ë¦¬ê³  ë¶€ë“±í˜¸ ì²´ì¸ì„ í†µí•´ ë§ˆì§€ë§‰ì—ëŠ”

\delta(s,y) \;=\; \delta(s,u) \;=\; y.d \;=\; u.d

ì²˜ëŸ¼ ëª¨ë‘ ê°™ì•„ì§„ë‹¤ëŠ” ê²°ë¡ ì— ì´ë¥´ê²Œ ë©ë‹ˆë‹¤.

## ê°œêµ¬ì½”: The structure of a shortest path - 1

### ê°œë…: í”Œë¡œì´ë“œ ì›Œì…œ ì•Œê³ ë¦¬ì¦˜ì˜ ê¸°ë³¸ì€, ìµœë‹¨ ë¶€ë¶„ ê±°ë¦¬ ë”í•˜ê¸° ìµœë‹¨ ë¶€ë¶„ ê±°ë¦¬ê°€ ì „ì²´ ìµœë‹¨ ê±°ë¦¬ë¼ëŠ” ê°„ë‹¨í•œ ë°œìƒì—ì„œ ì¶œë°œí•œë‹¤. 

- In the Floyd Warshal algorithm, we characterize the structure of a shortest path differently from how we characterized it in Section 23.1
- The Floyd-Warshall algorithm considers the intermediate vertices of a shortest path, where an intermediate vertex of a simple path = {v1, v2, â€¦, vL} is any vertex of p other than v1 or vL, that is, any vertex in the set{v2, v3, â€¦, vL-1}
- The Floyd-Warshall algorithm relies on the following observation.
  - Numbering the vertices of G by V = {1, 2, â€¦, n}, take a subset {1, 2, â€¦, k} of vertices for some 1 â‰¤ k â‰¤ n.
  - For any pair of vertices i, j in V, consider all paths from i to j whose intermediate vertices are all drawn from {1, 2, â€¦, k}, and let p be a minimum-weight path from among them. (Path p is simple)
  - The Floyd-Warshall algorithm exploits a relationship between path p and shortest paths from i to j with all intermediate vertices in the set {1, 2, â€¦, k - 1}. 
  - The details of the relationship depend on whether k is an intermediate vertex of p or not.
### êµ¬í˜„

- Optimal substructure used by the Floyd-Warshall algorithm. Path p is a shortest path from vertex i to vertex j, and k is the highest-numbered intermediate vertex of p. Path p1, the portion of path p from vertex i to vertex k, has all intermediate vertices in the set {1, 2, â€¦, k - 1}
- The same holds for path p2 from vertex k to vertex j.
- p1: all intermediate vertices in {1, 2, â€¦, k - 1}
- p2: all intermediate vertices in {1, 2, â€¦, k - 1}
![](./images/IMG_0122.png)

### ì½”ë©˜íŠ¸

ë¬´ìŠ¨ ë§ì¸ì§€ ë´ë„ë´ë„ ì´í•´ê°€ ì•ˆ ëœë‹¤. ë” ì‰½ê²Œ ì„¤ëª….

ì•„ì§ ìµìˆ™í•˜ì§€ ì•Šì€ ë¶„ë“¤ì€ â€œì •ì  kë¥¼ ì¤‘ê°„ ê²½ìœ ì§€ë¡œ ì“¸ ìˆ˜ë„ ìˆê³ , ì•ˆ ì“¸ ìˆ˜ë„ ìˆë‹¤â€ë¼ëŠ” ë§ì„ ë“¤ìœ¼ë©´ ê³§ë°”ë¡œ í—·ê°ˆë¦¬ê¸° ì‰¬ìš´ë°, ì‚¬ì‹¤ Floyd-Warshall ì•Œê³ ë¦¬ì¦˜ì€ â€œì •ì ë“¤ì„ í•˜ë‚˜ì”© ëŠ˜ë ¤ê°€ë©°, ê·¸ ì •ì ë“¤ì„ ì¤‘ê°„ ê²½ìœ ì§€ë¡œ ì“¸ ìˆ˜ ìˆëŠ” ìµœë‹¨ê²½ë¡œë¥¼ ê°±ì‹ í•˜ëŠ” ë°©ì‹â€ì´ë¼ê³  ìƒê°í•˜ë©´ í›¨ì”¬ ì‰½ìŠµë‹ˆë‹¤.

ì•„ë˜ì—ì„œëŠ” ì´ ê³¼ì •ì„ ìµœëŒ€í•œ ì¼ìƒì ì¸ ë¹„ìœ ë¡œ í’€ì–´ì„œ, ì™œ â€œì •ì  kë¥¼ ì¤‘ê°„ì— ì“´ë‹¤/ì•ˆ ì“´ë‹¤â€ë¼ëŠ” ë§ì„ í•˜ëŠ”ì§€, ê·¸ë¦¬ê³  ê·¸ê²Œ ì–´ë–»ê²Œ ìµœë‹¨ê²½ë¡œ ë¬¸ì œì™€ ì—°ê²°ë˜ëŠ”ì§€ ì°¨ê·¼ì°¨ê·¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

1. â€œì •ì  í•˜ë‚˜ì”© ì¶”ê°€í•´ ê°€ê¸°â€ ê´€ì 

1.	ì²˜ìŒì—ëŠ” ì–´ë–¤ ê²½ìœ ì§€ë„ ì“°ì§€ ì•ŠëŠ”ë‹¤ê³  ê°€ì •í•œë‹¤.

â€¢	ì¦‰, â€œì¤‘ê°„ ê²½ìœ ì§€ë¡œ ì“¸ ìˆ˜ ìˆëŠ” ì •ì ì´ ì „í˜€ ì—†ë‹¤ë©´, iì—ì„œ jë¡œ ê°€ëŠ” ìµœë‹¨ê²½ë¡œëŠ” â€˜ì§ì ‘ iì—ì„œ jë¡œ ê°€ëŠ” ê°„ì„ ì´ ìˆì„ ë•Œë§Œâ€™ ê°€ëŠ¥â€ì…ë‹ˆë‹¤.

â€¢	ì´ ìƒíƒœì—ì„œ êµ¬í•´ë†“ì€ (iâ†’j) ìµœë‹¨ê±°ë¦¬ë“¤ì„ d^{0}_{ij}ë¼ê³  í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ì—¬ê¸°ì„œ 0ì€ â€˜ì¤‘ê°„ ê²½ìœ ì§€ë¡œ ì“¸ ìˆ˜ ìˆëŠ” ì •ì ì´ ì•„ë¬´ê²ƒë„ ì—†ë‹¤â€™ëŠ” ëœ»)

â€¢	ë§Œì•½ iâ†’j ì§í†µ ê°„ì„ ì´ ì—†ìœ¼ë©´ â€œì•„ì˜ˆ ê°ˆ ìˆ˜ ì—†ìŒ(âˆë¡œ í‘œì‹œ)â€

â€¢	ì§í†µ ê°„ì„ ì´ ìˆìœ¼ë©´ ê·¸ ê°€ì¤‘ì¹˜ë¡œ ì´ˆê¸°í™”

2.	**ê·¸ ë‹¤ìŒ, ì •ì  1ë„ ì¤‘ê°„ ê²½ìœ ì§€ë¡œ â€œí—ˆìš©â€**í•´ ë´…ë‹ˆë‹¤.

â€¢	ì¦‰, iì—ì„œ jë¡œ ê°ˆ ë•Œ â€˜ì¤‘ê°„ì— ì •ì  1ì„ ê±°ì³ë„ ëœë‹¤ë©´â€™, ë” ì§§ì€ ê²½ë¡œê°€ ìƒê¸¸ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

â€¢	í—ˆìš© ì „(=ì •ì  0ê°œë§Œ ê²½ìœ  ê°€ëŠ¥) ìƒíƒœì—ì„œì˜ ìµœë‹¨ê²½ë¡œ vs. (iâ†’1) + (1â†’j) ê²½ë¡œ ì¤‘ ë” ì§§ì€ ìª½ì„ íƒí•´ d^{1}_{ij}ì— ì €ì¥í•©ë‹ˆë‹¤.

3.	ë˜ ì •ì  2ë„ ì¤‘ê°„ ê²½ìœ ì§€ë¡œ í—ˆìš©í•´ ë´…ë‹ˆë‹¤.

â€¢	ì´ì œëŠ” iì—ì„œ jë¡œ ê°ˆ ë•Œ â€˜ì •ì  1, 2 ì¤‘ ë§ˆìŒëŒ€ë¡œ ê³¨ë¼ ê²½ìœ â€™í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, iâ†’j ê²½ë¡œê°€ ë” ì§§ì•„ì§ˆ ê°€ëŠ¥ì„±ì´ ìƒê¹ë‹ˆë‹¤.

â€¢	ë‹¤ì‹œ â€œ(ê¸°ì¡´ì— êµ¬í–ˆë˜ ìµœë‹¨ê±°ë¦¬) vs. (iâ†’2 + 2â†’j)â€ ì¤‘ ë” ì‘ì€ ê°’ì„ íƒí•´ d^{2}_{ij}ë¥¼ ê°±ì‹ í•©ë‹ˆë‹¤.

4.	ê³„ì†í•´ì„œ k=3, 4, â€¦, nê¹Œì§€

â€¢	ì°¨ë¡€ë¡œ ì •ì ì„ í—ˆìš©í•´ë‚˜ê°€ë©´ì„œ, iì—ì„œ jë¡œ ê°€ëŠ” ê²½ë¡œê°€ ë” ìµœì í™”ë  ìˆ˜ ìˆëŠ”ì§€ë¥¼ ë§¤ë²ˆ ê°±ì‹ í•©ë‹ˆë‹¤.

â€¢	ê²°êµ­ k=nê¹Œì§€ ì§„í–‰í•˜ë©´ â€œëª¨ë“  ì •ì ì„ ì¤‘ê°„ ê²½ìœ ì§€ë¡œ ì“¸ ìˆ˜ ìˆëŠ”â€ ìƒíƒœì´ë¯€ë¡œ, ì´ë•Œì˜ d^{n}_{ij}ê°€ ê³§ iì—ì„œ jë¡œ ê°€ëŠ” ìµœë‹¨ê±°ë¦¬(ëª¨ë“  ê°€ëŠ¥í•œ ê²½ìœ ì§€ í—ˆìš©)ê°€ ë©ë‹ˆë‹¤.

ì´ ê³¼ì •ì„ í•œêº¼ë²ˆì— êµ¬í˜„í•˜ë©´, Floyd-Warshallì˜ 3ì¤‘ forë¬¸( â€œfor k in 1..nâ€, â€œfor i in 1..nâ€, â€œfor j in 1..nâ€ )ì´ ë‚˜ì˜¤ê³ ,

ê°±ì‹  ì‹ì´

$$
d_{ij}^{k}
\;=\;
\min\!\bigl( d_{ij}^{k-1},\, d_{i k}^{k-1} + d_{k j}^{k-1} \bigr)
$$

ê°€ ë˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

2. â€œkë¥¼ ì¤‘ê°„ì— ì“°ëŠ” ìµœë‹¨ê²½ë¡œ vs. ì•ˆ ì“°ëŠ” ìµœë‹¨ê²½ë¡œâ€

Floyd-Warshall ì•Œê³ ë¦¬ì¦˜ ì„¤ëª…ì—ì„œ ìì£¼ í•˜ëŠ” ë§ì´

> â€œkë²ˆ ì •ì ì„ ì¤‘ê°„ì— ê±°ì³¤ì„ ë•Œê°€ ë” ë¹ ë¥´ë©´ ê°±ì‹ í•˜ê³ , ì•„ë‹ˆë©´ ê·¸ëŒ€ë¡œ ë‘”ë‹¤.â€

ì¸ë°, ì´ê²ƒì„ **â€œê²½ìœ ì§€ë¡œ kë¥¼ ì¼ëƒ ì•ˆ ì¼ëƒâ€**ë¡œ ë‚˜ëˆ„ì–´ ìƒê°í•˜ëŠ” ì´ìœ ëŠ” ì´ë ‡ìŠµë‹ˆë‹¤.

â€¢	ì–´ë–¤ ìµœë‹¨ê²½ë¡œê°€ ìˆë‹¤ê³  ê°€ì •í•´ ë´…ì‹œë‹¤. ë§Œì•½ ì´ ìµœë‹¨ê²½ë¡œê°€ ì •ì  kë¥¼ ì „í˜€ ê±°ì¹˜ì§€ ì•ŠëŠ”ë‹¤ë©´, â€œkë¥¼ í—ˆìš©í•˜ê¸° ì „(=k-1ê¹Œì§€ì˜ ì •ì ë§Œ ê²½ìœ  ê°€ëŠ¥)â€ìœ¼ë¡œë„ ì´ë¯¸ êµ¬í•´ì¡Œì„ ê²ƒì…ë‹ˆë‹¤.

â€¢	ì¦‰, $\;d_{ij}^{k} = d_{ij}^{k-1}$ì™€ ê°™ì´ ê·¸ëŒ€ë¡œ ìœ ì§€ë©ë‹ˆë‹¤.

â€¢	ë°˜ë©´ ê·¸ ìµœë‹¨ê²½ë¡œê°€ â€œkë¥¼ ê¼­ ê±°ì¹˜ëŠ” ê²½ë¡œâ€ë¼ë©´, ê·¸ ê²½ë¡œë¥¼ iâ†’k êµ¬ê°„ê³¼ kâ†’j êµ¬ê°„ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆê³ , ê° êµ¬ê°„ì— ë“±ì¥í•˜ëŠ” ì¤‘ê°„ ì •ì ë“¤ì€ ë‹¹ì—°íˆ 1..k-1 ë²”ìœ„ì¼ ê²ƒì…ë‹ˆë‹¤.

â€¢	ê·¸ëŸ¬ë¯€ë¡œ iâ†’k, kâ†’jë¥¼ ê°ê° â€œk-1ê¹Œì§€ í—ˆìš©ë˜ëŠ” ìµœë‹¨ê²½ë¡œâ€ë¡œ ë³¼ ìˆ˜ ìˆê³ , â€œiâ†’k ìµœë‹¨ê±°ë¦¬ + kâ†’j ìµœë‹¨ê±°ë¦¬â€ê°€ iâ†’j ìµœë‹¨ê±°ë¦¬ê°€ ë©ë‹ˆë‹¤.

â€¢	ì´ ê²½ìš° 

$$
\;d_{ij}^{k} = d_{ik}^{k-1} + d_{kj}^{k-1}
$$

ì¦‰, â€œkë¥¼ ì“°ëƒ ì•ˆ ì“°ëƒâ€ ë‘ ê°€ì§€ ì¼€ì´ìŠ¤ ì¤‘ ë” ì‘ì€ ê°’ì„ íƒí•˜ë©´, ê·¸ê²ƒì´ ìµœì í•´ë¼ëŠ” ë…¼ë¦¬ë¡œ ì´ì–´ì§‘ë‹ˆë‹¤.

3. í•œ ë¬¸ì¥ìœ¼ë¡œ ìš”ì•½í•˜ê¸°

ê²°êµ­ Floyd-WarshallëŠ”,

> â€œì •ì ì„ í•˜ë‚˜ì”© â€˜ì“¸ ìˆ˜ ìˆëŠ” ê²½ìœ ì§€ ëª©ë¡â€™ì— ì¶”ê°€í•˜ë©´ì„œ, iâ†’j ìµœë‹¨ê±°ë¦¬ í…Œì´ë¸”ì„ ê°±ì‹ í•œë‹¤.

> ì´ë•Œ â€˜kë²ˆ ì •ì ì„ ê±°ì¹œ ê²½ë¡œâ€™ì™€ â€˜ê±°ì¹˜ì§€ ì•ŠëŠ” ê²½ë¡œâ€™ë¥¼ ë¹„êµí•´ì„œ, ë” ì§§ì€ ìª½ì„ ì·¨í•˜ëŠ” ë°©ì‹â€

ì´ë¼ê³  ë³´ì‹œë©´ ë©ë‹ˆë‹¤.

â€¢	ì™œ í•œ ë²ˆì— ì•ˆ í•˜ê³  ì¡°ê¸ˆì”© ëŠ˜ë ¤ê°€ë‚˜?

â€¢	ì´ë ‡ê²Œ í•´ì•¼ ë™ì  ê³„íšë²•(DP) í˜•íƒœì˜ ì í™”ì‹ì„ ì„¸ìš¸ ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

â€¢	â€œk-1ê¹Œì§€ ê²½ìœ  ê°€ëŠ¥í•˜ë‹¤ê³  í–ˆì„ ë•Œì˜ ìµœë‹¨ê±°ë¦¬ ì •ë³´â€ë¥¼ ì¬í™œìš©í•´ì•¼ ê³„ì‚°ì´ ê°„ë‹¨í•´ì§€ê³ , ì½”ë“œë„ 3ì¤‘ ë°˜ë³µë¬¸ìœ¼ë¡œ ê¹”ë”í•˜ê²Œ ì§¤ ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.

â€¢	ê²°ê³¼ì ìœ¼ë¡œ k=nê¹Œì§€ ê°€ë©´ â€œëª¨ë“  ì •ì ì„ ì¤‘ê°„ ê²½ìœ ì§€ë¡œ ì“¸ ìˆ˜ ìˆëŠ”â€ ì™„ì „í•œ ìµœë‹¨ê²½ë¡œê°€ êµ¬í•´ì§€ë¯€ë¡œ, ê° d^{n}_{ij}ê°€ ì‹¤ì œ ìµœë‹¨ê±°ë¦¬ê°€ ë©ë‹ˆë‹¤.

4. ê²°ë¡ ì ìœ¼ë¡œâ€¦

â€¢	ì²˜ìŒ ë³¼ ë•Œì—ëŠ” â€œê²½ìœ ì§€ë¥¼ ì •ì  ë²ˆí˜¸ ìˆœì„œë¡œ í•˜ë‚˜ì”© í—ˆìš©í•œë‹¤â€ëŠ” ì‚¬ê³ ë°©ì‹ì´ ì¢€ ë‚¯ì„¤ì–´ ë³´ì…ë‹ˆë‹¤.

â€¢	í•˜ì§€ë§Œ **â€œì •ì  kë¥¼ ì¶”ê°€í•  ë•Œë§ˆë‹¤, (iâ†’k) + (kâ†’j)ê°€ ë” ì´ë“ì¸ì§€ í™•ì¸í•œë‹¤â€**ë¼ëŠ” ê°„ë‹¨í•œ ê·œì¹™ì´ ìŒ“ì—¬, ëª¨ë“  i, j ìŒì— ëŒ€í•œ ìµœë‹¨ê±°ë¦¬ë¥¼ ì ì  ì •êµí•˜ê²Œ ì—…ë°ì´íŠ¸í•´ë‚˜ê°€ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.

â€¢	ì´ê±¸ 2ì°¨ì› í…Œì´ë¸”ë¡œ êµ¬í˜„í–ˆì„ ë•Œ ìƒê¸°ëŠ” ì í™”ì‹ì´ ë°”ë¡œ

,

$$
d_{ij}^{k} = \min \bigl( d_{ij}^{k-1},\, d_{ik}^{k-1} + d_{kj}^{k-1} \bigr)
$$

ë¼ëŠ” ê³µì‹ì¼ ë¿ì…ë‹ˆë‹¤.

ë”°ë¼ì„œ í•µì‹¬ì€,

> â€œkê¹Œì§€ì˜ ì •ì ì„ ê²½ìœ ë¡œ í—ˆìš©í–ˆì„ ë•Œ iâ†’j ìµœë‹¨ê²½ë¡œê°€ ë” ì¢‹ì•„ì§€ë©´ ê°±ì‹ , ì•„ë‹ˆë©´ ìœ ì§€â€

ë¼ëŠ” ë‹¨ìˆœí•œ ì•„ì´ë””ì–´ë¡œ ì´í•´í•˜ì‹œë©´ ë˜ê³ , â€œkë¥¼ ì¤‘ê°„ ê²½ìœ ì§€ë¡œ ì‹¤ì œë¡œ ì¼ëƒ/ì•ˆ ì¼ëƒë¥¼ ë‘ ê²½ìš°ë¡œ ë‚˜ëˆ  ë³¸ë‹¤â€ë¼ëŠ” ì„œìˆ ì€ ì´ ì•„ì´ë””ì–´ë¥¼ ì´ë¡ ì ìœ¼ë¡œ ì„¤ëª…í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” í‘œí˜„ì¼ ë¿ì…ë‹ˆë‹¤.

ì´ë ‡ê²Œ ìƒê°í•˜ì‹œë©´, ì™œ Floyd-Warshall ì•Œê³ ë¦¬ì¦˜ì—ì„œ â€˜ì •ì  ë²ˆí˜¸ë¥¼ í•˜ë‚˜ì”© ëŠ˜ë ¤ê°€ë©° ìµœë‹¨ê²½ë¡œ ì •ë³´ë¥¼ ê°±ì‹ â€™ í•˜ëŠ” ë°©ì‹ì„ ì“°ëŠ”ì§€ ì¢€ ë” ì‰½ê²Œ ì´í•´ë˜ì‹¤ ê²ƒì…ë‹ˆë‹¤.

### ì§ˆë¬¸

 intermediate vertexì˜ í›„ë³´ê°€ ë˜ëŠ” ë…¸ë“œ kë¥¼ ì •í•  ë•Œ ì•„ë˜ ë¬¸ì¥ê³¼ ê°™ì´ ì„¤ëª…í•˜ëŠ”ë°

- The Floyd-Warshall algorithm exploits a relationship between path p and shortest paths from i to j with all intermediate vertices in the set {1, 2, â€¦, k - 1}. 
ì´ë•Œ ì™œ k - 1ê¹Œì§€ i, jì˜ ì¤‘ê°„ ê²½ìœ ì§€ë¡œ ê³ ë ¤í•˜ëŠ” ê±°ì§€? kë„ ë´ì•¼í•˜ëŠ” ê±° ì•„ë‹Œê°€? 

Floyd-Warshall ì•Œê³ ë¦¬ì¦˜ì—ì„œ 

$$
\displaystyle d^{k}{ij} = \min \bigl(d^{k-1}{ij},\, d^{k-1}{i k} + d^{k-1}{k j}\bigr)
$$

 ê°™ì€ ì í™”ì‹ì„ ë³´ì…¨ë‹¤ë©´, í”íˆ

> â€œkë¼ëŠ” ì •ì ì„ ì¤‘ê°„ ê²½ìœ ì§€ë¡œ ìƒˆë¡œ í—ˆìš©í•œë‹¤ê³  í•  ë•Œ,

> (iâ†’k)ì™€ (kâ†’j) êµ¬ê°„ì€ k ì´ì „ì˜ ì •ì ë“¤(1..k-1)ë§Œì„ ì¤‘ê°„ì— ì“¸ ìˆ˜ ìˆëŠ” ìµœë‹¨ê²½ë¡œ ì •ë³´ë¡œë¶€í„° ê°€ì ¸ì˜¨ë‹¤.â€

ë¼ëŠ” ì„¤ëª…ì´ ë¶™ìŠµë‹ˆë‹¤. ì´ë•Œ â€œì™œ (iâ†’k)ë‚˜ (kâ†’j) êµ¬ê°„ì€ kê¹Œì§€ í—ˆìš©í•´ë„ ë˜ì§€ ì•ŠëŠëƒ?â€, â€œì™œ êµ³ì´ k - 1ê¹Œì§€ë§Œ ë³´ëŠëƒ?â€ í•˜ëŠ” ì˜ë¬¸ì´ ìƒê¸°ê¸° ì‰¬ìš´ë°, ì´ëŠ” ë™ì  ê³„íšë²•(DP) êµ¬ì¡°ìƒ â€œì´ë¯¸ ê³„ì‚°í•´ ë‘” ê²°ê³¼â€ë¥¼ í™œìš©í•˜ê¸° ìœ„í•´ì„œì…ë‹ˆë‹¤.

1. â€œë‹¨ê³„ë³„ë¡œ ì •ì ì„ í—ˆìš©â€í•˜ëŠ” Floyd-Warshallì˜ í•µì‹¬ ì•„ì´ë””ì–´

Floyd-Warshallì€ ì •ì ë“¤ì„ ì¤‘ê°„ ê²½ìœ ì§€ë¡œ ì ì§„ì ìœ¼ë¡œ í—ˆìš©í•´ë‚˜ê°€ëŠ” ë°©ì‹ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤.

1.	ì²˜ìŒ:

â€¢	d^{0}_{ij}ëŠ” â€œì¤‘ê°„ ê²½ìœ ì§€ë¥¼ ì „í˜€ ì•ˆ ì“´ë‹¤â€ëŠ” ê°€ì • í•˜ì—ì„œì˜ iâ†’j ìµœë‹¨ê±°ë¦¬ì…ë‹ˆë‹¤.

â€¢	ì¦‰, iì—ì„œ jë¡œ ê°€ëŠ” ì§ì ‘ ê°„ì„ ë§Œ ê³ ë ¤í•œ ê°’ì…ë‹ˆë‹¤. ì§í†µ ê°„ì„ ì´ ì—†ìœ¼ë©´ \infty.

2.	k=1ì¼ ë•Œ:

â€¢	ì´ì œ â€œì¤‘ê°„ ê²½ìœ ì§€ë¡œ 1ë²ˆ ì •ì ì„ ì“¸ ìˆ˜ë„ ìˆë‹¤â€ê³  í—ˆìš©í•©ë‹ˆë‹¤.

â€¢	ì¦‰, iì—ì„œ jê¹Œì§€ ê°€ëŠ” ë° ì •ì  1ì„ ê±°ì¹˜ëŠ” ê²½ë¡œê°€ ë” ì§§ë‹¤ë©´ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

â€¢	ì—…ë°ì´íŠ¸ê°€ ëë‚œ ê°’ì´ d^{1}_{ij}.

3.	k=2ì¼ ë•Œ:

â€¢	ì´ì œ â€œì¤‘ê°„ ê²½ìœ ì§€ë¡œ 1, 2ë²ˆ ì •ì ì„ ì“¸ ìˆ˜ ìˆë‹¤â€ê³  í—ˆìš©.

â€¢	(1)ì—ì„œ êµ¬í–ˆë˜ d^{1}_{\cdot\cdot}ì„ ì¬í™œìš©í•˜ì—¬, â€œ2ë²ˆì„ ìƒˆë¡œ ì¨ì„œ iâ†’2 + 2â†’j ê²½ë¡œê°€ ë” ì§§ì€ì§€â€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

â€¢	ê·¸ ê²°ê³¼ë¥¼ d^{2}_{ij}ì— ì €ì¥.

4.	ê³„ì†í•´ì„œ k=3, 4, â€¦, nê¹Œì§€

â€¢	ì´ëŸ° ì‹ìœ¼ë¡œ ì •ì ì„ í•˜ë‚˜ì”© ì¤‘ê°„ ê²½ìœ ì§€ë¡œ ì¶”ê°€í•  ë•Œë§ˆë‹¤ â€œì´ ì •ì ì„ ìƒˆë¡œ ì“´ ê²½ë¡œê°€ ë” ìœ ë¦¬í•œê°€?â€ë¥¼ í™•ì¸í•˜ì—¬ d^{k}_{ij}ë¥¼ ê°±ì‹ í•´ê°‘ë‹ˆë‹¤.

ê²°êµ­ \displaystyle d^{k}_{ij}ëŠ”

> ì •ì 

ì´ ë©ë‹ˆë‹¤.

2. â€œk - 1ê¹Œì§€ë§Œâ€ ì“°ëŠ” ì´ìœ 

(1) iâ†’kì™€ kâ†’jì˜ ê²½ë¡œë¥¼ êµ¬í•  ë•ŒëŠ” â€œì´ë¯¸ í™•ì •ëœâ€ ì •ë³´ë¥¼ í™œìš©

Floyd-Warshallì—ì„œ

$$
d^{k}{ij}
\;=\;
\min\!\Bigl(\,
d^{k-1}{ij},\;
d^{k-1}{i k} + d^{k-1}{k j}
\Bigr)
$$

ë¼ê³  ì“°ëŠ” ìˆœê°„,

â€¢	d^{k-1}_{i k}: â€œì •ì  \{1,\dots,k-1\}ê¹Œì§€ë§Œ ì“¸ ìˆ˜ ìˆëŠ” ìƒíƒœì—ì„œì˜ iâ†’k ìµœë‹¨ê±°ë¦¬â€

â€¢	d^{k-1}_{k j}: â€œì •ì  \{1,\dots,k-1\}ê¹Œì§€ë§Œ ì“¸ ìˆ˜ ìˆëŠ” ìƒíƒœì—ì„œì˜ kâ†’j ìµœë‹¨ê±°ë¦¬â€

ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. ì¦‰,

1.	(iâ†’k) ê²½ë¡œëŠ” â€œk ì´ì „ ë²ˆí˜¸ì˜ ì •ì ë“¤â€ê¹Œì§€ë§Œ ì¤‘ê°„ ê²½ìœ ì§€ë¡œ í—ˆìš©í•˜ëŠ” ìµœë‹¨ê²½ë¡œë¥¼ ì´ë¯¸ êµ¬í•´ ë‘ì—ˆë‹¤.â€

2.	(kâ†’j) ê²½ë¡œë„ ë§ˆì°¬ê°€ì§€ì´ë‹¤.

ì´ë ‡ê²Œ í•˜ëŠ” ì´ìœ ëŠ” ë™ì  ê³„íšë²•(DP)ì˜ ê¸°ë³¸ ì›ë¦¬ë¥¼ ì§€í‚¤ê¸° ìœ„í•´ì„œì…ë‹ˆë‹¤.

â€¢	ë§Œì•½ (iâ†’k) ê²½ë¡œë¥¼ êµ¬í•˜ë©´ì„œë„ ì´ë¯¸ â€œkë¥¼ ì¤‘ê°„ ê²½ìœ ì§€ë¡œ ì¨ë„ ëœë‹¤â€ê³  í—ˆìš©í•´ ë²„ë¦¬ë©´, iâ†’k ê²½ë¡œê°€ ë˜ kë¥¼ ê±°ì¹˜ëŠ” ìˆœí™˜ ë…¼ë¦¬(ì¬ê·€)ê°€ ë¼ ë²„ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ì¦‰, iâ†’kë¥¼ êµ¬í•˜ê¸° ìœ„í•´ kë¥¼ ì¤‘ê°„ì— ì“°ê³ , ë‹¤ì‹œ iâ†’kë¥¼ êµ¬í•˜ë ¤ë©´ kë¥¼ ë˜ ì¤‘ê°„ì— ì“°ê³ â€¦ ì´ëŸ° ì‹ìœ¼ë¡œ ëì—†ì´ ë°˜ë³µë  ìˆ˜ ìˆì–´, DPê°€ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

(2) â€œkë¥¼ ì§ì ‘ ì“°ëŠ”â€ ê²ƒì€ iâ†’jì—ì„œë§Œ ìƒˆë¡œ ê³ ë ¤

â€¢	iì—ì„œ jë¡œ ê°ˆ ë•Œ, â€œkë¥¼ í•œ ë²ˆ ë”± ì°ê³  ê°„ë‹¤â€ë¼ëŠ” ì¼€ì´ìŠ¤ë¥¼ ê³ ë ¤í•˜ëŠ” ì‹œì ì´ 

$$
\displaystyle d^{k}_{ij}
$$

ë¥¼ êµ¬í•  ë•Œì…ë‹ˆë‹¤.

â€¢	ê·¸ â€œkë¥¼ ì°ê¸° ì „ê¹Œì§€ (ì¦‰ iâ†’k êµ¬ê°„)â€ì™€ â€œkë¥¼ ì°ì€ í›„ì— (ì¦‰ kâ†’j êµ¬ê°„)â€ëŠ” ì´ë¯¸ ë‹¤ êµ¬í•´ì ¸ ìˆëŠ” d^{k-1}{i k}ì™€ d^{k-1}{k j}ë¥¼ ì´ìš©í•˜ë©´ ë©ë‹ˆë‹¤.

â€¢	ì´ë ‡ê²Œ í•´ì•¼ â€œëª¨ë“  i,j ìŒì— ëŒ€í•´ (iâ†’k + kâ†’j) ê²½ë¡œ ê°€ëŠ¥ì„±ì„ ë¹ ì§ì—†ì´ ê³ ë ¤â€í•˜ë©´ì„œë„, DP ê°’ ê°±ì‹ ì´ ì˜¬ë°”ë¥¸ ìˆœì„œë¡œ ì§„í–‰ë©ë‹ˆë‹¤.

3. ê°„ë‹¨íˆ ì •ë¦¬í•˜ë©´

â€¢	**â€œk - 1ê¹Œì§€ í—ˆìš©í•œë‹¤â€**ëŠ” ê²ƒì€, iâ†’kì™€ kâ†’jë¥¼ êµ¬í•  ë•Œ ì´ë¯¸ (k-1)ê¹Œì§€ ê³ ë ¤í•œ ìµœë‹¨ê±°ë¦¬ë¥¼ ì¬í™œìš©í•œë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.

â€¢	ê·¸ë¦¬ê³  â€œkë¥¼ ìƒˆë¡œ ì¤‘ê°„ ì •ì ìœ¼ë¡œ ì“´ë‹¤/ì•ˆ ì“´ë‹¤â€ë¥¼ ë¹„êµí•¨ìœ¼ë¡œì¨, iâ†’j ìµœë‹¨ê±°ë¦¬ë¥¼ ê°±ì‹ í•´ë‚˜ê°€ëŠ” ê²ƒì´ \displaystyle d^{k}_{ij}ì˜ ì •ì˜ì…ë‹ˆë‹¤.

â€¢	ë§Œì•½ iâ†’kë¥¼ êµ¬í•˜ëŠ” ê³¼ì •ì—ì„œ kê¹Œì§€ í—ˆìš©í•´ë²„ë¦¬ë©´, iâ†’k ê²½ë¡œ ì•ˆì—ì„œë„ kë¥¼ ì¬ê·€ì ìœ¼ë¡œ ë˜ ì¨ë²„ë¦¬ëŠ” ëª¨ìˆœì— ë¹ ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ê·¸ë˜ì„œ DPë¡œ êµ¬í•  ë•Œì—ëŠ” â€œ(iâ†’k)ì™€ (kâ†’j)ëŠ” ì˜¤ì§ k-1 ì´í•˜ ì •ì ë“¤ë¡œë§Œ ê²½ìœ  ê°€ëŠ¥â€í•˜ë‹¤ê³  ë‘ê³ , ìµœì¢…ì ìœ¼ë¡œ iâ†’jì—ì„œ â€œkë¥¼ í•œ ë²ˆ ì“°ëŠ”â€ ê²½ë¡œë¥¼ ê²€ì‚¬í•˜ëŠ” ê²Œ ì•ˆì „í•©ë‹ˆë‹¤.

4. ê²°ë¡ 

> â€œk-1ê¹Œì§€ í—ˆìš©ëœ ìµœë‹¨ê±°ë¦¬ ì •ë³´ë¥¼ ê°–ê³  iâ†’k, kâ†’jë¥¼ êµ¬í•œ ë’¤,

> kë¥¼ í•œ ë²ˆ ê²½ìœ í•´ì„œ iâ†’jë¥¼ ê°€ëŠ” ê²½ë¡œë¥¼ ì—…ë°ì´íŠ¸í•œë‹¤.â€

ì´ ë¡œì§ì´ Floyd-Warshallì˜ ë™ì  ê³„íš(DP) ì í™”ì‹ì´ë©°, ê·¸ êµ¬í˜„ìœ¼ë¡œ 3ì¤‘ forë¬¸ì´ ë‚˜ì˜¤ê²Œ ë©ë‹ˆë‹¤.

ë”°ë¼ì„œ ì§ˆë¬¸ì—ì„œ

> â€œì™œ kë„ ë´ì•¼ í•˜ëŠ” ê²ƒ ê°™ì€ë°, k - 1ê¹Œì§€ë§Œ i, jì˜ ì¤‘ê°„ ê²½ìœ ì§€ë¡œ ë³´ëŠ” ê±¸ê¹Œ?â€

ë¼ëŠ” ì˜ë¬¸ì´ ë“œëŠ” ê±´ ë‹¹ì—°í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì‹¤ì œë¡œëŠ”

1.	(iâ†’k), (kâ†’j) êµ¬ê°„ì—ì„œëŠ” â€œkë¥¼ ì“°ë©´ ì•ˆ ëœë‹¤.â€ (k-1ê¹Œì§€ë§Œ ì“°ëŠ” ê²½ë¡œ)

2.	iâ†’j ì „ì²´ ê²½ë¡œì—ì„œ â€œkëŠ” ìƒˆë¡œ ì¶”ê°€ í—ˆìš©ë˜ëŠ” ì •ì â€ì´ë¯€ë¡œ, â€œ(1)ì—ì„œ êµ¬í•œ iâ†’k + kâ†’jâ€ë¥¼ í•©ì³ì„œ iâ†’jë¥¼ ì—…ë°ì´íŠ¸í•œë‹¤.

ì‹ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ë³´ì•„ì•¼ ìˆœí™˜(ì¬ê·€) ì—†ì´ DPê°€ ëŒì•„ê°‘ë‹ˆë‹¤.

ì´ êµ¬ì¡° ë•ë¶„ì— Floyd-Warshall ì•Œê³ ë¦¬ì¦˜ì´

$$
d^{k}{ij} = \min( d^{k-1}{ij},\, d^{k-1}{i k} + d^{k-1}{k j} )
$$

ë¼ëŠ” ì í™”ì‹ì„ ê¹”ë”íˆ ì“¸ ìˆ˜ ìˆê²Œ ë˜ëŠ” ê²ƒì´ì£ .

## ê°œêµ¬ì½”: A recursive solution to the all-pairs shortest-paths problem

### ê°œë…: í”Œë¡œì´ë“œ ì›Œì…œ ì•Œê³ ë¦¬ì¦˜ì€ all-pairs shortest paths problem ë¬¸ì œì— ëŒ€í•œ ì¬ê·€ì ì¸ ì†”ë£¨ì…˜ì´ë‹¤.

- Let d_ij^(k) be the weight of a shortest path from vertex i to vertex j for which all intermediate vertices belong to the set {1, 2, â€¦, k} 
- When k = 0, a path from vertex i to vertex j with no intermediate vertex numbered higher than 0 has no intermediate vertices at all.
- Such a path has at most one edge, and hence d_{ij}^{(0)} = w_{ij}. 
- Following the above discussion, define d_{ij}^{(k)} recursively by 
 

### êµ¬í˜„

### ì½”ë©˜íŠ¸

ì±… ì• ë‚´ìš©ì„ ê±´ë„ˆë›°ì–´ì„œ, all-pairs shortest paths problemì˜ ì •ì˜ë¥¼ ì˜ ëª¨ë¥´ê² ë‹¤. 

### All-pairs shortest paths poblem

ì¢‹ì€ ì‹œì‘ì´ì—ìš”! ìš°ì„  ì§ˆë¬¸í•˜ì‹  all-pairs shortest paths problem (ëª¨ë“  ì •ì  ìŒ ìµœë‹¨ ê²½ë¡œ ë¬¸ì œ)ì´ë€ ë¬´ì—‡ì¸ì§€ ë¨¼ì € ì •ë¦¬í•´ë“œë¦´ê²Œìš”.

ğŸ§© All-Pairs Shortest Paths Problemì´ë€?

ì •ì˜:

ê·¸ë˜í”„ G = (V, E)ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ëª¨ë“  ì •ì  ìŒ (i, j) ì— ëŒ€í•´, iì—ì„œ jë¡œ ê°€ëŠ” ìµœë‹¨ ê²½ë¡œì˜ ê¸¸ì´ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

ì¦‰, ì •ì ì´ nê°œ ìˆìœ¼ë©´ ì´ nÃ—nê°œì˜ (i, j) ìŒì— ëŒ€í•´ ê°ê° ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•´ì•¼ í•©ë‹ˆë‹¤.

ğŸ“Œ ì˜ˆì‹œ

ì˜ˆë¥¼ ë“¤ì–´ ì •ì ì´ 4ê°œ ìˆê³ , ê° ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ ë‹¤ìŒê³¼ ê°™ë‹¤ê³  í•´ë³´ì£ :

ì´ì œ 1ì—ì„œ 3ìœ¼ë¡œ ê°€ëŠ” ìµœë‹¨ ê²½ë¡œëŠ” ì§ì ‘ ê°€ëŠ” ê°„ì„ ì´ ì—†ìœ¼ë‹ˆ, ì¤‘ê°„ ì •ì ì„ ê±°ì³ì•¼ í•˜ê² ì£ ? ì´ëŸ° ì‹ìœ¼ë¡œ ëª¨ë“  ìŒì— ëŒ€í•´ ê²½ë¡œë¥¼ ë‹¤ ê³„ì‚°í•˜ëŠ” ê²Œ ì´ ë¬¸ì œì˜ ëª©í‘œì…ë‹ˆë‹¤.

ğŸ“š ì™œ ì¬ê·€ì  í’€ì´ê°€ ê°€ëŠ¥í•œê°€?

í”Œë¡œì´ë“œ-ì›Œì…œ ì•Œê³ ë¦¬ì¦˜ì€ ë‹¤ìŒê³¼ ê°™ì€ ì¬ê·€ ê´€ê³„ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•©ë‹ˆë‹¤:

$$
d_{ij}^{(k)} = \min \left( d_{ij}^{(k-1)},; d_{ik}^{(k-1)} + d_{kj}^{(k-1)} \right) 
$$

ì„¤ëª…:

â€¢	kë²ˆ ì •ì ê¹Œì§€ë¥¼ ì¤‘ê°„ ì •ì ìœ¼ë¡œ í—ˆìš©í•œ ìƒíƒœì—ì„œ,

â€¢	iì—ì„œ jë¡œ ê°€ëŠ” ìµœë‹¨ ê²½ë¡œëŠ”

â€¢	kë¥¼ ê±°ì¹˜ì§€ ì•ŠëŠ” ê²½ë¡œ (d_{ij}^{(k-1)})ì™€

â€¢	kë¥¼ ê±°ì¹˜ëŠ” ê²½ë¡œ (d_{ik}^{(k-1)} + d_{kj}^{(k-1)}) ì¤‘

â€¢	ë” ì§§ì€ ìª½ì„ íƒí•˜ë©´ ë©ë‹ˆë‹¤.

ì´ê²Œ ì¬ê·€ì…ë‹ˆë‹¤. ì™œëƒí•˜ë©´ d_{ij}^{(k)}ë¥¼ êµ¬í•˜ë ¤ë©´ d_{ij}^{(k-1)}, d_{ik}^{(k-1)}, d_{kj}^{(k-1)ì„ ì•Œì•„ì•¼ í•˜ë‹ˆê¹Œìš”.

âœï¸ ì •ë¦¬

â€¢	ë¬¸ì œ ì •ì˜: ëª¨ë“  ì •ì  ìŒ (i, j) ì— ëŒ€í•´ ìµœë‹¨ ê²½ë¡œì˜ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ê²ƒ.

â€¢	í”Œë¡œì´ë“œ ì›Œì…œ: ì´ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ì •ì˜í•œ í›„, ë™ì  ê³„íšë²•ìœ¼ë¡œ í•´ê²°.

â€¢	ê¸°ë³¸ ì•„ì´ë””ì–´: â€œì§€ê¸ˆë³´ë‹¤ ë” ë§ì€ ì •ì ì„ ê±°ì¹  ìˆ˜ ìˆê²Œ ë˜ì—ˆì„ ë•Œ, ê²½ë¡œê°€ ë” ì§§ì•„ì§ˆ ìˆ˜ ìˆë‹¤!â€

ê¶ê¸ˆí•œ ì ì´ë‚˜, ì´ ì¬ê·€ ì •ì˜ë¥¼ ì½”ë“œë¡œ êµ¬í˜„í•˜ëŠ” ë° ë„ì›€ ë°›ê³  ì‹¶ë‹¤ë©´ ë§ì”€ ì£¼ì„¸ìš”!

## ê°œêµ¬ì½”: Computing the shortest-path weights bottom up

### ê°œë…

Decompose

- Based on recurrence, the bottom-up procedure FLOYD-WARSHALL computes the values d_{ij}^{(k)} in order of increasing values of k.
- Its input is an n x n matrix W defined as in equation 23.1
- The procedure returns the matrix D^{(n)} computed by the Floyd-Warshall algorithm for the graph in Figure 23.1.
- The running time of the Floyd-Warshall algorithm is determined by the triply nested for loops of lines 2-6.
- Because each execution of line 6 takes O(1) time, the algorithm runs in \theta(n^3) time.
- As in the final algorithm in Section 23.1, the code is tight, with no elaborate data structures, and so the ocnstant hidden in the \theta notation is small.
- Thus, the Floyd-Warshall algorithm is quite practical for een moderate-sized input graphs.
### êµ¬í˜„

```python
FLOYD-WARSHALL(W, n)
	D^(0) = W
	for k = 1 to n
		let D^(k) = (d_ij^(k)) be a new n by n matrix
		for i = 1 to n
			for j = 1 to n
				d_(ij)^(k) = min {d_ij^(k-1), d_ij^(k-1) + d_kj^(k-1)}
	return D^(n)
```

```python
def floyd_warshall(dist):
    """
    dist: 2ì°¨ì› ë¦¬ìŠ¤íŠ¸ í˜•íƒœì˜ ì¸ì ‘ í–‰ë ¬
          dist[i][j]ëŠ” i->jë¡œ ê°€ëŠ” ê°„ì„ ì˜ ê°€ì¤‘ì¹˜.
          ê²½ë¡œê°€ ì—†ë‹¤ë©´ float('inf') í˜¹ì€ ë§¤ìš° í° ê°’ìœ¼ë¡œ ì„¤ì •.

    ë°˜í™˜ê°’: ëª¨ë“  ì •ì  ìŒ (i, j)ì— ëŒ€í•œ ìµœë‹¨ ê±°ë¦¬ dist í…Œì´ë¸”
    """
    n = len(dist)
    # dist í…Œì´ë¸”ì„ ë³µì‚¬í•´ì„œ ì‚¬ìš©(ì›ë³¸ í›¼ì† ë°©ì§€)
    # ë§Œì•½ ì›ë³¸ ìˆ˜ì •ì´ ê´œì°®ë‹¤ë©´ ë”°ë¡œ ë³µì œí•˜ì§€ ì•Šì•„ë„ ë¨
    D = [row[:] for row in dist]
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                # ê¸°ì¡´ì˜ i->j ê±°ë¦¬ vs. i->k->jë¥¼ ê±°ì¹˜ëŠ” ìƒˆë¡œìš´ ê²½ë¡œ
                if D[i][k] + D[k][j] < D[i][j]:
                    D[i][j] = D[i][k] + D[k][j]

    return D

if __name__ == "__main__":
    # ì˜ˆì‹œ ì…ë ¥ (n=4, 4x4 ì¸ì ‘ í–‰ë ¬)
    # ì§í†µ ê²½ë¡œê°€ ì—†ìœ¼ë©´ float('inf')ë¡œ í‘œê¸°
    INF = float('inf')
    W = [
        [0,   5,   INF, 10],
        [INF, 0,   3,   INF],
        [INF, INF, 0,   1],
        [INF, INF, INF, 0]
    ]
    result = floyd_warshall(W)
    print("ìµœë‹¨ ê±°ë¦¬ ê²°ê³¼ í…Œì´ë¸”:")
    for row in result:
        print(row)
```

### ì½”ë©˜íŠ¸

ì—†ìŒ

### ì§ˆë¬¸: ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œëŠ” í”Œë¡œì´ë“œ ì›Œì…œ ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í•˜ì§€ ì•Šë‚˜?

ìš”ì :

â€¢	Floyd-Warshall ì•Œê³ ë¦¬ì¦˜ì€ **ëª¨ë“  ì •ì  ìŒ (i, j)**ì— ëŒ€í•œ ìµœë‹¨ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” O(n^3) ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.

â€¢	ê·¸ ê³¼ì •ì—ì„œ â€œì •ì  \{1,\dots,n\}â€ ì „ë¶€ë¥¼ ëŒ€ìƒìœ¼ë¡œ 3ì¤‘ ë£¨í”„ë¥¼ ì‹¤í–‰í•˜ê¸° ë•Œë¬¸ì—, ë‚´ë¶€ì ìœ¼ë¡œ ì¸ì ‘ í–‰ë ¬ í˜•íƒœ( n \times n 2ì°¨ì› ë°°ì—´ )ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ í›¨ì”¬ ìì—°ìŠ¤ëŸ½ìŠµë‹ˆë‹¤.

â€¢	ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ëŠ” ì¼ë°˜ì ìœ¼ë¡œ â€œê°„ì„ ì´ ë§ì§€ ì•Šì€ sparse ê·¸ë˜í”„ì—ì„œ, íŠ¹ì • ì •ì ì—ì„œì˜ íƒìƒ‰â€ì„ ë¹ ë¥´ê²Œ í•˜ê¸° ìœ„í•´ ì“°ëŠ” í‘œí˜„ì´ì§€ë§Œ, Floyd-Warshallì€ ê·¸ë˜í”„ êµ¬ì¡°ê°€ sparseì¸ì§€ denseì¸ì§€ ìƒê´€ì—†ì´ ëª¨ë“  ìŒì„ ëŒ€ìƒìœ¼ë¡œ ê³„ì‚°í•˜ë¯€ë¡œ, ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ê°€ ì„±ëŠ¥ ì´ì ì´ë‚˜ êµ¬í˜„ í¸ì˜ë¥¼ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.

1. ì™œ ì¸ì ‘ í–‰ë ¬ì„ ì‚¬ìš©í•˜ë‚˜?

1.	3ì¤‘ forë¬¸ì—ì„œ i, j, kë¥¼ ì „ë¶€ ìˆœíšŒ

â€¢	Floyd-Warshallì€

$$
\text{for } k \text{ in } 1..n:\quad
\text{for } i \text{ in } 1..n:\quad
\text{for } j \text{ in } 1..n:
d_{ij}^{(k)} = \min\!\bigl(d_{ij}^{(k-1)},\, d_{ik}^{(k-1)} + d_{kj}^{(k-1)}\bigr)
$$

ê°™ì€ ì‹ìœ¼ë¡œ ëª¨ë“  (i, j) ìŒì„ (k)ë³„ë¡œ ê°±ì‹ í•©ë‹ˆë‹¤.

â€¢	ë§¤ ë£¨í”„ì—ì„œ \;d[i][j], d[i][k], d[k][j] ë“±ì— ì¦‰ì‹œ ì ‘ê·¼(indexing)ì´ í•„ìš”í•©ë‹ˆë‹¤.

â€¢	ì¸ì ‘ í–‰ë ¬ì€ ì´ëŸ¬í•œ â€œëª¨ë“  ì •ì  ìŒâ€ ì ‘ê·¼ì— ìµœì í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

2.	ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¥¼ ì“°ë©´ ë§¤ë²ˆ íƒìƒ‰ì´ ì˜¤íˆë ¤ ë³µì¡

â€¢	ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ í˜•íƒœì—ì„œëŠ” â€œiê°€ kì™€ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ / kê°€ jì™€ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€â€ë¥¼ í™•ì¸í•˜ê±°ë‚˜, ê° ê°€ì¤‘ì¹˜ë¥¼ í™•ì¸í•˜ê¸° ìœ„í•´ ë¦¬ìŠ¤íŠ¸ ì „ì²´ë¥¼ ë’¤ì ¸ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ë˜í•œ Floyd-Warshallì˜ ëª©ì  ìì²´ê°€ â€œê·¸ë˜í”„ ì „ì²´ ìµœë‹¨ê±°ë¦¬ í…Œì´ë¸”â€ì´ê¸° ë•Œë¬¸ì—, ê²°êµ­ \;d[i][j]ë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ n \times n í¬ê¸°ì˜ 2ì°¨ì› ê³µê°„ì´ í•„ìš”í•©ë‹ˆë‹¤.

â€¢	ê·¸ëŸ¬ë‹¤ ë³´ë‹ˆ, ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ê°€ ì£¼ëŠ” â€˜ê³µê°„ ì ˆì•½â€™ ì´ì ì´ í¬ì„ë˜ê³ , ì˜¤íˆë ¤ êµ¬í˜„ë§Œ ë³µì¡í•´ì§‘ë‹ˆë‹¤.

3.	ë³µì¡ë„

â€¢	Floyd-Warshallì€ ê·¸ë˜í”„ê°€ **í¬ì†Œ(sparse)**ë“  **ë°€ì§‘(dense)**ì´ë“ , í•­ìƒ O(n^3) ì‹œê°„ë³µì¡ë„ë¥¼ ê°€ì§‘ë‹ˆë‹¤.

â€¢	ë”°ë¼ì„œ â€œê°„ì„ ì´ ì ì„ ë•Œ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¥¼ ì´ìš©í•´ ë” ë¹ ë¥´ê²Œ!â€ì™€ ê°™ì€ ê¸°ëŒ€íš¨ê³¼ëŠ” ì—†ìŠµë‹ˆë‹¤.

2. ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ ê·¸ë˜í”„ê°€ ì£¼ì–´ì¡Œë‹¤ë©´?

â€¢	ì—¬ì „íˆ Floyd-Warshallì„ ì“°ë ¤ë©´, ê²°êµ­ (i,j) ìŒì„ ì „ë¶€ ì²˜ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤.

â€¢	êµ¬í˜„ ë‹¨ê³„ì—ì„œ, ìš°ì„  â€œì¸ì ‘ ë¦¬ìŠ¤íŠ¸ â†’ ì¸ì ‘ í–‰ë ¬â€ í˜•íƒœë¡œ ë³€í™˜í•˜ëŠ” ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤.

1.	n\times n ë°°ì—´ distë¥¼ ë§Œë“¤ê³ , ì§í†µ ê°„ì„ ì´ ì—†ëŠ” ê³³ì€ infë¡œ ì„¤ì •.

2.	ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¥¼ ìˆœíšŒí•˜ë©°, dist[u][v] = w (uâ†’v ê°„ì„  ê°€ì¤‘ì¹˜ w) ì‹ìœ¼ë¡œ ì±„ì›Œ ë„£ê¸°.

3.	ê·¸ ë’¤ Floyd-Warshall ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©.

â€¢	ì´ë ‡ê²Œ í•˜ë©´ ì¶”ê°€ ë³€í™˜ ê³¼ì •ì´ O(n + E) ì •ë„ ë“¤ì§€ë§Œ, ê·¸ë˜í”„ ì „ì²´ì— ëŒ€í•´ ê·¸ë‹¤ì§€ í¬ì§€ ì•Šì€ ë¶€í•˜ì´ê³ , ì–´ì°¨í”¼ í”Œë¡œì´ë“œ-ì›Œì…œ ìì²´ê°€ O(n^3)ì´ë¯€ë¡œ í° ì°¨ì´ê°€ ì—†ìŠµë‹ˆë‹¤.

3. ê²°ë¡ 

> â€¢

> ì¸ì ‘ ë¦¬ìŠ¤íŠ¸

> â€¢	ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ ì£¼ì–´ì§„ ì…ë ¥ë„, ì‹¤ì œ ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í•  ë•ŒëŠ” ë³´í†µ

> â€œì¸ì ‘ ë¦¬ìŠ¤íŠ¸ â†’ ì¸ì ‘ í–‰ë ¬ ë³€í™˜â€ â†’ â€œFloyd-Warshall ì‹¤í–‰â€ ê³¼ì •ì„ ê±°ì¹©ë‹ˆë‹¤.

â€¢	ë”°ë¼ì„œ â€œì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ êµ³ì´ Floyd-Warshall ì•Œê³ ë¦¬ì¦˜ì„ ì§ì ‘ êµ¬í˜„â€í•˜ëŠ” ì¼ì€ ê±°ì˜ ì—†ë‹¤ê³  ë³´ì‹œë©´ ë©ë‹ˆë‹¤. (ê°€ëŠ¥í•˜ê¸´ í•˜ì§€ë§Œ, ë¶ˆí•„ìš”í•˜ê²Œ ë³µì¡í•´ì§ˆ ë¿ì…ë‹ˆë‹¤.)



