# [C] C programming language



> 개념과 이슈 트래킹을 조합해서 “복기 가능한” 자료를 만들도록 합니다.

> 이슈 트래킹 작성 원칙: Phase1(환경, 로그, 최근 변경사항), Phase2(확인, 시도, 결과분석) 형식으로 정리하세요. (Phase2는 최대 3회까지 반복하고 해결 안 되면 아예 처음부터 시작(불가능할 경우 도움 요청))

> 실습은 천천히, 하지만 robust하게 하세요. 



# 이슈: 컴파일 된 c 파일이 디버그 콘솔에서 실행되고, 터미널에서 안 보임(vs code 설정 문제)

## Phase1.

환경: macOS, vs code, c extension 설치함

로그: Cannot find run action!

최근 변경 사항

launch.json

```c
{
    "configurations": [
    {
        "name": "(lldb) Launch",
        "type": "cppdbg",
        "request": "launch",
        "program": "${fileDirname}/${fileBasenameNoExtension}",
        "args": [],
        "stopAtEntry": false,
        "cwd": "${fileDirname}",
        "environment": [],
        "externalConsole": false,
        "MIMode": "lldb"
    }
    ]
}
```

task.json

```c
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: clang build active file",
            "command": "/usr/bin/clang",
            "args": [
                "-fcolor-diagnostics",
                "-fansi-escape-codes",
                "-g",
                "${file}",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
```

## Phase2-1

확인: "externalConsole": false, 설정으로 인해 디버그 터미널에서 실행 되는 중.

시도: true로 변경

결과 분석: 외부 터미널에서 실행되긴 하는데 vs code의 터미널 콘솔이 아니라 별도의 창에서 실행된다.

## Phase2-2

확인: "externalConsole": false 을 없애고 “console”: “integratedTerminal”로 바꿔야 IDE 통합 터미널에서 실행된다고 함.

시도: “console”: “integratedTerminal”로 설정 변경

결과 분석: vs code의 터미널이 아닌 debug console에서 결과 값이 출력 됨.

## Phase2-3

확인: 기존 설정에도 불구하고 일부 설정이 여전히 디버그 콘솔을 기본으로 사용하게 할 가능성이 있음

시도: internalConsoleOptions: neveOpen 추가

결과 분석: 변화 없음. 여전히 debug console에서 결과 출력중

## Phase2-4

확인:  "debugConsoleMode": "disable", 추가 해보고, 이것도 안 되면 그냥 디버그 콘솔로 확인해라.

시도: 

결과 분석: 변화 없음. 여전히 debug console에서 결과 출력중

## 위와 같은 삽질에 대한 GPT-O1의 조언: 그냥 debug-console로 봐라.

```markdown
결론부터 말씀드리면, VS Code의 기본 C/C++ 디버거(type: cppdbg 또는 cppvsdbg) 설정으로는 ‘통합 터미널(integrated terminal)’을 디버그 콘솔로 사용하는 것이 지원되지 않습니다.
	•	cppdbg/cppvsdbg 구성에서는
	•	externalConsole: true → OS의 독립된 콘솔 창(Windows에서는 별도 cmd 창, mac/linux에서는 xterm 등)을 팝업
	•	externalConsole: false → VS Code의 “Debug Console”에서 입출력 표시
	•	console이나 internalConsoleOptions, debugConsoleMode 같은 속성은 Node.js, Python 등 다른 디버거 유형에서 쓰는 설정이며, MS C/C++ 확장에서는 인식하지 않는 경우가 대부분입니다.

왜 ‘통합 터미널’에서 C/C++ 디버깅이 안 되는가?

VS Code 디버거 설정은 각 언어/런타임별로 조금씩 다릅니다. 예컨대 Node.js나 Python 디버거에서는

{
  "console": "integratedTerminal"
}

이 동작해 ‘통합 터미널’에서 디버깅 입출력을 볼 수 있지만, MS가 제공하는 C/C++ 확장(ms-vscode.cpptools)에서는 이 옵션을 지원하지 않습니다. 대신 아래와 같이 externalConsole 속성만 제공합니다.

{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "C++ Launch",
      "type": "cppdbg",
      "request": "launch",
      "program": "${workspaceFolder}/a.exe",
      "cwd": "${workspaceFolder}",
      "externalConsole": true, // or false
      // ...
    }
  ]
}

	•	externalConsole: true → 별도의 콘솔(윈도우 cmd창, 맥/리눅스에서는 xterm 등)
	•	externalConsole: false → VS Code “Debug Console” 탭에서 입출력 처리

즉, cppdbg/cppvsdbg 타입의 디버거 설정에선 “Debug Console”과 “외부 콘솔”만 공식 지원하고, “VS Code 통합 터미널”은 제공되지 않습니다.

어떻게 해야 하나?
	1.	(권장) 디버그 콘솔 사용
	•	externalConsole: false 로 두고, VS Code 좌측 하단의 “Debug Console” 탭에서 입출력 확인.
	2.	별도 콘솔 창 사용
	•	externalConsole: true 로 두면, Windows라면 새 cmd 창, mac/linux라면 새로운 터미널 창(xterm 등)이 뜹니다.
	3.	정말 통합 터미널에 출력하고 싶다면
	•	실제 “디버거”가 아닌 방식으로,
	1.	“Tasks” 기능 등을 통해 빌드 →
	2.	통합 터미널에서 수동으로 실행(예: ./a.out or a.exe).
	•	이 경우에는 디버그 기능(중단점, 호출스택 확인 등)은 사용하기가 어렵고, 단순 빌드 & 실행 로그를 보고 싶을 때 주로 사용합니다.

요약
	•	MS C/C++ 확장으로는 VS Code 통합 터미널을 디버그 콘솔로 지정할 수 없다 (설정 속성 자체가 없음).
	•	externalConsole 값을 true / false 로 전환하며, 바깥 콘솔 또는 VS Code의 Debug Console 중 하나를 골라야 한다.
	•	“console”, “internalConsoleOptions” 등 Node.js/Python용 속성은 C++ 디버거에선 무시된다.

결국 현재로서는 Debug Console에 계속 나오거나, 별도 콘솔 창을 열어서 확인할 수밖에 없으니 참고하시기 바랍니다.
```

# Getting Started

```c
#include <stdio.h>
int main()
{
    printf("hello, world\n");
}
```

include <studio.h> : indluce information about standard library

main() : define a function called main that received no argument values.

printf("hello, world\n"); : main calls library function printf to print this sequence of characters 

# Variables and Arithmetic Expressino

## code

```c
#include <stdio.h>

int main()
{
    int fahr, celsius;
    int lower, upper, step;

    lower = 0;
    upper = 300;
    step = 20;

    fahr = lower;
    while (fahr <= upper){
        celsius = 5 * (fahr-32) / 9;
        printf("%3d\t%6d\n", fahr, celsius); // %(width)d -> width value for formatting
        fahr = fahr + step;
    }

}
```

## Table: digit formatting

# Skip: for statement

# Symbolic Constants

This is a way to deal with magic numbers: giving them meaningful names so that it can be read conventionally.

## code

```c
#include <stdio.h>

#define LOWER   0
#define UPPER   300
#define STEP    20

int main(){
    int fahr;
    for(fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)
        printf("%3d %6.1f\n", fahr, (5.0/9.0) * (fahr-32));
}


```

- LOWER, UPPER, STEP  are symbolic constants, not variables.
# Character Input and Output

> Given getchar and putchar , you can write a surprising amount of useful code without knowing anything more about input and output. 

## code

read a character

```c
#include <stdio.h>

int main()
{
    int c;
    c = getchar();
    while (c != EOF)
    {
        putchar(c);
        c = getchar();
    }
}

```

- We must declare c to be a type big enough to hold any value that getchar returns. 
- We can’t use char since c must be big enough to hold EOF in addition to any possible char. Therefore we use int.
- EOF is an integer defined in <stdio.h>. As long as it is the symbolic constant, we can be free from considering what specific values should be in to EOF. This is the beauty of the symbolic constants.
## Exercise1. Verify that the expression getchar() != EOF  is 0 or 1.

```c
#include <stdio.h>

int main()
{
    int c;
    c = getchar();
    while (c != EOF)
    {
        printf("%d\n", c != EOF); // <---!!
        putchar(c);
        c = getchar();
    }
}

```

## Exercise2. Print the value of EOF

```c
#include <stdio.h>

int main(){
    printf("%d\n", EOF); // -1
}
```

EOF 값은 -1로 나타나지만, cmd + d 로만 입력할 수 있다. EOF는 표준 입력이 끝났음을 의미하는 특수한 값일 뿐, 실제로 -1을 직접 입력하는 것이 아니다. 

