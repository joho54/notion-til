# [취준] 면접 대비



> 개념과 이슈 트래킹을 조합해서 “복기 가능한” 자료를 만들도록 합니다.



> Phase1. 각 주제에 대해 세 가지 질문을 만드세요

> Phase2. 각 질문에 대해 1. 전사문 작성, 2. GPT 피드백, 3. 비디오 촬영, 4. 주안점 개선을 진행합니다.



# 코딩 면접

## 코드

```python

import java.util.Scanner;

class BOJ2018 {

    public static void main(String[] args) {
        int ptr1 = 1;
        int ptr2 = 1;
        int tmp;
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int ans = 1;
        while (ptr2 < n) {
		        // 조건문에서 합을 구하는 대신 여기서 한번에 값을 구해도 논리적으로는 상관 없지 않나?
		        // 연속된 배열이 등차수열이 아닐 때는 이 방법을 못 쓰겠지. 예재처럼 풀면 모든 오름차순배열에 대해서 같은 답을 낼 수 있고
            tmp = ((ptr1 + ptr2) * (ptr2 - ptr1 + 1)) / 2; 
            if (tmp == n) {
                ans++;
                ptr1++; // 정답에는 이 부분이 없지만, 논리상으로 어차피 첫 번째 포인터도 옮겨야 한다.
                ptr2++;
            } else if (tmp > n) {
                ptr1++;
            } else if (tmp < n) {
                ptr2++;
            }
        }
        System.out.println(ans);

    }
}

```

## 질문1: 구체적으로 투 포인터(ptr1, ptr2)를 어떻게 사용하고 있나요?

1. 전사: 이 코드는 구체적으로 두 포인터를 두 개의 인덱스를 사용해서 1부터 특정한 숫가지의 합을 구한 다음 그 합이 주어진 숫자 n과 동일한지 구하는 목적으로 사용하고 있습니다. 그래서 기본적으로 두 포인터를 1로 초기화하고 만약에 기본적인 규칙에 따라서 만약에 그 포인터 두 개의 값이 주어진 값 n보다 작다면 편의상 StartIndex와 EndIndex로 정의하겠습니다. n보다 작을 경우 StartIndex를 1 증가시킵니다. 그리고 만약에 그렇게 해서 얻게 된 구간 합이 n보다 클 경우에는 반대로 StartIndex를 1 증가시켜서 구간의 범위를 좁힙니다. 그리고 만약에 구간 합이 n과 같을 경우 전체 정답 개수를 1 증가시키는 방식으로 연속된 구간 합과 n의 값이 같아지는 경우를 구하기도 했습니다.
1. 피드백
```markdown
아래는 말씀하신 답변(전사 부분)을 바탕으로 드리는 간단한 피드백입니다.

피드백
	1.	두 포인터 이동 조건의 혼동
	•	전사에서 “n보다 작을 경우 StartIndex를 1 증가시킵니다.” 라고 하셨는데, 실제 코드는 sum < n일 때 **ptr2++**를 통해 구간을 늘립니다.
	•	반대로, sum > n이면 **ptr1++**를 통해 구간을 줄이죠.
	•	즉, **“합이 작으면 오른쪽 포인터(ptr2)를 늘려 합을 키우고, 합이 크면 왼쪽 포인터(ptr1)를 늘려 합을 줄인다”**는 것이 핵심 로직입니다. 전사 내용과 실제 코드의 이동 방식이 살짝 반대로 설명된 부분이 있어서, 이 부분을 정확히 짚고 넘어가시면 좋겠습니다.
	2.	등차수열 합 공식 사용 언급 부족
	•	코드에서 연속 구간의 합을 구할 때, 일반적인 슬라이딩 윈도우 방식(배열에서 구간합을 더하고 빼는 방식) 대신
￼
를 활용하고 있습니다.
	•	전사 답변에서는 “1부터 특정 숫자까지 합을 구한다”는 표현이 있지만, 등차수열 공식으로 즉시 합을 구하는 아이디어가 구체적으로 드러나지 않아 아쉬웠습니다. 면접 답변에서는 “연속된 자연수는 등차수열이므로 위 공식을 이용해 한 번에 합을 계산한다”는 점을 분명히 해주시면 좋습니다.
	3.	정확한 포인터 초기화와 반복 종료 조건
	•	코드에서는 ptr1과 ptr2를 각각 1로 시작합니다. 그리고 ptr2 < n인 동안 반복을 진행합니다.
	•	이 로직은 “연속된 자연수의 합” 중에서 최대치가 n을 넘어가면 더 이상 유효한 경우의 수가 없을 것이라는 전제하에서 작성되었습니다(예: ptr2가 n에 도달하면 1+2+…+n = n(n+1)/2이므로 이미 충분히 큰 값이 됨).
	•	면접에서 “언제 반복이 종료되는가, 왜 이렇게 종료 조건을 설정했는가”를 물어볼 수 있으니, 이 부분도 조금 더 명확히 짚어 주시면 좋을 것 같습니다.
	4.	답변 구조의 명확성
	•	면접 답변에서는 “어떤 상황에서 어떤 포인터를 증가시키는지”를 조건별( sum < n, sum == n, sum > n ) 로 나누어 정확히 설명해주는 것이 직관적입니다.
	•	또한, “만약 sum == n이면 ans++ 후 포인터들은 어떻게 움직이는지”와 같은 세부 구현 로직을 간단히 요약해 주시면 듣는 사람이 훨씬 이해하기 쉽습니다.

정리하자면
	•	(1) “합이 n보다 작으면 ptr2++, 크면 ptr1++, 같으면 ans++ 후 ptr1++, ptr2++” 로직을 분명히 해주시면 좋고,
	•	(2) 등차수열 합 공식을 쓰는 이유(매번 더하고 빼는 대신 한 번에 합 계산이 가능하다는 점)를 강조하시면,
	•	(3) 종료 조건과 초기화를 함께 언급해 주시면 더욱 완성도 높은 답변이 될 것입니다.

지금도 큰 틀은 잘 짚어주셨으니, 위 사항들만 조금 다듬어 주시면 훨씬 더 매끄럽게 설명하실 수 있을 거예요. 면접 준비에 도움이 되길 바랍니다!

++ 모범 답변
“연속된 자연수의 합을 구하기 위해, 저는 두 개의 포인터 ptr1과 ptr2를 각각 연속 구간의 시작점과 끝점으로 사용했습니다. 초기값으로는 두 포인터 모두 1에 두고, 반복문을 통해 다음과 같은 방식을 적용합니다:
	1.	구간 합 계산
	•	연속된 자연수는 등차수열이므로, 등차수열의 합 공식을 사용하여 한 번에 합을 구합니다.
	2.	포인터 이동 규칙
	•	만약 구한 합이 n보다 작으면 더 큰 합을 만들어야 하므로, ptr2를 1 증가시켜 구간을 확장합니다.
	•	합이 n보다 크면 구간을 줄여야 하므로, ptr1을 1 증가시킵니다.
	•	합이 n과 같다면 일단 정답 카운트를 1 증가시키고, 중복 계산을 피하기 위해 ptr1과 ptr2를 모두 1 증가시켜 다음 구간을 탐색합니다.
	3.	반복 조건
	•	일반적으로 ptr2가 n에 도달하면 \frac{n(n+1)}{2}라는 큰 합이 만들어져 더 이상 유효한 구간이 없다고 볼 수 있으므로, ptr2 < n일 때까지만 탐색을 진행합니다.

이 과정을 통해 ptr1과 ptr2를 유연하게 움직이면서, 연속된 구간의 합이 n이 되는 모든 경우를 효율적으로 찾을 수 있습니다. 시간 복잡도 역시 두 포인터가 각각 최대 n번 정도만 이동하므로 O(n) 내에 문제를 해결할 수 있게 됩니다.”
```

## 질문2: 이 코드는 어떤 엣지 케이스에서 테스트해볼 수 있을까요?



## 질문3: 이 알고리즘의 시간 복잡도는 어떻게 되나요?

