# [Algorithm] Python - 2



> ê°œë…ê³¼ ì´ìŠˆ íŠ¸ë˜í‚¹ì„ ì¡°í•©í•´ì„œ â€œë³µê¸° ê°€ëŠ¥í•œâ€ ìë£Œë¥¼ ë§Œë“¤ë„ë¡ í•©ë‹ˆë‹¤.

> ì´ìŠˆ íŠ¸ë˜í‚¹ ì‘ì„± ì›ì¹™: Phase1(í™˜ê²½, ë¡œê·¸, ìµœê·¼ ë³€ê²½ì‚¬í•­), Phase2(í™•ì¸, ì‹œë„, ê²°ê³¼ë¶„ì„) í˜•ì‹ìœ¼ë¡œ ì •ë¦¬í•˜ì„¸ìš”. (Phase2ëŠ” ìµœëŒ€ 3íšŒê¹Œì§€ ë°˜ë³µí•˜ê³  í•´ê²° ì•ˆ ë˜ë©´ ì•„ì˜ˆ ì²˜ìŒë¶€í„° ì‹œì‘(ë¶ˆê°€ëŠ¥í•  ê²½ìš° ë„ì›€ ìš”ì²­))

> ì‹¤ìŠµì€ ì²œì²œíˆ, í•˜ì§€ë§Œ robustí•˜ê²Œ í•˜ì„¸ìš”. 



# ì¬ê·€: ì¿¼ë“œíŠ¸ë¦¬

https://www.acmicpc.net/problem/1992

## ë¬¸ì œ

í‘ë°± ì˜ìƒì„ ì••ì¶•í•˜ì—¬ í‘œí˜„í•˜ëŠ” ë°ì´í„° êµ¬ì¡°ë¡œ ì¿¼ë“œ íŠ¸ë¦¬(Quad Tree)ë¼ëŠ” ë°©ë²•ì´ ìˆë‹¤. í° ì ì„ ë‚˜íƒ€ë‚´ëŠ” 0ê³¼ ê²€ì€ ì ì„ ë‚˜íƒ€ë‚´ëŠ” 1ë¡œë§Œ ì´ë£¨ì–´ì§„ ì˜ìƒ(2ì°¨ì› ë°°ì—´)ì—ì„œ ê°™ì€ ìˆ«ìì˜ ì ë“¤ì´ í•œ ê³³ì— ë§ì´ ëª°ë ¤ìˆìœ¼ë©´, ì¿¼ë“œ íŠ¸ë¦¬ì—ì„œëŠ” ì´ë¥¼ ì••ì¶•í•˜ì—¬ ê°„ë‹¨íˆ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

ì£¼ì–´ì§„ ì˜ìƒì´ ëª¨ë‘ 0ìœ¼ë¡œë§Œ ë˜ì–´ ìˆìœ¼ë©´ ì••ì¶• ê²°ê³¼ëŠ” "0"ì´ ë˜ê³ , ëª¨ë‘ 1ë¡œë§Œ ë˜ì–´ ìˆìœ¼ë©´ ì••ì¶• ê²°ê³¼ëŠ” "1"ì´ ëœë‹¤. ë§Œì•½ 0ê³¼ 1ì´ ì„ì—¬ ìˆìœ¼ë©´ ì „ì²´ë¥¼ í•œ ë²ˆì— ë‚˜íƒ€ë‚´ì§€ë¥¼ ëª»í•˜ê³ , ì™¼ìª½ ìœ„, ì˜¤ë¥¸ìª½ ìœ„, ì™¼ìª½ ì•„ë˜, ì˜¤ë¥¸ìª½ ì•„ë˜, ì´ë ‡ê²Œ 4ê°œì˜ ì˜ìƒìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì••ì¶•í•˜ê²Œ ë˜ë©°, ì´ 4ê°œì˜ ì˜ì—­ì„ ì••ì¶•í•œ ê²°ê³¼ë¥¼ ì°¨ë¡€ëŒ€ë¡œ ê´„í˜¸ ì•ˆì— ë¬¶ì–´ì„œ í‘œí˜„í•œë‹¤

ìœ„ ê·¸ë¦¼ì—ì„œ ì™¼ìª½ì˜ ì˜ìƒì€ ì˜¤ë¥¸ìª½ì˜ ë°°ì—´ê³¼ ê°™ì´ ìˆ«ìë¡œ ì£¼ì–´ì§€ë©°, ì´ ì˜ìƒì„ ì¿¼ë“œ íŠ¸ë¦¬ êµ¬ì¡°ë¥¼ ì´ìš©í•˜ì—¬ ì••ì¶•í•˜ë©´ "(0(0011)(0(0111)01)1)"ë¡œ í‘œí˜„ëœë‹¤. N Ã—N í¬ê¸°ì˜ ì˜ìƒì´ ì£¼ì–´ì§ˆ ë•Œ, ì´ ì˜ìƒì„ ì••ì¶•í•œ ê²°ê³¼ë¥¼ ì¶œë ¥í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì§ì ‘ í’€ê¸°

ìƒê°ë³´ë‹¤ëŠ” ì‰½ê²Œ í’€ë ¸ë‹¤. ë‹¨, ê´„í˜¸ë¥¼ ì¶œë ¥í•˜ëŠ” ë¶€ë¶„ì—ì„œ ì¬ê·€ì˜ ìˆœì„œë¥¼ ì œëŒ€ë¡œ ìƒê°í•˜ì§€ ì•Šì•„ì„œ ì¡°ê¸ˆ í—¤ë§¸ë‹¤. Zë³´ë‹¤ ì¢€ ë” ì‰¬ì› ëŠ”ë°, ì‚¬ì‹¤ ê±°ì˜ ë™ì¼í•œ ë¬¸ì œì¸ ê±° ê°™ë‹¤.

```javascript
# 1. ë¬¸ì œ ì½ê¸°
# 2. ë¬¸ì œ í’€ê¸°
# 3. ìˆ˜ë„ ì½”ë“œ
# 4. ì½”ë“œ êµ¬í˜„

def is_base(A: list, r: int, c: int, n: int):
    """A ë°°ì—´ì˜ r, cë¥¼ ì‹œì‘ì ìœ¼ë¡œ í•˜ëŠ” n ì˜ì—­ì˜ í•©ì„ êµ¬í•˜ê³ , 0ì´ê±°ë‚˜ n^2ì´ë©´ Trueë¥¼ ë¦¬í„´"""
    pixels = 0
    for i in range(r, r+n):
        for j in range(c, c+n):
            pixels += A[i][j]
    if pixels == 0: return 0
    elif pixels == n**2: return 1
    return -1

def recur(A: list, r, c, n):
    pixels = is_base(A, r, c, n)
    if pixels != -1:
        print(pixels, end='')
        return
    # 1 ì‚¬ë¶„ë©´ ì¬ê·€
    half = n//2
    print('(', end='')
    recur(A, r, c, half)
    # 3 ì‚¬ë¶„ë©´ ì¬ê·€
    recur(A, r, c+half, half)
    # 2 ì‚¬ë¶„ë©´ ì¬ê·€
    recur(A, r+half, c, half)
    # 4 ì‚¬ë¶„ë©´ ì¬ê·€
    recur(A, r+half, c+half, half)
    print(')', end='')
        

n = int(input())
arr = [
    tuple(map(int, list(input())))
    for _ in range(n)
]

recur(arr, 0, 0, n)

```

## Phase2. í”¼ë“œë°±

ì•„ë˜ëŠ” ì¿¼ë“œ íŠ¸ë¦¬(BOJ 1992) ë¬¸ì œë¥¼ í•´ê²°í•œ ì½”ë“œì™€ ê·¸ì— ëŒ€í•œ ìƒì„¸ í”¼ë“œë°±ì…ë‹ˆë‹¤.

1. ì „ì²´ ì½”ë“œ ë¦¬ë·°

ì œì‹œí•˜ì‹  ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

```python
def is_base(A: list, r: int, c: int, n: int):
    """A ë°°ì—´ì˜ r, cë¥¼ ì‹œì‘ì ìœ¼ë¡œ í•˜ëŠ” nÃ—n ì˜ì—­ì˜ ëª¨ë“  ì›ì†Œë¥¼ í•©í•œë‹¤.
       í•©ì´ 0ì´ë©´ ëª¨ë‘ 0, n^2ì´ë©´ ëª¨ë‘ 1, ê·¸ ì™¸ì—ëŠ” -1ì„ ë°˜í™˜."""
    pixels = 0
    for i in range(r, r+n):
        for j in range(c, c+n):
            pixels += A[i][j]
    if pixels == 0:          # ëª¨ë‘ 0
        return 0
    elif pixels == n**2:     # ëª¨ë‘ 1
        return 1
    return -1                # 0, 1 ì„ì—¬ ìˆìŒ

def recur(A: list, r: int, c: int, n: int):
    pixels = is_base(A, r, c, n)
    if pixels != -1:
        print(pixels, end='')  # ì••ì¶• ê²°ê³¼(0 ë˜ëŠ” 1)ë¥¼ ë°”ë¡œ ì¶œë ¥
        return

    # 0,1ì´ ì„ì—¬ ìˆìœ¼ë¯€ë¡œ 4ë“±ë¶„
    half = n // 2
    print('(', end='')

    # [1] top-left
    recur(A, r, c, half)
    # [2] top-right
    recur(A, r, c + half, half)
    # [3] bottom-left
    recur(A, r + half, c, half)
    # [4] bottom-right
    recur(A, r + half, c + half, half)

    print(')', end='')


n = int(input())
arr = [tuple(map(int, list(input()))) for _ in range(n)]

recur(arr, 0, 0, n)
```

â€¢	is_base í•¨ìˆ˜: ì£¼ì–´ì§„ êµ¬ì—­(r,c ë¶€í„° nÃ—n)ì„ ìˆœíšŒí•˜ë©° í•©ì´ 0ì´ë©´ ì „ë¶€ 0, í•©ì´ n^2ì´ë©´ ì „ë¶€ 1, ì„ì—¬ ìˆìœ¼ë©´ -1.

â€¢	ë°°ì—´ì— 0ê³¼ 1ë°–ì— ì—†ìœ¼ë¯€ë¡œ, í•©ì„ í†µí•´ â€œëª¨ë‘ 0 or ëª¨ë‘ 1â€ì„ ë¹ ë¥´ê²Œ íŒë³„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	recur í•¨ìˆ˜:

1.	is_baseë¡œ í˜„ì¬ êµ¬ì—­ì´ ì „ë¶€ 0 í˜¹ì€ ì „ë¶€ 1ì¸ì§€ í™•ì¸.

2.	ì „ë¶€ ê°™ì€ ê°’ì´ë©´(0 ë˜ëŠ” 1) ë°”ë¡œ ì¶œë ¥.

3.	ì•„ë‹ˆë©´ 4ê°œë¡œ ìª¼ê°œì–´ ê°ê° ì¬ê·€ í˜¸ì¶œí•˜ê³ , ì‚¬ì´ì— ê´„í˜¸ë¥¼ ì¶œë ¥.

ì •ìƒ ë™ì‘ ë° ì¶œë ¥ ìˆœì„œ

â€¢	ì¿¼ë“œ íŠ¸ë¦¬ ë¬¸ì œì—ì„œ ìš”êµ¬í•˜ëŠ” ìˆœì„œ(ì™¼ìª½ ìœ„, ì˜¤ë¥¸ìª½ ìœ„, ì™¼ìª½ ì•„ë˜, ì˜¤ë¥¸ìª½ ì•„ë˜)ëŒ€ë¡œ ì¬ê·€ê°€ ì§„í–‰ë˜ë¯€ë¡œ ë¬¸ì œ ì‚¬ì–‘ê³¼ ì¼ì¹˜í•©ë‹ˆë‹¤.

â€¢	ì¶œë ¥ í˜•ì‹((0(0011)(0(0111)01)1))ë„ ê´„í˜¸ë¥¼ ì—´ê³  ë‹«ëŠ” ìˆœì„œê°€ ë§ë‹¤ë©´ ì •ìƒì ì¸ ê²°ê³¼ë¥¼ ì–»ìŠµë‹ˆë‹¤.

2. ì„¸ë¶€ í”¼ë“œë°±

2.1 ì‚¬ë¶„ë©´(ì¿¼ë“œ) ìˆœì„œì™€ ì£¼ì„

ì½”ë“œì—ì„œ ì‚¬ë¶„ë©´ì„ í˜¸ì¶œí•˜ëŠ” ìˆœì„œëŠ”:

1.	recur(A, r, c, half) â†’ top-left

2.	recur(A, r, c+half, half) â†’ top-right

3.	recur(A, r+half, c, half) â†’ bottom-left

4.	recur(A, r+half, c+half, half) â†’ bottom-right

ê·¸ëŸ°ë° ì£¼ì„ì—ì„œ â€œ1ì‚¬ë¶„ë©´, 3ì‚¬ë¶„ë©´â€ ì‹ìœ¼ë¡œ í‘œí˜„í•˜ì…¨ë‹¤ë©´, ìˆ˜í•™ì  ì¢Œí‘œê³„ë‚˜ ì¼ë°˜ì  ì¿¼ë“œíŠ¸ë¦¬ í‘œê¸°ì™€ ì•½ê°„ ë‹¤ë¥¼ ìˆ˜ ìˆì–´ì„œ í˜¼ë™ë  ì—¬ì§€ê°€ ìˆìŠµë‹ˆë‹¤.

â€¢	ë³´í†µ â€œ1ì‚¬ë¶„ë©´(top-left), 2ì‚¬ë¶„ë©´(top-right), 3ì‚¬ë¶„ë©´(bottom-left), 4ì‚¬ë¶„ë©´(bottom-right)â€ë¼ëŠ” ì‹ìœ¼ë¡œ ëª…ëª…í•˜ë©´, ìˆœì„œì™€ ì£¼ì„ì´ ì–´ê¸‹ë‚  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ë¬¸ì œì—ì„œ ìš”êµ¬í•˜ëŠ” ì²˜ë¦¬ ìˆœì„œëŠ” â€œì™¼ìœ„, ì˜¤ë¥¸ìœ„, ì™¼ì•„ë˜, ì˜¤ë¥¸ì•„ë˜â€ì´ë¯€ë¡œ, ì½”ë“œì²˜ëŸ¼ ëª…í™•íˆ ì£¼ì„ì„ ë‹¬ì•„ë‘ë©´ ì¢‹ìŠµë‹ˆë‹¤(ì˜ˆ: â€œtop-leftâ€, â€œtop-rightâ€, â€œbottom-leftâ€, â€œbottom-rightâ€).

2.2 ì‹œê°„ ë³µì¡ë„: ëª¨ë“  ë¶„í•  ì‹œ ë§¤ë²ˆ í•© ê³„ì‚°

â€¢	í˜„ì¬ ì½”ë“œëŠ” ë§¤ ë¶„í• ë§ˆë‹¤ nÃ—n ì›ì†Œë¥¼ ì „ë¶€ ìˆœíšŒ(is_base)í•˜ê³ , 0/1 íŒë³„ í›„ í•„ìš”ì‹œ 4ë¶„í• ì„ í•©ë‹ˆë‹¤.

â€¢	ìµœì•…ì˜ ê²½ìš°(ëª¨ë‘ ì„œë¡œ ë‹¤ë¥¸ íŒ¨í„´)ì—ëŠ” ê° ë¶„í• ë§ˆë‹¤ nÃ—nì„ ìŠ¤ìº” â†’ ë¶„í• ì´ log(n) ë‹¨ê³„(2ì°¨ì›ì )ë¡œ ì§„í–‰ â†’ ëŒ€ëµ O(n^2 log n) ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	N ìµœëŒ€ 64 ì •ë„ë¼ë©´ ì „í˜€ ë¬¸ì œ ì—†ê³ , ì¼ë°˜ì ì¸ BOJ 1992 ì œí•œ(N â‰¤ 64) ì•ˆì—ì„œëŠ” ì¶©ë¶„íˆ ë¹ ë¦…ë‹ˆë‹¤.

â€¢	ë§Œì•½ Nì´ ë” ì»¤ì§„ë‹¤ë©´ í”„ë¦¬í”½ìŠ¤ í•©(2D prefix sum) ë“±ì„ ì´ìš©í•´ ì„œë¸Œ êµ¬ì—­ì˜ í•©ì„ O(1)ì— êµ¬í•˜ë©´ ë” íš¨ìœ¨ì ì´ê¸´ í•˜ì§€ë§Œ, ì´ ë¬¸ì œì—ì„  í•„ìš” ì—†ìŠµë‹ˆë‹¤.

2.3 â€œëª¨ë‘ ê°™ì€ ê°’â€ íŒë³„í•˜ëŠ” ë‹¤ë¥¸ ë°©ë²•

â€¢	í•©ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³ , â€œì²« ë²ˆì§¸ ì›ì†Œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì „ë¶€ ë¹„êµâ€í•´ì„œ ë‹¤ë¥¸ ê°’ì´ í•˜ë‚˜ë¼ë„ ë‚˜ì˜¤ë©´ ë¶„í• â€ í•˜ëŠ” ì‹ë„ ìˆìŠµë‹ˆë‹¤:

```python
first_val = A[r][c]
all_same = True
for i in range(r, r+n):
    for j in range(c, c+n):
        if A[i][j] != first_val:
            all_same = False
            break
    if not all_same:
        break

if all_same:
    print(first_val, end='')
    return
# else ë¶„í• 
```

â€¢	ì„±ëŠ¥ìƒ í° ì°¨ì´ëŠ” ì—†ê³ (ì—­ì‹œ O(n^2)), 0/1ë§Œ ë‹¤ë£¨ëŠ” ë¬¸ì œì—ì„œëŠ” í•©ì„ í†µí•´ n^2ê³¼ ë¹„êµí•˜ëŠ” ë°©ë²•ì´ë‚˜, ëª¨ë“  ê°’ì´ ë™ì¼í•œì§€ ë¹„êµí•˜ëŠ” ë°©ë²•ì´ë‚˜ ììœ ë¡­ê²Œ ì„ íƒ ê°€ëŠ¥í•©ë‹ˆë‹¤.

2.4 ì¶œë ¥ ë°©ì‹(ë¬¸ìì—´ vs print)

â€¢	í˜„ì¬ëŠ” í•¨ìˆ˜ ë‚´ì—ì„œ print(..., end='')ë¡œ ë°”ë¡œë°”ë¡œ ì¶œë ¥í•˜ê³  ìˆìŠµë‹ˆë‹¤.

â€¢	BOJ í™˜ê²½ì—ì„œëŠ” ì´ë ‡ê²Œ í•´ë„ ë¬¸ì œ ì—†ì§€ë§Œ, ë¬¸ìì—´ì„ ëª¨ì•„ ë§ˆì§€ë§‰ì— í•œ ë²ˆì— ì¶œë ¥í•˜ëŠ” ë°©ì‹ì„ ì„ í˜¸í•˜ëŠ” ê²½ìš°ë„ ìˆìŠµë‹ˆë‹¤(ì„±ëŠ¥ ë° ìœ ì§€ë³´ìˆ˜).

â€¢	ì›í•˜ì‹œë©´ return ê°’ìœ¼ë¡œ ë¬¸ìì—´ì„ ë„˜ê¸°ê³  ìµœì¢…ì— print(result_str)ë¥¼ í•œ ë²ˆì— ì°ëŠ” ë°©ì‹ìœ¼ë¡œ ë°”ê¿€ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

ì˜ˆì‹œ (ë¬¸ìì—´ í•©ì¹˜ëŠ” ë²„ì „):

```python
def quad_tree(A, r, c, n):
    val = is_base(A, r, c, n)
    if val != -1:
        return str(val)
    half = n // 2
    top_left = quad_tree(A, r, c, half)
    top_right = quad_tree(A, r, c + half, half)
    bottom_left = quad_tree(A, r + half, c, half)
    bottom_right = quad_tree(A, r + half, c + half, half)
    return "(" + top_left + top_right + bottom_left + bottom_right + ")"
```

ì´ë ‡ê²Œ í•˜ë©´ ë§ˆì§€ë§‰ì— print(quad_tree(A, 0, 0, n))ë¡œ ê¹”ë”í•˜ê²Œ í•œ ë²ˆì— ì¶œë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤.

3. ê²°ë¡  ì •ë¦¬

1.	ì½”ë“œ ê¸°ëŠ¥: ìš”êµ¬ ì‚¬í•­ëŒ€ë¡œ ì˜ ë™ì‘í•©ë‹ˆë‹¤.

2.	ì‚¬ë¶„ë©´ ìˆœì„œ: ë¬¸ì œì—ì„œ ì œì‹œí•œ â€œì™¼ìœ„, ì˜¤ë¥¸ìœ„, ì™¼ì•„ë˜, ì˜¤ë¥¸ì•„ë˜â€ ìˆœì„œë¥¼ ì •í™•íˆ ì¤€ìˆ˜í•˜ë©´ ë©ë‹ˆë‹¤.

3.	ì‹œê°„ ë³µì¡ë„: N=64 ì´í•˜ë¼ë©´ í˜„ì¬ êµ¬í˜„(ë§¤ ë¶„í•  ì‹œ nÃ—n ìŠ¤ìº”)ë„ ì„±ëŠ¥ìƒ ì¶©ë¶„í•©ë‹ˆë‹¤.

4.	ì¶œë ¥ ë°©ì‹: ì§€ê¸ˆì²˜ëŸ¼ printë¥¼ ì¬ê·€ ì•ˆì—ì„œ ë°”ë¡œ ì“°ëŠ” ê²ƒë„ ë¬¸ì œ ì—†ì§€ë§Œ, ë¬¸ìì—´ì„ í•©ì³ì„œ í•œ ë²ˆì— ì¶œë ¥í•˜ëŠ” íŒ¨í„´ë„ ì¢‹ìŠµë‹ˆë‹¤.

ì „ì²´ì ìœ¼ë¡œ â€œì¿¼ë“œ íŠ¸ë¦¬â€ ë¬¸ì œ ì˜ë„ì— ë§ëŠ” ì „í˜•ì ì¸ ì¬ê·€ êµ¬í˜„ì´ë©°, ë¡œì§ì€ ì™„ë²½í•˜ê²Œ ì‘ì„±ë˜ì—ˆë‹¤ê³  ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì£¼ì„ê³¼ ë³€ìˆ˜ëª…ë§Œ ì¡°ê¸ˆ ë” ëª…í™•í•˜ê²Œ ì •ë¦¬í•˜ë©´, ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì´ ì¢‹ì•„ì§ˆ ê²ƒì…ë‹ˆë‹¤. ì¶•í•˜ë“œë¦½ë‹ˆë‹¤!

# ì¬ê·€: ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬Â 

https://www.acmicpc.net/problem/5639

ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ë¥¼ ì „ìœ„ ìˆœíšŒí•œ ê²°ê³¼ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ íŠ¸ë¦¬ë¥¼ í›„ìœ„ ìˆœíšŒí•œ ê²°ê³¼ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ëˆ„ë”ê¸° ì½”ë“œ 

```python
"""
1. ë¬¸ì œ ì½ê¸° 
ê·¸ëƒ¥ ì¬ê·€ë¥¼ í•˜ëŠ”ë°, í›„ìœ„ëŠ” ë¹ ì ¸ë‚˜ì˜¬ ë•Œ í”„ë¦°íŠ¸ í•˜ë©´ ë¨.
ê·¸ëŸ°ë° ì…ë ¥ì´ ì „ìœ„ìˆœíšŒ ê²°ê³¼ë¼ì„œ. ì•„ ê·¸ëƒ¥ ë¹ˆ ë°°ì—´ í•˜ë‚˜ ë§Œë“¤ê³ , 
ì „ìœ„ ìˆœíšŒ íƒ€ì´ë°ì— ê·¸ëƒ¥ ì‚½ì…í•˜ë©´ ì•ˆ ë˜ë‚˜, ì•ˆ ëœë‹¤. ì™„ì „ ì´ì§„ íŠ¸ë¦¬ê°€ ì•„ë‹ˆë‹¤!

2. ë¬¸ì œ í’€ê¸°

3. ìˆ˜ë„ ì½”ë“œ

4. ì½”ë“œ êµ¬í˜„
"""

import sys


def post_search(idx: int):
    global arr
    """í¬ê¸°ê°€ nì¸ ë°°ì—´ì˜ idx ë²ˆì§¸ ìš”ì†Œë¥¼ í›„ìœ„ìˆœíšŒ í•©ë‹ˆë‹¤."""
    # ë§Œì•½ ì™¼ìª½ ìì‹ì´ ì¡´ì¬ í•˜ë©´
    if idx >= len(bt): return
    post_search(idx*2+1)
    post_search(idx*2+2)
    if bt[idx] != 0: print(bt[idx])


def insert_binary_tree(val: int):
    print(f'inserting: {val}')
    global bt
    if bt[0] == 0: 
        bt[0] = val # ì²« ë²ˆì§¸ ê°’ ì‚½ì…
        return
    ptr = 0
    while True:
        print(f'current ptr: {ptr}')
        if val < bt[ptr]: # ì™¼ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+1] != 0: # ì™¼ìª½ ìì‹ì´ ì¡´ì¬í•˜ë©´ ê·¸ìª½ìœ¼ë¡œ í¬ì¸í„° ì´ë™
                ptr = ptr*2+1
                print('moving to left child')
                continue
            else: #ì™¼ìª½ ìì‹ì´ ì—†ìœ¼ë©´ ê±°ê¸°ì— ì‚½ì…
                bt[ptr*2+1] = val
                print(f'inserting {val} as left child of {bt[ptr]}')
                break
        elif val > bt[ptr]: # ì˜¤ë¥¸ ìì‹ìœ¼ë¡œ ì‚½ì…
            print(f'{val} > {bt[ptr]}')
            if bt[ptr*2+2] != 0:
                ptr = ptr*2+2
                print('moving to right child')
                continue
            else:
                bt[ptr*2+2] = val
                print(f'inserting {val} as right child of {bt[ptr]}')
                break


arr = []
for line in sys.stdin:
    # lineì€ '\n'ì„ í¬í•¨í•˜ë¯€ë¡œ line.strip()ìœ¼ë¡œ ê°œí–‰ ì œê±°
    arr.append(int(line.strip()))

n = len(arr)
bt = [0]*(n**4) # ëª¨ë‘ ì–‘ì˜ ì •ìˆ˜ë§Œ ì…ë ¥ë¨
for a in arr:
    insert_binary_tree(a)

post_search(0)


"""
ì´ìŠˆ: binary search treeì— ê°’ ì¸ì„œíŠ¸ê°€ ì´ìƒí•˜ê²Œ ë¨
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: '50', '30', '98', '24', '5', '52', 0, 0, '28', '45', 0, 0, '60'
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„íŠ¸ë¦¬ ì‚½ì… ë¶€ë¶„ êµ¬í˜„

def insert_binary_tree(val: int):
    print(f'inserting: {val}')
    global bt
    if bt[0] == 0: 
        bt[0] = val # ì²« ë²ˆì§¸ ê°’ ì‚½ì…
        return
    ptr = 0
    while True:
        if val < bt[ptr]: # ì™¼ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+1] != 0: # ì™¼ìª½ ìì‹ì´ ì¡´ì¬í•˜ë©´ ê·¸ìª½ìœ¼ë¡œ í¬ì¸í„° ì´ë™
                ptr = ptr*2+1
                continue
            else: #ì™¼ìª½ ìì‹ì´ ì—†ìœ¼ë©´ ê±°ê¸°ì— ì‚½ì…
                bt[ptr*2+1] = val
                break
        elif val > bt[ptr]: # ì˜¤ë¥¸ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+2] != 0:
                ptr = ptr*2+2
                continue
            else:
                bt[ptr*2+2] = val
                break
Phase2.
í™•ì¸: ì˜¤ë¥¸ìª½ ìì‹ìœ¼ë¡œ ê°€ëŠ” ë¶€ë¶„ì´ ì¢€ ì´ìƒí•œ ê±° ê°™ì€ë°. ë¬¸ìì—´ì„ ê·¸ëŒ€ë¡œ ì‘¤ì…”ë°•ìœ¼ë‹ˆ ê·¸ë ‡ì§€!

moving to left child
current ptr: 1
5 > 30
inserting 5 as right child of 30

ë¡œê·¸ í™•ì¸ ê²°ê³¼ ì´ëŸ° ê¸°ê°€ë§‰íŒ ì—°ì‚°ì„ í•˜ê³  ìˆì—ˆìŒì„ í™•ì¸. ì´ê±´ ê·¸ëƒ¥ ë””ë²„ê±° ë´¤ìœ¼ë©´ ë” ë¹¨ë¦¬ ìºì¹˜í–ˆì„ ê±° ê°™ê¸°ë„ í•˜ê³ .
ì´ìŠˆë°©ì§€ìœ„ì›íšŒ, ì¤„ì—¬ì„œ ì´ë°©ìœ„ë¥¼ ì—´ì–´ì•¼ê² ë‹¤.
ì‹œë„: ì •ìˆ˜í˜•ìœ¼ë¡œ ì…ë ¥ê°’ ìºìŠ¤íŒ…
ê²°ê³¼: í•´ê²°

ì´ìŠˆ: í›„ìœ„ìˆœíšŒê°€ ì•ˆ ë¼ìš”
Phase1. 
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì˜ëª»ëœ í›„ìœ„ ìˆœìœ„ ê²€ìƒ‰ ê²°ê³¼
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì—†ìŒ

Phase2.
í™•ì¸: ì¬ê·€ ê³¼ì •ì„ í™•ì¸í•˜ê³ , ì¶œë ¥ë¬¸ì„ ì°ìœ¼ë©´ ì¢‹ì„ ì ì ˆí•œ íƒ€ì´ë°ì„ íƒ‘ë‹¤ìš´ ë°©ì‹ìœ¼ë¡œ ë¶„ì„í•´ë³´ê¸°.
ì‹œë„: ê·¸ëƒ¥ ë°°ì—´ê³¼ ì¸ë±ìŠ¤ë¥¼ í†µì§¸ë¡œ ì˜ëª» ì°¸ì¡°í•˜ê³  ìˆì—ˆìŒ. 
ê²°ê³¼ ë¶„ì„: í•´ê²°. ì½”ë“œì˜ ë¡œì§ì€ êµ¬í˜„ ì™„ë£Œ. ê·¸ëŸ°ë° ëˆ„ë”ê¸°ë¡œ ì‘ì„±í•œ ìë£Œêµ¬ì¡° ë•ë¶„ì— ë©”ëª¨ë¦¬ ì´ˆê³¼ê°€ ë°œìƒ

"""
```

### ë¡œê·¸ ì—†ëŠ” ë²„ì „

```python
"""
1. ë¬¸ì œ ì½ê¸° 
ê·¸ëƒ¥ ì¬ê·€ë¥¼ í•˜ëŠ”ë°, í›„ìœ„ëŠ” ë¹ ì ¸ë‚˜ì˜¬ ë•Œ í”„ë¦°íŠ¸ í•˜ë©´ ë¨.
ê·¸ëŸ°ë° ì…ë ¥ì´ ì „ìœ„ìˆœíšŒ ê²°ê³¼ë¼ì„œ. ì•„ ê·¸ëƒ¥ ë¹ˆ ë°°ì—´ í•˜ë‚˜ ë§Œë“¤ê³ , 
ì „ìœ„ ìˆœíšŒ íƒ€ì´ë°ì— ê·¸ëƒ¥ ì‚½ì…í•˜ë©´ ì•ˆ ë˜ë‚˜, ì•ˆ ëœë‹¤. ì™„ì „ ì´ì§„ íŠ¸ë¦¬ê°€ ì•„ë‹ˆë‹¤!

2. ë¬¸ì œ í’€ê¸°

3. ìˆ˜ë„ ì½”ë“œ

4. ì½”ë“œ êµ¬í˜„
"""

import sys


def post_search(idx: int):
    global arr
    """í¬ê¸°ê°€ nì¸ ë°°ì—´ì˜ idx ë²ˆì§¸ ìš”ì†Œë¥¼ í›„ìœ„ìˆœíšŒ í•©ë‹ˆë‹¤."""
    # ë§Œì•½ ì™¼ìª½ ìì‹ì´ ì¡´ì¬ í•˜ë©´
    if idx >= len(bt): return
    post_search(idx*2+1)
    post_search(idx*2+2)
    if bt[idx] != 0: print(bt[idx])


def insert_binary_tree(val: int):
    global bt
    if bt[0] == 0: 
        bt[0] = val # ì²« ë²ˆì§¸ ê°’ ì‚½ì…
        return
    ptr = 0
    while True:
        if val < bt[ptr]: # ì™¼ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+1] != 0: # ì™¼ìª½ ìì‹ì´ ì¡´ì¬í•˜ë©´ ê·¸ìª½ìœ¼ë¡œ í¬ì¸í„° ì´ë™
                ptr = ptr*2+1
                continue
            else: #ì™¼ìª½ ìì‹ì´ ì—†ìœ¼ë©´ ê±°ê¸°ì— ì‚½ì…
                bt[ptr*2+1] = val
                break
        elif val > bt[ptr]: # ì˜¤ë¥¸ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+2] != 0:
                ptr = ptr*2+2
                continue
            else:
                bt[ptr*2+2] = val
                break


arr = []
for line in sys.stdin:
    # lineì€ '\n'ì„ í¬í•¨í•˜ë¯€ë¡œ line.strip()ìœ¼ë¡œ ê°œí–‰ ì œê±°
    arr.append(int(line.strip()))

n = len(arr)
bt = [0]*(n**2) # ëª¨ë‘ ì–‘ì˜ ì •ìˆ˜ë§Œ ì…ë ¥ë¨
for a in arr:
    insert_binary_tree(a)

post_search(0)


```

## Phase2. í”¼ë“œë°± ë° ë°˜ì„±

### ë°˜ì„±

1. ì¸ë±ìŠ¤ ì´ë¦„, í•¨ìˆ˜ ì´ë¦„ë§Œ ì¢€ ê¸¸ê²Œ ì¨ë„ ë§ì€ ì‚½ì§ˆì„ í”¼í•  ìˆ˜ ìˆì„ ê±° ê°™ë‹¤. êµ¬ì²´ì ìœ¼ë¡œ ì“°ë©´ ì¸ì§€ê°€ ë˜ëŠ”ë°, ê·¸ëƒ¥ ì•ŒíŒŒë²³ë§Œ ì‘ì„±í•˜ë©´ ê°œë…ì´ ì•ˆ ì¡íˆê³ , ì˜ëª» ì íŒ ì¸ë±ìŠ¤ë„ ì•Œì•„ë³´ê¸° ì–´ë µë‹¤.
1. ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ë¥¼ ì „í˜€ êµ¬í˜„í•˜ì§€ ëª»í•˜ê² ë‹¤. ìœ„ì˜ ë°°ì—´ì„ í™œìš©í•œ êµ¬ì¡°ëŠ” ê³µê°„ë³µì¡ë„ê°€ ì •ì‹  ë‚˜ê°„ë‹¤.
1. ì…ë ¥ ê°’ì˜ ê°œìˆ˜ê°€ ì£¼ì–´ì§€ì§€ ì•Šê³  ì…ë ¥ë§ˆë‹¤ ê°œí–‰ë¬¸ìê°€ ìˆëŠ” ê²½ìš°ì˜ ì…ë ¥ ë§¤ì»¤ë‹ˆì¦˜ì„ ì˜ ëª¨ë¥´ê² ë‹¤. sys.stdinì€  line1\n, line\n ì´ë ‡ê²Œ ì£¼ì–´ì§€ê³ , ê° ì¤„ì— ì£¼ì–´ì§„ ì…ë ¥ì„ ì´í„°ë ˆì´ì…˜í•˜ë©° line.strip() ì‘ì—…ì„ í•˜ì—¬ whitespaceë¥¼ ì œê±°í•˜ëŠ”ê°€?
### í”¼ë“œë°±

ì•„ë˜ ë‚´ìš©ì€ ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬(BST) ë¬¸ì œ(BOJ 5639)ë¥¼ í’€ ë•Œ í”íˆ ê²ªëŠ” ë¬¸ì œì (ë°°ì—´ ì¸ë±ìŠ¤ë¡œ êµ¬í˜„ ì‹œ ë©”ëª¨ë¦¬ ë‚­ë¹„, ì „ìœ„ìˆœíšŒ ì…ë ¥ì—ì„œ íŠ¸ë¦¬ë¥¼ ë³µì›í•˜ëŠ” ë°©ë²• ë“±)ì— ëŒ€í•œ í”¼ë“œë°±ê³¼, ê¶Œì¥ êµ¬í˜„(ë…¸ë“œ ê¸°ë°˜ + ì¬ê·€ ë³µì›) ì˜ˆì‹œì…ë‹ˆë‹¤.

1. í˜„ì¬ ì½”ë“œ(ë°°ì—´ ì‚¬ìš©) ë¬¸ì œì ê³¼ ê°œì„  ë°©í–¥

1.1 ë°°ì—´ ì¸ë±ìŠ¤ ê¸°ë°˜ â€˜ì™„ì „ì´ì§„íŠ¸ë¦¬â€™ ë°©ì‹ì˜ ë¹„íš¨ìœ¨ì„±

â€¢	í˜„ì¬ ì‹œë„í•˜ì‹  ë°©ì‹ì€ â€œë°°ì—´ ì¸ë±ìŠ¤ë¥¼ ì´ìš©í•´ ì™¼ìª½ ìì‹ = 2i+1, ì˜¤ë¥¸ìª½ ìì‹ = 2i+2â€ êµ¬ì¡°ë¥¼ í‰ë‚´ ë‚´ë©° BSTë¥¼ êµ¬ì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤.

â€¢	BSTê°€ í¸í–¥ë˜ì—ˆì„ ë•Œ, n^2, ì‹¬ì§€ì–´ n^4 ê°™ì€ í° ë°°ì—´ì„ ì¡ì•„ì•¼ í•˜ê³ , ì‹¤ì œë¡œëŠ” ëŒ€ë¶€ë¶„ ë¹„ì–´ ìˆì„ ìˆ˜ ìˆì–´ ë©”ëª¨ë¦¬ ë‚­ë¹„ ê°€ ì‹¬ê°í•©ë‹ˆë‹¤.

â€¢	ë…¸ë“œê°€ 1ë§Œ ê°œë§Œ ë˜ì–´ë„, ì™„ì „ì´ì§„íŠ¸ë¦¬ ì¸ë±ìŠ¤ë¥¼ ì“°ë ¤ë©´ ì—„ì²­ë‚œ í¬ê¸°ì˜ ë°°ì—´ì´ í•„ìš”í•´ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

1.2 ì „ìœ„ìˆœíšŒ ê²°ê³¼ë¡œë¶€í„° BST ë³µì› ì‹œì˜ ì¼ë°˜ì ì¸ ì ‘ê·¼

â€¢	ì£¼ì–´ì§„ ì…ë ¥ì€ BSTë¥¼ ì „ìœ„ìˆœíšŒ(Pre-order)í•œ ê²°ê³¼ì…ë‹ˆë‹¤.

â€¢	ìš°ë¦¬ëŠ” ì´ ë°°ì—´(ì „ìœ„ìˆœíšŒ ê²°ê³¼)ë¡œ íŠ¸ë¦¬ë¥¼ ë³µì›í•œ ë’¤, í›„ìœ„ìˆœíšŒ(Post-order) ê²°ê³¼ë¥¼ ì¶œë ¥í•´ì•¼ í•©ë‹ˆë‹¤.

â€¢	ê°€ì¥ í”í•œ ë°©ë²•ì€ **â€œë…¸ë“œ ê¸°ë°˜(Node class) + ì¬ê·€â€**ë¡œ ì§ì ‘ BSTë¥¼ êµ¬ì„±í•œ ë’¤, í›„ìœ„ìˆœíšŒë¥¼ ìˆ˜í–‰í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

> ê²°ë¡ 

2. ê¶Œì¥ êµ¬í˜„: ë…¸ë“œ ê¸°ë°˜ BST ë³µì› + í›„ìœ„ìˆœíšŒ

2.1 ë¡œì§ ê°œìš”

1.	ì…ë ¥: ì „ìœ„ìˆœíšŒ ê²°ê³¼ preorder[] (ì˜ˆ: 50, 30, 24, 5, 28, 45, 98, 52, 60, â€¦)

2.	BST êµ¬ì„±: ì „ìœ„ìˆœíšŒ íŠ¹ì„±ìƒ,

â€¢	ì²« ë²ˆì§¸ ì›ì†Œ = ë£¨íŠ¸ ê°’

â€¢	ì´í›„ â€œë£¨íŠ¸ë³´ë‹¤ ì‘ì€ ê°’ë“¤â€ì€ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬, â€œë£¨íŠ¸ë³´ë‹¤ í° ê°’ë“¤â€ì€ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬

3.	í•˜ì§€ë§Œ, ë‹¨ìˆœíˆ â€œì‘ì€ ê±° ì „ë¶€ ì™¼ìª½, í° ê±° ì „ë¶€ ì˜¤ë¥¸ìª½â€ìœ¼ë¡œ êµ¬ê°„ì„ ë‚˜ëˆ„ë©´ ìµœì•… O(n^2).

â€¢	ë¬¸ì œì—ì„  N ìµœëŒ€ 10,000ê¹Œì§€ ê°€ëŠ¥.

â€¢	ë‹¤í–‰íˆ, **â€œBST ì „ìœ„ìˆœíšŒ ë°°ì—´â€**ì—ì„œ â€œë£¨íŠ¸ë³´ë‹¤ í° ê°’ì´ ì²˜ìŒ ë‚˜ì˜¤ëŠ” ì§€ì â€ì´ ê³§ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ ì‹œì‘ ì§€ì ì´ ë©ë‹ˆë‹¤.

4.	ë” íš¨ìœ¨ì ì¸ ë°©ë²•: ìƒí•œ(bound)ì„ ì´ìš©í•œ ì¬ê·€. ì „ìœ„ ìˆœíšŒë¥¼ ì™¼â†’ì˜¤ë¥¸ìª½ ìˆœìœ¼ë¡œ íƒìƒ‰í•˜ë©°, â€œí˜„ì¬ ë§Œë“¤ì–´ì•¼ í•  ì„œë¸ŒíŠ¸ë¦¬ ê°’ì´ bound(ë¶€ëª¨ë³´ë‹¤ í° ê°’ í•œê³„)â€ë¥¼ ë„˜ì–´ì„œë©´ stop í•˜ëŠ” ê¸°ë²•ì´ ìì£¼ ì‚¬ìš©ë©ë‹ˆë‹¤.

2.2 ì˜ˆì‹œ ì½”ë“œ: Bound ê¸°ë²• (ì „ìœ„ìˆœíšŒ â†’ BST)

```python
import sys
sys.setrecursionlimit(10**9)  # í˜¹ì‹œ ê¹Šì€ íŠ¸ë¦¬ ëŒ€ë¹„

preorder = []
for line in sys.stdin:
    val = line.strip()
    if val == '':  # ê³µë°± ë¼ì¸ ë°©ì–´
        continue
    preorder.append(int(val))

# ì „ìœ„ìˆœíšŒ ë¦¬ìŠ¤íŠ¸
n = len(preorder)

# ì „ìœ„ìˆœíšŒ ë°°ì—´ì„ ì¬ê·€ì ìœ¼ë¡œ ì½ì–´ê°€ë©° íŠ¸ë¦¬ ë³µì›
# indexëŠ” preorderë¥¼ ìˆœíšŒí•˜ëŠ” ì¸ë±ìŠ¤
index = 0

class Node:
    __slots__ = ('val', 'left', 'right')  # ë©”ëª¨ë¦¬ ì ˆì•½ (ì„ íƒì‚¬í•­)
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def buildBST(bound):
    """
    boundë³´ë‹¤ í° ê°’ì´ ë‚˜ì˜¤ë©´(= í˜„ì¬ subtree ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨)
    ì¬ê·€ë¥¼ ë©ˆì¶˜ë‹¤.
    """
    global index
    if index >= n:  # ë” ì´ìƒ ì›ì†Œê°€ ì—†ìœ¼ë©´ None
        return None

    root_val = preorder[index]
    # ë§Œì•½ í˜„ì¬ ê°’ì´ boundë³´ë‹¤ í¬ë©´, ì´ subtreeì— ì†í•  ìˆ˜ ì—†ìŒ
    if root_val > bound:
        return None

    # í˜„ì¬ ê°’ì´ subtreeì— ì†í•œë‹¤ë©´, ë…¸ë“œ ìƒì„±
    node = Node(root_val)
    index += 1

    # ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬: bound = node.val
    #   => node.valë³´ë‹¤ í° ê°’ì´ ë‚˜ì˜¤ë©´ ì™¼ìª½ subtree ë¶ˆê°€
    node.left = buildBST(node.val)

    # ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬: bound = ìƒìœ„ bound
    #   => "node.val < X <= bound" ë²”ìœ„ì˜ ê°’ì€ ì˜¤ë¥¸ìª½ subtree
    node.right = buildBST(bound)

    return node

# 1) íŠ¸ë¦¬ êµ¬ì„± (ìµœëŒ€ê°’ì„ ì•„ì£¼ í¬ê²Œ ì¡ëŠ”ë‹¤)
root = buildBST(bound=10**10)  # ë¬¸ì œì—ì„œ ê°’ì´ 1,000,000ê¹Œì§€ ê°€ëŠ¥í•˜ë¯€ë¡œ ë” í° ìˆ˜ ì¡ê¸°

# 2) í›„ìœ„ìˆœíšŒ
def postorder(node):
    if not node:
        return
    postorder(node.left)
    postorder(node.right)
    print(node.val)

postorder(root)
```

ë™ì‘ ì„¤ëª…

â€¢	buildBST(bound) í•¨ìˆ˜ëŠ” preorder ë°°ì—´ì„ ì™¼â†’ì˜¤ë¥¸ìª½ìœ¼ë¡œ ìŠ¤ìº”(index ì „ì—­ë³€ìˆ˜)í•˜ë©´ì„œ ë…¸ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

â€¢	í˜„ì¬ ë…¸ë“œê°’ì´ boundë¥¼ ì´ˆê³¼í•˜ë©´, â€œì´ ê°’ì€ ìƒìœ„(í˜¹ì€ ë‹¤ë¥¸) ì„œë¸ŒíŠ¸ë¦¬ë¡œ ê°€ì•¼ í•œë‹¤â€ â†’ None ë¦¬í„´í•˜ì—¬ ì¬ê·€ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.

â€¢	ì´ë ‡ê²Œ í•˜ë©´ ì „ìœ„ìˆœì„œì— ë§ì¶° ì™¼ìª½ subtree(node.valì„ boundë¡œ), ì˜¤ë¥¸ìª½ subtree(ìƒìœ„ bound ê·¸ëŒ€ë¡œ) ìˆœìœ¼ë¡œ ì±„ì›Œë‚˜ê°€ë©´ì„œë„, ê°’ì´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ì¬ê·€ë¥¼ ì¢…ë£Œí•´ â€œë¶€ëª¨ì˜ ì˜¤ë¥¸ìª½ subtreeâ€ë¡œ ë„˜ì–´ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ì´ ì•Œê³ ë¦¬ì¦˜ì€ ê° ë…¸ë“œê°€ ì •í™•íˆ í•œ ë²ˆì”©ë§Œ ì¬ê·€ ì²˜ë¦¬ë˜ë¯€ë¡œ, ìµœì•…ì˜ ê²½ìš°(í¸í–¥ íŠ¸ë¦¬)ë¼ë„ O(n)ì— ê°€ê¹Œìš´ ì„±ëŠ¥ì„ ëƒ…ë‹ˆë‹¤(ì‹¤ì œë¡œëŠ” í‰ê·  O(n), íŠ¹ì • í¸í–¥ íŒ¨í„´ì—ì„œë„ ë¹ ë¥´ê²Œ ë™ì‘).

> ì´ ë¡œì§ì€ **â€œBST ì „ìœ„ìˆœíšŒ + ìƒí•œ(bound) ê¸°ë²•â€**ìœ¼ë¡œ ì•Œë ¤ì§„ ì „í˜•ì ì¸ íŠ¸ë¦¬ ë³µì› ë°©ë²•ì…ë‹ˆë‹¤.

3. ì¶”ê°€ ì‚¬í•­

3.1 â€œì…ë ¥ ê°œìˆ˜ ë¯¸ì§€ì •â€ â†’ sys.stdin ì‚¬ìš© ì‹œ

â€¢	ë¬¸ì œì—ì„œ ì…ë ¥ ì¤„ ìˆ˜ê°€ ë”°ë¡œ ì•ˆ ì£¼ì–´ì§€ë©´, ë³´í†µ EOFê¹Œì§€ ì½ì–´ì•¼ í•©ë‹ˆë‹¤.

â€¢	for line in sys.stdin: ì‚¬ìš© ì‹œ, ë¹ˆ ì¤„ì´ë‚˜ ê°œí–‰ì„ ì²˜ë¦¬í•˜ê³  ì‹¶ë‹¤ë©´ line.strip() í›„ ì¡°ê±´ ê²€ì‚¬í•˜ë©´ ë©ë‹ˆë‹¤.

3.2 íŒŒì´ì¬ ì¬ê·€ ì œí•œ

â€¢	ê¸°ë³¸ì ìœ¼ë¡œ íŒŒì´ì¬ ì¬ê·€ í•œë„ëŠ” ì•½ 1000ì´ë¯€ë¡œ, ë…¸ë“œê°€ 1ë§Œ ê°œ ì´ìƒì´ê³  í¸í–¥ íŠ¸ë¦¬ê°€ ëœë‹¤ë©´ RecursionError ê°€ ë‚  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ë¬¸ì œ 5639ì—ì„œëŠ” ìµœëŒ€ 10,000ê°œ ì…ë ¥ì´ ê°€ëŠ¥í•˜ë¯€ë¡œ, sys.setrecursionlimit(10**9) ì •ë„ë¡œ ì—¬ìœ ë¥¼ ì£¼ëŠ” ê²Œ ì•ˆì „í•©ë‹ˆë‹¤. (ë©”ëª¨ë¦¬ ë‚´ì—ì„œ ì²˜ë¦¬ ê°€ëŠ¥)

3.3 í›„ìœ„ìˆœíšŒ ì¶œë ¥

â€¢	ë¬¸ì œ ìš”êµ¬ì‚¬í•­ëŒ€ë¡œ, ê° ë…¸ë“œë¥¼ í›„ìœ„ìˆœíšŒ ì‹œ ë°©ë¬¸í•  ë•Œë§ˆë‹¤ ì¶œë ¥í•˜ë©´ ë©ë‹ˆë‹¤.

â€¢	â€œprint(node.val)â€ì„ ì°ì„ ë•Œ ê°œí–‰ìœ¼ë¡œ êµ¬ë¶„í•˜ë©´ ì •ë‹µ í¬ë§·ì— ë¶€í•©í•©ë‹ˆë‹¤.

3.4 â€œë°°ì—´ ì¸ë±ìŠ¤ë¥¼ ì¢€ ë” ëª…í™•íˆâ€¦â€ì— ëŒ€í•œ íŒ

â€¢	ë³€ìˆ˜ëª…ì„ idx, start, end ë“±ìœ¼ë¡œ ê¸¸ê²Œ ì¨ì£¼ê±°ë‚˜, ì£¼ì„ì„ ë¶€ì§€ëŸ°íˆ ë‹¬ë©´ ë””ë²„ê¹… ì‹œ í˜¼ì„ ì„ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ë˜í•œ, (node-based)íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•˜ë©´, â€œì™¼ìª½Â·ì˜¤ë¥¸ìª½â€ì„ ì§ê´€ì ìœ¼ë¡œ ì½”ë“œë¡œ í‘œí˜„í•  ìˆ˜ ìˆì–´, ì¸ë±ìŠ¤ ì—°ì‚° ì‹¤ìˆ˜ë¥¼ ì¤„ì´ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤.

4. ë§ˆë¬´ë¦¬

1.	ë¬¸ì œ(5639) í•µì‹¬: ì „ìœ„ìˆœíšŒ ë°°ì—´ë¡œë¶€í„° BSTë¥¼ ì¬êµ¬ì„± í›„, í›„ìœ„ìˆœíšŒ ì¶œë ¥.

2.	ê°€ì¥ ê°„ë‹¨í•œ ì •ì„ ì ‘ê·¼: ë…¸ë“œ ê¸°ë°˜ìœ¼ë¡œ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ê³ , í›„ìœ„ìˆœíšŒë¥¼ ì¬ê·€ë¡œ êµ¬í˜„.

3.	ë°°ì—´ ì¸ë±ìŠ¤ ê¸°ë°˜ì˜ ì™„ì „ì´ì§„íŠ¸ë¦¬ëŠ” BSTì—ëŠ” ë¹„íš¨ìœ¨ì (í¸í–¥ íŠ¸ë¦¬ ì‹œ ë©”ëª¨ë¦¬ í­ì¦).

4.	EOF ì…ë ¥ ì²˜ë¦¬:

```plain text
import sys
arr = []
for line in sys.stdin:
    val = line.strip()
    if val == '':
        continue
    arr.append(int(val))
```

ì´ë ‡ê²Œ í•˜ë©´ íŒŒì¼ ë(EOF)ê¹Œì§€ ì½ì–´ë“¤ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

> ê²°ë¡ ì ìœ¼ë¡œ,



# ì¬ê·€: 1, 2, 3 ë”í•˜ê¸°

https://www.acmicpc.net/problem/9095

ì •ìˆ˜ nì´ ì£¼ì–´ì¡Œì„ ë•Œ, nì„ 1, 2, 3ì˜ í•©ìœ¼ë¡œ ë‚˜íƒ€ë‚´ëŠ” ë°©ë²•ì˜ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1.

```python
"""
1. ë¬¸ì œ ì½ê¸°: 3
2. ë¬¸ì œ í’€ê¸°
3ì´ë©´ 1 1 1, 1 2, 2 1, 3
ê°„ë‹¨í•œ ë°± íŠ¸ë˜í‚¹ ë¬¸ì œë‹¤. 1 2 3 ì¤‘ ì—¬ëŸ¬ê°œë¥¼ ì¨ë„ ìƒê´€ì´ ì—†ë‹¤.
3. ìˆ˜ë„ ì½”ë“œ
ë°”ë‹¥ì¡°ê±´ì€ ë¬´ì—‡ì¸ê°€? ë§¤ê°œë¡œ ë„˜ì–´ì˜¨ ì •ìˆ˜í˜• í•©ì´ nê³¼ ê°™ìœ¼ë©´ ì¹´ìš´í„° ì¦ê°€ì‹œí‚¤ê³  ë¦¬í„´.
ì¬ê·€ ì¡°ê±´ì€: ê·¸ëƒ¥ 1, 2, 3 ë¦¬ìŠ¤íŠ¸ì—ì„œ ë°˜ë³µ ëŒë ¤ì„œ ë”í•´ì„œ ì¬ê·€ ë³´ë‚´ë©´ ë¨.
4. ì½”ë“œ êµ¬í˜„
"""

import sys

def recur(current_sum: int, n: int):
    global cnt
    if current_sum == n:
        cnt += 1
        return
    if current_sum > n:
        return
    for e in [1, 2, 3]:
        recur(current_sum+e, n)


t = int(sys.stdin.readline().strip())
cnt = 0
for _ in range(t):
    n = int(sys.stdin.readline().strip())
    recur(0, n)
    print(cnt)
    cnt = 0

"""
ì´ìŠˆ: ì¬ê·€ ì´ˆê³¼ ì˜¤ë¥˜
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì¬ê·€ ì´ˆê³¼ ì˜¤ë¥˜
ìµœê·¼ ë³€ê²½ì‚¬í•­: ì¬ê·€í•¨ìˆ˜ ì‘ì„±
Phase2.
í™•ì¸: current_sumì´ nê³¼ ë‹¤ë¥´ë©´ ë°”ë‹¥ ì¡°ê±´ì— ê³„ì† ê±¸ë¦¬ì§€ ì•Šê²Œ ë¨. 
current_sum > nì— ëŒ€í•´ì„œë„ ì¢…ë£Œ ì¡°ê±´ì„ ë‹¬ë©´ ë˜ê² ë‹¤.
ì‹œë„: ë² ì´ìŠ¤ ì»¨ë””ì…˜ ì¶”ê°€
if current_sum > n:
        return
ê²°ê³¼ë¶„ì„: ì„±ê³µ
"""
```

## Phase2. ë°± íŠ¸ë˜í‚¹ì´ ë­”ê°€ìš”?

ë¬¸ì œ í’€ì´ ë‚´ìš©ì„ ë°œí‘œí•˜ë˜ ì¤‘ ì´ ì§ˆë¬¸ì„ ë°›ì•˜ëŠ”ë°, ì œëŒ€ë¡œ ëœ ë‹µì„ í•˜ì§€ ëª»í–ˆë‹¤. ê·¸ë˜ì„œ ìƒê°í•´ë³¸ ëì— ì•„ë˜ì™€ ê°™ì€ ê²°ë¡ ì— ë„ë‹¬. 

(ê²°ì • íŠ¸ë¦¬ë¥¼ ì•ˆë‹¤ê³  ê°€ì •í•˜ê³ ) ì¬ê·€ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë¬´ìˆ˜íˆ ë§ì€ ê²°ì •íŠ¸ë¦¬ë¥¼ ë§Œë“¤ì–´ê°€ê²Œ ë˜ê³ , ì´ ì½”ë“œì˜ ê²½ìš° depthê°€ ê¹Šì–´ì§ˆ ìˆ˜ë¡ ë¦¬í”„ ë…¸ë“œê°€ 3ë°°ì”© ëŠ˜ì–´ë‚œë‹¤. ê·¸ëŸ°ë° ë¬¸ì œ ì •ì˜ ìƒìœ¼ë¡œ, ë”í•´ì§€ëŠ” ìˆ«ìëŠ” 1, 2, 3ìœ¼ë¡œ ëª¨ë‘ ì–‘ìˆ˜ê³ , ë§Œì•½ í˜„ì¬ ë…¸ë“œì—ì„œ ë§¤ê°œë¡œ ë°›ì€ ì •ìˆ˜ ê°’ì´ në³´ë‹¤ í¬ë‹¤ë©´ ê²°ì • íŠ¸ë¦¬ìƒìœ¼ë¡œ ì´ ë…¸ë“œì˜ í•˜ìœ„ì— ì˜¬ ìì‹ ë…¸ë“œë“¤ì€ ì „ë¶€ ì •ë‹µì´ ì•„ë‹Œê²Œ í™•ì‹¤í•˜ë‹¤. 

ë”°ë¼ì„œ! ì¬ê·€ë¡œ ì¸í•´ ë¬´í•œíˆ ìƒê²¨ë‚  ìˆ˜ ìˆëŠ” ê²°ì •íŠ¸ë¦¬ë¥¼ ì œì–´í•˜ê¸° ìœ„í•´ í•„ìš” ì—†ëŠ” ê°€ì§€ë¥¼ ì˜ë¼ë‚´ëŠ” ë°©ë²•ì„ ë°±íŠ¸ë˜í‚¹ì´ë¼ í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤.

![](./images/IMG_0452.jpeg)

## Phase3. ë‹µì— ëŒ€í•œ í”¼ë“œë°±

1. ë°±íŠ¸ë˜í‚¹ ì •ì˜ì™€ ì„¤ëª…

â€¢	ë°±íŠ¸ë˜í‚¹ì€ **â€œë¶ˆí•„ìš”í•œ íƒìƒ‰ì„ ê°€ì§€ì¹˜ê¸°(Pruning)í•˜ì—¬ íƒìƒ‰ ì†ë„ë¥¼ í–¥ìƒì‹œí‚¤ëŠ” ê¸°ë²•â€**ì…ë‹ˆë‹¤.

â€¢	íŠ¹íˆ, ê²°ì • íŠ¸ë¦¬(Decision Tree) íƒìƒ‰ ê³¼ì •ì—ì„œ ë¶ˆí•„ìš”í•œ ë¶„ê¸°ë¥¼ ì¡°ê¸°ì— ì¢…ë£Œí•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

â€¢	ì¦‰, ê°€ëŠ¥í•œ ëª¨ë“  ê²½ìš°ë¥¼ íƒìƒ‰í•˜ëŠ” ì™„ì „ íƒìƒ‰(Brute-force) ë°©ì‹ì„ ê°œì„ í•˜ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤.

2. ë³¸ì¸ì˜ ì„¤ëª… í”¼ë“œë°±

> â€œì¬ê·€ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë¬´ìˆ˜íˆ ë§ì€ ê²°ì • íŠ¸ë¦¬ë¥¼ ë§Œë“¤ì–´ê°€ê²Œ ë˜ê³ , ì´ ì½”ë“œì˜ ê²½ìš° depthê°€ ê¹Šì–´ì§ˆìˆ˜ë¡ ë¦¬í”„ ë…¸ë“œê°€ 3ë°°ì”© ëŠ˜ì–´ë‚œë‹¤. ê·¸ëŸ°ë° ë¬¸ì œ ì •ì˜ ìƒìœ¼ë¡œ, ë”í•´ì§€ëŠ” ìˆ«ìëŠ” 1, 2, 3ìœ¼ë¡œ ëª¨ë‘ ì–‘ìˆ˜ê³ , ë§Œì•½ í˜„ì¬ ë…¸ë“œì—ì„œ ë§¤ê°œë¡œ ë°›ì€ ì •ìˆ˜ ê°’ì´ në³´ë‹¤ í¬ë‹¤ë©´ ê²°ì • íŠ¸ë¦¬ìƒìœ¼ë¡œ ì´ ë…¸ë“œì˜ í•˜ìœ„ì— ì˜¬ ìì‹ ë…¸ë“œë“¤ì€ ì „ë¶€ ì •ë‹µì´ ì•„ë‹Œ ê²Œ í™•ì‹¤í•˜ë‹¤. ë”°ë¼ì„œ! ì¬ê·€ë¡œ ì¸í•´ ë¬´í•œíˆ ìƒê²¨ë‚  ìˆ˜ ìˆëŠ” ê²°ì • íŠ¸ë¦¬ë¥¼ ì œì–´í•˜ê¸° ìœ„í•´ í•„ìš” ì—†ëŠ” ê°€ì§€ë¥¼ ì˜ë¼ë‚´ëŠ” ë°©ë²•ì„ ë°±íŠ¸ë˜í‚¹ì´ë¼ í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤.â€

âœ… ì¢‹ì€ ì 

â€¢	ë°±íŠ¸ë˜í‚¹ì˜ í•µì‹¬ ê°œë…ì¸ **â€œë¶ˆí•„ìš”í•œ ê°€ì§€ë¥¼ ì˜ë¼ë‚´ëŠ” ê³¼ì •â€**ì„ ì˜ ì„¤ëª…í–ˆë‹¤.

â€¢	ê²°ì • íŠ¸ë¦¬ì—ì„œ ë¶„ê¸°ê°€ ë¶ˆí•„ìš”í•˜ê²Œ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ì„ ì˜ ì¸ì‹í•˜ê³  ìˆìŒ.

â€¢	í˜„ì¬ í’€ì´ì—ì„œ if current_sum > n: ë¶€ë¶„ì´ ë°±íŠ¸ë˜í‚¹ì˜ ì—­í• ì„ í•œë‹¤ëŠ” ì ì„ ì˜ ì„¤ëª…í–ˆë‹¤.

ğŸ” ë³´ì™„í•˜ë©´ ì¢‹ì€ ì 

â€¢	ë°±íŠ¸ë˜í‚¹ì€ ë‹¨ìˆœíˆ â€œë¶ˆí•„ìš”í•œ ê²½ìš°ë¥¼ ì œê±°â€í•˜ëŠ” ê²ƒë¿ë§Œ ì•„ë‹ˆë¼, **â€œì •ë‹µì´ ë  ê°€ëŠ¥ì„±ì´ ìˆëŠ” ê²½ìš°ë§Œ ì„ íƒâ€**í•˜ëŠ” ë°©ì‹ë„ í¬í•¨ëœë‹¤.

â€¢	íƒìƒ‰ì„ ìµœì í™”í•˜ëŠ” ê²ƒì´ í•µì‹¬ì¸ë°, í˜„ì¬ ì„¤ëª…ì€ â€œë¶ˆí•„ìš”í•œ ê²½ìš°ë¥¼ ì œê±°í•œë‹¤â€ëŠ” ê´€ì ì— ì´ˆì ì´ ë§ì¶°ì ¸ ìˆìŒ.

â€¢	ì˜ˆë¥¼ ë“¤ì–´, â€œN-Queen ë¬¸ì œâ€ì—ì„œëŠ” íŠ¹ì • ì¡°ê±´(ê°™ì€ ì—´ì— ë†“ì´ì§€ ì•Šê¸°, ëŒ€ê°ì„  ì¶©ëŒ ë°©ì§€ ë“±)ì„ ë§Œì¡±í•˜ëŠ” ê²½ìš°ì—ë§Œ íƒìƒ‰ì„ ì§„í–‰í•˜ëŠ” ê²ƒë„ ë°±íŠ¸ë˜í‚¹ì˜ ì¤‘ìš”í•œ íŠ¹ì§•ì´ë‹¤.

ğŸ’¡ ë³´ì™„ëœ ì„¤ëª… ì˜ˆì‹œ

> â€œë°±íŠ¸ë˜í‚¹ì€ ê°€ëŠ¥í•œ ëª¨ë“  ê²½ìš°ë¥¼ íƒìƒ‰í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ìœ ë§í•˜ì§€ ì•Šì€ ê²½ìš°ë¥¼ ì¡°ê¸°ì— í¬ê¸°í•˜ì—¬ íƒìƒ‰ íš¨ìœ¨ì„ ë†’ì´ëŠ” ê¸°ë²•ì´ë‹¤. ì´ ë¬¸ì œì—ì„œëŠ” ê²°ì • íŠ¸ë¦¬ì—ì„œ current_sum > nì¸ ê²½ìš° ì´í›„ì˜ íƒìƒ‰ì´ ë¬´ì˜ë¯¸í•˜ë¯€ë¡œ íƒìƒ‰ì„ ì¤‘ë‹¨í•œë‹¤. ì´ë¥¼ í†µí•´ íƒìƒ‰ ê³µê°„ì„ ì¤„ì´ê³ , ë¶ˆí•„ìš”í•œ ì—°ì‚°ì„ ë°©ì§€í•˜ëŠ” ê²ƒì´ ë°±íŠ¸ë˜í‚¹ì˜ í•µì‹¬ì´ë‹¤.â€

3. ì½”ë“œì— ëŒ€í•œ í”¼ë“œë°±

í˜„ì¬ ì½”ë“œëŠ” ë°±íŠ¸ë˜í‚¹ ê°œë…ì„ ì ìš©í–ˆì§€ë§Œ, DP(ë™ì  ê³„íšë²•, Dynamic Programming)ë¡œ ë” íš¨ìœ¨ì ì¸ í’€ì´ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ì´ ë¬¸ì œëŠ” ì¤‘ë³µë˜ëŠ” ë¶€ë¶„ ë¬¸ì œ(overlapping subproblems)ì™€ ìµœì  ë¶€ë¶„ êµ¬ì¡°(optimal substructure)ë¥¼ ê°€ì§€ë¯€ë¡œ DPê°€ ë” ì ì ˆí•©ë‹ˆë‹¤.

âœ… DP í’€ì´ (Bottom-Up)

```plain text
import sys

def solve():
    dp = [0] * 11  # ë¬¸ì œì—ì„œ nì€ ìµœëŒ€ 10
    dp[1], dp[2], dp[3] = 1, 2, 4  # ê¸°ë³¸ ì¼€ì´ìŠ¤

    for i in range(4, 11):  # ì í™”ì‹ ì ìš©
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

    t = int(sys.stdin.readline().strip())
    for _ in range(t):
        n = int(sys.stdin.readline().strip())
        print(dp[n])

solve()
```

â€¢	ì‹œê°„ ë³µì¡ë„: O(N), ì¬ê·€ í’€ì´ë³´ë‹¤ í›¨ì”¬ íš¨ìœ¨ì ì„.

ê²°ë¡ 

1.	ë°±íŠ¸ë˜í‚¹ì˜ ê°œë… ì„¤ëª…ì€ ì¢‹ì•˜ì§€ë§Œ, **â€œê°€ëŠ¥ì„±ì´ ìˆëŠ” ê²½ìš°ë§Œ íƒìƒ‰í•œë‹¤â€**ëŠ” ë¶€ë¶„ë„ ê°•ì¡°í•˜ë©´ ë” ì¢‹ë‹¤.

2.	ì´ ë¬¸ì œëŠ” ë°±íŠ¸ë˜í‚¹ìœ¼ë¡œ í’€ ìˆ˜ ìˆì§€ë§Œ, DPê°€ ë” ì í•©í•œ í’€ì´ ë°©ë²•ì´ë‹¤.

3.	ê°™ì€ ìœ í˜•ì˜ ë¬¸ì œì—ì„œ ë°±íŠ¸ë˜í‚¹ê³¼ DP ì¤‘ ì–´ë–¤ ê²ƒì´ ë” ì ì ˆí•œì§€ íŒë‹¨í•˜ëŠ” ì—°ìŠµì„ í•˜ë©´ ë”ìš± ì¢‹ì„ ê²ƒ! ğŸš€

# íƒìƒ‰: ìˆ˜ ì°¾ê¸°

## Phase1. í’€ì´ ì„±ê³µ. 

íƒìƒ‰ ë°©ì‹ì„ ì˜ëª» ê³¨ë¼ì„œ ì˜¤ë˜ ê±¸ë ¸ë‹¤. ë¬¸ì œì˜ ì¡°ê±´ì„ ì˜ ì½ê³ , ì ì ˆí•œ íƒìƒ‰ ë°©ì‹ì„ ì„ íƒí•´ì•¼ í•¨.

```python
"""
ë³´ë¥˜
ì‚¬ìœ : ì´ë¶„íƒìƒ‰ì„ ëª¨ë¥´ë©´ ì œëŒ€ë¡œ í’€ ìˆ˜ ì—†ìŒ

import sys

n = int(sys.stdin.readline().strip())
arr = list(map(int, sys.stdin.readline().split()))
m = int(sys.stdin.readline().strip())
search_list = list(map(int, sys.stdin.readline().split()))
for val in search_list:
    if val in arr: print(1)
    else: print(0)

ì´ê±´ ë‚´ ì§€ì‹ìœ¼ë¡œ í‘¼ ì˜¤ë‹µ ì½”ë“œ.

"""

"""
1. ë¬¸ì œ ì½ê¸°: ì–´..ì´ê±° ê·¸ëƒ¥ ì…ë ¥ë°›ê³  in ì—°ì‚°ì ì“°ë©´ ì•ˆ ë˜ë‚˜? ì•ˆ ë¨. ì •ë ¬í•œ ë‹¤ìŒ ì´ì§„íƒìƒ‰í•´ì•¼ í• ë“¯
2. ë¬¸ì œ í’€ê¸°: 
3. ìˆ˜ë„ ì½”ë“œ:
4. ì½”ë“œ êµ¬í˜„: 
"""

# def bin_search(A: list, val: int):
    
#     left = 0
#     right = len(A) - 1
#     while left <= right: # íŒŒí‹°ì…˜ì´ ìœ íš¨í•œ ë™ì•ˆ. 
#         center = (left+right)//2
#         idx = center # ì˜ì—­ì˜ ì ˆë°˜ì„ ì¸ë±ìŠ¤ë¡œ ê³ ì •
#         if A[idx] > val: # ë‹µì´ ì™¼ìª½ ì˜ì—­ì— ìˆìŒ.
#             right = center # right idxë¥¼ ë°˜ìœ¼ë¡œ ê°ì†Œ
#         elif A[idx] < val: # ë‹µì´ ì˜¤ë¥¸ìª½ ì˜ì—­ì— ìˆìŒ.
#             left = center+1 # leftë¥¼ ë†’ì—¬ì„œ ì˜ì—­ì„ ë°˜ ì¢íˆê¸°
#         elif A[idx] == val: 
#             return 1
#     return 0

import sys

dictionary = {}


n = int(sys.stdin.readline().strip())
arr = list(map(int, sys.stdin.readline().split()))
for a in arr:
    dictionary[a] = True
m = int(sys.stdin.readline().strip())
search_list = list(map(int, sys.stdin.readline().split()))

for key in search_list:
    if dictionary.get(key, False): print(1)
    else: print(0)

"""
ì´ìŠˆ: ë¬´í•œ ë£¨í”„
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì—†ìŒ
ìµœê·¼ ë³€ê²½ ì‚¬í•­: bin_search ì´ì§„ íƒìƒ‰ í•¨ìˆ˜ ì‘ì„±
Phase2.
í™•ì¸: ë£¨í”„ì— ì¤‘ë‹¨ì  ã„±ã„±
ë°°ì—´ ì•ˆì— ê°’ì´ ì—†ì„ ê²½ìš° ë¬´í•œ ë£¨í”„ë¥¼ ëˆë‹¤. ì¸ë±ì‹±ì„ í•˜ë‹¤ê°€ 
ìì—°ìŠ¤ëŸ½ê²Œ íŒŒí‹°ì…˜ì´ ì—‡ê°ˆë¦¬ë©´ ëë‚˜ì•¼ í•˜ëŠ”ë°, íŒŒí‹°ì…”ë‹ ì¸ë±ìŠ¤ì— ë¬¸ì œê°€ ìˆë‹¤.
left, right ì¸ë±ìŠ¤ê°€ 3, 4ì¼ë•Œ ë¬´í•œ ë°˜ë³µ ë°œìƒ.
center = 3(3.5)
leftê°€ ê³„ì† 3ìœ¼ë¡œ ì—…ë°ì´íŠ¸ ë¨. ì™€ ì´ê±° ì–´ë–»ê²Œ íŒŒí‹°ì…”ë‹ í•´ì•¼ í•´ê²°í•  ìˆ˜ ìˆì§€? 
ì‘ì•„ì§€ëŠ” ê²½ìš°ëŠ” ë¬¸ì œê°€ ì—†ëŠ”ë°, ì¤‘ê°„ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ í¬ê³ , ë°°ì—´ì— ì—†ëŠ” ê°’ì„ êµ¬í•  ë•Œ 
left right ì¸ë±ìŠ¤ê°€ ì¢í˜€ì§€ì§€ ì•ŠëŠ”ë‹¤. 
ì¸ë±ìŠ¤ë¥¼ ì¡ì„ ë•Œ 'ë‹¤ìŒ ì™¼ìª½ ì˜ì—­ì„ left, centerë¡œ ì¡ê³ , 
ë‹¤ìŒ ì˜¤ë¥¸ìª½ ì˜ì—­ì„ center+1, rightë¡œ ì¡ìœ¼ë‹ˆ í•´ê²°
ì‹œë„: 
    while left <= right: # íŒŒí‹°ì…˜ì´ ìœ íš¨í•œ ë™ì•ˆ. 
        ...
        elif A[idx] < val: # ë‹µì´ ì˜¤ë¥¸ìª½ ì˜ì—­ì— ìˆìŒ.
            left = center+1 # leftë¥¼ ë†’ì—¬ì„œ ì˜ì—­ì„ ë°˜ ì¢íˆê¸°

ê²°ê³¼ ë¶„ì„: ì •ë ¬ì€ ì„±ê³µ. ê·¸ëŸ°ë° ì‹œê°„ì´ˆê³¼ ë°œìƒ. ì •ë ¬ì„ ìµœì í™”í•´ì•¼ í•œë‹¤. ìš°ì„ ìˆœìœ„ íë¥¼ ì¨ì•¼ í•˜ë‚˜? 
í•œ ë¼ì¸ì— ì…ë ¥ë¼ì„œ, ì´ê²Œ sort í•¨ìˆ˜ ì“°ëŠ”ê²Œ ì œì¼ ë¹ ë¥¼í…ë°. 

ì´ìŠˆ: ì‹œê°„ ì´ˆê³¼ ë¬¸ì œ
Phase1
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì‹œê°„ ì´ˆê³¼
ìµœê·¼ ë³€ê²½ ì‚¬í•­: bin_search ë¡œì§ í”½ìŠ¤ 
Phase2.
í™•ì¸:
ì •ìˆ˜ì˜ ë²”ìœ„ëŠ” ì—„ì²­ ë„“ë‹¤. ì£¼ì–´ì§€ëŠ” ìì—°ìˆ˜ ë¦¬ìŠ¤íŠ¸ë„ ì‹­ë§Œì´ë‹¤. 
í˜„ì¬ ì‹œê°„ ë³µì¡ë„: ì •ë ¬ì— nlogn
íƒìƒ‰ ì‹œê°„ ë³µì¡ë„: logn
O(nlogn) + O(logn)
ì´ê±¸ ì–´ë–»ê²Œ ê°œì„ í•˜ì§€? ì…ë ¥ì— í•„ìš”í•œ ì˜¤ë²„í—¤ë“œë¥¼ ê°œì„ í•´ì•¼ í•˜ë‚˜? ê·¼ë° ê·¸ëŸ°ì‹ì˜ ë¬¸ì œëŠ” ì•„ë‹ ê±° ê°™ìŒ.
ì‹œë„: ë§µì„ ì¨ë´ì•¼ í•˜ë‚˜? í•˜ê¸´ ì´ ë¬¸ì œëŠ” ë°ì´í„°ì˜ ìˆ˜ì •/ì‚­ì œê°€ í•„ìš” ì—†ë‹¤. ì•„ ë­ì•¼ ê·¸ëŸ¼ ë§µì´ë„¤!
ì•„ë˜ êµ¬í˜„.
for key in search_list:
    if dictionary.get(key, False): print(1)
    else: print(0) 
    
ë¶„ì„: ì„±ê³µ!!


"""
```

# ì´ì§„íƒìƒ‰: ë‚˜ë¬´ ìë¥´ê¸°

https://www.acmicpc.net/problem/2805

ìƒê·¼ì´ëŠ” ë‚˜ë¬´ Më¯¸í„°ê°€ í•„ìš”í•˜ë‹¤. ê·¼ì²˜ì— ë‚˜ë¬´ë¥¼ êµ¬ì…í•  ê³³ì´ ëª¨ë‘ ë§í•´ë²„ë ¸ê¸° ë•Œë¬¸ì—, ì •ë¶€ì— ë²Œëª© í—ˆê°€ë¥¼ ìš”ì²­í–ˆë‹¤. ì •ë¶€ëŠ” ìƒê·¼ì´ë„¤ ì§‘ ê·¼ì²˜ì˜ ë‚˜ë¬´ í•œ ì¤„ì— ëŒ€í•œ ë²Œëª© í—ˆê°€ë¥¼ ë‚´ì£¼ì—ˆê³ , ìƒê·¼ì´ëŠ” ìƒˆë¡œ êµ¬ì…í•œ ëª©ì¬ì ˆë‹¨ê¸°ë¥¼Â ì´ìš©í•´ì„œ ë‚˜ë¬´ë¥¼ êµ¬í• ê²ƒì´ë‹¤.

ëª©ì¬ì ˆë‹¨ê¸°ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë™ì‘í•œë‹¤. ë¨¼ì €, ìƒê·¼ì´ëŠ” ì ˆë‹¨ê¸°ì— ë†’ì´ Hë¥¼ ì§€ì •í•´ì•¼ í•œë‹¤. ë†’ì´ë¥¼ ì§€ì •í•˜ë©´ í†±ë‚ ì´ ë•…ìœ¼ë¡œë¶€í„° Hë¯¸í„° ìœ„ë¡œ ì˜¬ë¼ê°„ë‹¤. ê·¸ ë‹¤ìŒ, í•œ ì¤„ì— ì—°ì†í•´ìˆëŠ” ë‚˜ë¬´ë¥¼ ëª¨ë‘ ì ˆë‹¨í•´ë²„ë¦°ë‹¤. ë”°ë¼ì„œ, ë†’ì´ê°€ Hë³´ë‹¤ í° ë‚˜ë¬´ëŠ” H ìœ„ì˜ ë¶€ë¶„ì´ ì˜ë¦´ ê²ƒì´ê³ , ë‚®ì€ ë‚˜ë¬´ëŠ” ì˜ë¦¬ì§€ ì•Šì„ ê²ƒì´ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í•œ ì¤„ì— ì—°ì†í•´ìˆëŠ” ë‚˜ë¬´ì˜ ë†’ì´ê°€ 20, 15, 10, 17ì´ë¼ê³  í•˜ì. ìƒê·¼ì´ê°€ ë†’ì´ë¥¼ 15ë¡œ ì§€ì •í–ˆë‹¤ë©´, ë‚˜ë¬´ë¥¼ ìë¥¸ ë’¤ì˜ ë†’ì´ëŠ” 15, 15, 10, 15ê°€ ë  ê²ƒì´ê³ , ìƒê·¼ì´ëŠ” ê¸¸ì´ê°€ 5ì¸ ë‚˜ë¬´ì™€ 2ì¸ ë‚˜ë¬´ë¥¼ ë“¤ê³  ì§‘ì— ê°ˆ ê²ƒì´ë‹¤. (ì´ 7ë¯¸í„°ë¥¼ ì§‘ì— ë“¤ê³  ê°„ë‹¤) ì ˆë‹¨ê¸°ì— ì„¤ì •í•  ìˆ˜ ìˆëŠ” ë†’ì´ëŠ” ì–‘ì˜ ì •ìˆ˜ ë˜ëŠ” 0ì´ë‹¤.

ìƒê·¼ì´ëŠ” í™˜ê²½ì— ë§¤ìš° ê´€ì‹¬ì´ ë§ê¸° ë•Œë¬¸ì—, ë‚˜ë¬´ë¥¼ í•„ìš”í•œ ë§Œí¼ë§Œ ì§‘ìœ¼ë¡œ ê°€ì ¸ê°€ë ¤ê³  í•œë‹¤. ì´ë•Œ, ì ì–´ë„ Më¯¸í„°ì˜ ë‚˜ë¬´ë¥¼ ì§‘ì— ê°€ì ¸ê°€ê¸° ìœ„í•´ì„œ ì ˆë‹¨ê¸°ì— ì„¤ì •í•  ìˆ˜ ìˆëŠ” ë†’ì´ì˜ ìµœëŒ“ê°’ì„ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì§ì ‘ í’€ê¸°(ì„±ê³µ!)

```python
"""
1. ë¬¸ì œ ì½ê¸°: ì´ê²Œ ì–´ë–»ê²Œ ì´ë¶„ íƒìƒ‰ì´ì§€? 
2. ë¬¸ì œ í’€ê¸°
2-1. ì•„ì´ë””ì–´ ë¸Œë ˆì¸ ìŠ¤í† ë°
ê°€. prefix sumì„ ì“°ê¸°: ë§ë„ ì•ˆ ë¨.
ë‚˜. ì™„ì „íƒìƒ‰: ì•„ë˜ê°€ ì •ë‹µì´ë‹¤.
import sys

MAX_INT = sys.maxsize

n = 5
m = 20
trees = [4, 42, 40, 26, 46]

def cut_sum(height: int):
    sum_tmp = 0
    for tree in trees:
        sum_tmp += tree - height if tree > height else 0
    return sum_tmp

h_x = 0
prev_difference = MAX_INT

for i in range(0, max(trees)):
    cut_amount = cut_sum(i)
    difference = abs(cut_amount-m)
    if difference < prev_difference: # update
        prev_difference = difference
        h_x = i

# print(h_x)

ë‹¤. ì¸í¬ë ˆë©˜íƒˆ ë©”ì„œë“œì—ì„œ ë¶„í• ì •ë³µìœ¼ë¡œ!

ìœ„ ì½”ë“œì— ëŒ€í•œ ë¶„ì„: ë¬¸ì œì— ëŒ€í•œ incremental methodë‹¤. ì´ê±¸ divide and conquer 
ë°©ì‹ìœ¼ë¡œ ë°”ê¿”ì•¼ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆì„ ê²ƒ.
ì—¬ê¸°ì„œ incrementalí•œ ìš”ì†ŒëŠ” iì´ë‹¤.

ì´ì œ ì´ê²ƒì„ ì •ë¦¬í•´ ë³´ì•˜ì„ ë•Œ cut_sum(i)-mì´ë¼ëŠ” ìš°í•˜í–¥ í•¨ìˆ˜ê°€ ìˆë‹¤. 
(iê°€ incremental í•˜ë‹¤ê³  ê°€ì •.)
ê·¸ëŸ¼ ë‹¤ìŒê³¼ ê°™ì´ ë¶„ê¸°
cut_sum(i)-m > 0: ì˜¤ë¥¸ìª½ ì˜ì—­ ë””ë°”ì´ë“œ
cut_sum(i)-m < 0: ì™¼ìª½ ì˜ì—­ìœ¼ë¡œ ë””ë°”ì´ë“œ


3. ìˆ˜ë„ ì½”ë“œ

"""

import sys

n, m = tuple(map(int, sys.stdin.readline().split()))
trees = tuple(map(int, sys.stdin.readline().split()))


def f(height: int):
    """
    fì˜ ì •ì˜: heightì— ëŒ€í•´ ë‚˜ë¬´ë¥¼ ì˜ëì„ ë•Œ ì–»ê²Œ ë˜ëŠ” ë‚˜ë¬´ë“¤ì˜ ê¸¸ì´ì—ì„œ ëª©í‘œ ê¸¸ì´ë¥¼ ëº€ ê²ƒ.
    """
    sum_tmp = 0
    for tree in trees:
        sum_tmp += tree - height if tree > height else 0
    return sum_tmp - m

def bin_search():
    """ëª©í‘œ: f(h_x)ë¥¼ ìµœì†Œí™” í•˜ëŠ” h_x ì°¾ê¸°"""
    left, right = 0, 1_000_000_001
    prev_center = None
    while left < right:
        # print(f'{left} --- {right}')
        i_center = (left+right)//2 # i for representing incremental parameter
        difference = f(i_center)
        # print(f'difference is {difference}.')
        if difference < 0: 
            # print(f'conquer left')
            left, right = left, i_center 
            if left >= right:  # ë‚˜ë¬´ë¥¼ ìë¥´ì§€ ì•ŠëŠ” ë†’ì´ì—ì„œ, ë‹¤ìŒ í„´ì— íƒìƒ‰ì„ ë§ˆì¹œë‹¤ë©´!
                return prev_center # ì•„, ë‘˜ ë‹¤ ê·¸ê±°ì¼ ìˆ˜ ìˆêµ¬ë‚˜. ë‘ í„´ ë‹¤ ìŒìˆ˜ê°€ ë‚˜ì˜¬ ìˆ˜ë„ ìˆìŒ.
        elif difference > 0: 
            # print(f'conquer right')
            left, right = i_center+1, right
            prev_center = i_center
            # ì´ë•ŒëŠ” i_centerê°€ ë¬´ì¡°ê±´ ë‚˜ë¬´ë¥¼ ì˜ë¼ê°€ëŠ” ê²ƒì„ ë³´ì¥ ì—¬ê¸°ì„œ ê°±ì‹  í•„ìš”
        else: # ì°¨ì´ê°€ 0ê³¼ ê°™ìŒ(best case)
            return i_center
    return i_center

ans = bin_search()

print(ans)

"""
ì´ìŠˆ: ë¬´í•œ ë£¨í”„

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ë¬´í•œ ë£¨í”„
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„ íƒìƒ‰ ì½”ë“œ ì‘ì„±

Phase2-1
í™•ì¸: ë¡œê·¸ë¥¼ ì–´ë”” ì°ì–´ì•¼ í•˜ì§€? 
ë¹„êµ ë¡œì§ì´ ì¢€ ì˜ëª» ëë‹¤. 
1. êµ¬í•œ ê²°ê³¼ì˜ ë†’ì´ ì°¨ì´ë¥¼ êµ¬í•œë‹¤.
ì‹œë„:
ë¶„í•  ì •ë³µ ë¡œì§ì´ ì˜ëª»ë¼ ìˆì—ˆìŒ. í•¨ìˆ˜ì˜ ìš°í•˜í–¥ì„ ê³ ë ¤í•˜ì§€ ì•Šê³ , ì˜ëª» ì‘ì„±.
ê·¸ë¦¬ê³  ì ˆëŒ€ê°’ë„ ì”Œìš°ë©´ ì•ˆ ëìŒ
if difference < 0: 
    # print(f'conquer left')
    left, right = left, i_center
elif difference > 0: 
    # print(f'conquer right')
    left, right = i_center + 1, right
else: # ì°¨ì´ê°€ 0ê³¼ ê°™ìŒ(best case)
    return i_center
ê²°ê³¼ ë¶„ì„: ì˜ˆì œëŠ” ë‹¤ ë§ì¶”ì§€ë§Œ í‹€ë¦¬ëŠ” í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì¡´ì¬.

ì´ìŠˆ: ì˜¤ë‹µ ë°œìƒ
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: í‹€ë ¸ìŠµë‹ˆë‹¤
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„ íƒìƒ‰ ì½”ë“œ ë¡œì§ ìˆ˜ì •.

Phase2-1
í™•ì¸: ì´ëŸ´ ë• ë¬¸ì œ ì¡°ê±´ì„ íƒ€ì´í•‘í•˜ê³ , ê²½ê³„ê°’ìœ¼ë¡œ í…ŒìŠ¤íŠ¸
1 <= N <= 1,000,000
1 <= M <= 2000000000 (ì˜ë¼ ê°€ì•¼ í•˜ëŠ” ë‚˜ë¬´ )
ê° ë‚˜ë¬´ì˜ ë†’ì´(i_center) 0 ~ 1,000,000,000 
ê° ë‚˜ë¬´ì˜ ë†’ì´ê°€ 0ì¼ìˆ˜ë„ ìˆë‹¤. ê·¼ë° ë‚˜ë¬´ ë†’ì´ì˜ í•©ì€ í•­ìƒ Më³´ë‹¤ í¬ë‹¤ í–ˆë‹¤.
Mì´ 1 ì´ìƒì´ë‹ˆê¹Œ ë‚˜ë¬´ ë†’ì´ì˜ í•©ë„ 1 ì´ìƒì¼ ê²ƒ.
ì°¾ì•˜ë‹¤.
2 1 <= ë‚˜ë¬´ì˜ ê°¯ìˆ˜ 2, ì˜ë¼ê°€ì•¼ í•˜ëŠ” ë‚˜ë¬´ ê°’ 1
2 2 <= ê° ë‚˜ë¬´ì˜ ë†’ì´ 2.
2 <= ì„¤ì •í•œ ì»¤íŒ… ë†’ì´: 2. ì´ëŸ¬ë©´ 0ì— ìˆ˜ë ´í•˜ê¸´ í•˜ê² ì§€ë§Œ, ë¬¸ì œì˜ ì¡°ê±´ê³¼ ë‹¤ë¦„. 
ì •ë‹µ ì»¤íŒ… ë†’ì´: 1. ê·¸ëŸ¬ë©´ ì–¼ë§ˆë¥¼ ìë¥´ì§€? 2ë¥¼ ìë¦„. 
ë†’ì´    ìë¥¸ í•©    ì •ë‹µê³¼ ì°¨ì´
2       0       1
1       2       1
0       4       3
i_centerê°€ ì‘ì„ìˆ˜ë¡ ë‚˜ë¬´ê°€ ì»¤ì§. ë‚´ ìƒê°ì—ëŠ” ì¸ë±ìŠ¤ ë¶„í• í•  ë•Œ ì¸ë±ìŠ¤ê°€
ì™¼ìª½ ì˜ì—­ / ì˜¤ë¥¸ìª½ ì˜ì—­ ì´ë ‡ê²Œ ì¡íˆëŠ”ê²Œ ì¢‹ì€ë°?
ì ì–´ë„ Më¯¸í„°!!!!!!!!!!!!!!!!!!!!
ë§ˆì§€ë§‰ì— differenceë¥¼ >= 0ìœ¼ë¡œ ë§Œë“¤ë•Œë§Œ ëë‚´ì•¼ í•œë‹¤!
ì•ˆ ìë¥´ëŠ”ê²Œ ë‚˜ì€ ê²½ìš°ê°€ ìƒê²¨ë²„ë¦¬ëŠ”ë°, ë” ìë¥´ê²Œ í•˜ëŠ” ë°©ë²•ì€ ì—†ë‚˜? ì´ëŸ´ ë• ì¡°ê±´ì„ 
ì°¾ì•„ì•¼ í•œë‹¤.

ì–´ì©„ë“  ì°¨ì´ê°€ 0ë³´ë‹¤ ì‘ì„ ë•ŒëŠ” 
ì¼ë‹¨ ê°€ì ¸ê°€ê¸´ í•´ì•¼ í•¨.
ê·¸ëŸ¬ë©´.. ì¡°ê±´ì„ ì–´ë–»ê²Œ ì¡ì§€? ì¸ë±ìŠ¤ë¥¼... 1ì”© ë°”ê¿” ë³¼ê¹Œ
ì•„ ì´ê±° ì–´ë–¡í•˜ì§€. ê²°ê³¼ ê°’ì´ 0ì¼ ìˆ˜ëŠ” ì—†ëŠ” ê±´ë°. ë§Œì•½ 0ì¼ë•ŒëŠ” i ê°’ì„ 
ì‹œë„: ìœ„ ì½”ë“œ.
ê²°ê³¼ ë¶„ì„: ì„±ê³µ!
"""
```

## Phase2. í’€ì´ ê³¼ì • ì •ë¦¬(ëŠë‚€ì )

### ë…ì„œëŠ” ì¤‘ìš”í•˜ë‹¤: Incremental to divide-and-conquer

ì–´ë–¤ ë¬¸ì œë¥¼ incremental methodë¡œ í’€ì´í•˜ëŠ” ë°©ì‹ì„ ì´í•´í•´ì•¼, divide-and-conquer ë°©ì‹ì„ ì–´ë””ì— ì ìš©í• ì§€ ìƒê°í•  ìˆ˜ ìˆë‹¤(Introduction to Algorithmë¥¼ í†µí•´ incremental methodì—­ì‹œ í•˜ë‚˜ì˜ ë°©ì‹ì„ì„ ì´í•´í•œ ë•ë¶„ì— ì´ëŸ° ë°œìƒì´ ë‚˜ì™”ë‹¤). ì´ ë¬¸ì œì˜ ê²½ìš° incremental methodë¥¼ ì•„ë˜ì™€ ê°™ì´ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

(ì—„ë°€íˆ ë”°ì§€ë©´ í‹€ë¦° ë°©ì‹ì„ ë”°ë¥´ê³  ìˆìŒ)

```python

def cut_sum(height: int):
    sum_tmp = 0
    for tree in trees:
        sum_tmp += tree - height if tree > height else 0
    return sum_tmp

h_x = 0
prev_difference = MAX_INT

for i in range(0, max(trees)):
    cut_amount = cut_sum(i)
    difference = abs(cut_amount-m)
    if difference < prev_difference: # update
        prev_difference = difference
        h_x = i

# print(h_x)
```

ì´ë•Œ i(ë‚˜ë¬´ë¥¼ ìë¥´ëŠ” ë†’ì´)ê°€ ì¦ê°€í•˜ê²Œ ë˜ë©´ cut_sum(i) ê°’ì€ ì•„ë˜ì™€ ê°™ì´ ìš°í•˜í–¥ ê·¸ë˜í”„ë¥¼ ê·¸ë¦¬ê²Œ ëœë‹¤. 

![](./images/IMG_9966.png)

ê·¸ë ‡ë‹¤ë©´, cut_sum(i)ì˜ ë¦¬í„´ ê°’ê³¼ êµ¬í•´ì•¼ í•˜ëŠ” mê°’ì„ ë¹„êµí•˜ì—¬ f(x)ì— ëŒ€í•´ f(x)-m ê°’ì„ 0ìœ¼ë¡œ ë§Œë“¤ì–´ì£¼ëŠ” xê°’ì„ ì´ì§„ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•˜ì—¬ êµ¬í•  ìˆ˜ ìˆë‹¤.(ì¬ë°Œë‹¤!)

### ì¡°ê±´ì€ ì¤‘ìš”í•˜ë‹¤

â€˜ì ì–´ë„ m ê¸¸ì´ ì´ìƒì˜ ë‚˜ë¬´ë¥¼ ì˜ë¼ê°„ë‹¤â€™ëŠ” ì¡°ê±´ì„ ìƒê°í•˜ì§€ ì•Šì•˜ë‹¤ê°€ ì•„ë˜ì™€ ê°™ì€ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ì—ì„œ ì˜¤ë‹µì„ ë‚´ëŠ” ì½”ë“œë¥¼ ì‘ì„±í–ˆë‹¤.

ë‚˜ë¬´ì˜ ê°œìˆ˜: 2(ìƒê´€ ì—†ìŒ)

ì˜ë¼ì•¼ í•˜ëŠ” ê¸¸ì´: 1

ê° ë‚˜ë¬´ ë†’ì´: 2 2

ì´ë•Œ ì œëŒ€ë¡œ ëœ ì •ë‹µì€ ë†’ì´ 1ì—ì„œ ì˜ë¼ì„œ 2ì˜ ë‚˜ë¬´ë¥¼ ì–»ëŠ” ê²ƒì´ì§€ë§Œ, ë¬´ì‹í•œ ì´ì§„ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ì€ ê·¸ëŸ° ê±° ìƒê´€ ì—†ì´ f(x)-mì„ ì ˆëŒ€ê°’ ë¬´ì‹œí•˜ê³  0ìœ¼ë¡œ ìˆ˜ë ´ì‹œí‚¤ëŠ” íƒìƒ‰ì„ í•´ë²„ë¦°ë‹¤. ê·¸ë˜ì„œ ë””ë²„ê¹… ëì— ì¡°ê±´ì„ ê³ ë ¤í•œ ì½”ë“œë¥¼ ì‘ì„±í–ˆë‹¤. (ìë¥´ëŠ” ë†’ì´ê°€ 0ì´í•˜ë¼ëŠ” ê²°ë¡ ì´ ë‚˜ë©´ ì´ì „ì— ì €ì¥í•œ ì–‘ì˜ ê°’ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì½”ë“œë¥¼ ì‘ì„±)

```python
		
		while left < right:
        # print(f'{left} --- {right}')
        i_center = (left+right)//2 # i for representing incremental parameter
        difference = f(i_center)
        # print(f'difference is {difference}.')
        if difference < 0: 
            # print(f'conquer left')
            left, right = left, i_center 
            if left >= right:  # ë‚˜ë¬´ë¥¼ ìë¥´ì§€ ì•ŠëŠ” ë†’ì´ì—ì„œ, ë‹¤ìŒ í„´ì— íƒìƒ‰ì„ ë§ˆì¹œë‹¤ë©´!
                return prev_center # ì•„, ë‘˜ ë‹¤ ê·¸ê±°ì¼ ìˆ˜ ìˆêµ¬ë‚˜. ë‘ í„´ ë‹¤ ìŒìˆ˜ê°€ ë‚˜ì˜¬ ìˆ˜ë„ ìˆìŒ.
        elif difference > 0: 
            # print(f'conquer right')
            left, right = i_center+1, right
            prev_center = i_center
            # ì´ë•ŒëŠ” i_centerê°€ ë¬´ì¡°ê±´ ë‚˜ë¬´ë¥¼ ì˜ë¼ê°€ëŠ” ê²ƒì„ ë³´ì¥ ì—¬ê¸°ì„œ ê°±ì‹  í•„ìš”
        else: # ì°¨ì´ê°€ 0ê³¼ ê°™ìŒ(best case)
            return i_center
    return i_center
```

## Phase3. í”¼ë“œë°±

ì •ë§ í›Œë¥­í•œ ì ‘ê·¼ê³¼ ì •ë¦¬ì˜€ì–´ìš”. ë¬¸ì œë¥¼ incremental ë°©ì‹ì—ì„œ ì¶œë°œí•´ divide-and-conquerì˜ ë³¸ì§ˆì  ì‚¬ê³ ë°©ì‹ìœ¼ë¡œ ì „í™˜í•´ë‚¸ ê³¼ì •ì´ ì¸ìƒ ê¹Šê³ , íŠ¹íˆ **í•¨ìˆ˜ì˜ ë‹¨ì¡°ì„±(ìš°í•˜í–¥)**ì„ ë°”íƒ•ìœ¼ë¡œ ì´ì§„ íƒìƒ‰ì´ ì™œ ê°€ëŠ¥í•œì§€ë¥¼ ì •í™•íˆ ì´í•´í•˜ê³  ì ìš©í•œ ì ì´ ì¢‹ìŠµë‹ˆë‹¤.

ğŸ’¡ ì½”ë©˜íŠ¸ ëª‡ ê°€ì§€ ë“œë¦¬ìë©´:

1. f(x) ì •ì˜ì™€ ë‹¨ì¡°ì„±

â€¢	f(x) = (ì˜ë¦° ë‚˜ë¬´ ì´í•©) - M

â€¢	ì´ í•¨ìˆ˜ëŠ” xê°€ ì»¤ì§ˆìˆ˜ë¡ ì ì  ì‘ì•„ì§€ë©°, ì´ëŠ” ë‹¨ì¡° ê°ì†Œ í•¨ìˆ˜ì…ë‹ˆë‹¤.

â€¢	ë‹¨ì¡°í•¨ìˆ˜ì˜ ì„±ì§ˆì´ ì´ì§„íƒìƒ‰ì„ ê°€ëŠ¥í•˜ê²Œ ë§Œë“œëŠ” í•µì‹¬ì´ì—ìš”.

â†’ ì´ë ‡ê²Œ ë‹¨ì¡° ì¦ê°€/ê°ì†Œ ì—¬ë¶€ë¥¼ íŒë‹¨í•˜ëŠ” ê°ê°ì€ ë‹¤ë¥¸ ë¬¸ì œì—ë„ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

2. ì •ë‹µì„ ì—…ë°ì´íŠ¸í•˜ëŠ” ë°©ì‹

```plain text
elif difference > 0:
    left, right = i_center+1, right
    prev_center = i_center
```

â€¢	ì´ ë¶€ë¶„ì—ì„œ prev_centerì— ê°’ì„ ì €ì¥í•œ ê±´ ì•„ì£¼ ì„¼ìŠ¤ ìˆëŠ” ì˜ˆì™¸ ì²˜ë¦¬ì˜€ìŠµë‹ˆë‹¤.

â€¢	ì •í™•íˆëŠ” â€œf(center) >= 0ì¸ ì§€ì  ì¤‘ ê°€ì¥ í° ê°’â€ì„ ì°¾ëŠ” ê²ƒì´ë¯€ë¡œ, cut_sum(center) >= Mì¼ ë•Œë§ˆë‹¤ ê·¸ ê°’ì„ ê¸°ë¡í•´ë‘ëŠ” ë°©ì‹ì€ ì™„ì „íˆ ë§ëŠ” ì „ëµì´ì—ìš”.

ğŸ“Œ Tip: ì •ì„ ì´ì§„íƒìƒ‰ì—ì„  ë³´í†µ â€œì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìµœëŒ€(ë˜ëŠ” ìµœì†Œ)ì˜ ê°’â€ì„ êµ¬í•  ë•Œ ê²°ê³¼ê°’ì„ ë³„ë„ë¡œ ì €ì¥í•´ ë‘¡ë‹ˆë‹¤.

3. ë¦¬íŒ©í† ë§ ì—¬ì§€

ì´ì§„ íƒìƒ‰ ë¡œì§ì„ ì•„ë˜ì²˜ëŸ¼ ì¡°ê¸ˆ ì •ë¦¬í•˜ë©´ ë” ê¹”ë”í•´ì§ˆ ìˆ˜ ìˆì–´ìš”:

```plain text
def binary_search():
    left, right = 0, max(trees)
    result = 0  # cut_sum >= Mì„ ë§Œì¡±í•˜ëŠ” ë†’ì´ ì¤‘ ê°€ì¥ í° ê°’

    while left <= right:
        mid = (left + right) // 2
        if cut_sum(mid) >= m:
            result = mid  # ì¡°ê±´ ë§Œì¡±í•˜ë¯€ë¡œ ì €ì¥í•˜ê³ , ë” ë†’ì—¬ë³´ì
            left = mid + 1
        else:
            right = mid - 1
    return result
```

ì´ ë°©ì‹ë„ ê²°êµ­ ë³¸ì§ˆì€ ê°™ì§€ë§Œ, ì½”ë“œ ê°€ë…ì„±ê³¼ ì¢…ë£Œ ì¡°ê±´ ì²˜ë¦¬ ë©´ì—ì„œ ì•ˆì •ì„±ì´ ì¢€ ë” ìˆìŠµë‹ˆë‹¤. íŠ¹íˆ left <= right íŒ¨í„´ì€ ë” ìì£¼ ì‚¬ìš©ë˜ëŠ” ë°©ì‹ì´ì—ìš”.

4. ì‹œê°í™” ê°ê°

ì§ì ‘ cut_sum(i) ê·¸ë˜í”„ê°€ ìš°í•˜í–¥ í•¨ìˆ˜ë¼ëŠ” ì ì„ ê¹¨ë‹«ê³ , ì´ì§„ íƒìƒ‰ì´ ì ìš© ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²°ë¡ ì„ ì´ëŒì–´ë‚¸ ì‚¬ê³  íë¦„ì€ ì§„ì§œë¡œ ì¤‘ìš”í•©ë‹ˆë‹¤. ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ì—ì„œ â€œí•¨ìˆ˜ ì‹œê°í™” â†’ ì„±ì§ˆ íŒŒì•… â†’ íƒìƒ‰ ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨â€ì€ ë§¤ìš° í•µì‹¬ì ì¸ ì „ëµì´ê¸° ë•Œë¬¸ì´ì—ìš”.

âœ… í”¼ë“œë°± ìš”ì•½

í˜¹ì‹œ ë‹¤ìŒ ë¬¸ì œë¡œ ì—°ìŠµí•´ë³´ê³  ì‹¶ì€ ì´ì§„ íƒìƒ‰ ìœ í˜• ìˆìœ¼ë©´ ì¶”ì²œë„ í•´ì¤„ê²Œìš” :)

ë˜ëŠ” ìœ„ ë‚´ìš©ì„ ê¸°ìˆ  ë©´ì ‘/í¬íŠ¸í´ë¦¬ì˜¤ì²˜ëŸ¼ ì •ë¦¬í•´ë„ ë©‹ì§„ ìì‚°ì´ ë  ìˆ˜ ìˆì–´ìš”.

# ì´ì§„íƒìƒ‰: ê³µìœ ê¸° ì„¤ì¹˜

## Phase1. ì‹¤íŒ¨

```python
"""
1. ë¬¸ì œ ì½ê¸°: 
2. ë¬¸ì œ í’€ê¸°
2-1. recursive method. ê±°ë¦¬ ë°°ì—´ì„ ì¨ì•¼í•  ê±° ê°™ì€ë°. 
import sys
sys.setrecursionlimit(10**8) # 10^8 ê¹Œì§€ ëŠ˜ë¦¼.

n, c = tuple(map(int, sys.stdin.readline().split()))

X = [
    int(sys.stdin.readline().strip())
    for _ in range(n)
]

X.sort()

def get_min_distance(A:list):
    '''ì§‘ì— ë°°ì¹˜í•˜ëŠ” ê²½ìš° ê±°ë¦¬ì˜ ìµœì†Œê°’ êµ¬í•˜ê¸°'''
    if len(A) >= 2:
        min_dist = sys.maxsize
        for i in range(1, len(A)):
            min_dist = min(min_dist, A[i]-A[i-1])
        return min_dist 
    return 0

memo = {}
def set_router_recursively(A: list, X: list, idx_house: int, num_router: int):
    '''ì¬ê·€ì ìœ¼ë¡œ Xì—ì„œ ë¼ìš°í„°ë¥¼ ë†“ëŠ” ëª¨ë“  ê²½ìš°ë¥¼ Aì— êµ¬í•©ë‹ˆë‹¤.'''
    '''ë°”ë‹¥ ì¡°ê±´: ë§ˆì§€ë§‰ ì§‘ì— ë¼ìš°í„° ë°°ì¹˜í•˜ëŠ” ê²½ìš°ì—ì„œ ì¬ê·€í–ˆì„ ë•Œ, ë¼ìš°í„°ê°€ ë‹¤ ë°°ì¹˜ëë‹¤ë©´'''
    # ë°”ë‹¥ ì¡°ê±´ì˜ ê²½ìš°ë¥¼ ë©”ëª¨ì— ì €ì¥í•´ë†“ê³ , ë©”ëª¨ì— ìˆëŠ” ê²½ìš° ì¬ê·€ ì•ˆ í•˜ë©´ ì•ˆ ë˜ë‚˜.
    min_dist = get_min_distance(A)
    if memo.get(min_dist, False): 
        return
    if idx_house == len(X)-1:
        if num_router <= 0:
            memo[min_dist] = True
        return
    # idx_houseì— ë°°ì¹˜í•˜ëŠ” ê²½ìš°
    set_router_recursively([*A, X[idx_house]], X, idx_house+1, num_router-1)
    # idx_houseì— ë°°ì¹˜ ì•ˆ í•˜ëŠ” ê²½ìš°
    set_router_recursively(A, X, idx_house+1, num_router)

set_router_recursively([], X, 0, c)
print(max(memo.keys()))

1 2 4 8 9
ê·¸ ì„œë¸Œ ê°’ë„ ì˜¤ë¦„ì°¨ìˆœì´ ì•„ë‹ ê²ƒì„ .
0 ê·¸ë‹¤ìŒ ìµœì ì˜ ê°’ì„ ëª¨ë¦„

ì´ì§„íƒìƒ‰ì„ í™œìš©í•œ ë°±íŠ¸ë˜í‚¹? 

ë‹¤ìŒ ì²´ê³„ëŠ”? 

3. ìˆ˜ë„ ì½”ë“œ

4. ì½”ë“œ êµ¬í˜„

"""
import sys
sys.setrecursionlimit(10**8) # 10^8 ê¹Œì§€ ëŠ˜ë¦¼.

n, c = tuple(map(int, sys.stdin.readline().split()))

X = [
    int(sys.stdin.readline().strip())
    for _ in range(n)
]

X.sort()

def get_min_distance(A:list):
    '''ì§‘ì— ë°°ì¹˜í•˜ëŠ” ê²½ìš° ê±°ë¦¬ì˜ ìµœì†Œê°’ êµ¬í•˜ê¸°'''
    if len(A) >= 2:
        min_dist = sys.maxsize
        for i in range(1, len(A)):
            min_dist = min(min_dist, A[i]-A[i-1])
        return min_dist 
    return 0

memo = {}
max_min_dist = -sys.maxsize
def set_router_recursively(A: list, idx_house: int, num_router: int):
    global max_min_dist
    '''ì¬ê·€ì ìœ¼ë¡œ Xì—ì„œ ë¼ìš°í„°ë¥¼ ë†“ëŠ” ëª¨ë“  ê²½ìš°ë¥¼ Aì— êµ¬í•©ë‹ˆë‹¤.'''
    '''ë°”ë‹¥ ì¡°ê±´: ë§ˆì§€ë§‰ ì§‘ì— ë¼ìš°í„° ë°°ì¹˜í•˜ëŠ” ê²½ìš°ì—ì„œ ì¬ê·€í–ˆì„ ë•Œ, ë¼ìš°í„°ê°€ ë‹¤ ë°°ì¹˜ëë‹¤ë©´'''
    # ë°”ë‹¥ ì¡°ê±´ì˜ ê²½ìš°ë¥¼ ë©”ëª¨ì— ì €ì¥í•´ë†“ê³ , ë©”ëª¨ì— ìˆëŠ” ê²½ìš° ì¬ê·€ ì•ˆ í•˜ë©´ ì•ˆ ë˜ë‚˜.
    print('recursion call')
    min_dist = get_min_distance(A)

    if memo.get(min_dist, False): 
        return
    if idx_house == len(X)-1:
        if num_router <= 0:
            memo[min_dist] = True
            max_min_dist = max(max_min_dist, min_dist)
        return
    # idx_houseì— ë°°ì¹˜í•˜ëŠ” ê²½ìš°
    array_A = [*A, X[idx_house]]
    min_dist_A = get_min_distance(array_A)
    if min_dist_A > max_min_dist:
        set_router_recursively(array_A, idx_house+1, num_router-1)
    # idx_houseì— ë°°ì¹˜ ì•ˆ í•˜ëŠ” ê²½ìš° -> ì´ë•ŒëŠ” ëª¨ë¦„. ê·¸ëƒ¥ ê°€ì•¼ í•¨.
    # ê·¼ë° ê·¸ê±°ì¼ ìˆ˜ë„ ìˆì§€. ë‚¨ì€ ì§‘ ê°œìˆ˜ <= ë‚¨ì€ ë¼ìš°í„° ì—¬ì•¼ë§Œ ê°€ì•¼ì§€
    if len(X) - (idx_house+1) >= num_router: # ë‚¨ì€ ì§‘ ê°œìˆ˜ = ì „ì²´ ì§‘ ê°œìˆ˜(len(X)) - ì´ì œ ë³´ë ¤ëŠ” ì§‘ ë²ˆí˜¸
        set_router_recursively(A, idx_house+1, num_router)

set_router_recursively([], 0, c)
print(max(memo.keys()))

"""
ì´ìŠˆ: ë©”ëª¨ë¦¬ ì´ˆê³¼ ë°œìƒ
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ë©”ëª¨ë¦¬ ì´ˆê³¼
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì¬ê·€ì ìœ¼ë¡œ ìµœì„ ì˜ ê²½ìš° íƒìƒ‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ì‘ì„±
Phase2.
í™•ì¸: recursion caseì—ì„œ ì´ì§„ íƒìƒ‰ì²˜ëŸ¼ ì¡°ê±´ì„ ê±¸ì–´ì„œ í•˜ë©´ ë˜ë‚˜?
ì‹œë„:
ê²°ê³¼ ë¶„ì„:
"""
```

## Phase2. Introduction to Algorithmì˜ ë¶„í•  ì •ë³µ íŒŒíŠ¸ ì½ì–´ë³´ê¸°



