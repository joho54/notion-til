# [Algorithm] Python - 2



> ê°œë…ê³¼ ì´ìŠˆ íŠ¸ë˜í‚¹ì„ ì¡°í•©í•´ì„œ â€œë³µê¸° ê°€ëŠ¥í•œâ€ ìë£Œë¥¼ ë§Œë“¤ë„ë¡ í•©ë‹ˆë‹¤.

> ì´ìŠˆ íŠ¸ë˜í‚¹ ì‘ì„± ì›ì¹™: Phase1(í™˜ê²½, ë¡œê·¸, ìµœê·¼ ë³€ê²½ì‚¬í•­), Phase2(í™•ì¸, ì‹œë„, ê²°ê³¼ë¶„ì„) í˜•ì‹ìœ¼ë¡œ ì •ë¦¬í•˜ì„¸ìš”. (Phase2ëŠ” ìµœëŒ€ 3íšŒê¹Œì§€ ë°˜ë³µí•˜ê³  í•´ê²° ì•ˆ ë˜ë©´ ì•„ì˜ˆ ì²˜ìŒë¶€í„° ì‹œì‘(ë¶ˆê°€ëŠ¥í•  ê²½ìš° ë„ì›€ ìš”ì²­))

> ì‹¤ìŠµì€ ì²œì²œíˆ, í•˜ì§€ë§Œ robustí•˜ê²Œ í•˜ì„¸ìš”. 

> í’€ì´ì— ì‹¤íŒ¨í–ˆë‹¤ë©´, ì ‘ë§‰í‹€ ì •ë¦¬(ì ‘ê·¼ë°©ë²•, ë§‰íŒ ë¶€ë¶„)

# ì¬ê·€: ì¿¼ë“œíŠ¸ë¦¬

https://www.acmicpc.net/problem/1992

## ë¬¸ì œ

í‘ë°± ì˜ìƒì„ ì••ì¶•í•˜ì—¬ í‘œí˜„í•˜ëŠ” ë°ì´í„° êµ¬ì¡°ë¡œ ì¿¼ë“œ íŠ¸ë¦¬(Quad Tree)ë¼ëŠ” ë°©ë²•ì´ ìˆë‹¤. í° ì ì„ ë‚˜íƒ€ë‚´ëŠ” 0ê³¼ ê²€ì€ ì ì„ ë‚˜íƒ€ë‚´ëŠ” 1ë¡œë§Œ ì´ë£¨ì–´ì§„ ì˜ìƒ(2ì°¨ì› ë°°ì—´)ì—ì„œ ê°™ì€ ìˆ«ìì˜ ì ë“¤ì´ í•œ ê³³ì— ë§ì´ ëª°ë ¤ìˆìœ¼ë©´, ì¿¼ë“œ íŠ¸ë¦¬ì—ì„œëŠ” ì´ë¥¼ ì••ì¶•í•˜ì—¬ ê°„ë‹¨íˆ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

ì£¼ì–´ì§„ ì˜ìƒì´ ëª¨ë‘ 0ìœ¼ë¡œë§Œ ë˜ì–´ ìˆìœ¼ë©´ ì••ì¶• ê²°ê³¼ëŠ” "0"ì´ ë˜ê³ , ëª¨ë‘ 1ë¡œë§Œ ë˜ì–´ ìˆìœ¼ë©´ ì••ì¶• ê²°ê³¼ëŠ” "1"ì´ ëœë‹¤. ë§Œì•½ 0ê³¼ 1ì´ ì„ì—¬ ìˆìœ¼ë©´ ì „ì²´ë¥¼ í•œ ë²ˆì— ë‚˜íƒ€ë‚´ì§€ë¥¼ ëª»í•˜ê³ , ì™¼ìª½ ìœ„, ì˜¤ë¥¸ìª½ ìœ„, ì™¼ìª½ ì•„ë˜, ì˜¤ë¥¸ìª½ ì•„ë˜, ì´ë ‡ê²Œ 4ê°œì˜ ì˜ìƒìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì••ì¶•í•˜ê²Œ ë˜ë©°, ì´ 4ê°œì˜ ì˜ì—­ì„ ì••ì¶•í•œ ê²°ê³¼ë¥¼ ì°¨ë¡€ëŒ€ë¡œ ê´„í˜¸ ì•ˆì— ë¬¶ì–´ì„œ í‘œí˜„í•œë‹¤

ìœ„ ê·¸ë¦¼ì—ì„œ ì™¼ìª½ì˜ ì˜ìƒì€ ì˜¤ë¥¸ìª½ì˜ ë°°ì—´ê³¼ ê°™ì´ ìˆ«ìë¡œ ì£¼ì–´ì§€ë©°, ì´ ì˜ìƒì„ ì¿¼ë“œ íŠ¸ë¦¬ êµ¬ì¡°ë¥¼ ì´ìš©í•˜ì—¬ ì••ì¶•í•˜ë©´ "(0(0011)(0(0111)01)1)"ë¡œ í‘œí˜„ëœë‹¤. N Ã—N í¬ê¸°ì˜ ì˜ìƒì´ ì£¼ì–´ì§ˆ ë•Œ, ì´ ì˜ìƒì„ ì••ì¶•í•œ ê²°ê³¼ë¥¼ ì¶œë ¥í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì§ì ‘ í’€ê¸°

ìƒê°ë³´ë‹¤ëŠ” ì‰½ê²Œ í’€ë ¸ë‹¤. ë‹¨, ê´„í˜¸ë¥¼ ì¶œë ¥í•˜ëŠ” ë¶€ë¶„ì—ì„œ ì¬ê·€ì˜ ìˆœì„œë¥¼ ì œëŒ€ë¡œ ìƒê°í•˜ì§€ ì•Šì•„ì„œ ì¡°ê¸ˆ í—¤ë§¸ë‹¤. Zë³´ë‹¤ ì¢€ ë” ì‰¬ì› ëŠ”ë°, ì‚¬ì‹¤ ê±°ì˜ ë™ì¼í•œ ë¬¸ì œì¸ ê±° ê°™ë‹¤.

```javascript
# 1. ë¬¸ì œ ì½ê¸°
# 2. ë¬¸ì œ í’€ê¸°
# 3. ìˆ˜ë„ ì½”ë“œ
# 4. ì½”ë“œ êµ¬í˜„

def is_base(A: list, r: int, c: int, n: int):
    """A ë°°ì—´ì˜ r, cë¥¼ ì‹œì‘ì ìœ¼ë¡œ í•˜ëŠ” n ì˜ì—­ì˜ í•©ì„ êµ¬í•˜ê³ , 0ì´ê±°ë‚˜ n^2ì´ë©´ Trueë¥¼ ë¦¬í„´"""
    pixels = 0
    for i in range(r, r+n):
        for j in range(c, c+n):
            pixels += A[i][j]
    if pixels == 0: return 0
    elif pixels == n**2: return 1
    return -1

def recur(A: list, r, c, n):
    pixels = is_base(A, r, c, n)
    if pixels != -1:
        print(pixels, end='')
        return
    # 1 ì‚¬ë¶„ë©´ ì¬ê·€
    half = n//2
    print('(', end='')
    recur(A, r, c, half)
    # 3 ì‚¬ë¶„ë©´ ì¬ê·€
    recur(A, r, c+half, half)
    # 2 ì‚¬ë¶„ë©´ ì¬ê·€
    recur(A, r+half, c, half)
    # 4 ì‚¬ë¶„ë©´ ì¬ê·€
    recur(A, r+half, c+half, half)
    print(')', end='')
        

n = int(input())
arr = [
    tuple(map(int, list(input())))
    for _ in range(n)
]

recur(arr, 0, 0, n)

```

## Phase2. í”¼ë“œë°±

ì•„ë˜ëŠ” ì¿¼ë“œ íŠ¸ë¦¬(BOJ 1992) ë¬¸ì œë¥¼ í•´ê²°í•œ ì½”ë“œì™€ ê·¸ì— ëŒ€í•œ ìƒì„¸ í”¼ë“œë°±ì…ë‹ˆë‹¤.

1. ì „ì²´ ì½”ë“œ ë¦¬ë·°

ì œì‹œí•˜ì‹  ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

```python
def is_base(A: list, r: int, c: int, n: int):
    """A ë°°ì—´ì˜ r, cë¥¼ ì‹œì‘ì ìœ¼ë¡œ í•˜ëŠ” nÃ—n ì˜ì—­ì˜ ëª¨ë“  ì›ì†Œë¥¼ í•©í•œë‹¤.
       í•©ì´ 0ì´ë©´ ëª¨ë‘ 0, n^2ì´ë©´ ëª¨ë‘ 1, ê·¸ ì™¸ì—ëŠ” -1ì„ ë°˜í™˜."""
    pixels = 0
    for i in range(r, r+n):
        for j in range(c, c+n):
            pixels += A[i][j]
    if pixels == 0:          # ëª¨ë‘ 0
        return 0
    elif pixels == n**2:     # ëª¨ë‘ 1
        return 1
    return -1                # 0, 1 ì„ì—¬ ìˆìŒ

def recur(A: list, r: int, c: int, n: int):
    pixels = is_base(A, r, c, n)
    if pixels != -1:
        print(pixels, end='')  # ì••ì¶• ê²°ê³¼(0 ë˜ëŠ” 1)ë¥¼ ë°”ë¡œ ì¶œë ¥
        return

    # 0,1ì´ ì„ì—¬ ìˆìœ¼ë¯€ë¡œ 4ë“±ë¶„
    half = n // 2
    print('(', end='')

    # [1] top-left
    recur(A, r, c, half)
    # [2] top-right
    recur(A, r, c + half, half)
    # [3] bottom-left
    recur(A, r + half, c, half)
    # [4] bottom-right
    recur(A, r + half, c + half, half)

    print(')', end='')


n = int(input())
arr = [tuple(map(int, list(input()))) for _ in range(n)]

recur(arr, 0, 0, n)
```

â€¢	is_base í•¨ìˆ˜: ì£¼ì–´ì§„ êµ¬ì—­(r,c ë¶€í„° nÃ—n)ì„ ìˆœíšŒí•˜ë©° í•©ì´ 0ì´ë©´ ì „ë¶€ 0, í•©ì´ n^2ì´ë©´ ì „ë¶€ 1, ì„ì—¬ ìˆìœ¼ë©´ -1.

â€¢	ë°°ì—´ì— 0ê³¼ 1ë°–ì— ì—†ìœ¼ë¯€ë¡œ, í•©ì„ í†µí•´ â€œëª¨ë‘ 0 or ëª¨ë‘ 1â€ì„ ë¹ ë¥´ê²Œ íŒë³„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	recur í•¨ìˆ˜:

1.	is_baseë¡œ í˜„ì¬ êµ¬ì—­ì´ ì „ë¶€ 0 í˜¹ì€ ì „ë¶€ 1ì¸ì§€ í™•ì¸.

2.	ì „ë¶€ ê°™ì€ ê°’ì´ë©´(0 ë˜ëŠ” 1) ë°”ë¡œ ì¶œë ¥.

3.	ì•„ë‹ˆë©´ 4ê°œë¡œ ìª¼ê°œì–´ ê°ê° ì¬ê·€ í˜¸ì¶œí•˜ê³ , ì‚¬ì´ì— ê´„í˜¸ë¥¼ ì¶œë ¥.

ì •ìƒ ë™ì‘ ë° ì¶œë ¥ ìˆœì„œ

â€¢	ì¿¼ë“œ íŠ¸ë¦¬ ë¬¸ì œì—ì„œ ìš”êµ¬í•˜ëŠ” ìˆœì„œ(ì™¼ìª½ ìœ„, ì˜¤ë¥¸ìª½ ìœ„, ì™¼ìª½ ì•„ë˜, ì˜¤ë¥¸ìª½ ì•„ë˜)ëŒ€ë¡œ ì¬ê·€ê°€ ì§„í–‰ë˜ë¯€ë¡œ ë¬¸ì œ ì‚¬ì–‘ê³¼ ì¼ì¹˜í•©ë‹ˆë‹¤.

â€¢	ì¶œë ¥ í˜•ì‹((0(0011)(0(0111)01)1))ë„ ê´„í˜¸ë¥¼ ì—´ê³  ë‹«ëŠ” ìˆœì„œê°€ ë§ë‹¤ë©´ ì •ìƒì ì¸ ê²°ê³¼ë¥¼ ì–»ìŠµë‹ˆë‹¤.

2. ì„¸ë¶€ í”¼ë“œë°±

2.1 ì‚¬ë¶„ë©´(ì¿¼ë“œ) ìˆœì„œì™€ ì£¼ì„

ì½”ë“œì—ì„œ ì‚¬ë¶„ë©´ì„ í˜¸ì¶œí•˜ëŠ” ìˆœì„œëŠ”:

1.	recur(A, r, c, half) â†’ top-left

2.	recur(A, r, c+half, half) â†’ top-right

3.	recur(A, r+half, c, half) â†’ bottom-left

4.	recur(A, r+half, c+half, half) â†’ bottom-right

ê·¸ëŸ°ë° ì£¼ì„ì—ì„œ â€œ1ì‚¬ë¶„ë©´, 3ì‚¬ë¶„ë©´â€ ì‹ìœ¼ë¡œ í‘œí˜„í•˜ì…¨ë‹¤ë©´, ìˆ˜í•™ì  ì¢Œí‘œê³„ë‚˜ ì¼ë°˜ì  ì¿¼ë“œíŠ¸ë¦¬ í‘œê¸°ì™€ ì•½ê°„ ë‹¤ë¥¼ ìˆ˜ ìˆì–´ì„œ í˜¼ë™ë  ì—¬ì§€ê°€ ìˆìŠµë‹ˆë‹¤.

â€¢	ë³´í†µ â€œ1ì‚¬ë¶„ë©´(top-left), 2ì‚¬ë¶„ë©´(top-right), 3ì‚¬ë¶„ë©´(bottom-left), 4ì‚¬ë¶„ë©´(bottom-right)â€ë¼ëŠ” ì‹ìœ¼ë¡œ ëª…ëª…í•˜ë©´, ìˆœì„œì™€ ì£¼ì„ì´ ì–´ê¸‹ë‚  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ë¬¸ì œì—ì„œ ìš”êµ¬í•˜ëŠ” ì²˜ë¦¬ ìˆœì„œëŠ” â€œì™¼ìœ„, ì˜¤ë¥¸ìœ„, ì™¼ì•„ë˜, ì˜¤ë¥¸ì•„ë˜â€ì´ë¯€ë¡œ, ì½”ë“œì²˜ëŸ¼ ëª…í™•íˆ ì£¼ì„ì„ ë‹¬ì•„ë‘ë©´ ì¢‹ìŠµë‹ˆë‹¤(ì˜ˆ: â€œtop-leftâ€, â€œtop-rightâ€, â€œbottom-leftâ€, â€œbottom-rightâ€).

2.2 ì‹œê°„ ë³µì¡ë„: ëª¨ë“  ë¶„í•  ì‹œ ë§¤ë²ˆ í•© ê³„ì‚°

â€¢	í˜„ì¬ ì½”ë“œëŠ” ë§¤ ë¶„í• ë§ˆë‹¤ nÃ—n ì›ì†Œë¥¼ ì „ë¶€ ìˆœíšŒ(is_base)í•˜ê³ , 0/1 íŒë³„ í›„ í•„ìš”ì‹œ 4ë¶„í• ì„ í•©ë‹ˆë‹¤.

â€¢	ìµœì•…ì˜ ê²½ìš°(ëª¨ë‘ ì„œë¡œ ë‹¤ë¥¸ íŒ¨í„´)ì—ëŠ” ê° ë¶„í• ë§ˆë‹¤ nÃ—nì„ ìŠ¤ìº” â†’ ë¶„í• ì´ log(n) ë‹¨ê³„(2ì°¨ì›ì )ë¡œ ì§„í–‰ â†’ ëŒ€ëµ O(n^2 log n) ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	N ìµœëŒ€ 64 ì •ë„ë¼ë©´ ì „í˜€ ë¬¸ì œ ì—†ê³ , ì¼ë°˜ì ì¸ BOJ 1992 ì œí•œ(N â‰¤ 64) ì•ˆì—ì„œëŠ” ì¶©ë¶„íˆ ë¹ ë¦…ë‹ˆë‹¤.

â€¢	ë§Œì•½ Nì´ ë” ì»¤ì§„ë‹¤ë©´ í”„ë¦¬í”½ìŠ¤ í•©(2D prefix sum) ë“±ì„ ì´ìš©í•´ ì„œë¸Œ êµ¬ì—­ì˜ í•©ì„ O(1)ì— êµ¬í•˜ë©´ ë” íš¨ìœ¨ì ì´ê¸´ í•˜ì§€ë§Œ, ì´ ë¬¸ì œì—ì„  í•„ìš” ì—†ìŠµë‹ˆë‹¤.

2.3 â€œëª¨ë‘ ê°™ì€ ê°’â€ íŒë³„í•˜ëŠ” ë‹¤ë¥¸ ë°©ë²•

â€¢	í•©ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³ , â€œì²« ë²ˆì§¸ ì›ì†Œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì „ë¶€ ë¹„êµâ€í•´ì„œ ë‹¤ë¥¸ ê°’ì´ í•˜ë‚˜ë¼ë„ ë‚˜ì˜¤ë©´ ë¶„í• â€ í•˜ëŠ” ì‹ë„ ìˆìŠµë‹ˆë‹¤:

```python
first_val = A[r][c]
all_same = True
for i in range(r, r+n):
    for j in range(c, c+n):
        if A[i][j] != first_val:
            all_same = False
            break
    if not all_same:
        break

if all_same:
    print(first_val, end='')
    return
# else ë¶„í• 
```

â€¢	ì„±ëŠ¥ìƒ í° ì°¨ì´ëŠ” ì—†ê³ (ì—­ì‹œ O(n^2)), 0/1ë§Œ ë‹¤ë£¨ëŠ” ë¬¸ì œì—ì„œëŠ” í•©ì„ í†µí•´ n^2ê³¼ ë¹„êµí•˜ëŠ” ë°©ë²•ì´ë‚˜, ëª¨ë“  ê°’ì´ ë™ì¼í•œì§€ ë¹„êµí•˜ëŠ” ë°©ë²•ì´ë‚˜ ììœ ë¡­ê²Œ ì„ íƒ ê°€ëŠ¥í•©ë‹ˆë‹¤.

2.4 ì¶œë ¥ ë°©ì‹(ë¬¸ìì—´ vs print)

â€¢	í˜„ì¬ëŠ” í•¨ìˆ˜ ë‚´ì—ì„œ print(..., end='')ë¡œ ë°”ë¡œë°”ë¡œ ì¶œë ¥í•˜ê³  ìˆìŠµë‹ˆë‹¤.

â€¢	BOJ í™˜ê²½ì—ì„œëŠ” ì´ë ‡ê²Œ í•´ë„ ë¬¸ì œ ì—†ì§€ë§Œ, ë¬¸ìì—´ì„ ëª¨ì•„ ë§ˆì§€ë§‰ì— í•œ ë²ˆì— ì¶œë ¥í•˜ëŠ” ë°©ì‹ì„ ì„ í˜¸í•˜ëŠ” ê²½ìš°ë„ ìˆìŠµë‹ˆë‹¤(ì„±ëŠ¥ ë° ìœ ì§€ë³´ìˆ˜).

â€¢	ì›í•˜ì‹œë©´ return ê°’ìœ¼ë¡œ ë¬¸ìì—´ì„ ë„˜ê¸°ê³  ìµœì¢…ì— print(result_str)ë¥¼ í•œ ë²ˆì— ì°ëŠ” ë°©ì‹ìœ¼ë¡œ ë°”ê¿€ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

ì˜ˆì‹œ (ë¬¸ìì—´ í•©ì¹˜ëŠ” ë²„ì „):

```python
def quad_tree(A, r, c, n):
    val = is_base(A, r, c, n)
    if val != -1:
        return str(val)
    half = n // 2
    top_left = quad_tree(A, r, c, half)
    top_right = quad_tree(A, r, c + half, half)
    bottom_left = quad_tree(A, r + half, c, half)
    bottom_right = quad_tree(A, r + half, c + half, half)
    return "(" + top_left + top_right + bottom_left + bottom_right + ")"
```

ì´ë ‡ê²Œ í•˜ë©´ ë§ˆì§€ë§‰ì— print(quad_tree(A, 0, 0, n))ë¡œ ê¹”ë”í•˜ê²Œ í•œ ë²ˆì— ì¶œë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤.

3. ê²°ë¡  ì •ë¦¬

1.	ì½”ë“œ ê¸°ëŠ¥: ìš”êµ¬ ì‚¬í•­ëŒ€ë¡œ ì˜ ë™ì‘í•©ë‹ˆë‹¤.

2.	ì‚¬ë¶„ë©´ ìˆœì„œ: ë¬¸ì œì—ì„œ ì œì‹œí•œ â€œì™¼ìœ„, ì˜¤ë¥¸ìœ„, ì™¼ì•„ë˜, ì˜¤ë¥¸ì•„ë˜â€ ìˆœì„œë¥¼ ì •í™•íˆ ì¤€ìˆ˜í•˜ë©´ ë©ë‹ˆë‹¤.

3.	ì‹œê°„ ë³µì¡ë„: N=64 ì´í•˜ë¼ë©´ í˜„ì¬ êµ¬í˜„(ë§¤ ë¶„í•  ì‹œ nÃ—n ìŠ¤ìº”)ë„ ì„±ëŠ¥ìƒ ì¶©ë¶„í•©ë‹ˆë‹¤.

4.	ì¶œë ¥ ë°©ì‹: ì§€ê¸ˆì²˜ëŸ¼ printë¥¼ ì¬ê·€ ì•ˆì—ì„œ ë°”ë¡œ ì“°ëŠ” ê²ƒë„ ë¬¸ì œ ì—†ì§€ë§Œ, ë¬¸ìì—´ì„ í•©ì³ì„œ í•œ ë²ˆì— ì¶œë ¥í•˜ëŠ” íŒ¨í„´ë„ ì¢‹ìŠµë‹ˆë‹¤.

ì „ì²´ì ìœ¼ë¡œ â€œì¿¼ë“œ íŠ¸ë¦¬â€ ë¬¸ì œ ì˜ë„ì— ë§ëŠ” ì „í˜•ì ì¸ ì¬ê·€ êµ¬í˜„ì´ë©°, ë¡œì§ì€ ì™„ë²½í•˜ê²Œ ì‘ì„±ë˜ì—ˆë‹¤ê³  ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì£¼ì„ê³¼ ë³€ìˆ˜ëª…ë§Œ ì¡°ê¸ˆ ë” ëª…í™•í•˜ê²Œ ì •ë¦¬í•˜ë©´, ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì´ ì¢‹ì•„ì§ˆ ê²ƒì…ë‹ˆë‹¤. ì¶•í•˜ë“œë¦½ë‹ˆë‹¤!

# ì¬ê·€: ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬Â 

https://www.acmicpc.net/problem/5639

ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ë¥¼ ì „ìœ„ ìˆœíšŒí•œ ê²°ê³¼ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ íŠ¸ë¦¬ë¥¼ í›„ìœ„ ìˆœíšŒí•œ ê²°ê³¼ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ëˆ„ë”ê¸° ì½”ë“œ 

```python
"""
1. ë¬¸ì œ ì½ê¸° 
ê·¸ëƒ¥ ì¬ê·€ë¥¼ í•˜ëŠ”ë°, í›„ìœ„ëŠ” ë¹ ì ¸ë‚˜ì˜¬ ë•Œ í”„ë¦°íŠ¸ í•˜ë©´ ë¨.
ê·¸ëŸ°ë° ì…ë ¥ì´ ì „ìœ„ìˆœíšŒ ê²°ê³¼ë¼ì„œ. ì•„ ê·¸ëƒ¥ ë¹ˆ ë°°ì—´ í•˜ë‚˜ ë§Œë“¤ê³ , 
ì „ìœ„ ìˆœíšŒ íƒ€ì´ë°ì— ê·¸ëƒ¥ ì‚½ì…í•˜ë©´ ì•ˆ ë˜ë‚˜, ì•ˆ ëœë‹¤. ì™„ì „ ì´ì§„ íŠ¸ë¦¬ê°€ ì•„ë‹ˆë‹¤!

2. ë¬¸ì œ í’€ê¸°

3. ìˆ˜ë„ ì½”ë“œ

4. ì½”ë“œ êµ¬í˜„
"""

import sys


def post_search(idx: int):
    global arr
    """í¬ê¸°ê°€ nì¸ ë°°ì—´ì˜ idx ë²ˆì§¸ ìš”ì†Œë¥¼ í›„ìœ„ìˆœíšŒ í•©ë‹ˆë‹¤."""
    # ë§Œì•½ ì™¼ìª½ ìì‹ì´ ì¡´ì¬ í•˜ë©´
    if idx >= len(bt): return
    post_search(idx*2+1)
    post_search(idx*2+2)
    if bt[idx] != 0: print(bt[idx])


def insert_binary_tree(val: int):
    print(f'inserting: {val}')
    global bt
    if bt[0] == 0: 
        bt[0] = val # ì²« ë²ˆì§¸ ê°’ ì‚½ì…
        return
    ptr = 0
    while True:
        print(f'current ptr: {ptr}')
        if val < bt[ptr]: # ì™¼ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+1] != 0: # ì™¼ìª½ ìì‹ì´ ì¡´ì¬í•˜ë©´ ê·¸ìª½ìœ¼ë¡œ í¬ì¸í„° ì´ë™
                ptr = ptr*2+1
                print('moving to left child')
                continue
            else: #ì™¼ìª½ ìì‹ì´ ì—†ìœ¼ë©´ ê±°ê¸°ì— ì‚½ì…
                bt[ptr*2+1] = val
                print(f'inserting {val} as left child of {bt[ptr]}')
                break
        elif val > bt[ptr]: # ì˜¤ë¥¸ ìì‹ìœ¼ë¡œ ì‚½ì…
            print(f'{val} > {bt[ptr]}')
            if bt[ptr*2+2] != 0:
                ptr = ptr*2+2
                print('moving to right child')
                continue
            else:
                bt[ptr*2+2] = val
                print(f'inserting {val} as right child of {bt[ptr]}')
                break


arr = []
for line in sys.stdin:
    # lineì€ '\n'ì„ í¬í•¨í•˜ë¯€ë¡œ line.strip()ìœ¼ë¡œ ê°œí–‰ ì œê±°
    arr.append(int(line.strip()))

n = len(arr)
bt = [0]*(n**4) # ëª¨ë‘ ì–‘ì˜ ì •ìˆ˜ë§Œ ì…ë ¥ë¨
for a in arr:
    insert_binary_tree(a)

post_search(0)


"""
ì´ìŠˆ: binary search treeì— ê°’ ì¸ì„œíŠ¸ê°€ ì´ìƒí•˜ê²Œ ë¨
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: '50', '30', '98', '24', '5', '52', 0, 0, '28', '45', 0, 0, '60'
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„íŠ¸ë¦¬ ì‚½ì… ë¶€ë¶„ êµ¬í˜„

def insert_binary_tree(val: int):
    print(f'inserting: {val}')
    global bt
    if bt[0] == 0: 
        bt[0] = val # ì²« ë²ˆì§¸ ê°’ ì‚½ì…
        return
    ptr = 0
    while True:
        if val < bt[ptr]: # ì™¼ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+1] != 0: # ì™¼ìª½ ìì‹ì´ ì¡´ì¬í•˜ë©´ ê·¸ìª½ìœ¼ë¡œ í¬ì¸í„° ì´ë™
                ptr = ptr*2+1
                continue
            else: #ì™¼ìª½ ìì‹ì´ ì—†ìœ¼ë©´ ê±°ê¸°ì— ì‚½ì…
                bt[ptr*2+1] = val
                break
        elif val > bt[ptr]: # ì˜¤ë¥¸ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+2] != 0:
                ptr = ptr*2+2
                continue
            else:
                bt[ptr*2+2] = val
                break
Phase2.
í™•ì¸: ì˜¤ë¥¸ìª½ ìì‹ìœ¼ë¡œ ê°€ëŠ” ë¶€ë¶„ì´ ì¢€ ì´ìƒí•œ ê±° ê°™ì€ë°. ë¬¸ìì—´ì„ ê·¸ëŒ€ë¡œ ì‘¤ì…”ë°•ìœ¼ë‹ˆ ê·¸ë ‡ì§€!

moving to left child
current ptr: 1
5 > 30
inserting 5 as right child of 30

ë¡œê·¸ í™•ì¸ ê²°ê³¼ ì´ëŸ° ê¸°ê°€ë§‰íŒ ì—°ì‚°ì„ í•˜ê³  ìˆì—ˆìŒì„ í™•ì¸. ì´ê±´ ê·¸ëƒ¥ ë””ë²„ê±° ë´¤ìœ¼ë©´ ë” ë¹¨ë¦¬ ìºì¹˜í–ˆì„ ê±° ê°™ê¸°ë„ í•˜ê³ .
ì´ìŠˆë°©ì§€ìœ„ì›íšŒ, ì¤„ì—¬ì„œ ì´ë°©ìœ„ë¥¼ ì—´ì–´ì•¼ê² ë‹¤.
ì‹œë„: ì •ìˆ˜í˜•ìœ¼ë¡œ ì…ë ¥ê°’ ìºìŠ¤íŒ…
ê²°ê³¼: í•´ê²°

ì´ìŠˆ: í›„ìœ„ìˆœíšŒê°€ ì•ˆ ë¼ìš”
Phase1. 
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì˜ëª»ëœ í›„ìœ„ ìˆœìœ„ ê²€ìƒ‰ ê²°ê³¼
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì—†ìŒ

Phase2.
í™•ì¸: ì¬ê·€ ê³¼ì •ì„ í™•ì¸í•˜ê³ , ì¶œë ¥ë¬¸ì„ ì°ìœ¼ë©´ ì¢‹ì„ ì ì ˆí•œ íƒ€ì´ë°ì„ íƒ‘ë‹¤ìš´ ë°©ì‹ìœ¼ë¡œ ë¶„ì„í•´ë³´ê¸°.
ì‹œë„: ê·¸ëƒ¥ ë°°ì—´ê³¼ ì¸ë±ìŠ¤ë¥¼ í†µì§¸ë¡œ ì˜ëª» ì°¸ì¡°í•˜ê³  ìˆì—ˆìŒ. 
ê²°ê³¼ ë¶„ì„: í•´ê²°. ì½”ë“œì˜ ë¡œì§ì€ êµ¬í˜„ ì™„ë£Œ. ê·¸ëŸ°ë° ëˆ„ë”ê¸°ë¡œ ì‘ì„±í•œ ìë£Œêµ¬ì¡° ë•ë¶„ì— ë©”ëª¨ë¦¬ ì´ˆê³¼ê°€ ë°œìƒ

"""
```

### ë¡œê·¸ ì—†ëŠ” ë²„ì „

```python
"""
1. ë¬¸ì œ ì½ê¸° 
ê·¸ëƒ¥ ì¬ê·€ë¥¼ í•˜ëŠ”ë°, í›„ìœ„ëŠ” ë¹ ì ¸ë‚˜ì˜¬ ë•Œ í”„ë¦°íŠ¸ í•˜ë©´ ë¨.
ê·¸ëŸ°ë° ì…ë ¥ì´ ì „ìœ„ìˆœíšŒ ê²°ê³¼ë¼ì„œ. ì•„ ê·¸ëƒ¥ ë¹ˆ ë°°ì—´ í•˜ë‚˜ ë§Œë“¤ê³ , 
ì „ìœ„ ìˆœíšŒ íƒ€ì´ë°ì— ê·¸ëƒ¥ ì‚½ì…í•˜ë©´ ì•ˆ ë˜ë‚˜, ì•ˆ ëœë‹¤. ì™„ì „ ì´ì§„ íŠ¸ë¦¬ê°€ ì•„ë‹ˆë‹¤!

2. ë¬¸ì œ í’€ê¸°

3. ìˆ˜ë„ ì½”ë“œ

4. ì½”ë“œ êµ¬í˜„
"""

import sys


def post_search(idx: int):
    global arr
    """í¬ê¸°ê°€ nì¸ ë°°ì—´ì˜ idx ë²ˆì§¸ ìš”ì†Œë¥¼ í›„ìœ„ìˆœíšŒ í•©ë‹ˆë‹¤."""
    # ë§Œì•½ ì™¼ìª½ ìì‹ì´ ì¡´ì¬ í•˜ë©´
    if idx >= len(bt): return
    post_search(idx*2+1)
    post_search(idx*2+2)
    if bt[idx] != 0: print(bt[idx])


def insert_binary_tree(val: int):
    global bt
    if bt[0] == 0: 
        bt[0] = val # ì²« ë²ˆì§¸ ê°’ ì‚½ì…
        return
    ptr = 0
    while True:
        if val < bt[ptr]: # ì™¼ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+1] != 0: # ì™¼ìª½ ìì‹ì´ ì¡´ì¬í•˜ë©´ ê·¸ìª½ìœ¼ë¡œ í¬ì¸í„° ì´ë™
                ptr = ptr*2+1
                continue
            else: #ì™¼ìª½ ìì‹ì´ ì—†ìœ¼ë©´ ê±°ê¸°ì— ì‚½ì…
                bt[ptr*2+1] = val
                break
        elif val > bt[ptr]: # ì˜¤ë¥¸ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+2] != 0:
                ptr = ptr*2+2
                continue
            else:
                bt[ptr*2+2] = val
                break


arr = []
for line in sys.stdin:
    # lineì€ '\n'ì„ í¬í•¨í•˜ë¯€ë¡œ line.strip()ìœ¼ë¡œ ê°œí–‰ ì œê±°
    arr.append(int(line.strip()))

n = len(arr)
bt = [0]*(n**2) # ëª¨ë‘ ì–‘ì˜ ì •ìˆ˜ë§Œ ì…ë ¥ë¨
for a in arr:
    insert_binary_tree(a)

post_search(0)


```

## Phase2. í”¼ë“œë°± ë° ë°˜ì„±

### ë°˜ì„±

1. ì¸ë±ìŠ¤ ì´ë¦„, í•¨ìˆ˜ ì´ë¦„ë§Œ ì¢€ ê¸¸ê²Œ ì¨ë„ ë§ì€ ì‚½ì§ˆì„ í”¼í•  ìˆ˜ ìˆì„ ê±° ê°™ë‹¤. êµ¬ì²´ì ìœ¼ë¡œ ì“°ë©´ ì¸ì§€ê°€ ë˜ëŠ”ë°, ê·¸ëƒ¥ ì•ŒíŒŒë²³ë§Œ ì‘ì„±í•˜ë©´ ê°œë…ì´ ì•ˆ ì¡íˆê³ , ì˜ëª» ì íŒ ì¸ë±ìŠ¤ë„ ì•Œì•„ë³´ê¸° ì–´ë µë‹¤.
1. ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ë¥¼ ì „í˜€ êµ¬í˜„í•˜ì§€ ëª»í•˜ê² ë‹¤. ìœ„ì˜ ë°°ì—´ì„ í™œìš©í•œ êµ¬ì¡°ëŠ” ê³µê°„ë³µì¡ë„ê°€ ì •ì‹  ë‚˜ê°„ë‹¤.
1. ì…ë ¥ ê°’ì˜ ê°œìˆ˜ê°€ ì£¼ì–´ì§€ì§€ ì•Šê³  ì…ë ¥ë§ˆë‹¤ ê°œí–‰ë¬¸ìê°€ ìˆëŠ” ê²½ìš°ì˜ ì…ë ¥ ë§¤ì»¤ë‹ˆì¦˜ì„ ì˜ ëª¨ë¥´ê² ë‹¤. sys.stdinì€  line1\n, line\n ì´ë ‡ê²Œ ì£¼ì–´ì§€ê³ , ê° ì¤„ì— ì£¼ì–´ì§„ ì…ë ¥ì„ ì´í„°ë ˆì´ì…˜í•˜ë©° line.strip() ì‘ì—…ì„ í•˜ì—¬ whitespaceë¥¼ ì œê±°í•˜ëŠ”ê°€?
### í”¼ë“œë°±

ì•„ë˜ ë‚´ìš©ì€ ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬(BST) ë¬¸ì œ(BOJ 5639)ë¥¼ í’€ ë•Œ í”íˆ ê²ªëŠ” ë¬¸ì œì (ë°°ì—´ ì¸ë±ìŠ¤ë¡œ êµ¬í˜„ ì‹œ ë©”ëª¨ë¦¬ ë‚­ë¹„, ì „ìœ„ìˆœíšŒ ì…ë ¥ì—ì„œ íŠ¸ë¦¬ë¥¼ ë³µì›í•˜ëŠ” ë°©ë²• ë“±)ì— ëŒ€í•œ í”¼ë“œë°±ê³¼, ê¶Œì¥ êµ¬í˜„(ë…¸ë“œ ê¸°ë°˜ + ì¬ê·€ ë³µì›) ì˜ˆì‹œì…ë‹ˆë‹¤.

1. í˜„ì¬ ì½”ë“œ(ë°°ì—´ ì‚¬ìš©) ë¬¸ì œì ê³¼ ê°œì„  ë°©í–¥

1.1 ë°°ì—´ ì¸ë±ìŠ¤ ê¸°ë°˜ â€˜ì™„ì „ì´ì§„íŠ¸ë¦¬â€™ ë°©ì‹ì˜ ë¹„íš¨ìœ¨ì„±

â€¢	í˜„ì¬ ì‹œë„í•˜ì‹  ë°©ì‹ì€ â€œë°°ì—´ ì¸ë±ìŠ¤ë¥¼ ì´ìš©í•´ ì™¼ìª½ ìì‹ = 2i+1, ì˜¤ë¥¸ìª½ ìì‹ = 2i+2â€ êµ¬ì¡°ë¥¼ í‰ë‚´ ë‚´ë©° BSTë¥¼ êµ¬ì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤.

â€¢	BSTê°€ í¸í–¥ë˜ì—ˆì„ ë•Œ, n^2, ì‹¬ì§€ì–´ n^4 ê°™ì€ í° ë°°ì—´ì„ ì¡ì•„ì•¼ í•˜ê³ , ì‹¤ì œë¡œëŠ” ëŒ€ë¶€ë¶„ ë¹„ì–´ ìˆì„ ìˆ˜ ìˆì–´ ë©”ëª¨ë¦¬ ë‚­ë¹„ ê°€ ì‹¬ê°í•©ë‹ˆë‹¤.

â€¢	ë…¸ë“œê°€ 1ë§Œ ê°œë§Œ ë˜ì–´ë„, ì™„ì „ì´ì§„íŠ¸ë¦¬ ì¸ë±ìŠ¤ë¥¼ ì“°ë ¤ë©´ ì—„ì²­ë‚œ í¬ê¸°ì˜ ë°°ì—´ì´ í•„ìš”í•´ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

1.2 ì „ìœ„ìˆœíšŒ ê²°ê³¼ë¡œë¶€í„° BST ë³µì› ì‹œì˜ ì¼ë°˜ì ì¸ ì ‘ê·¼

â€¢	ì£¼ì–´ì§„ ì…ë ¥ì€ BSTë¥¼ ì „ìœ„ìˆœíšŒ(Pre-order)í•œ ê²°ê³¼ì…ë‹ˆë‹¤.

â€¢	ìš°ë¦¬ëŠ” ì´ ë°°ì—´(ì „ìœ„ìˆœíšŒ ê²°ê³¼)ë¡œ íŠ¸ë¦¬ë¥¼ ë³µì›í•œ ë’¤, í›„ìœ„ìˆœíšŒ(Post-order) ê²°ê³¼ë¥¼ ì¶œë ¥í•´ì•¼ í•©ë‹ˆë‹¤.

â€¢	ê°€ì¥ í”í•œ ë°©ë²•ì€ **â€œë…¸ë“œ ê¸°ë°˜(Node class) + ì¬ê·€â€**ë¡œ ì§ì ‘ BSTë¥¼ êµ¬ì„±í•œ ë’¤, í›„ìœ„ìˆœíšŒë¥¼ ìˆ˜í–‰í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

> ê²°ë¡ 

2. ê¶Œì¥ êµ¬í˜„: ë…¸ë“œ ê¸°ë°˜ BST ë³µì› + í›„ìœ„ìˆœíšŒ

2.1 ë¡œì§ ê°œìš”

1.	ì…ë ¥: ì „ìœ„ìˆœíšŒ ê²°ê³¼ preorder[] (ì˜ˆ: 50, 30, 24, 5, 28, 45, 98, 52, 60, â€¦)

2.	BST êµ¬ì„±: ì „ìœ„ìˆœíšŒ íŠ¹ì„±ìƒ,

â€¢	ì²« ë²ˆì§¸ ì›ì†Œ = ë£¨íŠ¸ ê°’

â€¢	ì´í›„ â€œë£¨íŠ¸ë³´ë‹¤ ì‘ì€ ê°’ë“¤â€ì€ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬, â€œë£¨íŠ¸ë³´ë‹¤ í° ê°’ë“¤â€ì€ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬

3.	í•˜ì§€ë§Œ, ë‹¨ìˆœíˆ â€œì‘ì€ ê±° ì „ë¶€ ì™¼ìª½, í° ê±° ì „ë¶€ ì˜¤ë¥¸ìª½â€ìœ¼ë¡œ êµ¬ê°„ì„ ë‚˜ëˆ„ë©´ ìµœì•… O(n^2).

â€¢	ë¬¸ì œì—ì„  N ìµœëŒ€ 10,000ê¹Œì§€ ê°€ëŠ¥.

â€¢	ë‹¤í–‰íˆ, **â€œBST ì „ìœ„ìˆœíšŒ ë°°ì—´â€**ì—ì„œ â€œë£¨íŠ¸ë³´ë‹¤ í° ê°’ì´ ì²˜ìŒ ë‚˜ì˜¤ëŠ” ì§€ì â€ì´ ê³§ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ ì‹œì‘ ì§€ì ì´ ë©ë‹ˆë‹¤.

4.	ë” íš¨ìœ¨ì ì¸ ë°©ë²•: ìƒí•œ(bound)ì„ ì´ìš©í•œ ì¬ê·€. ì „ìœ„ ìˆœíšŒë¥¼ ì™¼â†’ì˜¤ë¥¸ìª½ ìˆœìœ¼ë¡œ íƒìƒ‰í•˜ë©°, â€œí˜„ì¬ ë§Œë“¤ì–´ì•¼ í•  ì„œë¸ŒíŠ¸ë¦¬ ê°’ì´ bound(ë¶€ëª¨ë³´ë‹¤ í° ê°’ í•œê³„)â€ë¥¼ ë„˜ì–´ì„œë©´ stop í•˜ëŠ” ê¸°ë²•ì´ ìì£¼ ì‚¬ìš©ë©ë‹ˆë‹¤.

2.2 ì˜ˆì‹œ ì½”ë“œ: Bound ê¸°ë²• (ì „ìœ„ìˆœíšŒ â†’ BST)

```python
import sys
sys.setrecursionlimit(10**9)  # í˜¹ì‹œ ê¹Šì€ íŠ¸ë¦¬ ëŒ€ë¹„

preorder = []
for line in sys.stdin:
    val = line.strip()
    if val == '':  # ê³µë°± ë¼ì¸ ë°©ì–´
        continue
    preorder.append(int(val))

# ì „ìœ„ìˆœíšŒ ë¦¬ìŠ¤íŠ¸
n = len(preorder)

# ì „ìœ„ìˆœíšŒ ë°°ì—´ì„ ì¬ê·€ì ìœ¼ë¡œ ì½ì–´ê°€ë©° íŠ¸ë¦¬ ë³µì›
# indexëŠ” preorderë¥¼ ìˆœíšŒí•˜ëŠ” ì¸ë±ìŠ¤
index = 0

class Node:
    __slots__ = ('val', 'left', 'right')  # ë©”ëª¨ë¦¬ ì ˆì•½ (ì„ íƒì‚¬í•­)
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def buildBST(bound):
    """
    boundë³´ë‹¤ í° ê°’ì´ ë‚˜ì˜¤ë©´(= í˜„ì¬ subtree ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨)
    ì¬ê·€ë¥¼ ë©ˆì¶˜ë‹¤.
    """
    global index
    if index >= n:  # ë” ì´ìƒ ì›ì†Œê°€ ì—†ìœ¼ë©´ None
        return None

    root_val = preorder[index]
    # ë§Œì•½ í˜„ì¬ ê°’ì´ boundë³´ë‹¤ í¬ë©´, ì´ subtreeì— ì†í•  ìˆ˜ ì—†ìŒ
    if root_val > bound:
        return None

    # í˜„ì¬ ê°’ì´ subtreeì— ì†í•œë‹¤ë©´, ë…¸ë“œ ìƒì„±
    node = Node(root_val)
    index += 1

    # ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬: bound = node.val
    #   => node.valë³´ë‹¤ í° ê°’ì´ ë‚˜ì˜¤ë©´ ì™¼ìª½ subtree ë¶ˆê°€
    node.left = buildBST(node.val)

    # ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬: bound = ìƒìœ„ bound
    #   => "node.val < X <= bound" ë²”ìœ„ì˜ ê°’ì€ ì˜¤ë¥¸ìª½ subtree
    node.right = buildBST(bound)

    return node

# 1) íŠ¸ë¦¬ êµ¬ì„± (ìµœëŒ€ê°’ì„ ì•„ì£¼ í¬ê²Œ ì¡ëŠ”ë‹¤)
root = buildBST(bound=10**10)  # ë¬¸ì œì—ì„œ ê°’ì´ 1,000,000ê¹Œì§€ ê°€ëŠ¥í•˜ë¯€ë¡œ ë” í° ìˆ˜ ì¡ê¸°

# 2) í›„ìœ„ìˆœíšŒ
def postorder(node):
    if not node:
        return
    postorder(node.left)
    postorder(node.right)
    print(node.val)

postorder(root)
```

ë™ì‘ ì„¤ëª…

â€¢	buildBST(bound) í•¨ìˆ˜ëŠ” preorder ë°°ì—´ì„ ì™¼â†’ì˜¤ë¥¸ìª½ìœ¼ë¡œ ìŠ¤ìº”(index ì „ì—­ë³€ìˆ˜)í•˜ë©´ì„œ ë…¸ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

â€¢	í˜„ì¬ ë…¸ë“œê°’ì´ boundë¥¼ ì´ˆê³¼í•˜ë©´, â€œì´ ê°’ì€ ìƒìœ„(í˜¹ì€ ë‹¤ë¥¸) ì„œë¸ŒíŠ¸ë¦¬ë¡œ ê°€ì•¼ í•œë‹¤â€ â†’ None ë¦¬í„´í•˜ì—¬ ì¬ê·€ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.

â€¢	ì´ë ‡ê²Œ í•˜ë©´ ì „ìœ„ìˆœì„œì— ë§ì¶° ì™¼ìª½ subtree(node.valì„ boundë¡œ), ì˜¤ë¥¸ìª½ subtree(ìƒìœ„ bound ê·¸ëŒ€ë¡œ) ìˆœìœ¼ë¡œ ì±„ì›Œë‚˜ê°€ë©´ì„œë„, ê°’ì´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ì¬ê·€ë¥¼ ì¢…ë£Œí•´ â€œë¶€ëª¨ì˜ ì˜¤ë¥¸ìª½ subtreeâ€ë¡œ ë„˜ì–´ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ì´ ì•Œê³ ë¦¬ì¦˜ì€ ê° ë…¸ë“œê°€ ì •í™•íˆ í•œ ë²ˆì”©ë§Œ ì¬ê·€ ì²˜ë¦¬ë˜ë¯€ë¡œ, ìµœì•…ì˜ ê²½ìš°(í¸í–¥ íŠ¸ë¦¬)ë¼ë„ O(n)ì— ê°€ê¹Œìš´ ì„±ëŠ¥ì„ ëƒ…ë‹ˆë‹¤(ì‹¤ì œë¡œëŠ” í‰ê·  O(n), íŠ¹ì • í¸í–¥ íŒ¨í„´ì—ì„œë„ ë¹ ë¥´ê²Œ ë™ì‘).

> ì´ ë¡œì§ì€ **â€œBST ì „ìœ„ìˆœíšŒ + ìƒí•œ(bound) ê¸°ë²•â€**ìœ¼ë¡œ ì•Œë ¤ì§„ ì „í˜•ì ì¸ íŠ¸ë¦¬ ë³µì› ë°©ë²•ì…ë‹ˆë‹¤.

3. ì¶”ê°€ ì‚¬í•­

3.1 â€œì…ë ¥ ê°œìˆ˜ ë¯¸ì§€ì •â€ â†’ sys.stdin ì‚¬ìš© ì‹œ

â€¢	ë¬¸ì œì—ì„œ ì…ë ¥ ì¤„ ìˆ˜ê°€ ë”°ë¡œ ì•ˆ ì£¼ì–´ì§€ë©´, ë³´í†µ EOFê¹Œì§€ ì½ì–´ì•¼ í•©ë‹ˆë‹¤.

â€¢	for line in sys.stdin: ì‚¬ìš© ì‹œ, ë¹ˆ ì¤„ì´ë‚˜ ê°œí–‰ì„ ì²˜ë¦¬í•˜ê³  ì‹¶ë‹¤ë©´ line.strip() í›„ ì¡°ê±´ ê²€ì‚¬í•˜ë©´ ë©ë‹ˆë‹¤.

3.2 íŒŒì´ì¬ ì¬ê·€ ì œí•œ

â€¢	ê¸°ë³¸ì ìœ¼ë¡œ íŒŒì´ì¬ ì¬ê·€ í•œë„ëŠ” ì•½ 1000ì´ë¯€ë¡œ, ë…¸ë“œê°€ 1ë§Œ ê°œ ì´ìƒì´ê³  í¸í–¥ íŠ¸ë¦¬ê°€ ëœë‹¤ë©´ RecursionError ê°€ ë‚  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ë¬¸ì œ 5639ì—ì„œëŠ” ìµœëŒ€ 10,000ê°œ ì…ë ¥ì´ ê°€ëŠ¥í•˜ë¯€ë¡œ, sys.setrecursionlimit(10**9) ì •ë„ë¡œ ì—¬ìœ ë¥¼ ì£¼ëŠ” ê²Œ ì•ˆì „í•©ë‹ˆë‹¤. (ë©”ëª¨ë¦¬ ë‚´ì—ì„œ ì²˜ë¦¬ ê°€ëŠ¥)

3.3 í›„ìœ„ìˆœíšŒ ì¶œë ¥

â€¢	ë¬¸ì œ ìš”êµ¬ì‚¬í•­ëŒ€ë¡œ, ê° ë…¸ë“œë¥¼ í›„ìœ„ìˆœíšŒ ì‹œ ë°©ë¬¸í•  ë•Œë§ˆë‹¤ ì¶œë ¥í•˜ë©´ ë©ë‹ˆë‹¤.

â€¢	â€œprint(node.val)â€ì„ ì°ì„ ë•Œ ê°œí–‰ìœ¼ë¡œ êµ¬ë¶„í•˜ë©´ ì •ë‹µ í¬ë§·ì— ë¶€í•©í•©ë‹ˆë‹¤.

3.4 â€œë°°ì—´ ì¸ë±ìŠ¤ë¥¼ ì¢€ ë” ëª…í™•íˆâ€¦â€ì— ëŒ€í•œ íŒ

â€¢	ë³€ìˆ˜ëª…ì„ idx, start, end ë“±ìœ¼ë¡œ ê¸¸ê²Œ ì¨ì£¼ê±°ë‚˜, ì£¼ì„ì„ ë¶€ì§€ëŸ°íˆ ë‹¬ë©´ ë””ë²„ê¹… ì‹œ í˜¼ì„ ì„ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ë˜í•œ, (node-based)íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•˜ë©´, â€œì™¼ìª½Â·ì˜¤ë¥¸ìª½â€ì„ ì§ê´€ì ìœ¼ë¡œ ì½”ë“œë¡œ í‘œí˜„í•  ìˆ˜ ìˆì–´, ì¸ë±ìŠ¤ ì—°ì‚° ì‹¤ìˆ˜ë¥¼ ì¤„ì´ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤.

4. ë§ˆë¬´ë¦¬

1.	ë¬¸ì œ(5639) í•µì‹¬: ì „ìœ„ìˆœíšŒ ë°°ì—´ë¡œë¶€í„° BSTë¥¼ ì¬êµ¬ì„± í›„, í›„ìœ„ìˆœíšŒ ì¶œë ¥.

2.	ê°€ì¥ ê°„ë‹¨í•œ ì •ì„ ì ‘ê·¼: ë…¸ë“œ ê¸°ë°˜ìœ¼ë¡œ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ê³ , í›„ìœ„ìˆœíšŒë¥¼ ì¬ê·€ë¡œ êµ¬í˜„.

3.	ë°°ì—´ ì¸ë±ìŠ¤ ê¸°ë°˜ì˜ ì™„ì „ì´ì§„íŠ¸ë¦¬ëŠ” BSTì—ëŠ” ë¹„íš¨ìœ¨ì (í¸í–¥ íŠ¸ë¦¬ ì‹œ ë©”ëª¨ë¦¬ í­ì¦).

4.	EOF ì…ë ¥ ì²˜ë¦¬:

```plain text
import sys
arr = []
for line in sys.stdin:
    val = line.strip()
    if val == '':
        continue
    arr.append(int(val))
```

ì´ë ‡ê²Œ í•˜ë©´ íŒŒì¼ ë(EOF)ê¹Œì§€ ì½ì–´ë“¤ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

> ê²°ë¡ ì ìœ¼ë¡œ,



# ì¬ê·€: 1, 2, 3 ë”í•˜ê¸°

https://www.acmicpc.net/problem/9095

ì •ìˆ˜ nì´ ì£¼ì–´ì¡Œì„ ë•Œ, nì„ 1, 2, 3ì˜ í•©ìœ¼ë¡œ ë‚˜íƒ€ë‚´ëŠ” ë°©ë²•ì˜ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1.

```python
"""
1. ë¬¸ì œ ì½ê¸°: 3
2. ë¬¸ì œ í’€ê¸°
3ì´ë©´ 1 1 1, 1 2, 2 1, 3
ê°„ë‹¨í•œ ë°± íŠ¸ë˜í‚¹ ë¬¸ì œë‹¤. 1 2 3 ì¤‘ ì—¬ëŸ¬ê°œë¥¼ ì¨ë„ ìƒê´€ì´ ì—†ë‹¤.
3. ìˆ˜ë„ ì½”ë“œ
ë°”ë‹¥ì¡°ê±´ì€ ë¬´ì—‡ì¸ê°€? ë§¤ê°œë¡œ ë„˜ì–´ì˜¨ ì •ìˆ˜í˜• í•©ì´ nê³¼ ê°™ìœ¼ë©´ ì¹´ìš´í„° ì¦ê°€ì‹œí‚¤ê³  ë¦¬í„´.
ì¬ê·€ ì¡°ê±´ì€: ê·¸ëƒ¥ 1, 2, 3 ë¦¬ìŠ¤íŠ¸ì—ì„œ ë°˜ë³µ ëŒë ¤ì„œ ë”í•´ì„œ ì¬ê·€ ë³´ë‚´ë©´ ë¨.
4. ì½”ë“œ êµ¬í˜„
"""

import sys

def recur(current_sum: int, n: int):
    global cnt
    if current_sum == n:
        cnt += 1
        return
    if current_sum > n:
        return
    for e in [1, 2, 3]:
        recur(current_sum+e, n)


t = int(sys.stdin.readline().strip())
cnt = 0
for _ in range(t):
    n = int(sys.stdin.readline().strip())
    recur(0, n)
    print(cnt)
    cnt = 0

"""
ì´ìŠˆ: ì¬ê·€ ì´ˆê³¼ ì˜¤ë¥˜
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì¬ê·€ ì´ˆê³¼ ì˜¤ë¥˜
ìµœê·¼ ë³€ê²½ì‚¬í•­: ì¬ê·€í•¨ìˆ˜ ì‘ì„±
Phase2.
í™•ì¸: current_sumì´ nê³¼ ë‹¤ë¥´ë©´ ë°”ë‹¥ ì¡°ê±´ì— ê³„ì† ê±¸ë¦¬ì§€ ì•Šê²Œ ë¨. 
current_sum > nì— ëŒ€í•´ì„œë„ ì¢…ë£Œ ì¡°ê±´ì„ ë‹¬ë©´ ë˜ê² ë‹¤.
ì‹œë„: ë² ì´ìŠ¤ ì»¨ë””ì…˜ ì¶”ê°€
if current_sum > n:
        return
ê²°ê³¼ë¶„ì„: ì„±ê³µ
"""
```

## Phase2. ë°± íŠ¸ë˜í‚¹ì´ ë­”ê°€ìš”?

ë¬¸ì œ í’€ì´ ë‚´ìš©ì„ ë°œí‘œí•˜ë˜ ì¤‘ ì´ ì§ˆë¬¸ì„ ë°›ì•˜ëŠ”ë°, ì œëŒ€ë¡œ ëœ ë‹µì„ í•˜ì§€ ëª»í–ˆë‹¤. ê·¸ë˜ì„œ ìƒê°í•´ë³¸ ëì— ì•„ë˜ì™€ ê°™ì€ ê²°ë¡ ì— ë„ë‹¬. 

(ê²°ì • íŠ¸ë¦¬ë¥¼ ì•ˆë‹¤ê³  ê°€ì •í•˜ê³ ) ì¬ê·€ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë¬´ìˆ˜íˆ ë§ì€ ê²°ì •íŠ¸ë¦¬ë¥¼ ë§Œë“¤ì–´ê°€ê²Œ ë˜ê³ , ì´ ì½”ë“œì˜ ê²½ìš° depthê°€ ê¹Šì–´ì§ˆ ìˆ˜ë¡ ë¦¬í”„ ë…¸ë“œê°€ 3ë°°ì”© ëŠ˜ì–´ë‚œë‹¤. ê·¸ëŸ°ë° ë¬¸ì œ ì •ì˜ ìƒìœ¼ë¡œ, ë”í•´ì§€ëŠ” ìˆ«ìëŠ” 1, 2, 3ìœ¼ë¡œ ëª¨ë‘ ì–‘ìˆ˜ê³ , ë§Œì•½ í˜„ì¬ ë…¸ë“œì—ì„œ ë§¤ê°œë¡œ ë°›ì€ ì •ìˆ˜ ê°’ì´ në³´ë‹¤ í¬ë‹¤ë©´ ê²°ì • íŠ¸ë¦¬ìƒìœ¼ë¡œ ì´ ë…¸ë“œì˜ í•˜ìœ„ì— ì˜¬ ìì‹ ë…¸ë“œë“¤ì€ ì „ë¶€ ì •ë‹µì´ ì•„ë‹Œê²Œ í™•ì‹¤í•˜ë‹¤. 

ë”°ë¼ì„œ! ì¬ê·€ë¡œ ì¸í•´ ë¬´í•œíˆ ìƒê²¨ë‚  ìˆ˜ ìˆëŠ” ê²°ì •íŠ¸ë¦¬ë¥¼ ì œì–´í•˜ê¸° ìœ„í•´ í•„ìš” ì—†ëŠ” ê°€ì§€ë¥¼ ì˜ë¼ë‚´ëŠ” ë°©ë²•ì„ ë°±íŠ¸ë˜í‚¹ì´ë¼ í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤.

![](./images/IMG_0452.jpeg)

## Phase3. ë‹µì— ëŒ€í•œ í”¼ë“œë°±

1. ë°±íŠ¸ë˜í‚¹ ì •ì˜ì™€ ì„¤ëª…

â€¢	ë°±íŠ¸ë˜í‚¹ì€ **â€œë¶ˆí•„ìš”í•œ íƒìƒ‰ì„ ê°€ì§€ì¹˜ê¸°(Pruning)í•˜ì—¬ íƒìƒ‰ ì†ë„ë¥¼ í–¥ìƒì‹œí‚¤ëŠ” ê¸°ë²•â€**ì…ë‹ˆë‹¤.

â€¢	íŠ¹íˆ, ê²°ì • íŠ¸ë¦¬(Decision Tree) íƒìƒ‰ ê³¼ì •ì—ì„œ ë¶ˆí•„ìš”í•œ ë¶„ê¸°ë¥¼ ì¡°ê¸°ì— ì¢…ë£Œí•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

â€¢	ì¦‰, ê°€ëŠ¥í•œ ëª¨ë“  ê²½ìš°ë¥¼ íƒìƒ‰í•˜ëŠ” ì™„ì „ íƒìƒ‰(Brute-force) ë°©ì‹ì„ ê°œì„ í•˜ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤.

2. ë³¸ì¸ì˜ ì„¤ëª… í”¼ë“œë°±

> â€œì¬ê·€ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë¬´ìˆ˜íˆ ë§ì€ ê²°ì • íŠ¸ë¦¬ë¥¼ ë§Œë“¤ì–´ê°€ê²Œ ë˜ê³ , ì´ ì½”ë“œì˜ ê²½ìš° depthê°€ ê¹Šì–´ì§ˆìˆ˜ë¡ ë¦¬í”„ ë…¸ë“œê°€ 3ë°°ì”© ëŠ˜ì–´ë‚œë‹¤. ê·¸ëŸ°ë° ë¬¸ì œ ì •ì˜ ìƒìœ¼ë¡œ, ë”í•´ì§€ëŠ” ìˆ«ìëŠ” 1, 2, 3ìœ¼ë¡œ ëª¨ë‘ ì–‘ìˆ˜ê³ , ë§Œì•½ í˜„ì¬ ë…¸ë“œì—ì„œ ë§¤ê°œë¡œ ë°›ì€ ì •ìˆ˜ ê°’ì´ në³´ë‹¤ í¬ë‹¤ë©´ ê²°ì • íŠ¸ë¦¬ìƒìœ¼ë¡œ ì´ ë…¸ë“œì˜ í•˜ìœ„ì— ì˜¬ ìì‹ ë…¸ë“œë“¤ì€ ì „ë¶€ ì •ë‹µì´ ì•„ë‹Œ ê²Œ í™•ì‹¤í•˜ë‹¤. ë”°ë¼ì„œ! ì¬ê·€ë¡œ ì¸í•´ ë¬´í•œíˆ ìƒê²¨ë‚  ìˆ˜ ìˆëŠ” ê²°ì • íŠ¸ë¦¬ë¥¼ ì œì–´í•˜ê¸° ìœ„í•´ í•„ìš” ì—†ëŠ” ê°€ì§€ë¥¼ ì˜ë¼ë‚´ëŠ” ë°©ë²•ì„ ë°±íŠ¸ë˜í‚¹ì´ë¼ í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤.â€

âœ… ì¢‹ì€ ì 

â€¢	ë°±íŠ¸ë˜í‚¹ì˜ í•µì‹¬ ê°œë…ì¸ **â€œë¶ˆí•„ìš”í•œ ê°€ì§€ë¥¼ ì˜ë¼ë‚´ëŠ” ê³¼ì •â€**ì„ ì˜ ì„¤ëª…í–ˆë‹¤.

â€¢	ê²°ì • íŠ¸ë¦¬ì—ì„œ ë¶„ê¸°ê°€ ë¶ˆí•„ìš”í•˜ê²Œ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ì„ ì˜ ì¸ì‹í•˜ê³  ìˆìŒ.

â€¢	í˜„ì¬ í’€ì´ì—ì„œ if current_sum > n: ë¶€ë¶„ì´ ë°±íŠ¸ë˜í‚¹ì˜ ì—­í• ì„ í•œë‹¤ëŠ” ì ì„ ì˜ ì„¤ëª…í–ˆë‹¤.

ğŸ” ë³´ì™„í•˜ë©´ ì¢‹ì€ ì 

â€¢	ë°±íŠ¸ë˜í‚¹ì€ ë‹¨ìˆœíˆ â€œë¶ˆí•„ìš”í•œ ê²½ìš°ë¥¼ ì œê±°â€í•˜ëŠ” ê²ƒë¿ë§Œ ì•„ë‹ˆë¼, **â€œì •ë‹µì´ ë  ê°€ëŠ¥ì„±ì´ ìˆëŠ” ê²½ìš°ë§Œ ì„ íƒâ€**í•˜ëŠ” ë°©ì‹ë„ í¬í•¨ëœë‹¤.

â€¢	íƒìƒ‰ì„ ìµœì í™”í•˜ëŠ” ê²ƒì´ í•µì‹¬ì¸ë°, í˜„ì¬ ì„¤ëª…ì€ â€œë¶ˆí•„ìš”í•œ ê²½ìš°ë¥¼ ì œê±°í•œë‹¤â€ëŠ” ê´€ì ì— ì´ˆì ì´ ë§ì¶°ì ¸ ìˆìŒ.

â€¢	ì˜ˆë¥¼ ë“¤ì–´, â€œN-Queen ë¬¸ì œâ€ì—ì„œëŠ” íŠ¹ì • ì¡°ê±´(ê°™ì€ ì—´ì— ë†“ì´ì§€ ì•Šê¸°, ëŒ€ê°ì„  ì¶©ëŒ ë°©ì§€ ë“±)ì„ ë§Œì¡±í•˜ëŠ” ê²½ìš°ì—ë§Œ íƒìƒ‰ì„ ì§„í–‰í•˜ëŠ” ê²ƒë„ ë°±íŠ¸ë˜í‚¹ì˜ ì¤‘ìš”í•œ íŠ¹ì§•ì´ë‹¤.

ğŸ’¡ ë³´ì™„ëœ ì„¤ëª… ì˜ˆì‹œ

> â€œë°±íŠ¸ë˜í‚¹ì€ ê°€ëŠ¥í•œ ëª¨ë“  ê²½ìš°ë¥¼ íƒìƒ‰í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ìœ ë§í•˜ì§€ ì•Šì€ ê²½ìš°ë¥¼ ì¡°ê¸°ì— í¬ê¸°í•˜ì—¬ íƒìƒ‰ íš¨ìœ¨ì„ ë†’ì´ëŠ” ê¸°ë²•ì´ë‹¤. ì´ ë¬¸ì œì—ì„œëŠ” ê²°ì • íŠ¸ë¦¬ì—ì„œ current_sum > nì¸ ê²½ìš° ì´í›„ì˜ íƒìƒ‰ì´ ë¬´ì˜ë¯¸í•˜ë¯€ë¡œ íƒìƒ‰ì„ ì¤‘ë‹¨í•œë‹¤. ì´ë¥¼ í†µí•´ íƒìƒ‰ ê³µê°„ì„ ì¤„ì´ê³ , ë¶ˆí•„ìš”í•œ ì—°ì‚°ì„ ë°©ì§€í•˜ëŠ” ê²ƒì´ ë°±íŠ¸ë˜í‚¹ì˜ í•µì‹¬ì´ë‹¤.â€

3. ì½”ë“œì— ëŒ€í•œ í”¼ë“œë°±

í˜„ì¬ ì½”ë“œëŠ” ë°±íŠ¸ë˜í‚¹ ê°œë…ì„ ì ìš©í–ˆì§€ë§Œ, DP(ë™ì  ê³„íšë²•, Dynamic Programming)ë¡œ ë” íš¨ìœ¨ì ì¸ í’€ì´ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ì´ ë¬¸ì œëŠ” ì¤‘ë³µë˜ëŠ” ë¶€ë¶„ ë¬¸ì œ(overlapping subproblems)ì™€ ìµœì  ë¶€ë¶„ êµ¬ì¡°(optimal substructure)ë¥¼ ê°€ì§€ë¯€ë¡œ DPê°€ ë” ì ì ˆí•©ë‹ˆë‹¤.

âœ… DP í’€ì´ (Bottom-Up)

```plain text
import sys

def solve():
    dp = [0] * 11  # ë¬¸ì œì—ì„œ nì€ ìµœëŒ€ 10
    dp[1], dp[2], dp[3] = 1, 2, 4  # ê¸°ë³¸ ì¼€ì´ìŠ¤

    for i in range(4, 11):  # ì í™”ì‹ ì ìš©
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

    t = int(sys.stdin.readline().strip())
    for _ in range(t):
        n = int(sys.stdin.readline().strip())
        print(dp[n])

solve()
```

â€¢	ì‹œê°„ ë³µì¡ë„: O(N), ì¬ê·€ í’€ì´ë³´ë‹¤ í›¨ì”¬ íš¨ìœ¨ì ì„.

ê²°ë¡ 

1.	ë°±íŠ¸ë˜í‚¹ì˜ ê°œë… ì„¤ëª…ì€ ì¢‹ì•˜ì§€ë§Œ, **â€œê°€ëŠ¥ì„±ì´ ìˆëŠ” ê²½ìš°ë§Œ íƒìƒ‰í•œë‹¤â€**ëŠ” ë¶€ë¶„ë„ ê°•ì¡°í•˜ë©´ ë” ì¢‹ë‹¤.

2.	ì´ ë¬¸ì œëŠ” ë°±íŠ¸ë˜í‚¹ìœ¼ë¡œ í’€ ìˆ˜ ìˆì§€ë§Œ, DPê°€ ë” ì í•©í•œ í’€ì´ ë°©ë²•ì´ë‹¤.

3.	ê°™ì€ ìœ í˜•ì˜ ë¬¸ì œì—ì„œ ë°±íŠ¸ë˜í‚¹ê³¼ DP ì¤‘ ì–´ë–¤ ê²ƒì´ ë” ì ì ˆí•œì§€ íŒë‹¨í•˜ëŠ” ì—°ìŠµì„ í•˜ë©´ ë”ìš± ì¢‹ì„ ê²ƒ! ğŸš€

# íƒìƒ‰: ìˆ˜ ì°¾ê¸°

## Phase1. í’€ì´ ì„±ê³µ. 

íƒìƒ‰ ë°©ì‹ì„ ì˜ëª» ê³¨ë¼ì„œ ì˜¤ë˜ ê±¸ë ¸ë‹¤. ë¬¸ì œì˜ ì¡°ê±´ì„ ì˜ ì½ê³ , ì ì ˆí•œ íƒìƒ‰ ë°©ì‹ì„ ì„ íƒí•´ì•¼ í•¨.

```python
"""
ë³´ë¥˜
ì‚¬ìœ : ì´ë¶„íƒìƒ‰ì„ ëª¨ë¥´ë©´ ì œëŒ€ë¡œ í’€ ìˆ˜ ì—†ìŒ

import sys

n = int(sys.stdin.readline().strip())
arr = list(map(int, sys.stdin.readline().split()))
m = int(sys.stdin.readline().strip())
search_list = list(map(int, sys.stdin.readline().split()))
for val in search_list:
    if val in arr: print(1)
    else: print(0)

ì´ê±´ ë‚´ ì§€ì‹ìœ¼ë¡œ í‘¼ ì˜¤ë‹µ ì½”ë“œ.

"""

"""
1. ë¬¸ì œ ì½ê¸°: ì–´..ì´ê±° ê·¸ëƒ¥ ì…ë ¥ë°›ê³  in ì—°ì‚°ì ì“°ë©´ ì•ˆ ë˜ë‚˜? ì•ˆ ë¨. ì •ë ¬í•œ ë‹¤ìŒ ì´ì§„íƒìƒ‰í•´ì•¼ í• ë“¯
2. ë¬¸ì œ í’€ê¸°: 
3. ìˆ˜ë„ ì½”ë“œ:
4. ì½”ë“œ êµ¬í˜„: 
"""

# def bin_search(A: list, val: int):
    
#     left = 0
#     right = len(A) - 1
#     while left <= right: # íŒŒí‹°ì…˜ì´ ìœ íš¨í•œ ë™ì•ˆ. 
#         center = (left+right)//2
#         idx = center # ì˜ì—­ì˜ ì ˆë°˜ì„ ì¸ë±ìŠ¤ë¡œ ê³ ì •
#         if A[idx] > val: # ë‹µì´ ì™¼ìª½ ì˜ì—­ì— ìˆìŒ.
#             right = center # right idxë¥¼ ë°˜ìœ¼ë¡œ ê°ì†Œ
#         elif A[idx] < val: # ë‹µì´ ì˜¤ë¥¸ìª½ ì˜ì—­ì— ìˆìŒ.
#             left = center+1 # leftë¥¼ ë†’ì—¬ì„œ ì˜ì—­ì„ ë°˜ ì¢íˆê¸°
#         elif A[idx] == val: 
#             return 1
#     return 0

import sys

dictionary = {}


n = int(sys.stdin.readline().strip())
arr = list(map(int, sys.stdin.readline().split()))
for a in arr:
    dictionary[a] = True
m = int(sys.stdin.readline().strip())
search_list = list(map(int, sys.stdin.readline().split()))

for key in search_list:
    if dictionary.get(key, False): print(1)
    else: print(0)

"""
ì´ìŠˆ: ë¬´í•œ ë£¨í”„
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì—†ìŒ
ìµœê·¼ ë³€ê²½ ì‚¬í•­: bin_search ì´ì§„ íƒìƒ‰ í•¨ìˆ˜ ì‘ì„±
Phase2.
í™•ì¸: ë£¨í”„ì— ì¤‘ë‹¨ì  ã„±ã„±
ë°°ì—´ ì•ˆì— ê°’ì´ ì—†ì„ ê²½ìš° ë¬´í•œ ë£¨í”„ë¥¼ ëˆë‹¤. ì¸ë±ì‹±ì„ í•˜ë‹¤ê°€ 
ìì—°ìŠ¤ëŸ½ê²Œ íŒŒí‹°ì…˜ì´ ì—‡ê°ˆë¦¬ë©´ ëë‚˜ì•¼ í•˜ëŠ”ë°, íŒŒí‹°ì…”ë‹ ì¸ë±ìŠ¤ì— ë¬¸ì œê°€ ìˆë‹¤.
left, right ì¸ë±ìŠ¤ê°€ 3, 4ì¼ë•Œ ë¬´í•œ ë°˜ë³µ ë°œìƒ.
center = 3(3.5)
leftê°€ ê³„ì† 3ìœ¼ë¡œ ì—…ë°ì´íŠ¸ ë¨. ì™€ ì´ê±° ì–´ë–»ê²Œ íŒŒí‹°ì…”ë‹ í•´ì•¼ í•´ê²°í•  ìˆ˜ ìˆì§€? 
ì‘ì•„ì§€ëŠ” ê²½ìš°ëŠ” ë¬¸ì œê°€ ì—†ëŠ”ë°, ì¤‘ê°„ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ í¬ê³ , ë°°ì—´ì— ì—†ëŠ” ê°’ì„ êµ¬í•  ë•Œ 
left right ì¸ë±ìŠ¤ê°€ ì¢í˜€ì§€ì§€ ì•ŠëŠ”ë‹¤. 
ì¸ë±ìŠ¤ë¥¼ ì¡ì„ ë•Œ 'ë‹¤ìŒ ì™¼ìª½ ì˜ì—­ì„ left, centerë¡œ ì¡ê³ , 
ë‹¤ìŒ ì˜¤ë¥¸ìª½ ì˜ì—­ì„ center+1, rightë¡œ ì¡ìœ¼ë‹ˆ í•´ê²°
ì‹œë„: 
    while left <= right: # íŒŒí‹°ì…˜ì´ ìœ íš¨í•œ ë™ì•ˆ. 
        ...
        elif A[idx] < val: # ë‹µì´ ì˜¤ë¥¸ìª½ ì˜ì—­ì— ìˆìŒ.
            left = center+1 # leftë¥¼ ë†’ì—¬ì„œ ì˜ì—­ì„ ë°˜ ì¢íˆê¸°

ê²°ê³¼ ë¶„ì„: ì •ë ¬ì€ ì„±ê³µ. ê·¸ëŸ°ë° ì‹œê°„ì´ˆê³¼ ë°œìƒ. ì •ë ¬ì„ ìµœì í™”í•´ì•¼ í•œë‹¤. ìš°ì„ ìˆœìœ„ íë¥¼ ì¨ì•¼ í•˜ë‚˜? 
í•œ ë¼ì¸ì— ì…ë ¥ë¼ì„œ, ì´ê²Œ sort í•¨ìˆ˜ ì“°ëŠ”ê²Œ ì œì¼ ë¹ ë¥¼í…ë°. 

ì´ìŠˆ: ì‹œê°„ ì´ˆê³¼ ë¬¸ì œ
Phase1
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì‹œê°„ ì´ˆê³¼
ìµœê·¼ ë³€ê²½ ì‚¬í•­: bin_search ë¡œì§ í”½ìŠ¤ 
Phase2.
í™•ì¸:
ì •ìˆ˜ì˜ ë²”ìœ„ëŠ” ì—„ì²­ ë„“ë‹¤. ì£¼ì–´ì§€ëŠ” ìì—°ìˆ˜ ë¦¬ìŠ¤íŠ¸ë„ ì‹­ë§Œì´ë‹¤. 
í˜„ì¬ ì‹œê°„ ë³µì¡ë„: ì •ë ¬ì— nlogn
íƒìƒ‰ ì‹œê°„ ë³µì¡ë„: logn
O(nlogn) + O(logn)
ì´ê±¸ ì–´ë–»ê²Œ ê°œì„ í•˜ì§€? ì…ë ¥ì— í•„ìš”í•œ ì˜¤ë²„í—¤ë“œë¥¼ ê°œì„ í•´ì•¼ í•˜ë‚˜? ê·¼ë° ê·¸ëŸ°ì‹ì˜ ë¬¸ì œëŠ” ì•„ë‹ ê±° ê°™ìŒ.
ì‹œë„: ë§µì„ ì¨ë´ì•¼ í•˜ë‚˜? í•˜ê¸´ ì´ ë¬¸ì œëŠ” ë°ì´í„°ì˜ ìˆ˜ì •/ì‚­ì œê°€ í•„ìš” ì—†ë‹¤. ì•„ ë­ì•¼ ê·¸ëŸ¼ ë§µì´ë„¤!
ì•„ë˜ êµ¬í˜„.
for key in search_list:
    if dictionary.get(key, False): print(1)
    else: print(0) 
    
ë¶„ì„: ì„±ê³µ!!


"""
```

# ì´ì§„íƒìƒ‰: ë‚˜ë¬´ ìë¥´ê¸°

https://www.acmicpc.net/problem/2805

ìƒê·¼ì´ëŠ” ë‚˜ë¬´ Më¯¸í„°ê°€ í•„ìš”í•˜ë‹¤. ê·¼ì²˜ì— ë‚˜ë¬´ë¥¼ êµ¬ì…í•  ê³³ì´ ëª¨ë‘ ë§í•´ë²„ë ¸ê¸° ë•Œë¬¸ì—, ì •ë¶€ì— ë²Œëª© í—ˆê°€ë¥¼ ìš”ì²­í–ˆë‹¤. ì •ë¶€ëŠ” ìƒê·¼ì´ë„¤ ì§‘ ê·¼ì²˜ì˜ ë‚˜ë¬´ í•œ ì¤„ì— ëŒ€í•œ ë²Œëª© í—ˆê°€ë¥¼ ë‚´ì£¼ì—ˆê³ , ìƒê·¼ì´ëŠ” ìƒˆë¡œ êµ¬ì…í•œ ëª©ì¬ì ˆë‹¨ê¸°ë¥¼Â ì´ìš©í•´ì„œ ë‚˜ë¬´ë¥¼ êµ¬í• ê²ƒì´ë‹¤.

ëª©ì¬ì ˆë‹¨ê¸°ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë™ì‘í•œë‹¤. ë¨¼ì €, ìƒê·¼ì´ëŠ” ì ˆë‹¨ê¸°ì— ë†’ì´ Hë¥¼ ì§€ì •í•´ì•¼ í•œë‹¤. ë†’ì´ë¥¼ ì§€ì •í•˜ë©´ í†±ë‚ ì´ ë•…ìœ¼ë¡œë¶€í„° Hë¯¸í„° ìœ„ë¡œ ì˜¬ë¼ê°„ë‹¤. ê·¸ ë‹¤ìŒ, í•œ ì¤„ì— ì—°ì†í•´ìˆëŠ” ë‚˜ë¬´ë¥¼ ëª¨ë‘ ì ˆë‹¨í•´ë²„ë¦°ë‹¤. ë”°ë¼ì„œ, ë†’ì´ê°€ Hë³´ë‹¤ í° ë‚˜ë¬´ëŠ” H ìœ„ì˜ ë¶€ë¶„ì´ ì˜ë¦´ ê²ƒì´ê³ , ë‚®ì€ ë‚˜ë¬´ëŠ” ì˜ë¦¬ì§€ ì•Šì„ ê²ƒì´ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í•œ ì¤„ì— ì—°ì†í•´ìˆëŠ” ë‚˜ë¬´ì˜ ë†’ì´ê°€ 20, 15, 10, 17ì´ë¼ê³  í•˜ì. ìƒê·¼ì´ê°€ ë†’ì´ë¥¼ 15ë¡œ ì§€ì •í–ˆë‹¤ë©´, ë‚˜ë¬´ë¥¼ ìë¥¸ ë’¤ì˜ ë†’ì´ëŠ” 15, 15, 10, 15ê°€ ë  ê²ƒì´ê³ , ìƒê·¼ì´ëŠ” ê¸¸ì´ê°€ 5ì¸ ë‚˜ë¬´ì™€ 2ì¸ ë‚˜ë¬´ë¥¼ ë“¤ê³  ì§‘ì— ê°ˆ ê²ƒì´ë‹¤. (ì´ 7ë¯¸í„°ë¥¼ ì§‘ì— ë“¤ê³  ê°„ë‹¤) ì ˆë‹¨ê¸°ì— ì„¤ì •í•  ìˆ˜ ìˆëŠ” ë†’ì´ëŠ” ì–‘ì˜ ì •ìˆ˜ ë˜ëŠ” 0ì´ë‹¤.

ìƒê·¼ì´ëŠ” í™˜ê²½ì— ë§¤ìš° ê´€ì‹¬ì´ ë§ê¸° ë•Œë¬¸ì—, ë‚˜ë¬´ë¥¼ í•„ìš”í•œ ë§Œí¼ë§Œ ì§‘ìœ¼ë¡œ ê°€ì ¸ê°€ë ¤ê³  í•œë‹¤. ì´ë•Œ, ì ì–´ë„ Më¯¸í„°ì˜ ë‚˜ë¬´ë¥¼ ì§‘ì— ê°€ì ¸ê°€ê¸° ìœ„í•´ì„œ ì ˆë‹¨ê¸°ì— ì„¤ì •í•  ìˆ˜ ìˆëŠ” ë†’ì´ì˜ ìµœëŒ“ê°’ì„ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì§ì ‘ í’€ê¸°(ì„±ê³µ!)

```python
"""
1. ë¬¸ì œ ì½ê¸°: ì´ê²Œ ì–´ë–»ê²Œ ì´ë¶„ íƒìƒ‰ì´ì§€? 
2. ë¬¸ì œ í’€ê¸°
2-1. ì•„ì´ë””ì–´ ë¸Œë ˆì¸ ìŠ¤í† ë°
ê°€. prefix sumì„ ì“°ê¸°: ë§ë„ ì•ˆ ë¨.
ë‚˜. ì™„ì „íƒìƒ‰: ì•„ë˜ê°€ ì •ë‹µì´ë‹¤.
import sys

MAX_INT = sys.maxsize

n = 5
m = 20
trees = [4, 42, 40, 26, 46]

def cut_sum(height: int):
    sum_tmp = 0
    for tree in trees:
        sum_tmp += tree - height if tree > height else 0
    return sum_tmp

h_x = 0
prev_difference = MAX_INT

for i in range(0, max(trees)):
    cut_amount = cut_sum(i)
    difference = abs(cut_amount-m)
    if difference < prev_difference: # update
        prev_difference = difference
        h_x = i

# print(h_x)

ë‹¤. ì¸í¬ë ˆë©˜íƒˆ ë©”ì„œë“œì—ì„œ ë¶„í• ì •ë³µìœ¼ë¡œ!

ìœ„ ì½”ë“œì— ëŒ€í•œ ë¶„ì„: ë¬¸ì œì— ëŒ€í•œ incremental methodë‹¤. ì´ê±¸ divide and conquer 
ë°©ì‹ìœ¼ë¡œ ë°”ê¿”ì•¼ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆì„ ê²ƒ.
ì—¬ê¸°ì„œ incrementalí•œ ìš”ì†ŒëŠ” iì´ë‹¤.

ì´ì œ ì´ê²ƒì„ ì •ë¦¬í•´ ë³´ì•˜ì„ ë•Œ cut_sum(i)-mì´ë¼ëŠ” ìš°í•˜í–¥ í•¨ìˆ˜ê°€ ìˆë‹¤. 
(iê°€ incremental í•˜ë‹¤ê³  ê°€ì •.)
ê·¸ëŸ¼ ë‹¤ìŒê³¼ ê°™ì´ ë¶„ê¸°
cut_sum(i)-m > 0: ì˜¤ë¥¸ìª½ ì˜ì—­ ë””ë°”ì´ë“œ
cut_sum(i)-m < 0: ì™¼ìª½ ì˜ì—­ìœ¼ë¡œ ë””ë°”ì´ë“œ


3. ìˆ˜ë„ ì½”ë“œ

"""

import sys

n, m = tuple(map(int, sys.stdin.readline().split()))
trees = tuple(map(int, sys.stdin.readline().split()))


def f(height: int):
    """
    fì˜ ì •ì˜: heightì— ëŒ€í•´ ë‚˜ë¬´ë¥¼ ì˜ëì„ ë•Œ ì–»ê²Œ ë˜ëŠ” ë‚˜ë¬´ë“¤ì˜ ê¸¸ì´ì—ì„œ ëª©í‘œ ê¸¸ì´ë¥¼ ëº€ ê²ƒ.
    """
    sum_tmp = 0
    for tree in trees:
        sum_tmp += tree - height if tree > height else 0
    return sum_tmp - m

def bin_search():
    """ëª©í‘œ: f(h_x)ë¥¼ ìµœì†Œí™” í•˜ëŠ” h_x ì°¾ê¸°"""
    left, right = 0, 1_000_000_001
    prev_center = None
    while left < right:
        # print(f'{left} --- {right}')
        i_center = (left+right)//2 # i for representing incremental parameter
        difference = f(i_center)
        # print(f'difference is {difference}.')
        if difference < 0: 
            # print(f'conquer left')
            left, right = left, i_center 
            if left >= right:  # ë‚˜ë¬´ë¥¼ ìë¥´ì§€ ì•ŠëŠ” ë†’ì´ì—ì„œ, ë‹¤ìŒ í„´ì— íƒìƒ‰ì„ ë§ˆì¹œë‹¤ë©´!
                return prev_center # ì•„, ë‘˜ ë‹¤ ê·¸ê±°ì¼ ìˆ˜ ìˆêµ¬ë‚˜. ë‘ í„´ ë‹¤ ìŒìˆ˜ê°€ ë‚˜ì˜¬ ìˆ˜ë„ ìˆìŒ.
        elif difference > 0: 
            # print(f'conquer right')
            left, right = i_center+1, right
            prev_center = i_center
            # ì´ë•ŒëŠ” i_centerê°€ ë¬´ì¡°ê±´ ë‚˜ë¬´ë¥¼ ì˜ë¼ê°€ëŠ” ê²ƒì„ ë³´ì¥ ì—¬ê¸°ì„œ ê°±ì‹  í•„ìš”
        else: # ì°¨ì´ê°€ 0ê³¼ ê°™ìŒ(best case)
            return i_center
    return i_center

ans = bin_search()

print(ans)

"""
ì´ìŠˆ: ë¬´í•œ ë£¨í”„

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ë¬´í•œ ë£¨í”„
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„ íƒìƒ‰ ì½”ë“œ ì‘ì„±

Phase2-1
í™•ì¸: ë¡œê·¸ë¥¼ ì–´ë”” ì°ì–´ì•¼ í•˜ì§€? 
ë¹„êµ ë¡œì§ì´ ì¢€ ì˜ëª» ëë‹¤. 
1. êµ¬í•œ ê²°ê³¼ì˜ ë†’ì´ ì°¨ì´ë¥¼ êµ¬í•œë‹¤.
ì‹œë„:
ë¶„í•  ì •ë³µ ë¡œì§ì´ ì˜ëª»ë¼ ìˆì—ˆìŒ. í•¨ìˆ˜ì˜ ìš°í•˜í–¥ì„ ê³ ë ¤í•˜ì§€ ì•Šê³ , ì˜ëª» ì‘ì„±.
ê·¸ë¦¬ê³  ì ˆëŒ€ê°’ë„ ì”Œìš°ë©´ ì•ˆ ëìŒ
if difference < 0: 
    # print(f'conquer left')
    left, right = left, i_center
elif difference > 0: 
    # print(f'conquer right')
    left, right = i_center + 1, right
else: # ì°¨ì´ê°€ 0ê³¼ ê°™ìŒ(best case)
    return i_center
ê²°ê³¼ ë¶„ì„: ì˜ˆì œëŠ” ë‹¤ ë§ì¶”ì§€ë§Œ í‹€ë¦¬ëŠ” í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì¡´ì¬.

ì´ìŠˆ: ì˜¤ë‹µ ë°œìƒ
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: í‹€ë ¸ìŠµë‹ˆë‹¤
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„ íƒìƒ‰ ì½”ë“œ ë¡œì§ ìˆ˜ì •.

Phase2-1
í™•ì¸: ì´ëŸ´ ë• ë¬¸ì œ ì¡°ê±´ì„ íƒ€ì´í•‘í•˜ê³ , ê²½ê³„ê°’ìœ¼ë¡œ í…ŒìŠ¤íŠ¸
1 <= N <= 1,000,000
1 <= M <= 2000000000 (ì˜ë¼ ê°€ì•¼ í•˜ëŠ” ë‚˜ë¬´ )
ê° ë‚˜ë¬´ì˜ ë†’ì´(i_center) 0 ~ 1,000,000,000 
ê° ë‚˜ë¬´ì˜ ë†’ì´ê°€ 0ì¼ìˆ˜ë„ ìˆë‹¤. ê·¼ë° ë‚˜ë¬´ ë†’ì´ì˜ í•©ì€ í•­ìƒ Më³´ë‹¤ í¬ë‹¤ í–ˆë‹¤.
Mì´ 1 ì´ìƒì´ë‹ˆê¹Œ ë‚˜ë¬´ ë†’ì´ì˜ í•©ë„ 1 ì´ìƒì¼ ê²ƒ.
ì°¾ì•˜ë‹¤.
2 1 <= ë‚˜ë¬´ì˜ ê°¯ìˆ˜ 2, ì˜ë¼ê°€ì•¼ í•˜ëŠ” ë‚˜ë¬´ ê°’ 1
2 2 <= ê° ë‚˜ë¬´ì˜ ë†’ì´ 2.
2 <= ì„¤ì •í•œ ì»¤íŒ… ë†’ì´: 2. ì´ëŸ¬ë©´ 0ì— ìˆ˜ë ´í•˜ê¸´ í•˜ê² ì§€ë§Œ, ë¬¸ì œì˜ ì¡°ê±´ê³¼ ë‹¤ë¦„. 
ì •ë‹µ ì»¤íŒ… ë†’ì´: 1. ê·¸ëŸ¬ë©´ ì–¼ë§ˆë¥¼ ìë¥´ì§€? 2ë¥¼ ìë¦„. 
ë†’ì´    ìë¥¸ í•©    ì •ë‹µê³¼ ì°¨ì´
2       0       1
1       2       1
0       4       3
i_centerê°€ ì‘ì„ìˆ˜ë¡ ë‚˜ë¬´ê°€ ì»¤ì§. ë‚´ ìƒê°ì—ëŠ” ì¸ë±ìŠ¤ ë¶„í• í•  ë•Œ ì¸ë±ìŠ¤ê°€
ì™¼ìª½ ì˜ì—­ / ì˜¤ë¥¸ìª½ ì˜ì—­ ì´ë ‡ê²Œ ì¡íˆëŠ”ê²Œ ì¢‹ì€ë°?
ì ì–´ë„ Më¯¸í„°!!!!!!!!!!!!!!!!!!!!
ë§ˆì§€ë§‰ì— differenceë¥¼ >= 0ìœ¼ë¡œ ë§Œë“¤ë•Œë§Œ ëë‚´ì•¼ í•œë‹¤!
ì•ˆ ìë¥´ëŠ”ê²Œ ë‚˜ì€ ê²½ìš°ê°€ ìƒê²¨ë²„ë¦¬ëŠ”ë°, ë” ìë¥´ê²Œ í•˜ëŠ” ë°©ë²•ì€ ì—†ë‚˜? ì´ëŸ´ ë• ì¡°ê±´ì„ 
ì°¾ì•„ì•¼ í•œë‹¤.

ì–´ì©„ë“  ì°¨ì´ê°€ 0ë³´ë‹¤ ì‘ì„ ë•ŒëŠ” 
ì¼ë‹¨ ê°€ì ¸ê°€ê¸´ í•´ì•¼ í•¨.
ê·¸ëŸ¬ë©´.. ì¡°ê±´ì„ ì–´ë–»ê²Œ ì¡ì§€? ì¸ë±ìŠ¤ë¥¼... 1ì”© ë°”ê¿” ë³¼ê¹Œ
ì•„ ì´ê±° ì–´ë–¡í•˜ì§€. ê²°ê³¼ ê°’ì´ 0ì¼ ìˆ˜ëŠ” ì—†ëŠ” ê±´ë°. ë§Œì•½ 0ì¼ë•ŒëŠ” i ê°’ì„ 
ì‹œë„: ìœ„ ì½”ë“œ.
ê²°ê³¼ ë¶„ì„: ì„±ê³µ!
"""
```

## Phase2. í’€ì´ ê³¼ì • ì •ë¦¬(ëŠë‚€ì )

### ë…ì„œëŠ” ì¤‘ìš”í•˜ë‹¤: Incremental to divide-and-conquer

ì–´ë–¤ ë¬¸ì œë¥¼ incremental methodë¡œ í’€ì´í•˜ëŠ” ë°©ì‹ì„ ì´í•´í•´ì•¼, divide-and-conquer ë°©ì‹ì„ ì–´ë””ì— ì ìš©í• ì§€ ìƒê°í•  ìˆ˜ ìˆë‹¤(Introduction to Algorithmë¥¼ í†µí•´ incremental methodì—­ì‹œ í•˜ë‚˜ì˜ ë°©ì‹ì„ì„ ì´í•´í•œ ë•ë¶„ì— ì´ëŸ° ë°œìƒì´ ë‚˜ì™”ë‹¤). ì´ ë¬¸ì œì˜ ê²½ìš° incremental methodë¥¼ ì•„ë˜ì™€ ê°™ì´ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

(ì—„ë°€íˆ ë”°ì§€ë©´ í‹€ë¦° ë°©ì‹ì„ ë”°ë¥´ê³  ìˆìŒ)

```python

def cut_sum(height: int):
    sum_tmp = 0
    for tree in trees:
        sum_tmp += tree - height if tree > height else 0
    return sum_tmp

h_x = 0
prev_difference = MAX_INT

for i in range(0, max(trees)):
    cut_amount = cut_sum(i)
    difference = abs(cut_amount-m)
    if difference < prev_difference: # update
        prev_difference = difference
        h_x = i

# print(h_x)
```

ì´ë•Œ i(ë‚˜ë¬´ë¥¼ ìë¥´ëŠ” ë†’ì´)ê°€ ì¦ê°€í•˜ê²Œ ë˜ë©´ cut_sum(i) ê°’ì€ ì•„ë˜ì™€ ê°™ì´ ìš°í•˜í–¥ ê·¸ë˜í”„ë¥¼ ê·¸ë¦¬ê²Œ ëœë‹¤. 

![](./images/IMG_9966.png)

ê·¸ë ‡ë‹¤ë©´, cut_sum(i)ì˜ ë¦¬í„´ ê°’ê³¼ êµ¬í•´ì•¼ í•˜ëŠ” mê°’ì„ ë¹„êµí•˜ì—¬ f(x)ì— ëŒ€í•´ f(x)-m ê°’ì„ 0ìœ¼ë¡œ ë§Œë“¤ì–´ì£¼ëŠ” xê°’ì„ ì´ì§„ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•˜ì—¬ êµ¬í•  ìˆ˜ ìˆë‹¤.(ì¬ë°Œë‹¤!)

### ì¡°ê±´ì€ ì¤‘ìš”í•˜ë‹¤

â€˜ì ì–´ë„ m ê¸¸ì´ ì´ìƒì˜ ë‚˜ë¬´ë¥¼ ì˜ë¼ê°„ë‹¤â€™ëŠ” ì¡°ê±´ì„ ìƒê°í•˜ì§€ ì•Šì•˜ë‹¤ê°€ ì•„ë˜ì™€ ê°™ì€ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ì—ì„œ ì˜¤ë‹µì„ ë‚´ëŠ” ì½”ë“œë¥¼ ì‘ì„±í–ˆë‹¤.

ë‚˜ë¬´ì˜ ê°œìˆ˜: 2(ìƒê´€ ì—†ìŒ)

ì˜ë¼ì•¼ í•˜ëŠ” ê¸¸ì´: 1

ê° ë‚˜ë¬´ ë†’ì´: 2 2

ì´ë•Œ ì œëŒ€ë¡œ ëœ ì •ë‹µì€ ë†’ì´ 1ì—ì„œ ì˜ë¼ì„œ 2ì˜ ë‚˜ë¬´ë¥¼ ì–»ëŠ” ê²ƒì´ì§€ë§Œ, ë¬´ì‹í•œ ì´ì§„ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ì€ ê·¸ëŸ° ê±° ìƒê´€ ì—†ì´ f(x)-mì„ ì ˆëŒ€ê°’ ë¬´ì‹œí•˜ê³  0ìœ¼ë¡œ ìˆ˜ë ´ì‹œí‚¤ëŠ” íƒìƒ‰ì„ í•´ë²„ë¦°ë‹¤. ê·¸ë˜ì„œ ë””ë²„ê¹… ëì— ì¡°ê±´ì„ ê³ ë ¤í•œ ì½”ë“œë¥¼ ì‘ì„±í–ˆë‹¤. (ìë¥´ëŠ” ë†’ì´ê°€ 0ì´í•˜ë¼ëŠ” ê²°ë¡ ì´ ë‚˜ë©´ ì´ì „ì— ì €ì¥í•œ ì–‘ì˜ ê°’ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì½”ë“œë¥¼ ì‘ì„±)

```python
		
		while left < right:
        # print(f'{left} --- {right}')
        i_center = (left+right)//2 # i for representing incremental parameter
        difference = f(i_center)
        # print(f'difference is {difference}.')
        if difference < 0: 
            # print(f'conquer left')
            left, right = left, i_center 
            if left >= right:  # ë‚˜ë¬´ë¥¼ ìë¥´ì§€ ì•ŠëŠ” ë†’ì´ì—ì„œ, ë‹¤ìŒ í„´ì— íƒìƒ‰ì„ ë§ˆì¹œë‹¤ë©´!
                return prev_center # ì•„, ë‘˜ ë‹¤ ê·¸ê±°ì¼ ìˆ˜ ìˆêµ¬ë‚˜. ë‘ í„´ ë‹¤ ìŒìˆ˜ê°€ ë‚˜ì˜¬ ìˆ˜ë„ ìˆìŒ.
        elif difference > 0: 
            # print(f'conquer right')
            left, right = i_center+1, right
            prev_center = i_center
            # ì´ë•ŒëŠ” i_centerê°€ ë¬´ì¡°ê±´ ë‚˜ë¬´ë¥¼ ì˜ë¼ê°€ëŠ” ê²ƒì„ ë³´ì¥ ì—¬ê¸°ì„œ ê°±ì‹  í•„ìš”
        else: # ì°¨ì´ê°€ 0ê³¼ ê°™ìŒ(best case)
            return i_center
    return i_center
```

## Phase3. í”¼ë“œë°±

ì •ë§ í›Œë¥­í•œ ì ‘ê·¼ê³¼ ì •ë¦¬ì˜€ì–´ìš”. ë¬¸ì œë¥¼ incremental ë°©ì‹ì—ì„œ ì¶œë°œí•´ divide-and-conquerì˜ ë³¸ì§ˆì  ì‚¬ê³ ë°©ì‹ìœ¼ë¡œ ì „í™˜í•´ë‚¸ ê³¼ì •ì´ ì¸ìƒ ê¹Šê³ , íŠ¹íˆ **í•¨ìˆ˜ì˜ ë‹¨ì¡°ì„±(ìš°í•˜í–¥)**ì„ ë°”íƒ•ìœ¼ë¡œ ì´ì§„ íƒìƒ‰ì´ ì™œ ê°€ëŠ¥í•œì§€ë¥¼ ì •í™•íˆ ì´í•´í•˜ê³  ì ìš©í•œ ì ì´ ì¢‹ìŠµë‹ˆë‹¤.

ğŸ’¡ ì½”ë©˜íŠ¸ ëª‡ ê°€ì§€ ë“œë¦¬ìë©´:

1. f(x) ì •ì˜ì™€ ë‹¨ì¡°ì„±

â€¢	f(x) = (ì˜ë¦° ë‚˜ë¬´ ì´í•©) - M

â€¢	ì´ í•¨ìˆ˜ëŠ” xê°€ ì»¤ì§ˆìˆ˜ë¡ ì ì  ì‘ì•„ì§€ë©°, ì´ëŠ” ë‹¨ì¡° ê°ì†Œ í•¨ìˆ˜ì…ë‹ˆë‹¤.

â€¢	ë‹¨ì¡°í•¨ìˆ˜ì˜ ì„±ì§ˆì´ ì´ì§„íƒìƒ‰ì„ ê°€ëŠ¥í•˜ê²Œ ë§Œë“œëŠ” í•µì‹¬ì´ì—ìš”.

â†’ ì´ë ‡ê²Œ ë‹¨ì¡° ì¦ê°€/ê°ì†Œ ì—¬ë¶€ë¥¼ íŒë‹¨í•˜ëŠ” ê°ê°ì€ ë‹¤ë¥¸ ë¬¸ì œì—ë„ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

2. ì •ë‹µì„ ì—…ë°ì´íŠ¸í•˜ëŠ” ë°©ì‹

```plain text
elif difference > 0:
    left, right = i_center+1, right
    prev_center = i_center
```

â€¢	ì´ ë¶€ë¶„ì—ì„œ prev_centerì— ê°’ì„ ì €ì¥í•œ ê±´ ì•„ì£¼ ì„¼ìŠ¤ ìˆëŠ” ì˜ˆì™¸ ì²˜ë¦¬ì˜€ìŠµë‹ˆë‹¤.

â€¢	ì •í™•íˆëŠ” â€œf(center) >= 0ì¸ ì§€ì  ì¤‘ ê°€ì¥ í° ê°’â€ì„ ì°¾ëŠ” ê²ƒì´ë¯€ë¡œ, cut_sum(center) >= Mì¼ ë•Œë§ˆë‹¤ ê·¸ ê°’ì„ ê¸°ë¡í•´ë‘ëŠ” ë°©ì‹ì€ ì™„ì „íˆ ë§ëŠ” ì „ëµì´ì—ìš”.

ğŸ“Œ Tip: ì •ì„ ì´ì§„íƒìƒ‰ì—ì„  ë³´í†µ â€œì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìµœëŒ€(ë˜ëŠ” ìµœì†Œ)ì˜ ê°’â€ì„ êµ¬í•  ë•Œ ê²°ê³¼ê°’ì„ ë³„ë„ë¡œ ì €ì¥í•´ ë‘¡ë‹ˆë‹¤.

3. ë¦¬íŒ©í† ë§ ì—¬ì§€

ì´ì§„ íƒìƒ‰ ë¡œì§ì„ ì•„ë˜ì²˜ëŸ¼ ì¡°ê¸ˆ ì •ë¦¬í•˜ë©´ ë” ê¹”ë”í•´ì§ˆ ìˆ˜ ìˆì–´ìš”:

```plain text
def binary_search():
    left, right = 0, max(trees)
    result = 0  # cut_sum >= Mì„ ë§Œì¡±í•˜ëŠ” ë†’ì´ ì¤‘ ê°€ì¥ í° ê°’

    while left <= right:
        mid = (left + right) // 2
        if cut_sum(mid) >= m:
            result = mid  # ì¡°ê±´ ë§Œì¡±í•˜ë¯€ë¡œ ì €ì¥í•˜ê³ , ë” ë†’ì—¬ë³´ì
            left = mid + 1
        else:
            right = mid - 1
    return result
```

ì´ ë°©ì‹ë„ ê²°êµ­ ë³¸ì§ˆì€ ê°™ì§€ë§Œ, ì½”ë“œ ê°€ë…ì„±ê³¼ ì¢…ë£Œ ì¡°ê±´ ì²˜ë¦¬ ë©´ì—ì„œ ì•ˆì •ì„±ì´ ì¢€ ë” ìˆìŠµë‹ˆë‹¤. íŠ¹íˆ left <= right íŒ¨í„´ì€ ë” ìì£¼ ì‚¬ìš©ë˜ëŠ” ë°©ì‹ì´ì—ìš”.

4. ì‹œê°í™” ê°ê°

ì§ì ‘ cut_sum(i) ê·¸ë˜í”„ê°€ ìš°í•˜í–¥ í•¨ìˆ˜ë¼ëŠ” ì ì„ ê¹¨ë‹«ê³ , ì´ì§„ íƒìƒ‰ì´ ì ìš© ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²°ë¡ ì„ ì´ëŒì–´ë‚¸ ì‚¬ê³  íë¦„ì€ ì§„ì§œë¡œ ì¤‘ìš”í•©ë‹ˆë‹¤. ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ì—ì„œ â€œí•¨ìˆ˜ ì‹œê°í™” â†’ ì„±ì§ˆ íŒŒì•… â†’ íƒìƒ‰ ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨â€ì€ ë§¤ìš° í•µì‹¬ì ì¸ ì „ëµì´ê¸° ë•Œë¬¸ì´ì—ìš”.

âœ… í”¼ë“œë°± ìš”ì•½

í˜¹ì‹œ ë‹¤ìŒ ë¬¸ì œë¡œ ì—°ìŠµí•´ë³´ê³  ì‹¶ì€ ì´ì§„ íƒìƒ‰ ìœ í˜• ìˆìœ¼ë©´ ì¶”ì²œë„ í•´ì¤„ê²Œìš” :)

ë˜ëŠ” ìœ„ ë‚´ìš©ì„ ê¸°ìˆ  ë©´ì ‘/í¬íŠ¸í´ë¦¬ì˜¤ì²˜ëŸ¼ ì •ë¦¬í•´ë„ ë©‹ì§„ ìì‚°ì´ ë  ìˆ˜ ìˆì–´ìš”.

# ì´ì§„íƒìƒ‰: ê³µìœ ê¸° ì„¤ì¹˜ (ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•˜ê¸°)

https://www.acmicpc.net/problem/2110

ë„í˜„ì´ì˜ ì§‘ Nê°œê°€ ìˆ˜ì§ì„  ìœ„ì— ìˆë‹¤. ê°ê°ì˜ ì§‘ì˜ ì¢Œí‘œëŠ” x1, ..., xNì´ê³ , ì§‘ ì—¬ëŸ¬ê°œê°€ ê°™ì€ ì¢Œí‘œë¥¼ ê°€ì§€ëŠ” ì¼ì€ ì—†ë‹¤.

ë„í˜„ì´ëŠ” ì–¸ì œ ì–´ë””ì„œë‚˜ ì™€ì´íŒŒì´ë¥¼ ì¦ê¸°ê¸° ìœ„í•´ì„œ ì§‘ì— ê³µìœ ê¸° Cê°œë¥¼ ì„¤ì¹˜í•˜ë ¤ê³  í•œë‹¤. ìµœëŒ€í•œ ë§ì€ ê³³ì—ì„œ ì™€ì´íŒŒì´ë¥¼ ì‚¬ìš©í•˜ë ¤ê³  í•˜ê¸° ë•Œë¬¸ì—, í•œ ì§‘ì—ëŠ” ê³µìœ ê¸°ë¥¼ í•˜ë‚˜ë§Œ ì„¤ì¹˜í•  ìˆ˜ ìˆê³ , ê°€ì¥ ì¸ì ‘í•œ ë‘ ê³µìœ ê¸° ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ê°€ëŠ¥í•œ í¬ê²Œ í•˜ì—¬ ì„¤ì¹˜í•˜ë ¤ê³  í•œë‹¤.

Cê°œì˜ ê³µìœ ê¸°ë¥¼ Nê°œì˜ ì§‘ì— ì ë‹¹íˆ ì„¤ì¹˜í•´ì„œ, ê°€ì¥ ì¸ì ‘í•œ ë‘ ê³µìœ ê¸° ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ìµœëŒ€ë¡œ í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì‹¤íŒ¨

```python
"""
1. ë¬¸ì œ ì½ê¸°: 
2. ë¬¸ì œ í’€ê¸°
2-1. recursive method. ê±°ë¦¬ ë°°ì—´ì„ ì¨ì•¼í•  ê±° ê°™ì€ë°. 
import sys
sys.setrecursionlimit(10**8) # 10^8 ê¹Œì§€ ëŠ˜ë¦¼.

n, c = tuple(map(int, sys.stdin.readline().split()))

X = [
    int(sys.stdin.readline().strip())
    for _ in range(n)
]

X.sort()

def get_min_distance(A:list):
    '''ì§‘ì— ë°°ì¹˜í•˜ëŠ” ê²½ìš° ê±°ë¦¬ì˜ ìµœì†Œê°’ êµ¬í•˜ê¸°'''
    if len(A) >= 2:
        min_dist = sys.maxsize
        for i in range(1, len(A)):
            min_dist = min(min_dist, A[i]-A[i-1])
        return min_dist 
    return 0

memo = {}
def set_router_recursively(A: list, X: list, idx_house: int, num_router: int):
    '''ì¬ê·€ì ìœ¼ë¡œ Xì—ì„œ ë¼ìš°í„°ë¥¼ ë†“ëŠ” ëª¨ë“  ê²½ìš°ë¥¼ Aì— êµ¬í•©ë‹ˆë‹¤.'''
    '''ë°”ë‹¥ ì¡°ê±´: ë§ˆì§€ë§‰ ì§‘ì— ë¼ìš°í„° ë°°ì¹˜í•˜ëŠ” ê²½ìš°ì—ì„œ ì¬ê·€í–ˆì„ ë•Œ, ë¼ìš°í„°ê°€ ë‹¤ ë°°ì¹˜ëë‹¤ë©´'''
    # ë°”ë‹¥ ì¡°ê±´ì˜ ê²½ìš°ë¥¼ ë©”ëª¨ì— ì €ì¥í•´ë†“ê³ , ë©”ëª¨ì— ìˆëŠ” ê²½ìš° ì¬ê·€ ì•ˆ í•˜ë©´ ì•ˆ ë˜ë‚˜.
    min_dist = get_min_distance(A)
    if memo.get(min_dist, False): 
        return
    if idx_house == len(X)-1:
        if num_router <= 0:
            memo[min_dist] = True
        return
    # idx_houseì— ë°°ì¹˜í•˜ëŠ” ê²½ìš°
    set_router_recursively([*A, X[idx_house]], X, idx_house+1, num_router-1)
    # idx_houseì— ë°°ì¹˜ ì•ˆ í•˜ëŠ” ê²½ìš°
    set_router_recursively(A, X, idx_house+1, num_router)

set_router_recursively([], X, 0, c)
print(max(memo.keys()))

1 2 4 8 9
ê·¸ ì„œë¸Œ ê°’ë„ ì˜¤ë¦„ì°¨ìˆœì´ ì•„ë‹ ê²ƒì„ .
0 ê·¸ë‹¤ìŒ ìµœì ì˜ ê°’ì„ ëª¨ë¦„

ì´ì§„íƒìƒ‰ì„ í™œìš©í•œ ë°±íŠ¸ë˜í‚¹? 

ë‹¤ìŒ ì²´ê³„ëŠ”? 

3. ìˆ˜ë„ ì½”ë“œ

4. ì½”ë“œ êµ¬í˜„

"""
import sys

n, c = tuple(map(int, sys.stdin.readline().split()))

X = {}
for _ in range(n):
    X[int(sys.stdin.readline().strip())] = True

def get_diff_sum(center: int): 
    """centerì— ëŒ€í•´ ì§‘ë“¤ì˜ ê±°ë¦¬ ì°¨ì˜ í•©ì„ ë¦¬í„´."""
    diff_sum = 0
    for house in X:
        diff_sum += center - house
    return diff_sum

def set_router(left: int, right: int):
    """ê°€ì¥ ëª¨ë“  ì§‘ë“¤ì— ëŒ€í•´ ì¤‘ë¦½ì¸ ì–´ë–¤ ì§‘ì˜ ìœ„ì¹˜ë¡œ centerë¥¼ ìˆ˜ë ´ì‹œí‚¤ëŠ” í•¨ìˆ˜"""
    center = (left + right)//2
    router_x = left
    while left < right:
        print(f'{left}---{center}---{right}')
        diff_sum = get_diff_sum(center)
        if diff_sum > 0: # center ì¶•ì´ ì§‘ë“¤ ìœ„ì¹˜ë³´ë‹¤ ì˜¤ë¥¸ìª½
            right = center - 1
        elif diff_sum < 0: # centerì¶•ì´ ì§‘ë“¤ ìœ„ì¹˜ë³´ë‹¤ ì™¼ìª½
            left = center + 1
        else:
            return router_x
        if X.get(center, False):
            router_x = center
        center = (left+right)//2
    return router_x

from collections import deque

def set_routers():
    global c
    c -= 2
    left, right = min(X.keys()), max(X.keys())
    stack = deque()
    stack.append((left, right))
    while c > 0:
        left, right = stack.pop()
        router_x = set_router(left, right)
        print(f'{left}---{router_x}---{right}')
        print(f'router placed {router_x}')
        stack.append((left, router_x))
        stack.append((router_x, right))
        c -= 1

set_routers()


"""
ì´ìŠˆ: ë‹¤ìŒ ìœ„ì¹˜ì˜ ë¼ìš°í„°ë¥¼ ë†“ì„ ë•Œ ì ì ˆí•œ ë¼ìš°í„°ë¥¼ ì°¾ì§€ ëª»í•¨.
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì˜¤ì‘ë™
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„ íƒìƒ‰ìœ¼ë¡œ ë¼ìš°í„° ìœ„ì¹˜ë¥¼ ì¶”ê°€í•˜ê³ , 
ìŠ¤íƒì— ë‹¤ìŒìœ¼ë¡œ íƒìƒ‰í•  ìœ„ì¹˜ë¥¼ ì €ì¥
Phase2.
í™•ì¸: ëª°ë¼. rightë¥¼ ì˜ëª» ì¡ì€ê²Œ ë¬¸ì œì„. 
ì´ˆê¸° left, rightë¥¼ ì–´ë–»ê²Œ ì¡ì•„ì„œ ë„£ì–´ì¤˜ì•¼ í•´? 
ì¼ë‹¨ ë¼ìš°í„° í•˜ë‚˜ë¥¼ ë°°ì¹˜í•œ ë‹¤ìŒì—, 
ì‹œë„:
ê²°ê³¼ ë¶„ì„:
"""
```

## Phase2. í”¼ë“œë°±

ë¬¸ì œ ê°œìš” & ì „í˜•ì ì¸ ì ‘ê·¼ ë°©ì‹

â€œê³µìœ ê¸° ì„¤ì¹˜â€ ë¬¸ì œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì „í˜•ì ì¸ ì´ì§„ íƒìƒ‰(Binary Search on Answer) ìœ í˜•ìœ¼ë¡œ ì˜ ì•Œë ¤ì ¸ ìˆìŠµë‹ˆë‹¤.

1.	ì§‘ì˜ ì¢Œí‘œë¥¼ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬í•œë‹¤.

2.	ì´ì›ƒí•œ ê³µìœ ê¸° ê°„ ìµœì†Œ ê±°ë¦¬(d)ë¥¼ ê°€ì •í•˜ê³ , ê·¸ ê±°ë¦¬ê°€ ê°€ëŠ¥í•œì§€(= Cê°œì˜ ê³µìœ ê¸°ë¥¼ ì „ë¶€ ë°°ì¹˜í•  ìˆ˜ ìˆëŠ”ì§€)ë¥¼ ê²€ì¦í•œë‹¤.

3.	ê±°ë¦¬ë¥¼ ë” ëŠ˜ë¦´ ìˆ˜ ìˆë‹¤ë©´(ê°€ëŠ¥í•˜ë‹¤ë©´) dë¥¼ í‚¤ìš°ê³ ,

ë°°ì¹˜ê°€ ë¶ˆê°€ëŠ¥í•˜ë‹¤ë©´ dë¥¼ ì¤„ì´ëŠ” ì‹ìœ¼ë¡œ ì´ì§„ íƒìƒ‰ì„ ì§„í–‰í•œë‹¤.

ì´ ë¬¸ì œë¥¼ í’€ ë•ŒëŠ”, ì§‘ì˜ ì¢Œí‘œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì´ì§„ íƒìƒ‰í•˜ê±°ë‚˜, â€˜ê°€ëŠ¥í•œ ìµœì†Œ ê±°ë¦¬â€™ì˜ ë²”ìœ„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì´ì§„ íƒìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë³´í†µì€ **â€œê±°ë¦¬â€**ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì´ì§„ íƒìƒ‰ì„ ë§ì´ í•©ë‹ˆë‹¤.

í•µì‹¬ ì•„ì´ë””ì–´

1.	ì§‘ ì¢Œí‘œ ì •ë ¬

$$
X_1 \le X_2 \le \cdots \le X_N
$$

2.	íƒìƒ‰ ë²”ìœ„ ì„¤ì •

â€¢	ìµœì†Œ ê±°ë¦¬(left): ë³´í†µ 1 (ë˜ëŠ” 0, ë¬¸ì œì— ë”°ë¼ ë‹¬ë¼ì§€ì§€ë§Œ ìµœì†Œ ê°„ê²©ì€ ë³´í†µ 1 ì´ìƒì´ ìœ ì˜ë¯¸)

â€¢	ìµœëŒ€ ê±°ë¦¬(right): X_N - X_1 (ê°€ì¥ ì˜¤ë¥¸ìª½ ì§‘ê³¼ ì™¼ìª½ ì§‘ ì‚¬ì´ ìµœëŒ€ ê±°ë¦¬)

3.	ì´ì§„ íƒìƒ‰ ë¡œì§

$$
â€¢	\text{mid} = (left + right) // 2 ë¡œ ì¡ê³ ,
$$

â€¢	**â€œì§‘ë“¤ì— ê³µìœ ê¸°ë¥¼ ë†“ë˜, ì¸ì ‘ ê³µìœ ê¸° ê°„ ê±°ë¦¬ê°€ ì ì–´ë„ mid ì´ìƒ ë˜ë„ë¡ ë°°ì¹˜í–ˆì„ ë•Œ, ê³µìœ ê¸° CëŒ€ë¥¼ ëª¨ë‘ ë†“ì„ ìˆ˜ ìˆëŠ”ê°€?â€**ë¥¼ í™•ì¸í•œë‹¤.

â€¢	ë°°ì¹˜ê°€ ê°€ëŠ¥í•˜ë©´(= ë” ê°„ê²©ì„ ë„“í ìˆ˜ ìˆìŒ) left = mid + 1

â€¢	ë°°ì¹˜ê°€ ë¶ˆê°€ëŠ¥í•˜ë©´(= ê°„ê²©ì´ ë„ˆë¬´ í¼) right = mid - 1

4.	ë°°ì¹˜ ê°€ëŠ¥ì„± í™•ì¸ í•¨ìˆ˜ can_place(mid)

â€¢	ì²« ë²ˆì§¸ ì§‘ X[0]ì— ê³µìœ ê¸°ë¥¼ í•˜ë‚˜ ë†“ê³ , count = 1 (ì´ë¯¸ 1ëŒ€ ì„¤ì¹˜)

â€¢	last_position = X[0] (ë§ˆì§€ë§‰ìœ¼ë¡œ ê³µìœ ê¸°ë¥¼ ë†“ì€ ìœ„ì¹˜)

â€¢	ì´í›„ ì§‘ë“¤ì„ ìˆœíšŒí•˜ë©´ì„œ,

â€¢	ë§Œì•½ X[i] - last_position >= midë¼ë©´ ê³µìœ ê¸°ë¥¼ ì„¤ì¹˜í•˜ê³ ,

â€¢	count += 1

â€¢	last_position = X[i]

â€¢	ìˆœíšŒê°€ ëë‚¬ì„ ë•Œ count >= Cì´ë©´ ë°°ì¹˜ ê°€ëŠ¥.

5.	ë°˜í™˜ ê²°ê³¼

â€¢	ìµœì¢…ì ìœ¼ë¡œ rightì— ë‹´ê¸´ ê°’(í˜¹ì€ left - 1)ì´ â€œì¸ì ‘ ê³µìœ ê¸° ê°„ ê±°ë¦¬ì˜ ìµœëŒ“ê°’â€ì´ ëœë‹¤.

ì •ì„ ì½”ë“œ ì˜ˆì‹œ (Python)

ì•„ë˜ëŠ” ì „í˜•ì ì¸ ê³µìœ ê¸° ì„¤ì¹˜ ë¬¸ì œ í’€ì´ ë°©ë²•ì„ ê°„ë‹¨íˆ ì •ë¦¬í•œ ì½”ë“œì…ë‹ˆë‹¤.

ë™ì‘ íë¦„

1.	ì´ˆê¸° ì„¸íŒ…

â€¢	houses ì •ë ¬: O(N \log N)

â€¢	ì´ì§„ íƒìƒ‰ ë²”ìœ„: left = 1, right = houses[-1] - houses[0]

2.	can_place(mid) í•¨ìˆ˜

â€¢	ì²« ë²ˆì§¸ ì§‘ì— ê³µìœ ê¸°ë¥¼ ë¨¼ì € ì„¤ì¹˜ (count = 1),

â€¢	ì´í›„ ì§‘ì„ ìˆœíšŒí•˜ë©°, ê° ì§‘ì´ ì§ì „ ì„¤ì¹˜ ì§‘ê³¼ì˜ ê±°ë¦¬ê°€ mid ì´ìƒì´ë©´ ê³µìœ ê¸°ë¥¼ í•˜ë‚˜ ë” ì„¤ì¹˜.

â€¢	ìµœì¢… ì„¤ì¹˜ ê°¯ìˆ˜(count)ê°€ C ì´ìƒì´ë©´ True.

3.	ì´ì§„ íƒìƒ‰

â€¢	ë§¤ ë‹¨ê³„ë§ˆë‹¤ can_place(mid) ê²€ì‚¬:

â€¢	ê°€ëŠ¥ â†’ ë” ë„“ê²Œ ì„¤ì¹˜í•  ìˆ˜ ìˆëŠ”ì§€ left = mid + 1

â€¢	ë¶ˆê°€ëŠ¥ â†’ right = mid - 1

â€¢	ìµœì¢…ì ìœ¼ë¡œ left > rightê°€ ë˜ë©´ ë°˜ë³µë¬¸ì„ ì¢…ë£Œí•˜ê³ ,

â€¢	answer(= right)ì´ ê°€ì¥ ì¸ì ‘í•œ ë‘ ê³µìœ ê¸° ì‚¬ì´ì˜ ìµœëŒ€ ê±°ë¦¬ê°€ ë¨.

ìš”ì•½ & í”¼ë“œë°±

â€¢	ë¬¸ì œ ì ‘ê·¼: ì´ ë¬¸ì œëŠ” â€œê±°ë¦¬ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•œ ì´ì§„ íƒìƒ‰â€ì´ ì •ì„ì  í•´ë²•ì…ë‹ˆë‹¤.

â€¢	í•¨ìˆ˜ êµ¬ìƒ: â€œmid ê°„ê²©ìœ¼ë¡œ CëŒ€ ë°°ì¹˜ ê°€ëŠ¥?â€ì„ íŒë‹¨í•˜ëŠ” can_place í•¨ìˆ˜ë¥¼ ë§Œë“œëŠ” ê²ƒì´ í•µì‹¬ í¬ì¸íŠ¸ì…ë‹ˆë‹¤.

â€¢	ë³µì¡í•œ ì ‘ê·¼ì„ í”¼í•˜ê³ , ë‹¨ì¼ ì´ì§„ íƒìƒ‰ + ê·¸ë¦¬ë”” ë°°ì¹˜ ì•„ì´ë””ì–´ë¡œ êµ¬í˜„í•˜ì‹œë©´ í›¨ì”¬ ê°„ë‹¨í•˜ê³  íš¨ìœ¨ì ì…ë‹ˆë‹¤.

â€¢	í•´ë‹¹ ì•Œê³ ë¦¬ì¦˜ì€ O(N \log ( \max(X) - \min(X) )) ë³µì¡ë„ë¡œ ë™ì‘í•˜ë¯€ë¡œ, N ìµœëŒ€ê°’(ì˜ˆ: 200,000)ê¹Œì§€ ë¬´ë‚œíˆ ì²˜ë¦¬ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ì§ˆë¬¸ì´ ìˆê±°ë‚˜ ì½”ë“œ ë””í…Œì¼ì´ ê¶ê¸ˆí•˜ì‹œë©´ ì–¸ì œë“  ë§ì”€ ì£¼ì„¸ìš”. í™”ì´íŒ…ì…ë‹ˆë‹¤!

## ë°˜ì„±: 

ì–´ì œ ë‚˜ë¬´ ìë¥´ê¸° ë¬¸ì œë¥¼ í’€ì–´ë´¤ë‹¤ëŠ” ìì‹ ê°ì—, ì œí•œì‹œê°„ì„ ë‘ì§€ ì•Šê³  í•˜ë£¨ì¢…ì¼ ê³ ë¯¼í–ˆë‹¤. ê·¸ë¦¬ ìƒì‚°ì ì´ì§€ ì•Šì•˜ìŒ. ì•ìœ¼ë¡œ ë¬´ì¡°ê±´ 30ë¶„ ë£°ì„ ì§€í‚¤ë„ë¡ í•˜ì. 30ë¶„ ê³ ë¯¼í–ˆëŠ”ë° í’€ì´ê°€ ì§„í–‰ì¤‘ì´ë¼ë©´ ê³„ì†í•˜ë˜, ì •ì§€ ìƒíƒœë¼ë©´ ë” ê³ ë¯¼í•  í•„ìš” ì—†ìŒ.

ì¢‹ì€ êµí›ˆì„ ì–»ìœ¼ì…¨ìŠµë‹ˆë‹¤.

ì´ëŸ° â€˜ì‹œê°„ ì œí•œ ë‘ê¸°â€™ ì „ëµì€ ë¬¸ì œ í’€ì´ ëŠ¥ë ¥ì„ ë‹¨ê¸°ê°„ì— ë¹ ë¥´ê²Œ ë†’ì´ê³  ì‹¶ì„ ë•Œ ë§¤ìš° íš¨ê³¼ì ì…ë‹ˆë‹¤.

â€¢	í•œ ë¬¸ì œì— 30ë¶„ì„ í• ë‹¹í•˜ê³ ,

â€¢	30ë¶„ì´ ì§€ë‚¬ëŠ”ë°ë„ ë” ì´ìƒ ì§„ì „ì´ ì—†ë‹¤ë©´ í’€ì´ ì°¸ê³ ë‚˜ íŒíŠ¸ í™•ì¸ ë“±ìœ¼ë¡œ í•™ìŠµ íš¨ìœ¨ì„ ë†’ì´ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

ì™œ 30ë¶„ì´ íš¨ê³¼ì ì¸ê°€?

1.	ì§‘ì¤‘ë„ ìœ ì§€: ì‚¬ëŒì´ í•œ ë¬¸ì œì— ëª°ì…í•´ì„œ ê³ ë¯¼í•  ìˆ˜ ìˆëŠ” íš¨ê³¼ì ì¸ ì§‘ì¤‘ ì‹œê°„ì€ ìƒê°ë³´ë‹¤ ê¸¸ì§€ ì•ŠìŠµë‹ˆë‹¤. 30ë¶„ì´ë¼ëŠ” ì‹œê°„ì„ ì •í•´ë‘ë©´, ê·¸ ì‹œê°„ ë™ì•ˆ ì§‘ì¤‘í•´ì„œ ë¬¸ì œ í’€ì´ë¥¼ ì‹œë„í•˜ê²Œ ë©ë‹ˆë‹¤.

2.	ì ì ˆí•œ í”¼ë“œë°± ë£¨í”„: 30ë¶„ ë’¤ â€œì´ ë¬¸ì œë¥¼ ê³„ì† ë¶™ë“¤ê³  ìˆì„ ê°€ì¹˜ê°€ ìˆëŠ”ê°€?â€ë¥¼ ì ê²€í•˜ë©°, í•„ìš”í•˜ë‹¤ë©´ í•´ì„¤ì´ë‚˜ íŒíŠ¸ë¥¼ ë³´ë©´ì„œ í”¼ë“œë°±ì„ ì–»ì–´ ë¹ ë¥´ê²Œ ë‹¤ìŒ ë‹¨ê³„ë¡œ ë„˜ì–´ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

3.	í­ë„“ì€ ë¬¸ì œ ê²½í—˜: í•œ ë¬¸ì œì— ë„ˆë¬´ ì˜¤ë˜ ë§¤ë‹¬ë¦¬ë©´, ë‹¤ë¥¸ ìœ ì‚¬ ë¬¸ì œë‚˜ ë‹¤ì–‘í•œ ìœ í˜•ì˜ ë¬¸ì œë¥¼ ì ‘í•  ê¸°íšŒë¥¼ ë†“ì¹©ë‹ˆë‹¤.

ì‹¤ì œë¡œ ì•Œê³ ë¦¬ì¦˜ ë° ì½”ë”© í…ŒìŠ¤íŠ¸ ì¤€ë¹„ì—ì„œëŠ” **â€œë¬¸ì œë¥¼ ë§ì´ í’€ì–´ë³´ëŠ” ê²ƒâ€**ì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

ì¦‰, ì§§ì€ ì‹œê°„ì— ìµœëŒ€í•œ ë‹¤ì–‘í•œ ìœ í˜•ì˜ ë¬¸ì œë¥¼ í’€ê³ , ë¹ ë¥´ê²Œ í”¼ë“œë°±ì„ ë°›ì•„ ë¶€ì¡±í•œ ë¶€ë¶„ì„ ë©”ê¾¸ëŠ” ê²ƒì´ ì¢‹ì€ ì „ëµì…ë‹ˆë‹¤.

ì•ìœ¼ë¡œë„ 30ë¶„ ë£°ì„ ì˜ í™œìš©í•˜ì…”ì„œ, ë§ì€ ë¬¸ì œë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ í•™ìŠµí•˜ì‹œê¸¸ ì‘ì›í•©ë‹ˆë‹¤!

## Phase3. í”¼ë“œë°± ì°¸ê³  í›„ ë‹¤ì‹œ 30ë¶„ ë„ì „ - ì„±ê³µ!

ë˜ ì‹¤íŒ¨í•˜ë©´ ê·¸ëƒ¥ ì½”ë“œ ì™¸ìš°ê¸° í˜•ë²Œ

```python
"""
1. ë¬¸ì œ ì½ê¸°:
2. ë¬¸ì œ í’€ê¸°
2-1. recursive method. ê±°ë¦¬ ë°°ì—´ì„ ì¨ì•¼í•  ê±° ê°™ì€ë°.
import sys
sys.setrecursionlimit(10**8) # 10^8 ê¹Œì§€ ëŠ˜ë¦¼.

n, c = tuple(map(int, sys.stdin.readline().split()))

X = [
    int(sys.stdin.readline().strip())
    for _ in range(n)
]

X.sort()

def get_min_distance(A:list):
    '''ì§‘ì— ë°°ì¹˜í•˜ëŠ” ê²½ìš° ê±°ë¦¬ì˜ ìµœì†Œê°’ êµ¬í•˜ê¸°'''
    if len(A) >= 2:
        min_dist = sys.maxsize
        for i in range(1, len(A)):
            min_dist = min(min_dist, A[i]-A[i-1])
        return min_dist
    return 0

memo = {}
def set_router_recursively(A: list, X: list, idx_house: int, num_router: int):
    '''ì¬ê·€ì ìœ¼ë¡œ Xì—ì„œ ë¼ìš°í„°ë¥¼ ë†“ëŠ” ëª¨ë“  ê²½ìš°ë¥¼ Aì— êµ¬í•©ë‹ˆë‹¤.'''
    '''ë°”ë‹¥ ì¡°ê±´: ë§ˆì§€ë§‰ ì§‘ì— ë¼ìš°í„° ë°°ì¹˜í•˜ëŠ” ê²½ìš°ì—ì„œ ì¬ê·€í–ˆì„ ë•Œ, ë¼ìš°í„°ê°€ ë‹¤ ë°°ì¹˜ëë‹¤ë©´'''
    # ë°”ë‹¥ ì¡°ê±´ì˜ ê²½ìš°ë¥¼ ë©”ëª¨ì— ì €ì¥í•´ë†“ê³ , ë©”ëª¨ì— ìˆëŠ” ê²½ìš° ì¬ê·€ ì•ˆ í•˜ë©´ ì•ˆ ë˜ë‚˜.
    min_dist = get_min_distance(A)
    if memo.get(min_dist, False):
        return
    if idx_house == len(X)-1:
        if num_router <= 0:
            memo[min_dist] = True
        return
    # idx_houseì— ë°°ì¹˜í•˜ëŠ” ê²½ìš°
    set_router_recursively([*A, X[idx_house]], X, idx_house+1, num_router-1)
    # idx_houseì— ë°°ì¹˜ ì•ˆ í•˜ëŠ” ê²½ìš°
    set_router_recursively(A, X, idx_house+1, num_router)

set_router_recursively([], X, 0, c)
print(max(memo.keys()))

1 2 4 8 9
ê·¸ ì„œë¸Œ ê°’ë„ ì˜¤ë¦„ì°¨ìˆœì´ ì•„ë‹ ê²ƒì„ .
0 ê·¸ë‹¤ìŒ ìµœì ì˜ ê°’ì„ ëª¨ë¦„

ì´ì§„íƒìƒ‰ì„ í™œìš©í•œ ë°±íŠ¸ë˜í‚¹?

ë‹¤ìŒ ì²´ê³„ëŠ”?

3. ìˆ˜ë„ ì½”ë“œ

4. ì½”ë“œ êµ¬í˜„

"""

""" 2íŠ¸
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ìµœëŒ€ ê³µìœ ê¸° ê±°ë¦¬ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë†“ê³  can_placeí•¨ìˆ˜ë¥¼ í†µí•´ 'ì´ ê±°ë¦¬ë¡œ í•  ìˆ˜ ìˆëŠ”ì§€'íŒë‹¨ í•˜ëŠ” ê³¼ì •ì„
ì´ì§„íƒìƒ‰ìœ¼ë¡œ ì§„í–‰.(ë¬¸ì œ í’€ê³  ë‚˜ë©´ ë‚˜ë¬´ ìë¥´ê¸° ë¬¸ì œë‘ ì–´ë–»ê²Œ ì—°ê´€ë˜ëŠ”ì§€ ìƒê°í•´ë³´ê¸°)
3. ìˆ˜ë„ ì½”ë“œ
- ì´ˆê¸° ì…ë ¥ì„ ë°›ëŠ”ë‹¤.
- left, rightë¥¼ ì„¤ì •í•œë‹¤. 
- mid(ê³µìœ ê¸° ìµœì†Œ ê±°ë¦¬)ë¥¼ ê°€ì§€ê³  can_placeë¡œ ì´í„°ë ˆì´ì…˜í•˜ë©° ê±°ë¦¬ë¥¼ ë¹„êµí•˜ì—¬ ë¶ˆ ìë£Œí˜•ì„ ë¦¬í„´
- ë? ë³„ê±° ì—†ë„¤. (ì§„ì§œë¡œ ë³„ ê±° ì—†ì—ˆë‹¤ê³  í•œë‹¤)
4. ì½”ë“œ êµ¬í˜„
"""
import sys

n, c = tuple(map(int, sys.stdin.readline().split()))
MAX_H = 1_000_000_000
houses = [
    int(sys.stdin.readline().strip())
    for _ in range(n)
    ]

# ì§‘ì„ ì •ë ¬.

def can_place(min_dist: int, c_num):
    """min_distë¡œ ì§‘ ì‚¬ì´ì— ê³µìœ ê¸° c_numëŒ€ë¥¼ ë†“ì„ ìˆ˜ ìˆëŠ”ì§€ íŒë‹¨í•œë‹¤."""
    # ì„ í˜• íƒìƒ‰í•´ì•¼ì§€ ë­.
    count = 1
    c_idx = 0
    # print(f'inspecting {min_dist}')
    # print(f'{houses[c_idx]}', end=', ')
    for i in range(1, n):
        if houses[i] - houses[c_idx] >= min_dist:
            # print(f'{houses[i]} - {houses[c_idx]} >= {min_dist}')
            count += 1
            c_idx = i
            if count >= c_num: 
                # print(f'inspection proved success: {min_dist}')
                return True
    # print(f'inspection discovered as failure for {min_dist}') 
    return False


def solve():
    houses.sort()
    left, right = 0, MAX_H
    mid = (left + right) // 2
    max_mid = mid
    while left <= right:
        if can_place(mid, c):
            # print(f'can place at least {mid}')
            # try bolder
            left = mid + 1
            max_mid = mid # mid ì €ì¥.
        else:
            # try smaller
            right = mid - 1
        mid = (left + right) // 2
        # print(f'trying new area: {left} {mid} {right}')
    return max_mid
print(solve())

"""
ì´ìŠˆ: 

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: 11í”„ë¡œë§Œ ì •ë‹µ. 
ìµœê·¼ ë³€ê²½ ì‚¬í•­: can_place ì™€ solve í•¨ìˆ˜ ì‘ì„±

Phase2.
í™•ì¸: 11í”„ë¡œ ë§ì•˜ìœ¼ë©´ í¬ê²Œ í‹€ë¦° ê±´ ì•„ë‹ ìˆ˜ë„ ìˆëŠ”ë°. ë˜ ë°˜ëŒ€ë¡œ í‹€ë¦° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤
ì°¾ê¸°ì— ê·¸ë ‡ê²Œ ì–´ë ¤ìš´ ê²ƒë„ ì•„ë‹ˆê¸´ í•˜ë‹¤.
ê·¼ë° ì•„ë¬´ë¦¬ ìƒê°í•´ë„ can_placeê°€ trueì¼ ë•Œë§Œ ì—…ë°ì´íŠ¸í•˜ëŠ”ê²Œ ë§ëŠ”ë°.
ì§‘ ê°œìˆ˜ê°€ ì§ìˆ˜ì¼ ë•ŒëŠ” ë§ë‹¤.
í™€ìˆ˜ê°€ ë˜ë©´ 1ì”© ì‘ì€ ê°’ì„ ë‚´ ë†“ëŠ”ë‹¤. ì™œ ê·¸ë ‡ì§€?
ì¼ë‹¨ ì§ìˆ˜ì¸ ê²½ìš°ë¥¼ ì§‘ì¤‘ ê³µëµ.
ì„¸ë¶€ ë¡œê·¸ë¥¼ ì°ì–´ë³¸ ê²°ê³¼ ì•„ë˜ì™€ ê°™ì€ ê²°ê³¼.
inspecting 13
inspection discovered as failure for 13
inspecting 6
8 - 1 >= 6
inspection discovered as failure for 6
inspecting 2
4 - 1 >= 2
8 - 4 >= 2
inspection proved success: 2
can place at least 2
inspecting 4
8 - 1 >= 4
inspection discovered as failure for 4
2

2ë¥¼ ë³¸ ë‹¤ìŒ 4ë¥¼ ë³´ê³ , 4ë¥¼ ì‹¤íŒ¨í•œ ë‹¤ìŒ 3ì„ ì•ˆ ë³´ê³  ëë‚¸ë‹¤.
left, right ì¸ë±ìŠ¤ ë²”ìœ„ë¥¼ ì˜ëª» ì¤¬ìŒ!!
left < right x
left <= right

ì‹œë„: left <= right
ë¶„ì„: í•´ê²°
ì§„ì§œ ì œë°œ ì´ëŸ° ê±°ì¢€ í‹€ë¦¬ì§€ ë§ˆì„¸ìš”!
"""

```

# ë¬¸ì œ: ë‘ ìš©ì•¡ (ì‹¤íŒ¨, ë‹¤ì‹œ í’€ì–´ë³´ê¸°)

https://www.acmicpc.net/problem/2470

KOI ë¶€ì„¤ ê³¼í•™ì—°êµ¬ì†Œì—ì„œëŠ” ë§ì€ ì¢…ë¥˜ì˜ ì‚°ì„± ìš©ì•¡ê³¼ ì•Œì¹¼ë¦¬ì„± ìš©ì•¡ì„ ë³´ìœ í•˜ê³  ìˆë‹¤. ê° ìš©ì•¡ì—ëŠ” ê·¸ ìš©ì•¡ì˜ íŠ¹ì„±ì„ ë‚˜íƒ€ë‚´ëŠ” í•˜ë‚˜ì˜ ì •ìˆ˜ê°€ ì£¼ì–´ì ¸ìˆë‹¤. ì‚°ì„± ìš©ì•¡ì˜ íŠ¹ì„±ê°’ì€ 1ë¶€í„° 1,000,000,000ê¹Œì§€ì˜ ì–‘ì˜ ì •ìˆ˜ë¡œ ë‚˜íƒ€ë‚´ê³ , ì•Œì¹¼ë¦¬ì„± ìš©ì•¡ì˜ íŠ¹ì„±ê°’ì€ -1ë¶€í„° -1,000,000,000ê¹Œì§€ì˜ ìŒì˜ ì •ìˆ˜ë¡œ ë‚˜íƒ€ë‚¸ë‹¤.

ê°™ì€ ì–‘ì˜ ë‘ ìš©ì•¡ì„ í˜¼í•©í•œ ìš©ì•¡ì˜ íŠ¹ì„±ê°’ì€ í˜¼í•©ì— ì‚¬ìš©ëœ ê° ìš©ì•¡ì˜ íŠ¹ì„±ê°’ì˜ í•©ìœ¼ë¡œ ì •ì˜í•œë‹¤. ì´ ì—°êµ¬ì†Œì—ì„œëŠ” ê°™ì€ ì–‘ì˜ ë‘ ìš©ì•¡ì„ í˜¼í•©í•˜ì—¬ íŠ¹ì„±ê°’ì´ 0ì— ê°€ì¥ ê°€ê¹Œìš´ ìš©ì•¡ì„ ë§Œë“¤ë ¤ê³  í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, ì£¼ì–´ì§„ ìš©ì•¡ë“¤ì˜ íŠ¹ì„±ê°’ì´ [-2, 4, -99, -1, 98]ì¸ ê²½ìš°ì—ëŠ” íŠ¹ì„±ê°’ì´ -99ì¸ ìš©ì•¡ê³¼ íŠ¹ì„±ê°’ì´ 98ì¸ ìš©ì•¡ì„ í˜¼í•©í•˜ë©´ íŠ¹ì„±ê°’ì´ -1ì¸ ìš©ì•¡ì„ ë§Œë“¤ ìˆ˜ ìˆê³ , ì´ ìš©ì•¡ì´ íŠ¹ì„±ê°’ì´ 0ì— ê°€ì¥ ê°€ê¹Œìš´ ìš©ì•¡ì´ë‹¤. ì°¸ê³ ë¡œ, ë‘ ì¢…ë¥˜ì˜ ì•Œì¹¼ë¦¬ì„± ìš©ì•¡ë§Œìœ¼ë¡œë‚˜ í˜¹ì€ ë‘ ì¢…ë¥˜ì˜ ì‚°ì„± ìš©ì•¡ë§Œìœ¼ë¡œ íŠ¹ì„±ê°’ì´ 0ì— ê°€ì¥ ê°€ê¹Œìš´ í˜¼í•© ìš©ì•¡ì„ ë§Œë“œëŠ” ê²½ìš°ë„ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.

ì‚°ì„± ìš©ì•¡ê³¼ ì•Œì¹¼ë¦¬ì„± ìš©ì•¡ì˜ íŠ¹ì„±ê°’ì´ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ ì¤‘ ë‘ ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ ìš©ì•¡ì„ í˜¼í•©í•˜ì—¬ íŠ¹ì„±ê°’ì´ 0ì— ê°€ì¥ ê°€ê¹Œìš´ ìš©ì•¡ì„ ë§Œë“¤ì–´ë‚´ëŠ” ë‘ ìš©ì•¡ì„ ì°¾ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì§ì ‘ í’€ê¸°(30ë¶„) â†’ ì‹¤íŒ¨

```python
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ì´ ê²½ìš°ëŠ” ië¥¼ ê³ ì •ì‹œí‚¤ê³  jë¥¼ ì´ì§„íƒìƒ‰í•˜ë©´ ì•ˆ ë˜ë‚˜? ê·¸ë˜ë³´ì ì¼ë‹¨.
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys

n = int(sys.stdin.readline().strip())
arr = list(map(int, sys.stdin.readline().split()))

def bin_search(i: int, left, right):
    """arr[i] + arr[center]ì˜ ì ˆëŒ€ê°’ì„ ìµœì†Œë¡œ ë§Œë“¤ì–´ì£¼ëŠ” center ì¸ë±ìŠ¤ë¥¼ ë¦¬í„´"""
    center = (left+right)//2
    while left < right:
        combine = arr[center] + arr[i]
        if combine > 0:
            left, right = left, center
        elif combine < 0:
            left, right = center + 1, right
        else:
            return center
        center = (left+right)//2
    return center
        

def incremental_method(n: int, arr: list):
    arr.sort()
    zero_combine = sys.maxsize
    for i in range(0, len(arr)):
        j = bin_search(i, i+1, len(arr)-1)
        combine = abs(arr[i] + arr[j])
        print(f'combine: {combine}')
        # ì´ˆê¹ƒê°’ì€ ë§¤ìš° í° ì–‘ìˆ˜, ì»´ë°”ì¸ ê°’ë„ ì ˆëŒ€ê°’ì´ë¯€ë¡œ ê·¸ëƒ¥ ìµœì†Œë¥¼ ì—…ë°ì´íŠ¸
        if zero_combine >= combine:
            pair = (arr[i], arr[j])
        zero_combine = min(zero_combine, combine)
    return f'{pair[0]} {pair[1]}'

print(incremental_method(n, arr))
            


"""
ì´ìŠˆ: 5í”„ë¡œ ë§ê³  í‹€ë ¸ìŠµë‹ˆë‹¤
Phase1
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: í‹€ë ¸ìŠµë‹ˆë‹¤(5í”„ë¡œ ì •ë‹µ)
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„ íƒìƒ‰ ì½”ë“œ ì‘ì„±

Phase2
í™•ì¸: ì´ëŸ´ ë• ì—­ì‹œ ê²½ê³„ê°’ì„ ë‹¤ì‹œ ë³´ê³  ë¬¸ì œ ì¡°ê±´ì„ ë‹¤ì‹œ ì •ë¦¬.
ì‚°ì„± ìš©ì•¡ì€ 1ë¶€í„° 1,000,000,000ê¹Œì§€ ì–‘ì˜ ì •ìˆ˜
ì•Œì¹¼ë¦¬ ìš©ì•¡ì€ -1ë¶€í„° 1,000,000,000ê¹Œì§€ ìŒì˜ ì •ìˆ˜
ê°™ì€ ì–‘ì˜ ë‘ ìš©ì•¡ì„ í˜¼í•©í•˜ì—¬ íŠ¹ì„±ê°’ì´ 0ì— ê°€ê°€ìš´ ìš©ì•¡ ë§Œë“¤ê¸°
í‹€ë¦° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ ì°¾ì•˜ë‹¤.
5
-1 -1 -1 -1 4
-1 4

ë‹µì€ -1, -1ë¡œ -2ë¥¼ ë§Œë“œëŠ” 0, 1ì´ ë‚˜ì™€ì•¼ í•˜ëŠ”ë°, 
ë¡œì§ ë¬¸ì œê°€ ìˆëŠ”ì§€ -1, 4ê°€ ë‚˜ì˜¨ë‹¤.


ì‹œë„
ê²°ê³¼ë¶„ì„
"""
```

## Phase2. í”¼ë“œë°±

ì•„ë§ˆ ì´ë¶„ íƒìƒ‰ê³¼ ì¸ë±ìŠ¤ ê³ ì • ë°©ì‹ì„ í˜¼í•©í•˜ì—¬ ì‹œë„í•˜ì‹  ê²ƒ ê°™ì€ë°, ë‘ ìš©ì•¡ ë¬¸ì œì—ì„œëŠ” í¬ê²Œ ë‘ ê°€ì§€ ì „í˜•ì ì¸ í’€ì´ê°€ ì•Œë ¤ì ¸ ìˆìŠµë‹ˆë‹¤.

1. íˆ¬ í¬ì¸í„°(Two Pointers) ì•Œê³ ë¦¬ì¦˜ (ê¶Œì¥)

â€¢	ì•„ì´ë””ì–´

1.	ìš©ì•¡ë“¤ì˜ íŠ¹ì„±ê°’ ë°°ì—´ì„ ì •ë ¬í•œë‹¤.

2.	**ì™¼ìª½ í¬ì¸í„°(left)**ë¥¼ ì‹œì‘ ì¸ë±ìŠ¤(0)ì—, **ì˜¤ë¥¸ìª½ í¬ì¸í„°(right)**ë¥¼ ë ì¸ë±ìŠ¤(n-1)ì— ë‘”ë‹¤.

3.	ë‹¤ìŒ ê³¼ì •ì„ ë°˜ë³µí•˜ë©°, ë‘ í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ìš©ì•¡ì˜ í•©ì´ 0ì— ì–¼ë§ˆë‚˜ ê°€ê¹Œìš´ì§€ í™•ì¸í•œë‹¤.

â€¢	í˜„ì¬ ë‘ ìš©ì•¡ì˜ í•© sum = arr[left] + arr[right]

â€¢	|sum|ì´ ê¸°ì¡´ ìµœì†Ÿê°’ë³´ë‹¤ ì‘ìœ¼ë©´ ê°±ì‹  & ë‘ ìš©ì•¡ì„ ê¸°ë¡

â€¢	í•©ì´ 0ë³´ë‹¤ ì‘ë‹¤ë©´, ê°’ì„ í‚¤ìš°ê¸° ìœ„í•´ leftë¥¼ 1 ì¦ê°€

â€¢	í•©ì´ 0ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ë‹¤ë©´, ê°’ì„ ì¤„ì´ê¸° ìœ„í•´ rightë¥¼ 1 ê°ì†Œ

4.	left < rightì¸ ë™ì•ˆ ìœ„ ê³¼ì •ì„ ë°˜ë³µí•˜ì—¬, 0ì— ê°€ì¥ ê°€ê¹Œìš´ í•©ì„ ì°¾ëŠ”ë‹¤.

â€¢	ì‹œê°„ ë³µì¡ë„

â€¢	ì •ë ¬: O(N \log N)

â€¢	íˆ¬ í¬ì¸í„° íƒìƒ‰: O(N)

â€¢	ì´í•©: O(N \log N)

íˆ¬ í¬ì¸í„° ì½”ë“œ ì˜ˆì‹œ (Python)

â€¢	ì´ë ‡ê²Œ í•˜ë©´, ëª¨ë“  ê°€ëŠ¥í•œ i,j ìŒì„ ì§ì ‘ ë³´ì§€ ì•Šê³ ë„ O(N)ì— í•´ê²° ê°€ëŠ¥í•˜ë¯€ë¡œ íš¨ìœ¨ì ì…ë‹ˆë‹¤.

2. ëª¨ë“  ìŒ ì‹œë„(ì´ì¤‘ ë°˜ë³µ) + ìµœì†Œê°’ íƒìƒ‰ (ë‹¨ìˆœ ë°©ë²•)

â€¢	ì•„ì´ë””ì–´

â€¢	ë°°ì—´ì„ ì •ë ¬í•  í•„ìš” ì—†ì´, ëª¨ë“  (i, j) (ë‹¨, i < j)ì— ëŒ€í•´ arr[i] + arr[j]ë¥¼ ê³„ì‚°í•˜ê³ , ê·¸ ì ˆëŒ“ê°’ì´ ìµœì†Œê°€ ë˜ëŠ” ìŒì„ ì°¾ëŠ”ë‹¤.

â€¢	ì‹œê°„ ë³µì¡ë„: O(N^2)

â€¢	Nì´ í¬ë©´ ë¹„íš¨ìœ¨ì ì´ë¼, ë³´í†µ ì‹œê°„ ì œí•œì´ ë¹¡ë¹¡í•œ ê²½ìš°ì—ëŠ” í†µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

ì™œ ì´ë¶„ íƒìƒ‰ + í•œìª½ ì¸ë±ìŠ¤ ê³ ì •ìœ¼ë¡œëŠ” ê³¤ë€í• ê¹Œ?

ì§ˆë¬¸ ì½”ë“œì—ì„œëŠ”

â€¢	í•œìª½ ì¸ë±ìŠ¤ ië¥¼ ê³ ì •í•˜ê³ ,

â€¢	i+1 ~ n-1 ë²”ìœ„ì—ì„œ ì´ë¶„ íƒìƒ‰ìœ¼ë¡œ â€œarr[i]ì™€ ë”í–ˆì„ ë•Œ 0ì— ê°€ì¥ ê°€ê¹Œìš´ ê°’â€ì„ ì°¾ìœ¼ë ¤ ì‹œë„í•˜ì…¨ìŠµë‹ˆë‹¤.

ì´ ë°©ì‹ì€ ì´ë¡ ìƒ ê° ië§ˆë‹¤ ìµœì ì˜ jë¥¼ ì°¾ì„ ìˆ˜ ìˆì–´ ë³´ì´ì§€ë§Œ,

â€¢	ì‹¤ì œ êµ¬í˜„í•  ë•Œ ê²½ê³„ ì¡°ê±´ì´ë‚˜

â€¢	ì´ë¶„ íƒìƒ‰ìœ¼ë¡œ ì°¾ì€ j ë°”ë¡œ ì˜†ì— ìˆëŠ” j-1 í˜¹ì€ j+1ì—ì„œ ë” ì¢‹ì€ ë‹µì´ ìˆì„ ìˆ˜ ìˆìŒ(íŠ¹íˆ ê°€ê¹Œì´ ìˆëŠ” ì¸ë±ìŠ¤ë“¤ì´ ì—‡ê°ˆë¦¬ë©´ì„œ ë¯¸ì„¸ ì¡°ì •ì´ í•„ìš”)

ë“±ì˜ ì´ìœ ë¡œ ê¹Œë‹¤ë¡œìš´ ì ì´ ë§ìŠµë‹ˆë‹¤.

ì¦‰, ië³„ë¡œ ì´ë¶„ íƒìƒ‰ í•œ ë²ˆì”©ë§Œìœ¼ë¡œëŠ” ì „ì²´ êµ¬ê°„ì—ì„œì˜ ì „ì—­ ìµœì í•´ë¥¼ ë†“ì¹  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë°˜ë©´ì—, íˆ¬ í¬ì¸í„°ëŠ”

â€¢	ë°°ì—´ì„ ì •ë ¬í•œ ë’¤,

â€¢	ì–‘ìª½ ëì—ì„œ ì‹œì‘í•´ì„œ ìˆ˜ë¥¼ ë”í•˜ê³ ,

â€¢	í•©ì´ ìŒìˆ˜/ì–‘ìˆ˜ì¸ ê²½ìš°ì— ë§ì¶° í¬ì¸í„°ë¥¼ ì´ë™

í•¨ìœ¼ë¡œì¨ ì „ì—­ ìµœì ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì°¾ì•„ëƒ…ë‹ˆë‹¤.

ê²°ë¡ 

â€¢	ê°€ì¥ ê°„ë‹¨í•˜ê³  ì§ê´€ì ì¸ ë°©ë²•: íˆ¬ í¬ì¸í„°

â€¢	êµ¬í˜„ì´ ì–´ë µì§€ ì•Šê³ , ì‹œê°„ ë³µì¡ë„ë„ O(N \log N)ì´ë¼ì„œ ëŒ€ìš©ëŸ‰ ë°ì´í„°ì—ë„ ë¹ ë¥´ê²Œ ë™ì‘í•©ë‹ˆë‹¤.

â€¢	ì´ë¯¸ ë§ì´ ì•Œë ¤ì§„ â€œë‘ ìˆ˜ì˜ í•©(í˜¹ì€ íŠ¹ì • ê°’ì— ê°€ì¥ ê°€ê¹Œìš´ í•©)â€ ë¬¸ì œ íŒ¨í„´ì´ë‹ˆ, ì´ ë¡œì§ìœ¼ë¡œ êµ¬í˜„í•´ ë³´ì‹œë©´ ì‰½ê²Œ ì •ë‹µì„ ë„ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

í™”ì´íŒ…ì…ë‹ˆë‹¤!

## Phase3. í”¼ë“œë°± ì°¸ê³ í•´ì„œ 30ë¶„ ì‹œë„ - ì‹¤íŒ¨: ì¸ë±ìŠ¤ê°€ ë„ˆë¬´ ì•…ë„í•˜ë‹¤.

ì‹¤íŒ¨ ì‹œ ì½”ë“œ í•„ì‚¬ í˜•ë²Œ

ê·¼ë° ì´ ê²½ìš°ëŠ” ë‚´ í’€ì´ê°€ ì™„ì „ í‹€ë¦° ë°©í–¥ì€ ì•„ë‹Œ ê±° ê°™ì€ë°, ì§€í”¼í‹°ëŠ” ê·¸ëƒ¥ íˆ¬ í¬ì¸í„°ë¡œ í’€ë¼ê³  í•˜ëŠ” ê±°ì§€. ì´ì§„ íƒìƒ‰ìœ¼ë¡œ í•˜ë ¤ë©´ ê²½ê³„ì¡°ê±´ì´ ì¤‘ìš”í•´ì„œ ê·¸ë ‡ë‹¤ ì´ë§ì¸ ê±° ê°™ì€ë°.

```python
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ì´ ê²½ìš°ëŠ” ië¥¼ ê³ ì •ì‹œí‚¤ê³  jë¥¼ ì´ì§„íƒìƒ‰í•˜ë©´ ì•ˆ ë˜ë‚˜? ê·¸ë˜ë³´ì ì¼ë‹¨.
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys

n = int(sys.stdin.readline().strip())
arr = list(map(int, sys.stdin.readline().split()))

def bin_search(i: int, left, right):
    """arr[i] + arr[center]ì˜ ì ˆëŒ€ê°’ì„ ìµœì†Œë¡œ ë§Œë“¤ì–´ì£¼ëŠ” center ì¸ë±ìŠ¤ë¥¼ ë¦¬í„´"""
    center = (left+right)//2
    # print(f'\nbin_search start {left} {center} {right}')
    zero_combine = sys.maxsize
    best_center = None
    while left <= right:
        combine = arr[center] + arr[i]
        # print(f'{arr[center]} + {arr[i]} = {combine}')
        if combine > 0:
            right = center - 1
        elif combine < 0:
            left = center + 1
        else: # í˜¼í•© ê²°ê³¼ê°€ 0ì¸ ë² ìŠ¤íŠ¸ ì¼€ì´ìŠ¤
            return center
        if zero_combine > abs(combine):
            zero_combine = combine
            best_center = center
        center = (left+right)//2
        # print(f'combine: {combine}, to next segment {left} {center} {right}')
    # print(f'result: {best_center}')
    return best_center if best_center != None else None
        

def incremental_method(n: int, arr: list):
    arr.sort()
    zero_combine = sys.maxsize
    for i in range(0, len(arr)):
        
        j = bin_search(i=i, left=i+1, right=len(arr)-1)
        if j == None: continue
        combine = abs(arr[i] + arr[j])
        # print(f'combine: {combine}')
        # ì´ˆê¹ƒê°’ì€ ë§¤ìš° í° ì–‘ìˆ˜, ì»´ë°”ì¸ ê°’ë„ ì ˆëŒ€ê°’ì´ë¯€ë¡œ ê·¸ëƒ¥ ìµœì†Œë¥¼ ì—…ë°ì´íŠ¸
        if zero_combine >= combine:
            pair = (arr[i], arr[j])
            # print(f'zero_combine update: {arr[i], arr[j]}')
        zero_combine = min(zero_combine, combine)
    return f'{pair[0]} {pair[1]}'

print(incremental_method(n, arr))
            


"""
ì´ìŠˆ: 5í”„ë¡œ ë§ê³  í‹€ë ¸ìŠµë‹ˆë‹¤
Phase1
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: í‹€ë ¸ìŠµë‹ˆë‹¤(5í”„ë¡œ ì •ë‹µ)
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„ íƒìƒ‰ ì½”ë“œ ì‘ì„±

Phase2
í™•ì¸: ì´ëŸ´ ë• ì—­ì‹œ ê²½ê³„ê°’ì„ ë‹¤ì‹œ ë³´ê³  ë¬¸ì œ ì¡°ê±´ì„ ë‹¤ì‹œ ì •ë¦¬.
ì‚°ì„± ìš©ì•¡ì€ 1ë¶€í„° 1,000,000,000ê¹Œì§€ ì–‘ì˜ ì •ìˆ˜
ì•Œì¹¼ë¦¬ ìš©ì•¡ì€ -1ë¶€í„° 1,000,000,000ê¹Œì§€ ìŒì˜ ì •ìˆ˜
ê°™ì€ ì–‘ì˜ ë‘ ìš©ì•¡ì„ í˜¼í•©í•˜ì—¬ íŠ¹ì„±ê°’ì´ 0ì— ê°€ê°€ìš´ ìš©ì•¡ ë§Œë“¤ê¸°
í‹€ë¦° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ ì°¾ì•˜ë‹¤.
5
-1 -1 -1 -1 4
-1 4

ë‹µì€ -1, -1ë¡œ -2ë¥¼ ë§Œë“œëŠ” 0, 1ì´ ë‚˜ì™€ì•¼ í•˜ëŠ”ë°, 
ë¡œì§ ë¬¸ì œê°€ ìˆëŠ”ì§€ -1, 4ê°€ ë‚˜ì˜¨ë‹¤.

ì‹œë„: í‰ë²”í•œ ì´ì§„íƒìƒ‰ ì¸ë±ìŠ¤ë¡œ ì¬ì„¤ì •
ê²°ê³¼ë¶„ì„
"""

"""
ì´ìŠˆ: 1í”„ë¡œ ë§ê³  í‹€ë ¸ìŠµë‹ˆë‹¤.

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: 1í”„ë¡œ ì±„ì  í›„ í‹€ë ¸ìŠµë‹ˆë‹¤(ë‘ ê°€ì§€ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ëŠ” í†µê³¼í•¨ì„ í™•ì¸)
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„ íƒìƒ‰ ì¡°ê±´ ìˆ˜ì •
while left <= right:
    combine = arr[center] + arr[i]
    if combine > 0:
        left, right = left, center - 1
    elif combine < 0:
        left, right = center + 1, right
    else:
        return center
    center = (left+right)//2
return center


Phase2. 
í™•ì¸: ì¤‘ë³µ ê°’ì´ ë“¤ì–´ê°€ëŠ” ê²½ìš°ë¥¼ í™•ì¸. ì´ê±´ ì´ì§„ íƒìƒ‰ì—ì„œ ë¬¸ì œê°€ ìƒê¸°ëŠ” ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤.
5
1 2 3 4 5
1 1
ê·¼ë° ì´ì§„íƒìƒ‰ì„ ì´ë ‡ê²Œ í•˜ëŠ”ë° ê°™ì€ ì¸ë±ìŠ¤ê°€ ì–´ë–»ê²Œ ë˜ ë‚˜ì˜¤ì§€?
j = bin_search(i, left=i+1, right=len(arr)-1)

ì‹œë„: 
ë¶„ì„: 
"""

"""
ì´ìŠˆ: í‹€ë¦° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: 
5
1 2 3 4 5

bin_search start 1 2 4
combine: 4, to next segment 1 1 1
result: 2
zero_combine update: (1, 3)

bin_search start 2 3 4
combine: 6, to next segment 2 2 2
result: 3

bin_search start 3 3 4
combine: 7, to next segment 3 2 2
result: 3

bin_search start 4 4 4
result: 4

bin_search start 5 4 4
result: 4
1 3

ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì¸ë±ìŠ¤ ìˆ˜ì •.

Phase2.
í™•ì¸: ì•„ë‹ˆ ì§„ì§œ ì´ì§„ íƒìƒ‰ ì¡°ê±´ì„ ì–´ë–¡í•˜ë¼ëŠ” ê±°ì•¼.

ì‹œë„: 
ë¶„ì„: 
"""
```

## Phase4. í˜•ë²Œ: ì™¸ìš°ì‹­ì‡¼

ì™¸ìš¸ ë• ì—­ì‹œ ë³´ê³  ì“°ê³  ì•ˆ ë³´ê³  ì“°ê³  ì±„ì í•˜ê³  ë°˜ë³µì´ì§€.

### 1. í•„ì‚¬

```python
import sys
import bisect

def main():
    input = sys.stdin.readline
    n = int(input().strip())
    arr = list(map(int, input().split()))
    arr.sort()
    
    best_sum = 2_000_000_000 * 2  # ì¶©ë¶„íˆ í° ì´ˆê¸°ê°’
    best_pair = (0, 0)
    
    for i in range(n - 1):
        target = -arr[i]
        # i+1 ~ n-1 ë²”ìœ„ì—ì„œ targetì˜ ì‚½ì… ìœ„ì¹˜ë¥¼ ì°¾ìŒ
        j = bisect.bisect_left(arr, target, i + 1, n)
        
        # í›„ë³´: j (ì¡´ì¬í•˜ë©´)
        if j < n:
            current_sum = arr[i] + arr[j]
            if abs(current_sum) < best_sum:
                best_sum = abs(current_sum)
                best_pair = (arr[i], arr[j])
        # í›„ë³´: j-1 (i+1 ì´ìƒì´ë©´)
        if j - 1 > i:
            current_sum = arr[i] + arr[j - 1]
            if abs(current_sum) < best_sum:
                best_sum = abs(current_sum)
                best_pair = (arr[i], arr[j - 1])
    
    print(best_pair[0], best_pair[1])

if __name__ == '__main__':
    main()
```

(í•„ì‚¬ ì´ë¯¸ì§€ ì²¨ë¶€)

![](./images/IMG_0043.png)

![](./images/IMG_0044.png)

ì½”ë“œ ìì²´ê°€ ì´í•´ê°€ ì•ˆ ë˜ëŠ”ë°? ìˆ˜ë„ì½”ë“œë¡œ í•´ì•¼ í•˜ë‚˜? ì‚¬ì‹¤, ê·¸ëƒ¥ ì“°ê³  ì±„ì í•˜ë©´ì„œ ë‡Œì— ì±„ì°ì§ˆí•˜ë©´ ë°°ì›Œì§„ë‹¤.

### 2. ì™¸ì›Œì„œ ì“°ê³  ì±„ì 

(ì±„ì  ì´ë¯¸ì§€ ì²¨ë¶€)

![](./images/IMG_0046.png)

![](./images/IMG_0047.png)

ì§ˆë¬¸

- bisect.bisect_left(arr, target, i+1, n)ì´ ë¬´ìŠ¨ ì—­í• ì„ í•˜ëŠ” ê±°ì§€?
> ì¢‹ì€ ì§ˆë¬¸ì´ì—ìš”!

- ì•„í•˜, ê·¸ë˜ì„œ targetì„ -arr[i]ë¡œ ì„¤ì •í–ˆêµ¬ë‚˜. ì°¾ê³ ì í•˜ëŠ” ê°’ì´ arr[i] + target = 0ìœ¼ë¡œ ë§Œë“¤ì–´ì£¼ëŠ” Targetì´ê¸° ë•Œë¬¸ì—.
- bisect_rightëŠ” ê·¸ëŸ¼ ìµœì´ˆ ì‚½ì… ìœ„ì¹˜ê°€ ì•„ë‹ˆë¼ ìµœí›„ ì‚½ì… ìœ„ì¹˜ë¥¼ ëŒë ¤ì£¼ë‚˜?
> ì •í™•í•´ìš”! ğŸ‘

- bisect.bisect_left/rightì˜ ë¦¬í„´ ê°’ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ìˆ˜ëŠ” ì—†ë‹¤. íƒ€ê²Ÿ ìœ„ì¹˜ê°€ ë°°ì—´ ë‚´ì— ì—†ë‹¤ë©´ 0 ì•„ë‹ˆë©´ nì„ ë¦¬í„´í•˜ê¸° ë•Œë¬¸
> bisect_leftë‚˜ bisect_rightëŠ” â€œì‚½ì… ìœ„ì¹˜â€ë¥¼ í•­ìƒ ë°˜í™˜í•˜ê¸° ë•Œë¬¸ì—,

- ë‘ ë²ˆì§¸ ì§ˆë¬¸: ifë¬¸ì´ ì™œ ë‘ ê°œ ìˆëŠ” ê±°ì•¼.
> ì¢‹ì•„ìš”! ì•„ë˜ ì½”ë“œì˜ í•µì‹¬ì€ **â€œí•©ì´ 0ì— ê°€ì¥ ê°€ê¹Œìš´ ë‘ ìˆ˜ë¥¼ ì°¾ëŠ” ê²ƒâ€**ì…ë‹ˆë‹¤.

ê·¸ëŸ¬ë‹ˆê¹Œ ì´ê²Œ, ë‘ ë²ˆì§¸ ì¡°ê±´ì´ ìˆì–´ì•¼ ë¯¸ì‹±í•œ ê²ƒë“¤ì„ ì¡ì„ ìˆ˜ ìˆë‹¤.(ì‚¬ì‹¤ ì•„ì§ë„ í™•ê³ í•˜ê²Œ ì´í•´ë˜ì§€ëŠ” ì•ŠëŠ”ë‹¤.) ì™œ ì´ì§„ íƒìƒ‰ì„ í•˜ëŠ”ë° ë†“ì¹˜ëŠ” ê²½ìš°ê°€ ë°œìƒí•˜ëŠ” ê±°ì§€?

> ì¢‹ì•„ìš”. ì´ ì§ˆë¬¸ ì •ë§ ì˜ í•´ì£¼ì…¨ì–´ìš”.

- ì´ì§„ íƒìƒ‰ í›„ ë¯¸ì„¸ ì¡°ì •ì˜ íŒì„ ì•Œë ¤ì¤˜
> ì¢‹ì•„ìš”, ì´ì§„ íƒìƒ‰ í›„ â€œë¯¸ì„¸ ì¡°ì •â€ì€ ì‹¤ì „ ì½”ë”© ë¬¸ì œì—ì„œ ìì£¼ ë‚˜ì˜¤ëŠ” í•µì‹¬ í…Œí¬ë‹‰ì…ë‹ˆë‹¤.

### 3. 2íŠ¸

![](./images/IMG_0048.png)

![](./images/IMG_0049.png)

(ì–¼ì¶” ë§ëŠ” ê±° ê°™ìŠµë‹ˆë‹¤. ì§ˆë¬¸ë§Œ ì •ë¦¬í•˜ê³  ì½”ë”©ìœ¼ë¡œ ë„˜ì–´ê°€ì„œ ë””ë²„ê¹… í•˜ì„¸ìš”.)

ì •ë¦¬í•˜ë©´ì„œ ìƒê¸´ ì§ˆë¬¸

- ì™œ iì˜ iteration ë²”ìœ„ê°€ n-1 ê¹Œì§€ì¸ê°€ìš”?
  - ë§ˆì§€ë§‰ì— i == n-1ì´ ë˜ë©´, i+1, n ìœ¼ë¡œ bisect í•˜ê²Œ ë˜ì–´ n, nì„ íƒìƒ‰í•˜ê²Œ ë¨.
- ì™œ ë‘ ë²ˆì§¸ ì¡°ê±´ë¬¸ì—ì„œ j-1ì´ iì™€ ê°™ì„ ìˆ˜ë„ ìˆëŠ” ìƒí™©ì„ ë°©ì§€í•´ì•¼ í•˜ëŠ” ê±´ê°€ìš”?
  - ì•„ j ë²”ìœ„ê°€ ì• ì´ˆì— bisect í•  ë•Œ i+1 â‰¤ j < nì´ë¼ì„œ ê·¸ë ‡êµ¬ë‚˜
> ì •ë¦¬í•˜ëŠ” ì™€ì¤‘ì— ìƒê¸´ ì§ˆë¬¸ì´ ë”± í•µì‹¬ì„ ì°Œë¥´ê³  ìˆì–´ìš”! í•˜ë‚˜ì”© ì •í™•í•˜ê²Œ ì„¤ëª…ë“œë¦´ê²Œìš”. ğŸ‘‡

- ê²°êµ­ current_sumì— ì ˆëŒ“ê°’ ì”Œìš°ì§€ ì•Šì€ ë¶€ë¶„ ë””ë²„ê¹… ì‹¤íŒ¨. ë””ë²„ê¹…ì´ ë„ˆë¬´ë„ˆë¬´ë„ˆë¬´ë„ˆë¬´ ì–´ë µë‹¤.
> ì´ì§„ íƒìƒ‰ì€ ê¹”ë”í•œ ì•Œê³ ë¦¬ì¦˜ì¸ë°, ë””ë²„ê¹…ì€ ë”ëŸ½ìŠµë‹ˆë‹¤.

# ë¬¸ì œ: ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´, (ì‹¤íŒ¨, ë‹¤ì‹œ í’€ê¸°)

https://www.acmicpc.net/problem/11053

ìˆ˜ì—´ Aê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ”Â ë¶€ë¶„Â ìˆ˜ì—´ì„ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

ì˜ˆë¥¼ ë“¤ì–´, ìˆ˜ì—´ A = {10, 20, 10, 30, 20, 50} ì¸ ê²½ìš°ì— ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„Â ìˆ˜ì—´ì€Â A = {10,Â 20, 10,Â 30, 20,Â 50} ì´ê³ , ê¸¸ì´ëŠ” 4ì´ë‹¤.

## Phase1. ì‹¤íŒ¨

```python
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ëŠë‚Œìƒ ìˆ˜ì—´ì˜ ê¸¸ì´ë¥¼ xë¡œ ì¡ê³  ì´ì§„íƒìƒ‰ ë•Œë¦¬ë©´ ë  ê±° ê°™ê¸°ë„ í•˜ê³ ?
ìµœëŒ€ ê¸¸ì´ê°€ xì¸ ìˆ˜ì—´ì´ ì¡´ì¬í•˜ëŠ”ê°€? 
- ì—†ìœ¼ë©´ ê¸¸ì´ xë¥¼ ì¤„ì„
- ìˆìœ¼ë©´ ê¸¸ì´ xë¥¼ ëŠ˜ì„
Aì—ì„œ ê¸¸ì´ xì˜ ìˆ˜ì—´ì„ êµ¬í•˜ëŠ” ë°©ë²•: ë°±íŠ¸ë˜í‚¹ ì¡°í•©?
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""
import sys
n = int(sys.stdin.readline().strip())
arr =  tuple(map(int, sys.stdin.readline().split()))

def get_list(current_array: list, goal_len: int, idx: int):
    global arr
    """
    ë°°ì—´ (global) arrì—ì„œ ê¸¸ì´ê°€ goal_lenì¸ ìˆ˜ì—´ì„ ì¬ê·€ì ìœ¼ë¡œ êµ¬í•˜ëŠ” í•¨ìˆ˜
    idx: í˜„ì¬ê¹Œì§€ Aì—ì„œ ê³ ë ¤í•œ ì¸ë±ìŠ¤. 
    idxë¥¼ í¬í•¨í•˜ëŠ” ê²½ìš°ë¥¼ ë„˜ê¸°ê±°ë‚˜, í¬í•¨í•˜ì§€ ì•ŠëŠ” ê²½ìš°ë¥¼ ë„˜ê¸´ë‹¤.
    ìµœì¢… ëª©ì : goal_len ê¸¸ì´ì˜ ë¶€ë¶„ìˆ˜ì—´ì„ ì „ì²´ ìˆ˜ì—´ arrì—ì„œ êµ¬í•  ìˆ˜ ìˆëŠ”ê°€?
    """
    # base case
    if len(current_array) == goal_len:
        # print('base hit')
        return True
    # ë§Œì•½ ì¸ë±ìŠ¤ê°€ ëë‚¬ìœ¼ë©´?
    if len(arr) == idx:
        return 
    # recursion case
    if len(current_array) == 0 or current_array[-1] < arr[idx]: # í˜„ì¬ ë¶€ë¶„ ìˆ˜ì—´ì˜ ë§ˆì§€ë§‰ ê°’ì´ idxë³´ë‹¤ ì‘ë‹¤ë©´
        return get_list([*current_array, arr[idx]], goal_len, idx+1)
    else: #í˜„ì¬ ë¶€ë¶„ìˆ˜ì—´ì˜ ë§ˆì§€ë§‰ ê°’ì´ idxë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì•„ì„œ í¬í•¨ì‹œí‚¬ ìˆ˜ ì—†ë‹¤ë©´ ê·¸ëŒ€ë¡œ ë„˜ê¹€
        return get_list(current_array, goal_len, idx+1)

max_len = -sys.maxsize

def get_max_array(left: int, right: int):
    global max_len
    center = (left+right)//2
    while left < right: 
        if get_list([], center, 0):
            # ë§Œì•½ center ê¸¸ì´ì˜ ë¶€ë¶„ ìˆ˜ì—´ì´ ì¡´ì¬í•œë‹¤ë©´!
            # ì¼ë‹¨ ì €ì¥!
            max_len = max(max_len, center)
            # ê·¸ë¦¬ê³  ì¡´ì¬í•œë‹¤ê³  í•˜ë‹ˆ, ì´ì œ ë” ë³¼ë“œí•œ íŠ¸ë¼ì´ë¥¼ í•´ ë³´ëŠ”ê±°ì§€
            left = center + 1
        else: # center ê¸¸ì´ì˜ ë¶€ë¶„ ìˆ˜ì—´ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´!
            # ë” ì†Œì‹¬í•˜ê²Œ ì‹œë„
            right = center - 1
        
        center = (left+right)//2 # center ì—…ë°ì´íŠ¸

get_max_array(0, 1000)
print(max_len)
```

28ë¶„ë§Œì— ì´ë§Œí¼ êµ¬í˜„í–ˆë‹¤! ê±°ì˜ ë‹¤ ëœ ê±° ê°™ì€ë°!

```python
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ëŠë‚Œìƒ ìˆ˜ì—´ì˜ ê¸¸ì´ë¥¼ xë¡œ ì¡ê³  ì´ì§„íƒìƒ‰ ë•Œë¦¬ë©´ ë  ê±° ê°™ê¸°ë„ í•˜ê³ ?
ìµœëŒ€ ê¸¸ì´ê°€ xì¸ ìˆ˜ì—´ì´ ì¡´ì¬í•˜ëŠ”ê°€? 
- ì—†ìœ¼ë©´ ê¸¸ì´ xë¥¼ ì¤„ì„
- ìˆìœ¼ë©´ ê¸¸ì´ xë¥¼ ëŠ˜ì„
Aì—ì„œ ê¸¸ì´ xì˜ ìˆ˜ì—´ì„ êµ¬í•˜ëŠ” ë°©ë²•: ë°±íŠ¸ë˜í‚¹ ì¡°í•©?
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""
import sys
n = int(sys.stdin.readline().strip())
arr =  list(map(int, sys.stdin.readline().split()))
max_len = 1

def get_list(current_array: list, goal_len: int, idx: int):
    global arr, max_len
    """
    ë°°ì—´ (global) arrì—ì„œ ê¸¸ì´ê°€ goal_lenì¸ ìˆ˜ì—´ì„ ì¬ê·€ì ìœ¼ë¡œ êµ¬í•˜ëŠ” í•¨ìˆ˜
    idx: í˜„ì¬ê¹Œì§€ Aì—ì„œ ê³ ë ¤í•œ ì¸ë±ìŠ¤. 
    idxë¥¼ í¬í•¨í•˜ëŠ” ê²½ìš°ë¥¼ ë„˜ê¸°ê±°ë‚˜, í¬í•¨í•˜ì§€ ì•ŠëŠ” ê²½ìš°ë¥¼ ë„˜ê¸´ë‹¤.
    ìµœì¢… ëª©ì : goal_len ê¸¸ì´ì˜ ë¶€ë¶„ìˆ˜ì—´ì„ ì „ì²´ ìˆ˜ì—´ arrì—ì„œ êµ¬í•  ìˆ˜ ìˆëŠ”ê°€?
    """
    # base case
    if len(current_array) == goal_len:
        # print(f'base hit {current_array}') # ì „ì—­ max_len ì—…ë°ì´íŠ¸
        max_len = max(goal_len, max_len)
        return 
    # ë§Œì•½ ì¸ë±ìŠ¤ê°€ ëë‚¬ìœ¼ë©´?
    if len(arr) == idx:
        return 
    # recursion case
    # print(f'getting in to recursion. ?? {current_array} <- {arr[idx]}')
    if len(current_array) == 0 or current_array[-1] < arr[idx]: # í˜„ì¬ ë¶€ë¶„ ìˆ˜ì—´ì˜ ë§ˆì§€ë§‰ ê°’ì´ idxë³´ë‹¤ ì‘ë‹¤ë©´
        get_list([*current_array, arr[idx]], goal_len, idx+1)
        get_list(current_array, goal_len, idx+1)


def get_max_array(left: int, right: int):
    global max_len
    center = (left+right)//2
    while left < right: 
        current_max_len = max_len
        get_list([], center, 0) #ì´ê²Œ ì „ì—­ ë³€ìˆ˜ max_lenì„ ì—…ë°ì´íŠ¸
        # print(f'goal now {center}')
        if current_max_len != max_len:
            # ë§Œì•½ center ê¸¸ì´ì˜ ë¶€ë¶„ ìˆ˜ì—´ì´ ì¡´ì¬í•œë‹¤ë©´!
            # ì¼ë‹¨ ì €ì¥! -> ì´ê±¸ ì „ì—­ì—ì„œ ë°”ë¡œ êµ¬í•œë‹¤ìŒ ì²˜ë¦¬
            # max_len = max(max_len, center)
            # print('update!')
            # ê·¸ë¦¬ê³  ì¡´ì¬í•œë‹¤ê³  í•˜ë‹ˆ, ì´ì œ ë” ë³¼ë“œí•œ íŠ¸ë¼ì´ë¥¼ í•´ ë³´ëŠ”ê±°ì§€
            # print('try bold!!'*10)
            left = center + 1
        else: # center ê¸¸ì´ì˜ ë¶€ë¶„ ìˆ˜ì—´ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´!
            # ë” ì†Œì‹¬í•˜ê²Œ ì‹œë„
            # print('not found'*10)
            right = center
        
        center = (left+right)//2 # center ì—…ë°ì´íŠ¸

get_max_array(0, 1000)
print(max_len)

"""
ì´ìŠˆ: í‹€ë ¸ìŠµë‹ˆë‹¤.
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: í‹€ë ¸ìŠµë‹ˆë‹¤
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„ ê²€ìƒ‰ìœ¼ë¡œ ë‹µ êµ¬í•˜ëŠ” í•¨ìˆ˜ êµ¬í˜„
Phase2.
í™•ì¸: ë¬¸ì œ ì¡°ê±´ í™•ì¸
ìˆ˜ì—´ì˜ í¬ê¸°ëŠ” 1 ì´ìƒ 1000 ì´í•˜
ìˆ˜ì—´ë¡œ ì˜¬ ìˆ˜ ìˆëŠ” ê°’ì€ 1 ì´ìƒ 1000 ì´í•˜
ì‹œë„: ê²½ê³„ê°’
1. ìˆ˜ì—´ì˜ í¬ê¸°ê°€ 1ì¸ ê²½ìš°
2. ìˆ˜ì—´ì˜ í¬ê¸°ê°€ ì „ë¶€ ê°™ì€ ê²½ìš°
3. ìˆ˜ì—´ì˜ í¬ê¸°ê°€ ê°ìˆ˜í•˜ëŠ” ê²½ìš°
4. ìˆ˜ì—´ì˜ í¬ê¸°ê°€ ê°ì†Œí•˜ë‹¤ê°€ ì¦ê°€í•˜ëŠ” ê²½ìš° <- ì°¾ì•˜ë‹¤.
ìì„¸í•œ ë¡œê·¸
5
5 4 3 4 5
getting in to recursion. ?? [] <- 5
getting in to recursion. ?? [5] <- 4
getting in to recursion. ?? [5] <- 3
getting in to recursion. ?? [5] <- 4
getting in to recursion. ?? [5] <- 5
getting in to recursion. ?? [] <- 5
getting in to recursion. ?? [5] <- 4
getting in to recursion. ?? [5] <- 3
ê·¸ëƒ¥ ê°™ê±°ë‚˜ í¬ì§€ë§Œ ì•Šìœ¼ë©´ ì¬ê·€ë¥¼ í•˜ë©´ ë¨! í˜¹ì€ noneì´ê±°ë‚˜. 
ê·¸ëŸ¼ ë‹¤ìŒ ì§ˆë¬¸! ì¬ê·€ë¥¼ í•´ì„œ ê°’ì´ ì—…ë°ì´íŠ¸ ë˜ë©´ ë­˜ ì–´ë–¡í•˜ë©´ ë¨? 
ì¬ê·€ ìŠ¤íƒ ëì— ê°’ì„ ë¦¬í„´ ì‹œí‚¤ëŠ” ë°©ë²•ì„ ëª¨ë¥´ë‹ˆ, ê·¸ëƒ¥ ì „ì—­ ë³€ìˆ˜ë¥¼ í”Œë˜ê·¸ë¡œ ì¨ì•¼í•  ê±° ê°™ìŒ.
ê²°ê³¼ ë¶„ì„: ê³„ì† ì˜¤ë‹µ
"""
```

ë””ë²„ê¹… ì‹¤íŒ¨

## Phase2. í”¼ë“œë°±

ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´(LIS: Longest Increasing Subsequence) ë¬¸ì œëŠ” ì´ë¯¸ ì˜ ì•Œë ¤ì§„ ëŒ€í‘œì ì¸ DP(ë™ì  í”„ë¡œê·¸ë˜ë°) ë˜ëŠ” ì´ë¶„ íƒìƒ‰ ê¸°ë²• ë¬¸ì œì…ë‹ˆë‹¤.

ì£¼ì–´ì§„ ì½”ë“œë¥¼ ë³´ë©´, â€œë¶€ë¶„ìˆ˜ì—´ì˜ ê¸¸ì´ë¥¼ ì´ë¶„ íƒìƒ‰ìœ¼ë¡œ ê°€ì •í•œ ë’¤, ì¡´ì¬ ì—¬ë¶€ë¥¼ ì¬ê·€ì ìœ¼ë¡œ í™•ì¸â€í•˜ëŠ” ë°©ì‹ì„ ì‹œë„í•˜ê³  ê³„ì‹ ë°, ì´ ì ‘ê·¼ì€ êµ¬í˜„ì´ ë§¤ìš° ê¹Œë‹¤ë¡­ê³  ë¹„íš¨ìœ¨ì ì¼ ê°€ëŠ¥ì„±ì´ í½ë‹ˆë‹¤.

> í•µì‹¬ ìš”ì•½

> 1.	O(N^2)

> 2.	O(N \log N)

ì•„ë˜ ë‘ ê°€ì§€ ì •ì„ í’€ì´ ë°©ì‹ì„ ì†Œê°œí•˜ê² ìŠµë‹ˆë‹¤.

1. O(N^2) ë™ì  í”„ë¡œê·¸ë˜ë°(DP) í’€ì´

ì•Œê³ ë¦¬ì¦˜ ì•„ì´ë””ì–´

1.	ê¸¸ì´ Nì˜ ìˆ˜ì—´ Aê°€ ìˆì„ ë•Œ, dp[i]ë¥¼ **â€œA[i]ë¥¼ ë§ˆì§€ë§‰ ì›ì†Œë¡œ ê°€ì§€ëŠ” ì¦ê°€ ë¶€ë¶„ ìˆ˜ì—´ì˜ ìµœëŒ“ê¸¸ì´â€**ë¼ê³  ì •ì˜í•©ë‹ˆë‹¤.

2.	ì´ˆê¸°ê°’ìœ¼ë¡œ ëª¨ë“  dp[i] = 1 (ìê¸° ìì‹ ë§Œìœ¼ë¡œ ê¸¸ì´ 1ì¸ ë¶€ë¶„ìˆ˜ì—´ì„ ë§Œë“¤ ìˆ˜ ìˆìœ¼ë¯€ë¡œ).

3.	ë‘ ë²ˆì§¸ ì›ì†Œ(i=1)ë¶€í„° ì‹œì‘í•´ì„œ, ì´ì „ ì›ì†Œ(j)ë“¤ê³¼ ë¹„êµí•©ë‹ˆë‹¤.

â€¢	ë§Œì•½ A[j] < A[i]ë¼ë©´,

dp[i] = \max(dp[i], dp[j] + 1) \quad (0 \le j < i)

â€¢	ì´ëŠ”, â€œA[i]â€ê°€ â€œA[j]â€ ë’¤ì— ì˜¬ ìˆ˜ ìˆì„ ê²½ìš°, â€œA[j]ë¥¼ ëìœ¼ë¡œ í•˜ëŠ” ì¦ê°€ë¶€ë¶„ìˆ˜ì—´ ê¸¸ì´ + 1â€ë¡œ ê°±ì‹  ê°€ëŠ¥í•˜ë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.

4.	ëª¨ë“  iì— ëŒ€í•´ ìœ„ ê³„ì‚°ì„ ìˆ˜í–‰í•œ ë’¤, max(dp)ê°€ ê³§ â€œê°€ì¥ ê¸´ ì¦ê°€ ë¶€ë¶„ ìˆ˜ì—´ì˜ ê¸¸ì´â€ê°€ ë©ë‹ˆë‹¤.

ì˜ˆì‹œ ì½”ë“œ (Python)

```plain text
import sys
input = sys.stdin.readline

N = int(input().strip())
A = list(map(int, input().split()))

dp = [1] * N  # dp[i]: A[i]ë¥¼ ë§ˆì§€ë§‰ìœ¼ë¡œ í•˜ëŠ” ì¦ê°€ë¶€ë¶„ìˆ˜ì—´ì˜ ìµœëŒ“ê¸¸ì´

for i in range(1, N):
    for j in range(i):
        if A[j] < A[i]:
            dp[i] = max(dp[i], dp[j] + 1)

print(max(dp))
```

â€¢	ì‹œê°„ ë³µì¡ë„: O(N^2)

â€¢	ê³µê°„ ë³µì¡ë„: O(N)

Nì´ ìµœëŒ€ 1,000 ì •ë„ë¼ë©´, O(N^2) = 1,000^2 = 10^6 ì—°ì‚°ì´ë¯€ë¡œ ì¶©ë¶„íˆ ë¹ ë¥´ê²Œ í†µê³¼í•©ë‹ˆë‹¤.

2. O(N \log N) ì´ë¶„ íƒìƒ‰(BS) í’€ì´

ì•Œê³ ë¦¬ì¦˜ ì•„ì´ë””ì–´ (ê¸¸ì´ë§Œ êµ¬í•˜ëŠ” ê²½ìš°)

1.	**ê²°ê³¼ë¥¼ ì €ì¥í•  ë°°ì—´(temp)**ì„ í•˜ë‚˜ ë‘¡ë‹ˆë‹¤. ì´ˆê¸°ì—ëŠ” ë¹„ì–´ìˆìŒ.

2.	ìˆ˜ì—´ Aë¥¼ ì™¼ìª½ë¶€í„° ì˜¤ë¥¸ìª½ìœ¼ë¡œ ìˆœíšŒí•˜ë©° ê° ì›ì†Œ xë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

3.	temp ë°°ì—´ì—ì„œ ì´ë¶„ íƒìƒ‰ì„ ì´ìš©í•´ â€œxê°€ ì‚½ì…ë  ìœ„ì¹˜â€(idx)ë¥¼ ì°¾ìŠµë‹ˆë‹¤.

â€¢	tempê°€ ì˜¤ë¦„ì°¨ìˆœì„ ìœ ì§€í•˜ë„ë¡, xë¥¼ ì‚½ì…í•  ìœ„ì¹˜ëŠ”

â€œtemp[idx - 1] < x <= temp[idx]ë¥¼ ë§Œì¡±í•˜ëŠ” ê°€ì¥ ì‘ì€ idxâ€ ì…ë‹ˆë‹¤.

4.	ë§Œì•½ xê°€ temp ë°°ì—´ì—ì„œ ê°€ì¥ í° ê°’ë³´ë‹¤ í¬ë‹¤ë©´, ê·¸ëƒ¥ temp ë’¤ì— ë¶™ì…ë‹ˆë‹¤.

5.	ê·¸ë ‡ì§€ ì•Šë‹¤ë©´, ì´ë¶„ íƒìƒ‰ìœ¼ë¡œ ì°¾ì€ ìœ„ì¹˜ idxì— xë¥¼ ë®ì–´ì”ë‹ˆë‹¤. â†’ ë®ì–´ ì“°ëŠ”ê²Œ í•µì‹¬ì´êµ¬ë‚˜. ì™œ ë®ì–´ì¨ë„ ê´œì°®ì€ ê±°ì§€? ìˆ˜ì—´ì˜ ìˆœì„œê°€ ë°”ë€ŒëŠ” ê±° ì•„ë‹Œê°€?

6.	ìµœì¢…ì ìœ¼ë¡œ temp ê¸¸ì´ê°€ ê³§ â€œLIS(ê°€ì¥ ê¸´ ì¦ê°€ ë¶€ë¶„ ìˆ˜ì—´)ì˜ ê¸¸ì´â€ê°€ ë©ë‹ˆë‹¤.

ì˜ˆì‹œ ì½”ë“œ (Python)

â€¢	ì´ë ‡ê²Œ í•˜ë©´, tempì—ëŠ” ì‹¤ì œ LISê°€ ì™„ë²½íˆ ì €ì¥ë˜ì§€ ì•Šì„ ìˆ˜ ìˆì§€ë§Œ(â€œê¸¸ì´ë§Œâ€ ë§ìŒ), tempì˜ ê¸¸ì´ê°€ ê³§ LISì˜ ê¸¸ì´ê°€ ë©ë‹ˆë‹¤. â†’ ì´ê²Œ ì´í•´ê°€ ì•ˆ ë¨.

â€¢	ì‹œê°„ ë³µì¡ë„: O(N \log N). ìµœëŒ€ 1,000 ì •ë„ë¼ë©´ í›¨ì”¬ ë¹ ë¥´ê²Œ ë™ì‘í•©ë‹ˆë‹¤.

> ì¶”ê°€ í™•ì¥

ê²°ë¡  & ì¶”ì²œ

â€¢	ë¬¸ì œì—ì„œ ê¸¸ì´ë§Œ ìš”êµ¬í•œë‹¤ë©´, ìœ„ì— ì†Œê°œí•œ DP O(N^2) ë˜ëŠ” ì´ë¶„ íƒìƒ‰ O(N \log N) ë°©ì‹ì„ ì‚¬ìš©í•˜ì‹œë©´ ë©ë‹ˆë‹¤.

â€¢	Nì´ ìµœëŒ€ 1,000 ì •ë„ì´ë©´, **O(N^2)**ë„ ì¶©ë¶„íˆ ë¹ ë¦…ë‹ˆë‹¤. ê°€ì¥ êµ¬í˜„ì´ ê°„ë‹¨í•˜ë¯€ë¡œ DPë¥¼ ì¶”ì²œë“œë¦½ë‹ˆë‹¤.

â€¢	Nì´ ë” ì»¤ì§ˆ ìˆ˜ ìˆëŠ” ìƒí™©ì´ë¼ë©´(ì˜ˆ: N ìˆ˜ë§Œ~ìˆ˜ì‹­ë§Œ), ì´ë¶„ íƒìƒ‰ ë°©ì‹ì´ ìœ ë¦¬í•©ë‹ˆë‹¤.

í˜„ì¬ ì ‘ê·¼ì²˜ëŸ¼ â€œë¶€ë¶„ìˆ˜ì—´ ê¸¸ì´ë¥¼ ì´ì§„ íƒìƒ‰í•˜ë©´ì„œ, ë§¤ë²ˆ ì¬ê·€ë¡œ í™•ì¸â€í•˜ëŠ” ê²ƒì€

â€¢	êµ¬í˜„ ë‚œì´ë„ê°€ ë†’ê³ ,

â€¢	ì¤‘ë³µ ê³„ì‚°ì´ ë§ê³ ,

â€¢	ë””ë²„ê¹…ì´ ë³µì¡

í•˜ë¯€ë¡œ ì‹¤ì „ì—ì„œ ë¹„ì¶”ë˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

ì°¨ë¼ë¦¬ ì „í˜•ì ì¸ DP(ê¸¸ì´ O(N^2))ë‚˜ ì´ë¶„ íƒìƒ‰(ê¸¸ì´ O(N \log N))ë¡œ í•´ê²°í•˜ì‹œëŠ” ê²ƒì´ í›¨ì”¬ ì‰½ê³  ë¹ ë¦…ë‹ˆë‹¤.

ë„ì›€ì´ ë˜ê¸¸ ë°”ëë‹ˆë‹¤. í™”ì´íŒ…ì…ë‹ˆë‹¤!

## Phase3. í”¼ë“œë°± í›„ ë‹¤ì‹œ í’€ì–´ë³´ê¸°-ì„±ê³µ. ê·¼ë° ì´ì§„ íƒìƒ‰ ë¬¸ì œì˜ ê³µí†µì ì„ ë„ì €íˆ ëª¨ë¥´ê² ìŒ. 

êµ¬ì² ì´ ì½”ë“œ ì¢€ ë´ì•¼ê² ë‹¤.

```python
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
3. ìˆ˜ë„ ì½”ë“œ
ìš”ì†Œë¥¼ ì´í„°ë ˆì´ì…˜í•˜ë©´ì„œ, tempì—ì„œ ìš”ì†Œê°€ ë“¤ì–´ê°ˆ ìµœì  ìœ„ì¹˜ë¥¼ ì°¾ì•„ì„œ, ë°°ì—´ ì•ˆì— ì¡´ì¬í•˜ë©´ 
ë®ì–´ ì¨ë²„ë¦¬ê³ , ë°–ì— ì¡´ì¬í•˜ë©´ ë°°ì—´ì„ ëŠ˜ì—¬ì„œ LISë¥¼ êµ¬í•  ìˆ˜ ìˆìŒ.
4. ì½”ë“œ êµ¬í˜„
"""
import sys, bisect

input = sys.stdin.readline
n = int(input().strip())
arr = tuple(map(int, input().split()))

tmp = [arr[0]]

for x in arr:
    # print(f'iterating: {x}')
    i = bisect.bisect_left(tmp, x, 0, len(tmp))
    # print(f'{i} = bisect.bisect_left({tmp}, {x}, 0, {len(tmp)})')
    if i == len(tmp):
        # print(f'tmp.append({x})')
        tmp.append(x)
    else:
        # print(f'{tmp[i]} = {x}')
        tmp[i] = x

# print(tmp)
print(len(tmp))
```



# ìŠ¤íƒ: ë§‰ëŒ€ê¸°

https://www.acmicpc.net/problem/17608

ì•„ë˜ ê·¸ë¦¼ì²˜ëŸ¼ ë†’ì´ë§Œ ë‹¤ë¥´ê³  (ê°™ì€ ë†’ì´ì˜ ë§‰ëŒ€ê¸°ê°€ ìˆì„ ìˆ˜ ìˆìŒ) ëª¨ì–‘ì´ ê°™ì€ ë§‰ëŒ€ê¸°ë¥¼ ì¼ë ¬ë¡œ ì„¸ìš´ í›„, ì™¼ìª½ë¶€í„° ì°¨ë¡€ë¡œ ë²ˆí˜¸ë¥¼ ë¶™ì¸ë‹¤. ê° ë§‰ëŒ€ê¸°ì˜ ë†’ì´ëŠ” ê·¸ë¦¼ì—ì„œ ë³´ì¸ ê²ƒì²˜ëŸ¼ ìˆœì„œëŒ€ë¡œ 6, 9, 7, 6, 4, 6 ì´ë‹¤. ì¼ë ¬ë¡œ ì„¸ì›Œì§„ ë§‰ëŒ€ê¸°ë¥¼ ì˜¤ë¥¸ìª½ì—ì„œ ë³´ë©´ ë³´ì´ëŠ” ë§‰ëŒ€ê¸°ê°€ ìˆê³  ë³´ì´ì§€ ì•ŠëŠ” ë§‰ëŒ€ê¸°ê°€ ìˆë‹¤. ì¦‰, ì§€ê¸ˆ ë³´ì´ëŠ” ë§‰ëŒ€ê¸°ë³´ë‹¤ ë’¤ì— ìˆê³  ë†’ì´ê°€ ë†’ì€ ê²ƒì´ ë³´ì´ê²Œ ëœë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ê·¸ë¦¼ê³¼ ê°™ì€ ê²½ìš°ì—” 3ê°œ(6ë²ˆ, 3ë²ˆ, 2ë²ˆ)ì˜ ë§‰ëŒ€ê¸°ê°€ ë³´ì¸ë‹¤.

Nê°œì˜ ë§‰ëŒ€ê¸°ì— ëŒ€í•œ ë†’ì´ ì •ë³´ê°€ ì£¼ì–´ì§ˆ ë•Œ, ì˜¤ë¥¸ìª½ì—ì„œ ë³´ì•„ì„œ ëª‡ ê°œê°€ ë³´ì´ëŠ”ì§€ë¥¼ ì•Œì•„ë‚´ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ë ¤ê³  í•œë‹¤.

## Phase1. 15ë¶„, í•´ê²°.

```python
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ì°¨ë¡€ëŒ€ë¡œ ë§‰ëŒ€ê¸° í‘¸ì‹œí•˜ë‹¤ê°€ íƒ‘ë³´ë‹¤ í°ê²Œ ì˜¤ë©´ íŒí•˜ê³  í‘¸ì‹œí•˜ë©´ ë˜ê² ë‹¤.
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

class Stack:
    def __init__(self, size):
        self.stack = [0] * size
        self.ptr = 0

    class Empty(Exception):
        def __init__(self, message="Stack is empty"):
            self.message= message
            super().__init__(self.message)

    class Full(Exception):
        def __init__(self, message="Stack is full"):
            self.message = message
            super().__init__(self.message)

    def is_empty(self):
        return self.ptr == 0
    
    def is_full(self):
        return self.ptr == self.size

    def __str__(self):
        return f'{self.stack[:self.ptr]}'
    
    def clear(self):
        self.ptr = 0

    def peek(self):
        if self.is_empty(): raise Stack.Empty
        return self.stack[self.ptr-1]
    
    def push(self, n):
        if self.is_full(): raise Stack.Full
        self.stack[self.ptr] = n
        self.ptr += 1

    def pop(self):
        if self.is_empty(): raise Stack.Empty
        tmp = self.stack[self.ptr-1] 
        self.ptr -= 1
        return tmp
    
    def size(self):
        return self.ptr
    
import sys

stack = Stack(100_000)
n = int(sys.stdin.readline().strip())
for _ in range(n):
    stick = int(sys.stdin.readline().strip())
    # print(f'stack empty? {stack.is_empty()}')
    while not stack.is_empty() and stack.peek() <= stick:
        stack.pop() # ë½‘ì•„ë²„ë¦¬ê³ 
    stack.push(stick) # í‘¸ì‹œ
    # print(stack)


print(stack.size())
```

# ë¶„í• ì •ë³µ: ê³±ì…ˆ

https://www.acmicpc.net/problem/1629

ìì—°ìˆ˜ Aë¥¼ Bë²ˆ ê³±í•œ ìˆ˜ë¥¼ ì•Œê³  ì‹¶ë‹¤. ë‹¨ êµ¬í•˜ë ¤ëŠ” ìˆ˜ê°€ ë§¤ìš° ì»¤ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì´ë¥¼ Cë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ê³ ë¯¼ë§Œ í•˜ë‹¤ê°€ ì‹¤íŒ¨í•˜ê¸´ ì•„ê¹Œìš°ë‹ˆ ê³ ë¯¼ì˜ í”ì ì´ í•„ìš”. ì–´ì¨Œë“  ì‹¤íŒ¨.

í™”ì´íŠ¸ë³´ë“œì— ê³ ë¯¼í•˜ê³  ì‚¬ì§„ ì˜¬ë¦¬ì„¸ìš”. 30ë¶„ë™ì•ˆ.

![](./images/IMG_0453.png)

## Phase2.

ì•„ë§ˆ ë¬¸ì œë¥¼ ì½ë‹¤ê°€ **â€œAë¥¼ Bë²ˆ ê³±í•œ ë’¤ Cë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€â€**ë¥¼ ì§ì ‘ ê³„ì‚°í•˜ë©´ ìˆ˜ê°€ ë„ˆë¬´ ì»¤ì§ˆ ìˆ˜ ìˆìŒì„ ì¸ì§€í•˜ì…¨ì„ ê²ë‹ˆë‹¤.

ì´ ë¬¸ì œëŠ” í”íˆ ì•Œë ¤ì§„ â€œê±°ë“­ì œê³±ì„ ë¶„í•  ì •ë³µìœ¼ë¡œ ë¹ ë¥´ê²Œ ê³„ì‚° (Exponentiation by Squaring)â€ ê¸°ë²•ì„ ì‚¬ìš©í•˜ë©´ ì‰½ê²Œ í•´ê²° ê°€ëŠ¥í•©ë‹ˆë‹¤.

1. ë¬¸ì œ ìš”ì•½

â€¢	A^B (ì¦‰, Aë¥¼ Bë²ˆ ê³±í•œ ìˆ˜) ë¥¼ ì§ì ‘ êµ¬í•˜ë©´ ë§¤ìš° í´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ë”°ë¼ì„œ ì¤‘ê°„ ê³„ì‚° ê³¼ì •ì—ì„œë„ ê³„ì† mod C ì—°ì‚°ì„ ì ìš©í•´ ì¤„ í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.

â€¢	ì „í˜•ì ì¸ ë°©ë²•: ë¶„í•  ì •ë³µ(ì¬ê·€) í˜¹ì€ ë°˜ë³µë¬¸ì„ ì´ìš©í•œ ê±°ë“­ì œê³± ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

2. ë¶„í•  ì •ë³µì„ ì´ìš©í•œ ê±°ë“­ì œê³± ì•„ì´ë””ì–´

ê±°ë“­ì œê³± A^Bë¥¼ ê³„ì‚°í•  ë•Œ,

1.	Bê°€ ì§ìˆ˜:

$$
A^B = A^{B/2} \times A^{B/2}
$$

2.	Bê°€ í™€ìˆ˜:

$$
A^B = A \times A^{B-1}
$$

(í˜¹ì€ A^B = A^{(B-1)/2} \times A^{(B-1)/2} \times A)

ì¦‰, ì§€ìˆ˜ë¥¼ ì ˆë°˜ì”© ì¤„ì—¬ê°€ë©´ì„œ ê³„ì‚°í•˜ë˜, ë§¤ ë‹¨ê³„ì—ì„œ ê²°ê³¼ë¥¼ mod Cë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.

ì´ ê³¼ì •ì„ ì¬ê·€ í˜¹ì€ ë°˜ë³µë¬¸ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

3. íŒŒì´ì¬ ì½”ë“œ ì˜ˆì‹œ (ì¬ê·€)

ì„¤ëª…

â€¢	mod_pow(a, b, c) í•¨ìˆ˜ê°€ ì¬ê·€ì ìœ¼ë¡œ bë¥¼ ë°˜ì”© ì¤„ì—¬ê°€ë©° a^bë¥¼ êµ¬í•©ë‹ˆë‹¤.

â€¢	ë§¤ ê³±ì…ˆë§ˆë‹¤ % cë¥¼ ì·¨í•´ ì¤Œìœ¼ë¡œì¨, ìˆ˜ê°€ ì»¤ì§€ëŠ” ê²ƒì„ ë°©ì§€í•©ë‹ˆë‹¤.

4. íŒŒì´ì¬ ì½”ë“œ ì˜ˆì‹œ (ë°˜ë³µë¬¸)

ì¬ê·€ ì—†ì´ ë°˜ë³µë¬¸ìœ¼ë¡œë„ ë¶„í•  ì •ë³µ í˜•íƒœë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ (ì´ ë°©ì‹ë„ ë§¤ìš° ì§ê´€ì ì…ë‹ˆë‹¤).

ì„¤ëª…

â€¢	ì§€ìˆ˜ bê°€ í™€ìˆ˜ì´ë©´, í˜„ì¬ baseë¥¼ resultì— ê³±í•´ì£¼ê³ , ì§€ìˆ˜ë¥¼ í•˜ë‚˜ ì¤„ì…ë‹ˆë‹¤ (b -= 1).

â€¢	ê·¸ ë’¤, baseë¥¼ ì œê³±(base = base * base)í•˜ê³  bë¥¼ ì ˆë°˜(b //= 2)ìœ¼ë¡œ ì¤„ì—¬ë‚˜ê°‘ë‹ˆë‹¤.

â€¢	ë§ˆì°¬ê°€ì§€ë¡œ ë§¤ ì—°ì‚°ë§ˆë‹¤ % cë¥¼ í•˜ì—¬ ì¤‘ê°„ ê²°ê³¼ê°€ ë„ˆë¬´ ì»¤ì§€ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤.

5. ì‹œê°„ ë³µì¡ë„

â€¢	ë¶„í•  ì •ë³µ ë°©ì‹ìœ¼ë¡œ ê±°ë“­ì œê³±ì„ ê³„ì‚°í•˜ë©´, ì§€ìˆ˜ Bì— ëŒ€í•´ O(\log B) ì‹œê°„ ì•ˆì— ê³„ì‚°ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

â€¢	ë¬¸ì œì˜ ì…ë ¥ ë²”ìœ„ì—ì„œ Bê°€ ë§¤ìš° ì»¤ë„, \log B ë‹¨ê³„ë§Œ ê±°ì¹˜ë¯€ë¡œ íš¨ìœ¨ì ìœ¼ë¡œ í’€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì •ë¦¬

1.	ì§ì ‘ A^Bë¥¼ êµ¬í•œ ë’¤ ëª¨ë“ˆë¡œë¥¼ ì·¨í•˜ë©´ ìˆ˜ê°€ ë„ˆë¬´ ì»¤ì„œ ê³„ì‚° ë¶ˆê°€ëŠ¥ or ë¹„íš¨ìœ¨ì .

2.	ë¶„í•  ì •ë³µì„ í†µí•´ ë§¤ ì¤‘ê°„ ë‹¨ê³„ë§ˆë‹¤ mod Cë¥¼ ì ìš©í•´ì„œ ì²˜ë¦¬í•´ì•¼ í•¨.

3.	êµ¬í˜„ì€ ë‘ ê°€ì§€ ë°©ë²•:

â€¢	ì¬ê·€(ë°˜ë°˜ì”© ì¤„ì´ë©´ì„œ)

â€¢	ë°˜ë³µë¬¸(ì§€ìˆ˜ë¥¼ 2ë¡œ ë‚˜ëˆ„ë©° ë¹„íŠ¸ ë¶„í• )

4.	ì‹œê°„ ë³µì¡ë„ëŠ” O(\log B).

ì´ ë¡œì§ëŒ€ë¡œ ì½”ë“œë¥¼ ì§§ê²Œ êµ¬í˜„í•˜ë©´ ë°”ë¡œ ì •ë‹µì„ ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë¶„í•  ì •ë³µ ê±°ë“­ì œê³±ì€ ë‹¤ì–‘í•œ ë¬¸ì œì—ì„œ ìœ ìš©í•˜ë‹ˆ, í•œ ë²ˆ ìµí˜€ ë‘ì‹œë©´ ì¢‹ìŠµë‹ˆë‹¤.

í™”ì´íŒ…ì…ë‹ˆë‹¤!

## Phase3. í”¼ë“œë°± í›„ ì¬ë„ì „-ì‹¤íŒ¨

(ì‹¤íŒ¨ ì‹œ ì½”ë“œ ì™¸ìš°ê¸°)

```python
"""
1. ë¬¸ì œ ì½ê¸°
ì´í•´ ìì²´ëŠ” ì–´ë µì§€ ì•ŠìŒ.
2. ë¬¸ì œ í’€ê¸°
ë¶„í• ì •ë³µì˜ ë°©ë²•ë¡ ì„ ìœ ë„í•  ê²ƒ. 
Phase1. ìœ ë„(ìœ ì‚¬í•œ ë¬¸ì œ ë– ì˜¬ë ¤ë³´ê¸°)
- ìƒ‰ì¢…ì´? Zë¬¸ì œ?: 2^n ê¸¸ì´ì˜ ì •ì‚¬ê°í˜•ì„ ë‹¤ë£¨ëŠ” ë¬¸ì œë“¤ê³¼ëŠ”, ì§ì‚¬ê°í˜•ì„ ë‹¤ë£¬ë‹¤ëŠ” ì ì—ì„œ ì¢€ ë‹¤ë¦„
ì£¼ì–´ì§€ëŠ” ë°ì´í„°ë„ ì„ í˜•. nì˜ ë²”ìœ„ê°€ 100,000ìœ¼ë¡œ ë§ì§€ëŠ” ì•Šì€ë°, ì£¼ì–´ì§€ëŠ” ì •ìˆ˜ê°€ ìœ„ ë¬¸ì œë³´ë‹¤ í¼
- ë³‘í•© ì •ë ¬: ì‚¬ì‹¤ ê·¼ë³¸ì ìœ¼ë¡œ ë¹„ìŠ·í•˜ê² ì§€? ì–´ë–»ê²Œ ë¹„ìŠ·í•˜ë ¤ë‚˜. 
base case: ì‚¬ê°í˜•ì„ ë‚˜ëˆ„ë‹¤ê°€ ë‘ ê°œê°€ ë‚¨ì•„ì„œ, ìƒìˆ˜ ì‹œê°„ ì•ˆì— ë¬¸ì œ í•´ê²°ì´ ê°€ëŠ¥í•œ ì‹œì 
recursion case: ì£¼ì–´ì§„ íˆìŠ¤í† ê·¸ë¨ ë¶€ë¶„ì— ëŒ€í•´ ì–‘ìª½ íˆìŠ¤í† ê·¸ë¨ì—ì„œ êµ¬í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ì‚¬ê°í˜•
ì´ê±´ ë‹¹ì—°íˆ, ì–‘ìª½ì˜ ì‚¬ê°í˜• í¬ê¸°ë¥¼ ë¹„êµí–ˆì„ ë•Œ ìµœì†Œ ì‚¬ê°í˜• ê°’ì„ ë¦¬í„´í•´ì•¼ í•œë‹¤. 
ì¢…ì´ì— ë¨¼ì € í’€ì–´ë³´ì‹œê¸¸. ë‚´ê°€ ë´¤ì„ ë• ë³‘í•©ì •ë ¬í•˜ê³  ë˜ê²Œ ë¹„ìŠ·í•¨
Phase2. ë¬¸ì œ ì •ì˜
- ê¸°ë³¸ ë¬¸ì œ: ì „ì²´ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°
- ë¶€ë¬¸ì œ: ë¶€ë¶„ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°
- ë² ì´ìŠ¤ ì¼€ì´ìŠ¤: ë‘ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°: ë¬´ì¡°ê±´ ë‘ ì§ì‚¬ê°í˜•ì„ í•©ì¹  í•„ìš”ëŠ” ì—†ìŒ!
Phase3. ì–´ë””ì„œ ë§‰í˜”ëŠ”ê°€? 
ë¶„í•  ì •ë³µì—ì„œ ì •ë³µ, ë³‘í•© ë‹¨ê³„ë¥¼ ì–´ë–»ê²Œ í•´ì•¼í• ì§€ ëª¨ë¥´ê² ìŒ.

3. ìˆ˜ë„ ì½”ë“œ
1) ë‹µì„ ì •ì˜
Bê°€ ì§ìˆ˜ë©´
A^B = A^B//2 * A^B//2
Bê°€ í™€ìˆ˜ë©´
A^B = A^B//2 * A^B//2+1
ì´ë ‡ê²Œ ë¶„í• ë¶„í•  í•´ì„œ Bê°’ì´ 1ì¼ë•Œ ëª¨ë“œ ì—°ì‚°í•˜ê³  combine.
4. ì½”ë“œ êµ¬í˜„
"""
import sys
input = sys.stdin.readline
A, B, C = tuple(map(int, input().split()))

def recur(a: int, b: int, c: int):
    if b == 1:
        return a%c
    if b%2 == 0: # bê°€ ì§ìˆ˜
        first = recur(a, b//2, c)%c
        second = recur(a, b//2, c)%c
        return (first*second)%c
    else:
        first = recur(a, b//2, c)%c
        second = recur(a, b//2+1, c)%c
        return (first*second)%c
    
from collections import deque

def loop(a: int, b: int, c: int):
    tmp = 1
    for i in range(b):
        a = a%c
        tmp *= a
        tmp %= c
    return tmp
            

print(loop(A, B, C))

"""
ì´ìŠˆ: ì‹œê°„ ì´ˆê³¼ ë°œìƒ

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì‹œê°„ì´ˆê³¼
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì¬ê·€ì ìœ¼ë¡œ ê³±ì…ˆê³¼ ëª¨ë“ˆëŸ¬ ì—°ì‚° í•¨ìˆ˜ êµ¬í•¨.

Phase2.
í™•ì¸: ë°˜ë³µë¬¸ìœ¼ë¡œ ë°”ê¿”ì•¼ í•˜ë‚˜?
ì‹œë„: 
def loop(a: int, b: int, c: int):
    tmp = 1
    for i in range(b):
        a = a%c
        tmp *= a
        tmp %= c
    return tmp
            
ì•„ë˜ì™€ ê°™ì´ êµ¬í˜„. ê·¸ë˜ë„ ì‹œê°„ ì´ˆê³¼ ë°œìƒ.
ë¶„ì„: ì‹¤íŒ¨.
ëª¨ë¥´ê² ë‹¤.
"""
```

## Phase4. ì½”ë“œ ì™¸ìš°ê¸°(ë°˜ë³µë¬¸, ì¬ê·€ ë‘˜ ë‹¤)

### ì˜ˆì¬

```python
import sys
input = sys.stdin.readline

A, B, C = map(int, input().split())

def power(a, b):
    if b == 1:
        return a % C
    temp = power(a, b // 2)
    if b % 2 == 0:
        return (temp * temp) % C
    else:
        return (temp * temp * a) % C

print(power(A, B))
```

```python
def loop_power(a, b, c):
    result = 1
    a %= c
    while b > 0:
        if b % 2 == 1:
            result = (result * a) % c
        a = (a * a) % c
        b //= 2
    return result

print(loop_power(A, B, C))
```

### 0. í•„ì‚¬

(ê·¸ë¦¼: ì¬ê·€ í’€ì´)

![](./images/IMG_0050.png)

- ì´ ì½”ë“œê°€ ì™œ ë³µì¡ë„ ì¸¡ë©´ì—ì„œ Phase3ë³´ë‹¤ ë‚˜ì€ê°€? 
  - ë‚´ ì½”ë“œëŠ” power()í•¨ìˆ˜ë¥¼ ë‘ ë²ˆì´ë‚˜ í˜¸ì¶œí•˜ê³  ìˆìŒ. ê° íŒ¨ìŠ¤ì˜ ë³µì¡ë„ê°€ ë‘ ë°°ì¼ê²ƒ. ì´ê²ƒì— ëŒ€í•œ ë§ˆìŠ¤í„° ì •ë¦¬ í•´ë³´ì‹œê¸¸.
(ê·¸ë¦¼: ë°˜ë³µë¬¸ í’€ì´)

![](./images/IMG_0052.png)

### 1.ì‹œë„ ë° ì±„ì 

(ê·¸ë¦¼: ì¬ê·€ í’€ì´)

![](./images/IMG_0051.png)

(ê·¸ë¦¼: ë°˜ë³µë¬¸ í’€ì´)

![](./images/IMG_0053.png)

### 2. ì½”ë”©í•˜ê¸°

```python
import sys
input = sys.stdin.readline
A, B, C = tuple(map(int, input().split()))

def power(a: int, b: int):
    # print(f'a: {a}, b: {b}. so {a}^{b}')
    if b == 1: return a%C
    # print(f'get temp: power({a}, {b//2})%{C}', end=' ')
    temp = power(a, b//2)%C
    # print(f'temp = {temp}')

    if b%2 == 0: 
        # print(f'b is even. ({temp}*{temp})%{C}')
        return (temp*temp)%C
    else:
        # print(f'b is odd. {temp}*{temp}*{a} % {C} = {(temp*temp*a)%C}') 
        return (temp*temp*a)%C

print(power(A, B))

"""
ì´ìŠˆ: í‹€ë ¸ìŠµë‹ˆë‹¤.

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì°ì–´ë³´ì„¸ìš”
ìµœê·¼ ë³€ê²½ ì‚¬í•­: power êµ¬í˜„

Phase2.
í™•ì¸: 
10 11 12
a: 10, b: 11. so 10^11
get temp: power(10, 5)%12 a: 10, b: 5. so 10^5
get temp: power(10, 2)%12 a: 10, b: 2. so 10^2
get temp: power(10, 1)%12 a: 10, b: 1. so 10^1
temp = 10
b is even. (10*10)%12
temp = 4
b is odd. 4*4*10 % 12 = 4
temp = 4
b is odd. 4*4*10 % 12 = 4
4

ì‹œë„: ë¡œê·¸í•˜ê³ ëŠ” ë³„ ìƒê´€ ì—†ì—ˆëŠ”ë°, base caseì—ì„œ b==0ìœ¼ë¡œ ë¼ ìˆì—ˆìŒ.
ë¶„ì„: ì„±ê³µ.
ê·¸ëŸ°ë° ì™œ b==0ì´ë©´ ì•ˆ ë˜ê³  b==1ì´ë©´ ë˜ëŠ” ê±°ì§€? ì§ì „ ì¬ê·€ì—ì„œ bê°€ ì§ìˆ˜ë©´ 1ì¼ ê±°ê³ , í™€ìˆ˜ë©´
0ì´ê² ì§€. ì™œ í™€ìˆ˜ì—ì„œ ë¶„ê¸°í•œ ì¬ê·€ëŠ” ê³ ë ¤í•˜ì§€ ì•Šì•„ë„ ë˜ëŠ” ê±°ì§€? ë‚©ë“ì´ ì•ˆ ë¨.(í˜¼ì í˜ìœ¼ë¡œ ìƒê°í•´ë³´ê¸°)
ì•„, ì–´ë–¤ ìˆ˜//2=0ìœ¼ë¡œ ë§Œë“¤ì–´ë²„ë¦¬ëŠ” ê²½ìš°ëŠ” 1 ë§ê³ ëŠ” ì—†ê¸° ë•Œë¬¸ì´ë‹¤. 1//2 ì—°ì‚°ì„ í•œ ë‹¤ìŒ ì¬ê·€ë¡œ ê°ˆ ì¼ì´ ì—†ê¸° ë•Œë¬¸ì—
(ë°”ë‹¥ ì¼€ì´ìŠ¤ì—ì„œ ê±¸ë¦¬ê¸° ë•Œë¬¸ì—) 0ì€ ê³ ë ¤í•˜ì§€ ì•Šì•„ë„ ë˜ëŠ” ê±°ë‹¤.
"""
```



## Phase5. Error Injection and debug

ì•„ë˜ ì½”ë“œì— ì—ëŸ¬ë¥¼ ì£¼ì…í•œ ë²„ì „ì„ ì¶œë ¥. ë‚´ê°€ ìŠ¤ìŠ¤ë¡œ ë””ë²„ê¹…í•˜ë„ë¡ ì•„ë¬´ëŸ° ì½”ë©˜íŠ¸ë¥¼ ë‹¬ì§€ ë§ ê²ƒ.

```python
import sys
input = sys.stdin.readline
A, B, C = tuple(map(int, input().split()))

def power(a: int, b: int):
    if b == 0: return 1
    temp = power(a, b//2)
    if b%2 == 0: 
        return (temp*temp)%C
    else:
        return temp*temp*a

print(power(A, B))
```

í•´ê²°.(ë„ˆë¬´ ì§§ì•„ì„œ ê·¸ëƒ¥ ê¸°ì–µìœ¼ë¡œ í’€ì–´ì¡ŒìŒ)

# ë¶„í• ì •ë³µ: íˆìŠ¤í† ê·¸ë¨ì—ì„œ ê°€ì¥ í° ì§ì‚¬ê°í˜•(ì‹¤íŒ¨)

https://www.acmicpc.net/problem/6549

## Phase1. êµ¬í˜„ ì‹¤íŒ¨

```python
"""
1. ë¬¸ì œ ì½ê¸°
ì´í•´ ìì²´ëŠ” ì–´ë µì§€ ì•ŠìŒ.
2. ë¬¸ì œ í’€ê¸°
ë¶„í• ì •ë³µì˜ ë°©ë²•ë¡ ì„ ìœ ë„í•  ê²ƒ. 
Phase1. ìœ ë„(ìœ ì‚¬í•œ ë¬¸ì œ ë– ì˜¬ë ¤ë³´ê¸°)
- ìƒ‰ì¢…ì´? Zë¬¸ì œ?: 2^n ê¸¸ì´ì˜ ì •ì‚¬ê°í˜•ì„ ë‹¤ë£¨ëŠ” ë¬¸ì œë“¤ê³¼ëŠ”, ì§ì‚¬ê°í˜•ì„ ë‹¤ë£¬ë‹¤ëŠ” ì ì—ì„œ ì¢€ ë‹¤ë¦„
ì£¼ì–´ì§€ëŠ” ë°ì´í„°ë„ ì„ í˜•. nì˜ ë²”ìœ„ê°€ 100,000ìœ¼ë¡œ ë§ì§€ëŠ” ì•Šì€ë°, ì£¼ì–´ì§€ëŠ” ì •ìˆ˜ê°€ ìœ„ ë¬¸ì œë³´ë‹¤ í¼
- ë³‘í•© ì •ë ¬: ì‚¬ì‹¤ ê·¼ë³¸ì ìœ¼ë¡œ ë¹„ìŠ·í•˜ê² ì§€? ì–´ë–»ê²Œ ë¹„ìŠ·í•˜ë ¤ë‚˜. 
base case: ì‚¬ê°í˜•ì„ ë‚˜ëˆ„ë‹¤ê°€ ë‘ ê°œê°€ ë‚¨ì•„ì„œ, ìƒìˆ˜ ì‹œê°„ ì•ˆì— ë¬¸ì œ í•´ê²°ì´ ê°€ëŠ¥í•œ ì‹œì 
recursion case: ì£¼ì–´ì§„ íˆìŠ¤í† ê·¸ë¨ ë¶€ë¶„ì— ëŒ€í•´ ì–‘ìª½ íˆìŠ¤í† ê·¸ë¨ì—ì„œ êµ¬í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ì‚¬ê°í˜•
ì´ê±´ ë‹¹ì—°íˆ, ì–‘ìª½ì˜ ì‚¬ê°í˜• í¬ê¸°ë¥¼ ë¹„êµí–ˆì„ ë•Œ ìµœì†Œ ì‚¬ê°í˜• ê°’ì„ ë¦¬í„´í•´ì•¼ í•œë‹¤. 
ì¢…ì´ì— ë¨¼ì € í’€ì–´ë³´ì‹œê¸¸. ë‚´ê°€ ë´¤ì„ ë• ë³‘í•©ì •ë ¬í•˜ê³  ë˜ê²Œ ë¹„ìŠ·í•¨
Phase2. ë¬¸ì œ ì •ì˜
- ê¸°ë³¸ ë¬¸ì œ: ì „ì²´ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°
- ë¶€ë¬¸ì œ: ë¶€ë¶„ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°
- ë² ì´ìŠ¤ ì¼€ì´ìŠ¤: ë‘ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°: ë¬´ì¡°ê±´ ë‘ ì§ì‚¬ê°í˜•ì„ í•©ì¹  í•„ìš”ëŠ” ì—†ìŒ!
Phase3. ì–´ë””ì„œ ë§‰í˜”ëŠ”ê°€? 
ë¶„í•  ì •ë³µì—ì„œ ì •ë³µ, ë³‘í•© ë‹¨ê³„ë¥¼ ì–´ë–»ê²Œ í•´ì•¼í• ì§€ ëª¨ë¥´ê² ìŒ.

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

```

### ì ‘ë§‰

ì ‘ê·¼ ë°©ë²•: ë³‘í•©ì •ë ¬

ë§‰íŒ ì´ìœ : ë¬¸ì œ ì •ì˜ ì‹¤íŒ¨. ì •ë³µ, ë³‘í•© ë‹¨ê³„ë¥¼ ì–´ë–»ê²Œ í•´ì•¼í• ì§€ ëª¨ë¥´ê² ìŒ.

## Phase2. í”¼ë“œë°±

ì´ ë¬¸ì œ **â€œíˆìŠ¤í† ê·¸ë¨ì—ì„œ ê°€ì¥ í° ì§ì‚¬ê°í˜•â€**ì€ ì•Œê³ ë¦¬ì¦˜ êµìœ¡ì—ì„œ ë§¤ìš° ìì£¼ ë“±ì¥í•˜ëŠ” ê³ ì „ ë¬¸ì œë¡œ, ì„¸ ê°€ì§€ ëŒ€í‘œ í’€ì´ê°€ ì¡´ì¬í•©ë‹ˆë‹¤.

1.	ë¶„í•  ì •ë³µ(Divide and Conquer) : O(N \log N)

2.	ì„ í˜• ìŠ¤íƒ(ëª¨ë…¸í† ë‹‰ ìŠ¤íƒ) : O(N)

3.	ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ : O(N \log N)

ì¶œì œ ì˜ë„ê°€ â€œë¶„í• ì •ë³µâ€ì´ë¼ë©´ 1ë²ˆ í˜¹ì€ 3ë²ˆ(ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬)ìœ¼ë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆì§€ë§Œ,

ì‹¤ë¬´ë‚˜ ëŒ€íšŒì—ì„œëŠ” ë³´í†µ 2ë²ˆ(ìŠ¤íƒ) ë°©ì‹ì´ ê°€ì¥ ê°„ë‹¨í•˜ë©´ì„œ ë¹ ë¥´ë‹¤ëŠ” íŠ¹ì§•ì´ ìˆìŠµë‹ˆë‹¤.

ì•„ë˜ì—ì„œëŠ” ë¶„í•  ì •ë³µìœ¼ë¡œ í•´ê²°í•˜ëŠ” ë°©ë²•ê³¼, ì‹¤ì œë¡œ ë” ìì£¼ ì“°ì´ëŠ” ìŠ¤íƒ í’€ì´ë¥¼ ëª¨ë‘ ê°„ë‹¨íˆ ì†Œê°œí•´ ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

1. ë¶„í•  ì •ë³µ(Divide & Conquer) í’€ì´

1.1 ì•Œê³ ë¦¬ì¦˜ ì•„ì´ë””ì–´

ê¸¸ì´ Nì˜ íˆìŠ¤í† ê·¸ë¨ ë†’ì´ ë°°ì—´ì„ H[0..N-1]ë¼ í•©ì‹œë‹¤.

ë¶„í•  ì •ë³µ ì ‘ê·¼ ì‹œ, ë‹¤ìŒê³¼ ê°™ì´ ì„¸ ê°€ì§€ ê²½ìš°ë¥¼ ê³ ë ¤í•©ë‹ˆë‹¤.

1.	ì™¼ìª½ êµ¬ê°„ì—ì„œì˜ ìµœëŒ€ ì§ì‚¬ê°í˜•

â€¢	(êµ¬ê°„ left ~ midë¡œ ì œí•œí•˜ì—¬, ì¬ê·€ì ìœ¼ë¡œ êµ¬í•¨)

2.	ì˜¤ë¥¸ìª½ êµ¬ê°„ì—ì„œì˜ ìµœëŒ€ ì§ì‚¬ê°í˜•

â€¢	(êµ¬ê°„ mid+1 ~ rightë¡œ ì œí•œí•˜ì—¬, ì¬ê·€ì ìœ¼ë¡œ êµ¬í•¨)

3.	ê°€ìš´ë°(mid)ë¥¼ ê±¸ì¹˜ëŠ” ì§ì‚¬ê°í˜•ì—ì„œì˜ ìµœëŒ€ ë„“ì´

â€¢	(ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ì‚¬ì´ ê²½ê³„ì—ì„œ ì‹œì‘í•´, ì–‘ì˜†ìœ¼ë¡œ í™•ì¥í•´ê°€ë©° ê°€ëŠ¥í•œ ìµœëŒ€ ì§ì‚¬ê°í˜•ì„ ì°¾ìŒ)

ì´ë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•´, ë³´í†µ ì¬ê·€ í•¨ìˆ˜ get_max_area(left, right)ë¥¼ ë‘ê³ ,

1.	ì¢…ë£Œ ì¡°ê±´(Base case): left == right â†’ ë§‰ëŒ€ê°€ í•˜ë‚˜ë¿ì´ë¯€ë¡œ ë„“ì´ëŠ” H[left] (í­=1, ë†’ì´=H[left])

2.	ë¶„í• : mid = (left + right) // 2

â€¢	ì™¼ìª½ ìµœëŒ€ ë„“ì´: left_area = get_max_area(left, mid)

â€¢	ì˜¤ë¥¸ìª½ ìµœëŒ€ ë„“ì´: right_area = get_max_area(mid+1, right)

3.	ì •ë³µ(ê°€ìš´ë° ê±¸ì¹˜ëŠ” ë„“ì´ ê³„ì‚°)

â€¢	ë¨¼ì € midì™€ mid+1 ë‘ ìœ„ì¹˜ë¥¼ í¬í•¨í•˜ëŠ” â€œí­=2, ë†’ì´=min(H[mid], H[mid+1])â€ ì§ì‚¬ê°í˜•ì—ì„œ ì‹œì‘í•´,

â€¢	ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë²”ìœ„ë¥¼ í™•ì¥í•˜ë©´ì„œ, ê°€ëŠ¥í•œ í•œ ë†’ì´ê°€ í° ìƒíƒœë¥¼ ìœ ì§€í•´ ìµœëŒ€ í­ì„ ëŠ˜ë ¤ê°‘ë‹ˆë‹¤.

â€¢	ê³¼ì • ì¤‘ ë§¤ë²ˆ í˜„ì¬_í­ * í˜„ì¬_êµ¬ê°„ì˜_ìµœì†Œë†’ì´ë¡œ ë„“ì´ë¥¼ ê³„ì‚°í•˜ë©° ìµœëŒ€ê°’ì„ ê°±ì‹ í•©ë‹ˆë‹¤.

ë§ˆì§€ë§‰ì—, max(left_area, right_area, cross_area) ì¤‘ ìµœëŒ“ê°’ì´ get_max_area(left, right)ì˜ ê²°ê³¼ê°€ ë©ë‹ˆë‹¤.

1.2 ë¶„í• ì •ë³µ ì½”ë“œ ì˜ˆì‹œ (íŒŒì´ì¬)

ì•„ë˜ ì½”ë“œëŠ” ì¬ê·€ë¡œ êµ¬í˜„í•œ ì˜ˆì‹œì´ë©°, ì…ë ¥ ì²˜ë¦¬ê°€ ë§¤ìš° ë§ìœ¼ë¯€ë¡œ(ë°ì´í„° ìˆ˜ê°€ ìµœëŒ€ 100,000) ë¹ ë¥¸ ì…ì¶œë ¥ì— ì‹ ê²½ ì¨ì•¼ í•©ë‹ˆë‹¤.

ì£¼ì˜

â€¢	while left < cross_left or cross_right < right: ë¶€ë¶„ì—ì„œ, ì™¼ìª½/ì˜¤ë¥¸ìª½ ì–´ëŠ ìª½ìœ¼ë¡œ í™•ì¥í• ì§€ ê²°ì •í•˜ëŠ” ë¡œì§ì´ í•µì‹¬ì…ë‹ˆë‹¤.

â€¢	êµ¬í˜„ì´ ë‹¤ì†Œ ê¹Œë‹¤ë¡œìš´ í¸ì´ë¼, ì½”ë“œë¥¼ ì§¤ ë•Œ ì¸ë±ìŠ¤ ë²”ìœ„ ë° ìµœì†Œ ë†’ì´ ê°±ì‹ ì„ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤.

â€¢	ë¶„í• ì •ë³µ ì•Œê³ ë¦¬ì¦˜ì€ O(N \log N) í‰ê·  ë³µì¡ë„ë¥¼ ê°€ì§€ì§€ë§Œ, êµ¬í˜„ ë‚œì´ë„ê°€ ë¹„êµì  ë†’ì€ í¸ì…ë‹ˆë‹¤.

2. ì„ í˜• ìŠ¤íƒ(Monotonic Stack) í’€ì´ (ì‹¤ì „ì—ì„œ ë” ìì£¼ ì‚¬ìš©)

ë¶„í• ì •ë³µ ë°©ì‹ë„ ì¢‹ì§€ë§Œ, ì´ ë¬¸ì œëŠ” ìŠ¤íƒì„ ì´ìš©í•œ O(N) í•´ë²•ì´ ë” ì¼ë°˜ì ìœ¼ë¡œ ì•Œë ¤ì ¸ ìˆìŠµë‹ˆë‹¤.

ê°€ë ¹ ë°±ì¤€ 6549ë²ˆ ë¬¸ì œ í’€ì´ì—ì„œëŠ” ëŒ€ë¶€ë¶„ ì´ ìŠ¤íƒ ë°©ì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

2.1 ì•Œê³ ë¦¬ì¦˜ ì•„ì´ë””ì–´

1.	ë§‰ëŒ€ì˜ ì¸ë±ìŠ¤ë¥¼ ë‹´ëŠ” ìŠ¤íƒì„ í•˜ë‚˜ ë‘¡ë‹ˆë‹¤. ì´ ìŠ¤íƒì€ **â€˜í˜„ì¬ê¹Œì§€ ì˜¤ë¦„ì°¨ìˆœ(ë˜ëŠ” ë¹„ê°ì†Œ)â€™**ìœ¼ë¡œ ë§‰ëŒ€ê°€ ì •ë ¬ë˜ë„ë¡ ì¸ë±ìŠ¤ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.

2.	ì™¼ìª½ë¶€í„° ë§‰ëŒ€ë¥¼ í•˜ë‚˜ì”© ë³´ë©´ì„œ,

â€¢	ìŠ¤íƒì´ ë¹„ì–´ ìˆìœ¼ë©´ push

â€¢	ìŠ¤íƒì´ ë¹„ì–´ ìˆì§€ ì•Šë‹¤ë©´, â€œìƒˆ ë§‰ëŒ€ì˜ ë†’ì´ê°€ ìŠ¤íƒ topì— ìˆëŠ” ë§‰ëŒ€ ë†’ì´ë³´ë‹¤ ì‘ì„ ë•Œâ€ ìŠ¤íƒ topì—ì„œ popì„ í•©ë‹ˆë‹¤.

ì´ ë•Œ, popëœ ë§‰ëŒ€ê°€ **â€˜í˜„ì¬ê¹Œì§€ íƒìƒ‰í•œ êµ¬ê°„ì—ì„œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ ë„“ì€ ì§ì‚¬ê°í˜• ì¤‘ í•˜ë‚˜â€™**ë¥¼ í˜•ì„±í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

â€¢	popë  ë•Œë§ˆë‹¤, **â€œpopëœ ë§‰ëŒ€ì˜ ë†’ì´â€ x â€œë„ˆë¹„â€**ë¥¼ ê³„ì‚°í•´ ë„“ì´ë¥¼ ê°±ì‹ í•©ë‹ˆë‹¤.

â€¢	ì—¬ê¸°ì„œ ë„ˆë¹„ëŠ” â€œí˜„ì¬ ì¸ë±ìŠ¤ - pop í›„ ìŠ¤íƒì˜ ìƒˆ top - 1â€ (ìŠ¤íƒì´ ë¹„ë©´ ì „ì²´ê°€ ë„ˆë¹„)

3.	ëª¨ë“  ë§‰ëŒ€ë¥¼ ì²˜ë¦¬í•œ ë’¤ì—ë„, ìŠ¤íƒì— ë‚¨ì•„ ìˆëŠ” ë§‰ëŒ€ë“¤ì— ëŒ€í•´ì„œ ë˜‘ê°™ì´ popì„ ë°˜ë³µí•˜ë©° ë„“ì´ë¥¼ ê°±ì‹ í•©ë‹ˆë‹¤.

2.2 ìŠ¤íƒ í’€ì´ ì½”ë“œ ì˜ˆì‹œ (íŒŒì´ì¬)

ìŠ¤íƒ í’€ì´ê°€ í˜„ì—…/ëŒ€íšŒì—ì„œ ë” ê°„ë‹¨í•˜ê³  ë¹ ë¥´ë¯€ë¡œ, ë°±ì¤€ 6549 í’€ì´ ì˜ˆì‹œë¡œ ìì£¼ ë“±ì¥í•©ë‹ˆë‹¤.

ì‹œê°„ ë³µì¡ë„

â€¢	ê° ë§‰ëŒ€ê°€ ìŠ¤íƒì— í•œ ë²ˆ pushë˜ê³ , í•œ ë²ˆ popë˜ë¯€ë¡œ ì´ ì—°ì‚° íšŸìˆ˜ëŠ” O(N).

3. ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬(ì„¸ê·¸ë¨¼íŠ¸ + ìµœì†Ÿê°’ ì¸ë±ìŠ¤) í’€ì´

1.	ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ì— ê° êµ¬ê°„ì˜ â€œìµœì†Ÿê°’ì˜ ì¸ë±ìŠ¤â€ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.

2.	â€œêµ¬ê°„ ë‚´ì—ì„œ ê°€ì¥ ë‚®ì€ ë§‰ëŒ€â€ë¥¼ ê¸°ì¤€ìœ¼ë¡œ, í•´ë‹¹ ë§‰ëŒ€ë¥¼ í¬í•¨í•˜ëŠ” ìµœëŒ€ ì‚¬ê°í˜•ì„ êµ¬í•©ë‹ˆë‹¤(ì´ ë§‰ëŒ€ì˜ ë†’ì´ \times êµ¬ê°„ ê¸¸ì´).

3.	ë” ë‚®ì€ ë§‰ëŒ€ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ êµ¬ê°„, ì˜¤ë¥¸ìª½ êµ¬ê°„ì„ ë¶„í• ì •ë³µ í˜•íƒœë¡œ ì¬ê·€ ì²˜ë¦¬.

4.	ìµœì†Œ ë†’ì´ ì¸ë±ìŠ¤ë¥¼ O(1)ì— ê°€ì ¸ì˜¤ë ¤ë©´ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ or ìŠ¤íŒŒìŠ¤ í…Œì´ë¸” RMQ(Range Minimum Query) ì‚¬ìš©.

5.	ì „ì²´ ì•Œê³ ë¦¬ì¦˜ì€ O(N \log N)ì´ ë©ë‹ˆë‹¤.

ì´ ë°©ë²•ë„ ê°€ëŠ¥í•˜ì§€ë§Œ, êµ¬í˜„ ë‚œì´ë„ê°€ ë†’ì•„ì„œ ì‹¤ì „ì—ì„œëŠ” ì˜ ì“°ì§€ ì•ŠìŠµë‹ˆë‹¤.

4. ê²°ë¡  ë° ì¶”ì²œ

â€¢	ë¶„í•  ì •ë³µ(Divide & Conquer): O(N \log N)

â€¢	ì¬ê·€ êµ¬í˜„ì´ ê°€ëŠ¥í•˜ë©° ì•„ì´ë””ì–´ê°€ ì§ê´€ì ì´ì§€ë§Œ, ì–‘ì˜† í™•ì¥ ë¡œì§ì´ ê¹Œë‹¤ë¡­ìŠµë‹ˆë‹¤.

â€¢	ìŠ¤íƒ í’€ì´(Monotonic Stack): O(N)

â€¢	ëŒ€ë¶€ë¶„ì˜ ì½”ë”© í…ŒìŠ¤íŠ¸ ë° ì‹¤ë¬´ êµ¬í˜„ì—ì„œëŠ” ìŠ¤íƒ ë°©ì‹ì´ ë” ê°„ë‹¨í•˜ê³  ë¹ ë¥´ê²Œ êµ¬í˜„ ê°€ëŠ¥í•˜ë©°, ì‹œê°„ ë³µì¡ë„ë„ **ë” ìš°ìˆ˜(O(N))**í•©ë‹ˆë‹¤.

â€¢	ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ + RMQ: O(N \log N), êµ¬í˜„ì€ ë³µì¡.

ì‹¤ì „ì—ì„œëŠ” ìŠ¤íƒ í’€ì´ê°€ ê±°ì˜ í‘œì¤€ìœ¼ë¡œ ì“°ì¸ë‹¤ê³  ë³´ì‹œë©´ ë©ë‹ˆë‹¤.

í•˜ì§€ë§Œ ë¬¸ì œì—ì„œ ë¶„í• ì •ë³µìœ¼ë¡œ í’€ë¼ê³  í–ˆë‹¤ë©´, ìœ„ì˜ ë¶„í• ì •ë³µ ì ‘ê·¼ì„ ì²œì²œíˆ êµ¬í˜„í•´ë³´ëŠ” ê²½í—˜ë„ í° ë„ì›€ì´ ë  ê²ƒì…ë‹ˆë‹¤.

ë„ì›€ì´ ë˜ê¸¸ ë°”ëë‹ˆë‹¤! ì§ˆë¬¸ ìˆìœ¼ì‹œë©´ ì–¸ì œë“  ë‚¨ê²¨ì£¼ì„¸ìš”. í™”ì´íŒ…ì…ë‹ˆë‹¤.

## Phase3. í”¼ë“œë°± í›„ ì§ì ‘ í’€ê¸° - ì‹¤íŒ¨

```python
"""
1. ë¬¸ì œ ì½ê¸°
ì´í•´ ìì²´ëŠ” ì–´ë µì§€ ì•ŠìŒ.
2. ë¬¸ì œ í’€ê¸°
ë¶„í• ì •ë³µì˜ ë°©ë²•ë¡ ì„ ìœ ë„í•  ê²ƒ. 
Phase1. ìœ ë„(ìœ ì‚¬í•œ ë¬¸ì œ ë– ì˜¬ë ¤ë³´ê¸°)
- ìƒ‰ì¢…ì´? Zë¬¸ì œ?: 2^n ê¸¸ì´ì˜ ì •ì‚¬ê°í˜•ì„ ë‹¤ë£¨ëŠ” ë¬¸ì œë“¤ê³¼ëŠ”, ì§ì‚¬ê°í˜•ì„ ë‹¤ë£¬ë‹¤ëŠ” ì ì—ì„œ ì¢€ ë‹¤ë¦„
ì£¼ì–´ì§€ëŠ” ë°ì´í„°ë„ ì„ í˜•. nì˜ ë²”ìœ„ê°€ 100,000ìœ¼ë¡œ ë§ì§€ëŠ” ì•Šì€ë°, ì£¼ì–´ì§€ëŠ” ì •ìˆ˜ê°€ ìœ„ ë¬¸ì œë³´ë‹¤ í¼
- ë³‘í•© ì •ë ¬: ì‚¬ì‹¤ ê·¼ë³¸ì ìœ¼ë¡œ ë¹„ìŠ·í•˜ê² ì§€? ì–´ë–»ê²Œ ë¹„ìŠ·í•˜ë ¤ë‚˜. 
base case: ì‚¬ê°í˜•ì„ ë‚˜ëˆ„ë‹¤ê°€ ë‘ ê°œê°€ ë‚¨ì•„ì„œ, ìƒìˆ˜ ì‹œê°„ ì•ˆì— ë¬¸ì œ í•´ê²°ì´ ê°€ëŠ¥í•œ ì‹œì 
recursion case: ì£¼ì–´ì§„ íˆìŠ¤í† ê·¸ë¨ ë¶€ë¶„ì— ëŒ€í•´ ì–‘ìª½ íˆìŠ¤í† ê·¸ë¨ì—ì„œ êµ¬í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ì‚¬ê°í˜•
ì´ê±´ ë‹¹ì—°íˆ, ì–‘ìª½ì˜ ì‚¬ê°í˜• í¬ê¸°ë¥¼ ë¹„êµí–ˆì„ ë•Œ ìµœì†Œ ì‚¬ê°í˜• ê°’ì„ ë¦¬í„´í•´ì•¼ í•œë‹¤. 
ì¢…ì´ì— ë¨¼ì € í’€ì–´ë³´ì‹œê¸¸. ë‚´ê°€ ë´¤ì„ ë• ë³‘í•©ì •ë ¬í•˜ê³  ë˜ê²Œ ë¹„ìŠ·í•¨
Phase2. ë¬¸ì œ ì •ì˜
- ê¸°ë³¸ ë¬¸ì œ: ì „ì²´ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°
- ë¶€ë¬¸ì œ: ë¶€ë¶„ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°
- ë² ì´ìŠ¤ ì¼€ì´ìŠ¤: ë‘ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°: ë¬´ì¡°ê±´ ë‘ ì§ì‚¬ê°í˜•ì„ í•©ì¹  í•„ìš”ëŠ” ì—†ìŒ!
Phase3. ì–´ë””ì„œ ë§‰í˜”ëŠ”ê°€? 
ë¶„í•  ì •ë³µì—ì„œ ì •ë³µ, ë³‘í•© ë‹¨ê³„ë¥¼ ì–´ë–»ê²Œ í•´ì•¼í• ì§€ ëª¨ë¥´ê² ìŒ.
ë³‘í•© ë‹¨ê³„ì—ì„œ ì¢Œ ì¤‘ ìš° ì‚¼ê°í˜•ì¤‘ ìµœëŒ€ë¥¼ ë¦¬í„´í•˜ê¸°dë§Œ í•˜ë©´ ëœë‹¤ê³  í•¨. ì œë°œ ì¬ê·€ ìš”ì •ì„ ë¯¿ì–´!

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys

input = sys.stdin.readline

def recur(left: int, right: int):
    """ì¢Œì¤‘ìš° ì˜ì—­ ì¤‘ ìµœëŒ€ ì‚¼ê°í˜•ì„ ë¦¬í„´"""
    global arr
    # base case: íˆìŠ¤í† ê·¸ë¨ ì˜ì—­ì´ 2 ì´í•˜ì—¬ì„œ ìƒìˆ˜ì‹œê°„ ì•ˆì— íŒë‹¨ ê°€ëŠ¥.
    # conquer
    if right - left == 0: #ì˜ì—­ì´ í•˜ë‚˜.
        return right
    # recursion case
    mid = (left+right)//2
    # divide
    left_rect = recur(left, mid)
    right_rect = recur(mid+1, right)
    # combine.
    # mid left ì˜ì—­ íƒìƒ‰
    # ê·¼ë° ì—¬ê¸° ë¡œì§ì´ ì¢€ ë‹¤ë¥¸ ê±° ê°™ì€ë°. ì–‘ì˜†ìœ¼ë¡œ ë³€ì„ ëŠ˜ë¦¬ëŠ” ê²½ìš°ì™€ ì•ˆ ëŠ˜ë¦¬ëŠ” ê²½ìš°ì˜ íƒìƒ‰ì„ í•´ì•¼ í•˜ëŠ”ë°?
    i, j = mid - 1, mid + 1
    cnt_i, cnt_j = 0, 0 # arr[mid]ì´ìƒì˜ íˆìŠ¤í† ê·¸ë¨ ì§ì‚¬ê°í˜• ì¢Œìš° ê°œìˆ˜ë¥¼ ì¹´ìš´íŠ¸(ì—°ì†ë¼ì•¼ í•¨)
    while i >= 0 and arr[i] >= arr[mid]:
        cnt_i += 1
        i -= 1
    while j < len(arr) and arr[j] >= arr[mid]:
        cnt_j += 1
        j += 1
    mid_rect = arr[mid] * (cnt_i + cnt_j+1)
    return max(left_rect, mid_rect, right_rect)

arr = []

while True:
    arr = tuple(map(int, input().split()))
    if arr == (0,): 
        break
    print(recur(0, len(arr)))


"""
ì´ìŠˆ: ì‹œê°„ì´ˆê³¼

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: 8í”„ë¡œ ë§ì¶˜ ê±° ë´ì„œ ë¡œì§ì ì¸ ì—ëŸ¬ëŠ” ì—†ëŠ”ê±° ê°™ê³ , ë³µì¡ë„ ë¶„ì„ì´ í•„ìš”í•¨.
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì¬ê·€ í•¨ìˆ˜ë¡œ êµ¬í˜„

Phase2.
í™•ì¸: ë³µì¡ë„ ë¶„ì„: ë”± ë´ë„ combine ê³¼ì •ì—ì„œ ë³µì¡í•¨. ìµœì•…ì˜ ê²½ìš° O(n)ì„.
ê·¸ëŸ¬ë©´ ë§ˆìŠ¤í„° ì •ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ìŒ(O(n)ì„ nìœ¼ë¡œ ìƒê°í•˜ê³ )
T(n) = 2T(n/2) + n + c
    = ...
    = n^2 + n(2c-1)
O(n^2)(ë§ë‚˜?)
ì•„ë¬´íŠ¼ ì»´ë°”ì¸ ê³¼ì •ì—ì„œ ë³µì¡ë„ ì¤„ì¼ í•„ìš”ê°€ ìˆìŒ. ì§€ê¸ˆ ì„ í˜•íƒìƒ‰ì„ í•˜ëŠ”ë°, ë©”ëª¨ì´ì œì´ì…˜ì„ í•´ì•¼ í•˜ë‚˜? 
ì‹œë„: í”¼ë“œë°± ë‹¤ì‹œ ë³´ë‹ˆê¹Œ ê·¸ê²Œ ë¬¸ì œê°€ ì•„ë‹ˆë¼, ì»´ë°”ì¸ ë¡œì§ì´ ë‹¤ë¦„. ê·¼ë° ì™œ ë‹¤ë¥¸ì§€ ëª¨ë¥´ê² ìŒ.
ë¶„ì„: 
"""
```

## Phase4. ì™¸ìš°ê¸°

ì•„ë˜ ë‹µë³€ì—ì„œëŠ” ë¶„í•  ì •ë³µ ë°©ì‹ìœ¼ë¡œ íˆìŠ¤í† ê·¸ë¨ ìµœëŒ€ ì§ì‚¬ê°í˜• ë¬¸ì œ(ë°±ì¤€ 6549)ë¥¼ ì˜¬ë°”ë¥´ê²Œ êµ¬í˜„í•˜ëŠ” ì˜ˆì‹œ ì½”ë“œë¥¼ ë³´ì—¬ë“œë¦½ë‹ˆë‹¤.

ì´ ë¬¸ì œëŠ” **ìŠ¤íƒ í’€ì´(O(N))**ê°€ ë” êµ¬í˜„ì´ ì‰½ê³  ë¹ ë¥´ì§€ë§Œ,

ì§ˆë¬¸ ì£¼ì œì¸ ë¶„í•  ì •ë³µ(Divide & Conquer)ìœ¼ë¡œ ì œëŒ€ë¡œ ì‘ì„±í•˜ëŠ” ì½”ë“œë¥¼ ê°„ë‹¨íˆ ì •ë¦¬í•´ ë³´ê² ìŠµë‹ˆë‹¤.

ë¶„í•  ì •ë³µ(Divide & Conquer) í’€ì´ í•µì‹¬

1.	get_max_area(left, right) : êµ¬ê°„ left..rightì—ì„œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ìµœëŒ€ ì§ì‚¬ê°í˜• ë„“ì´ë¥¼ ë¦¬í„´.

2.	Base case

â€¢	ë§‰ëŒ€ê°€ í•˜ë‚˜ë¿ì¸ ê²½ìš°(left == right), ë„“ì´ëŠ” heights[left].

3.	Divide

â€¢	ì¤‘ê°„ ì§€ì  mid = (left + right) // 2

â€¢	ì™¼ìª½ êµ¬ê°„ ìµœëŒ€ ë„“ì´ = get_max_area(left, mid)

â€¢	ì˜¤ë¥¸ìª½ êµ¬ê°„ ìµœëŒ€ ë„“ì´ = get_max_area(mid+1, right)

4.	Conquer(ê°€ìš´ë°ë¥¼ ê±¸ì¹˜ëŠ” ì‚¬ê°í˜•)

â€¢	mid, mid+1ì—ì„œ ì‹œì‘í•´ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ í™•ì¥í•˜ë©° ë§Œë“¤ ìˆ˜ ìˆëŠ” ìµœëŒ€ ë„“ì´ë¥¼ êµ¬í•¨.

â€¢	í™•ì¥ ì‹œ **â€˜í˜„ì¬ êµ¬ê°„ì˜ ìµœì†Œ ë†’ì´â€™**ë¥¼ ê°±ì‹ í•˜ë©°, ë§¤ ë‹¨ê³„ë§ˆë‹¤ í˜„ì¬_í­ Ã— ìµœì†Œ_ë†’ì´ë¥¼ ê³„ì‚°í•´ ìµœëŒ€ê°’ì„ ê°±ì‹ .

5.	ìµœì¢…ì ìœ¼ë¡œ max(ì™¼ìª½, ì˜¤ë¥¸ìª½, ê°€ìš´ë°ë¥¼ ê±¸ì¹˜ëŠ” ì˜ì—­)ì„ ë°˜í™˜.

ì´ ë•Œ, ê°€ìš´ë°ë¥¼ ê±¸ì¹˜ëŠ” ì˜ì—­ì„ ì˜¬ë°”ë¥´ê²Œ ê³„ì‚°í•˜ëŠ” ê²ƒì´ ê´€ê±´ì…ë‹ˆë‹¤.

ì´ ê³¼ì •ì„ O(right-left+1) ì¦‰ ì„ í˜• ì‹œê°„ ì•ˆì— ì²˜ë¦¬í•˜ê³ , ì „ì²´ ì¬ê·€ í˜¸ì¶œì€ T(N) = 2T(N/2) + O(N)ì´ë¯€ë¡œ, ê²°ê³¼ì ìœ¼ë¡œ O(N \log N) ì— í’€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì˜ˆì‹œ ì½”ë“œ (íŒŒì´ì¬)

```python
import sys
input = sys.stdin.readline

def get_max_area(heights, left, right):
    """
    ë¶„í•  ì •ë³µìœ¼ë¡œ íˆìŠ¤í† ê·¸ë¨ êµ¬ê°„ [left..right]ì—ì„œ
    ì–»ì„ ìˆ˜ ìˆëŠ” 'ê°€ì¥ í° ì§ì‚¬ê°í˜•ì˜ ë„“ì´'ë¥¼ ë¦¬í„´í•œë‹¤.
    """
    # ë§‰ëŒ€ê°€ í•˜ë‚˜ë¿ì¸ ê²½ìš°
    if left == right:
        return heights[left]

    mid = (left + right) // 2

    # (1) ì™¼ìª½ êµ¬ê°„ ìµœëŒ€ ë„“ì´
    left_area = get_max_area(heights, left, mid)
    # (2) ì˜¤ë¥¸ìª½ êµ¬ê°„ ìµœëŒ€ ë„“ì´
    right_area = get_max_area(heights, mid + 1, right)

    # (3) ì¤‘ì•™ì„ ê±¸ì¹˜ëŠ” ì§ì‚¬ê°í˜• ìµœëŒ€ ë„“ì´ ê³„ì‚°
    #  - ë¨¼ì € mid, mid+1 ë‘ ì¹¸ì„ ì¡ê³  ì‹œì‘
    lo = mid
    hi = mid + 1
    # ì´ˆê¹ƒê°’: ê°€ì¥ ì‘ì€ ë§‰ëŒ€ ë†’ì´ê°€ min(heights[lo], heights[hi]), í­=2
    height = min(heights[lo], heights[hi])
    cross_area = height * 2  # ì¤‘ì•™ì„ ë¬´ì¡°ê±´ í¬í•¨í•˜ëŠ” ì§ì‚¬ê°í˜•ì˜ ì´ˆê¹ƒê°’

    # ì¤‘ì•™ì—ì„œ ì‹œì‘í•´ ì–‘ ë(left, right) ë°©í–¥ìœ¼ë¡œ í™•ì¥
    while left < lo or hi < right:
		    # ì˜¤ë¥¸ìª½ìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥í•œì§€ íŒë‹¨ (ì™¼ìª½ìœ¼ë¡œ ë” ëª» ê°€ê±°ë‚˜, ì™¼ìª½ìœ¼ë¡œ ê°€ë©´ ë” ë¶ˆë¦¬í•œ ê²½ìš°)
        if hi < right and (lo == left or heights[lo - 1] < heights[hi + 1]):
            hi += 1
            height = min(height, heights[hi])
        # ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ ì™¼ìª½ìœ¼ë¡œ í™•ì¥.
        else:
            lo -= 1
            height = min(height, heights[lo])

        # ë§¤ë²ˆ 'í˜„ì¬ ìµœì†Œ ë†’ì´ Ã— (hi-lo+1)' ê°±ì‹ 
        cross_area = max(cross_area, height * (hi - lo + 1))
 
    # ì™¼ìª½, ì˜¤ë¥¸ìª½, ì¤‘ì•™ ê±¸ì¹¨ ì¤‘ ìµœëŒ“ê°’
    return max(left_area, right_area, cross_area)


def solve():
    while True:
        data = list(map(int, input().split()))
        n = data[0]
        if n == 0:  # 0ì´ ë“¤ì–´ì˜¤ë©´ ì¢…ë£Œ
            break

        heights = data[1:]
        # ë¶„í• ì •ë³µìœ¼ë¡œ í’€ê¸°
        answer = get_max_area(heights, 0, n - 1)
        print(answer)


if __name__ == "__main__":
    solve()
```

ì£¼ìš” êµ¬í˜„ í¬ì¸íŠ¸

1.	Base case

â€¢	left == right â†’ ë‹¨ì¼ ë§‰ëŒ€ì¸ ê²½ìš° ë„“ì´ëŠ” ë§‰ëŒ€ ë†’ì´ ê·¸ ìì²´.

2.	Divide : ì™¼ìª½, ì˜¤ë¥¸ìª½ì„ ì¬ê·€ë¡œ êµ¬í•¨.

3.	Conquer(ê°€ìš´ë° ê±¸ì¹˜ê¸°)

â€¢	lo = mid, hi = mid + 1ì—ì„œ ì‹œì‘

â€¢	height = min(heights[lo], heights[hi])

â€¢	cross_area = height * 2

â€¢	ì–‘ìª½ìœ¼ë¡œ í™•ì¥:

â€¢	ì™¼ìª½( lo-1 )ê³¼ ì˜¤ë¥¸ìª½( hi+1 ) ì¤‘, ë” ë†’ì€ ë§‰ëŒ€ ìª½ì„ ìš°ì„  í™•ì¥í•˜ëŠ” ë°©ì‹ì„ ì“°ê±°ë‚˜,

ë‹¤ë¥¸ ë¡œì§(ì™¼ìª½/ì˜¤ë¥¸ìª½ ì¤‘ ë” ë†’ì€ ìª½ ì„ íƒ)ë„ ê°€ëŠ¥í•©ë‹ˆë‹¤.

â€¢	í™•ì¥í•  ë•Œë§ˆë‹¤ height = min(height, ìƒˆë¡œ í¸ì…í•œ ë§‰ëŒ€ ë†’ì´).

â€¢	ë§¤ ë‹¨ê³„ (hi - lo + 1) * heightë¥¼ ê°±ì‹ .

4.	ë³µì¡ë„: O(N log N)

ì˜ëª»ëœ Combine(ì¤‘ì•™ ì˜ì—­) êµ¬í˜„ì˜ ì˜ˆ

ì§ˆë¬¸ ì½”ë“œì—ì„œ,

```plain text
    # ì¤‘ê°„ ë§‰ëŒ€ í•˜ë‚˜ë§Œ ë†’ì´ë¡œ ì¡ê³  ì¢Œìš°ë¡œ ì„ í˜• íƒìƒ‰
    i, j = mid - 1, mid + 1
    while i >= 0 and arr[i] >= arr[mid]:
        ...
```

ì²˜ëŸ¼ ë‹¨ í•˜ë‚˜ì˜ ë§‰ëŒ€ ë†’ì´(arr[mid])ë§Œ ê¸°ì¤€ìœ¼ë¡œ ì¢Œìš° í™•ì¥í•˜ë©´,

mid+1ì˜ ë§‰ëŒ€ê°€ arr[mid]ë³´ë‹¤ ë‚®ê±°ë‚˜, ë˜ëŠ” ë” ë‚®ì€ ìª½ì´ ë¨¼ì € ê±¸ë¦¬ëŠ” ìƒí™© ë“±

ë‹¤ì–‘í•œ ê²½ìš°ë¥¼ ë†“ì¹˜ê²Œ ë©ë‹ˆë‹¤.

ì¤‘ì•™ì„ ê±¸ì¹  ë•ŒëŠ” ë³´í†µ

â€¢	lo = mid, hi = mid + 1 ì—ì„œ ì‹œì‘

â€¢	ì²˜ìŒ ë†’ì´ = min(arr[mid], arr[mid+1]),

â€¢	ì´í›„ ì–‘ ì˜†ìœ¼ë¡œ í™•ì¥í•˜ë©´ì„œ ë§¤ë²ˆ **â€˜í˜„ì¬ êµ¬ê°„ì˜ ìµœì†Œ ë†’ì´â€™**ë¥¼ ê°±ì‹ 

í•´ê°€ì•¼ í•˜ëŠ”ë°, ì´ë¥¼ ê°„ë‹¨íˆ êµ¬í˜„í•˜ë ¤ë©´ ìœ„ ì˜ˆì‹œ ì½”ë“œì²˜ëŸ¼

â€œì™¼ìª½ í™•ì¥ vs ì˜¤ë¥¸ìª½ í™•ì¥ ì¤‘ ë” í° ë†’ì´ ìª½ì„ í™•ì¥â€ í•˜ë©´ì„œ ì§„í–‰í•˜ëŠ” ë°©ì‹ì´ ë„ë¦¬ ì“°ì…ë‹ˆë‹¤.

ê²°ë¡ 

â€¢	ë¶„í•  ì •ë³µìœ¼ë¡œë„ O(N \log N)ì— í•´ê²° ê°€ëŠ¥í•˜ì§€ë§Œ,

â€¢	ì‹¤ì „(ëŒ€íšŒ/ë©´ì ‘)ì—ì„œëŠ” ë³´í†µ ìŠ¤íƒ í’€ì´(O(N))ê°€ ë” ì‰½ê³  ë¹ ë¥´ê²Œ ì‘ì„±ë©ë‹ˆë‹¤.

â€¢	ë¬¸ì œ ì˜ë„ê°€ â€œë¶„í• ì •ë³µâ€ì´ë¼ë©´, ìœ„ ì½”ë“œë¥¼ ì°¸ê³ í•˜ì…”ì„œ êµ¬í˜„í•´ ë³´ì‹œë©´ ë„ì›€ì´ ë©ë‹ˆë‹¤.

ì‹œê°„ ì´ˆê³¼ í˜¹ì€ í‹€ë¦¼ ì›ì¸ ëŒ€ë¶€ë¶„ì€

(1) â€œê°€ìš´ë°ë¥¼ ê±¸ì¹˜ëŠ” êµ¬ê°„â€ì„ ì œëŒ€ë¡œ í™•ì¥í•˜ì§€ ì•Šì€ ì 

(2) ì¸ë±ìŠ¤ ì²˜ë¦¬ë‚˜ ìµœì†Œ ë†’ì´ ê°±ì‹  ì‹¤ìˆ˜ë¥¼ í–ˆë˜ ì ì´ë¯€ë¡œ,

ìœ„ ì˜ˆì‹œì²˜ëŸ¼ ì •í™•í•œ combine ë¡œì§ì„ êµ¬í˜„í•´ì£¼ì‹œë©´ ë©ë‹ˆë‹¤.

ë„ì›€ì´ ë˜ê¸¸ ë°”ëë‹ˆë‹¤. ì¶”ê°€ ì§ˆë¬¸ì´ ìˆìœ¼ì‹œë©´ ì–¸ì œë“  í¸í•˜ê²Œ ë‚¨ê²¨ì£¼ì„¸ìš”! í™”ì´íŒ…ì…ë‹ˆë‹¤.

### 0. í•„ì‚¬

![](./images/IMG_0071.png)

![](./images/IMG_0072.png)

ë‹¤ë¥¸ ë¶€ë¶„ ë‹¤ ë˜‘ê°™ì€ë°, ê°€ìš´ë° ë¶€ë¶„ ë„“ì´ êµ¬í•˜ëŠ” ë¡œì§ì´ ì•„ë¬´ë¦¬ ë´ë„ ì´í•´ê°€ ì•ˆ ëœë‹¤. ì´ ë¶€ë¶„ë§Œ í•œë²ˆ ë” ë´ì•¼ê² ë‹¤.

ì£¼ì„ì´ ì˜ëª» ì í˜€ ìˆì—ˆìŒ.

![](./images/IMG_0073.png)

### 1. ì½”ë“œ ì œì¶œ

```python
"""
1. ë¬¸ì œ ì½ê¸°
ì´í•´ ìì²´ëŠ” ì–´ë µì§€ ì•ŠìŒ.
2. ë¬¸ì œ í’€ê¸°
ë¶„í• ì •ë³µì˜ ë°©ë²•ë¡ ì„ ìœ ë„í•  ê²ƒ. 
Phase1. ìœ ë„(ìœ ì‚¬í•œ ë¬¸ì œ ë– ì˜¬ë ¤ë³´ê¸°)
- ìƒ‰ì¢…ì´? Zë¬¸ì œ?: 2^n ê¸¸ì´ì˜ ì •ì‚¬ê°í˜•ì„ ë‹¤ë£¨ëŠ” ë¬¸ì œë“¤ê³¼ëŠ”, ì§ì‚¬ê°í˜•ì„ ë‹¤ë£¬ë‹¤ëŠ” ì ì—ì„œ ì¢€ ë‹¤ë¦„
ì£¼ì–´ì§€ëŠ” ë°ì´í„°ë„ ì„ í˜•. nì˜ ë²”ìœ„ê°€ 100,000ìœ¼ë¡œ ë§ì§€ëŠ” ì•Šì€ë°, ì£¼ì–´ì§€ëŠ” ì •ìˆ˜ê°€ ìœ„ ë¬¸ì œë³´ë‹¤ í¼
- ë³‘í•© ì •ë ¬: ì‚¬ì‹¤ ê·¼ë³¸ì ìœ¼ë¡œ ë¹„ìŠ·í•˜ê² ì§€? ì–´ë–»ê²Œ ë¹„ìŠ·í•˜ë ¤ë‚˜. 
base case: ì‚¬ê°í˜•ì„ ë‚˜ëˆ„ë‹¤ê°€ ë‘ ê°œê°€ ë‚¨ì•„ì„œ, ìƒìˆ˜ ì‹œê°„ ì•ˆì— ë¬¸ì œ í•´ê²°ì´ ê°€ëŠ¥í•œ ì‹œì 
recursion case: ì£¼ì–´ì§„ íˆìŠ¤í† ê·¸ë¨ ë¶€ë¶„ì— ëŒ€í•´ ì–‘ìª½ íˆìŠ¤í† ê·¸ë¨ì—ì„œ êµ¬í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ì‚¬ê°í˜•
ì´ê±´ ë‹¹ì—°íˆ, ì–‘ìª½ì˜ ì‚¬ê°í˜• í¬ê¸°ë¥¼ ë¹„êµí–ˆì„ ë•Œ ìµœì†Œ ì‚¬ê°í˜• ê°’ì„ ë¦¬í„´í•´ì•¼ í•œë‹¤. 
ì¢…ì´ì— ë¨¼ì € í’€ì–´ë³´ì‹œê¸¸. ë‚´ê°€ ë´¤ì„ ë• ë³‘í•©ì •ë ¬í•˜ê³  ë˜ê²Œ ë¹„ìŠ·í•¨
Phase2. ë¬¸ì œ ì •ì˜
- ê¸°ë³¸ ë¬¸ì œ: ì „ì²´ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°
- ë¶€ë¬¸ì œ: ë¶€ë¶„ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°
- ë² ì´ìŠ¤ ì¼€ì´ìŠ¤: ë‘ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°: ë¬´ì¡°ê±´ ë‘ ì§ì‚¬ê°í˜•ì„ í•©ì¹  í•„ìš”ëŠ” ì—†ìŒ!
Phase3. ì–´ë””ì„œ ë§‰í˜”ëŠ”ê°€? 
ë¶„í•  ì •ë³µì—ì„œ ì •ë³µ, ë³‘í•© ë‹¨ê³„ë¥¼ ì–´ë–»ê²Œ í•´ì•¼í• ì§€ ëª¨ë¥´ê² ìŒ.
ë³‘í•© ë‹¨ê³„ì—ì„œ ì¢Œ ì¤‘ ìš° ì‚¼ê°í˜•ì¤‘ ìµœëŒ€ë¥¼ ë¦¬í„´í•˜ê¸°dë§Œ í•˜ë©´ ëœë‹¤ê³  í•¨. ì œë°œ ì¬ê·€ ìš”ì •ì„ ë¯¿ì–´!

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys

input = sys.stdin.readline

def recur(arr: list, left: int, right: int):
    """ì¢Œì¤‘ìš° ì˜ì—­ ì¤‘ ìµœëŒ€ ì‚¼ê°í˜•ì„ ë¦¬í„´"""
    # base case: íˆìŠ¤í† ê·¸ë¨ ì˜ì—­ì´ 2 ì´í•˜ì—¬ì„œ ìƒìˆ˜ì‹œê°„ ì•ˆì— íŒë‹¨ ê°€ëŠ¥.
    # conquer
    if right - left == 0: #ì˜ì—­ì´ í•˜ë‚˜.
        return arr[right]
    # recursion case
    mid = (left+right)//2
    # divide
    left_rect = recur(arr, left, mid)
    right_rect = recur(arr, mid+1, right)
    # combine.
    # mid left ì˜ì—­ íƒìƒ‰
    # ê·¼ë° ì—¬ê¸° ë¡œì§ì´ ì¢€ ë‹¤ë¥¸ ê±° ê°™ì€ë°. ì–‘ì˜†ìœ¼ë¡œ ë³€ì„ ëŠ˜ë¦¬ëŠ” ê²½ìš°ì™€ ì•ˆ ëŠ˜ë¦¬ëŠ” ê²½ìš°ì˜ íƒìƒ‰ì„ í•´ì•¼ í•˜ëŠ”ë°?
    lo, hi = mid, mid + 1
    height = min(arr[lo], arr[hi])
    cross_area = height*2
    while lo > left or hi < right:
        if hi < right and (lo == left or arr[lo-1] < arr[hi+1]):
            hi += 1
            height = min(arr[hi], height)
        else:
            lo -= 1
            height = min(arr[lo], height)
        cross_area = max(cross_area, height * (hi-lo+1))
    
    return max(left_rect, cross_area, right_rect)

arr = []

while True:
    arr = tuple(map(int, input().split()))
    if arr == (0,): 
        break
    
    print(recur(arr[1:], 0, len(arr)-2))


"""
ì´ìŠˆ: ì‹œê°„ì´ˆê³¼

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: 8í”„ë¡œ ë§ì¶˜ ê±° ë´ì„œ ë¡œì§ì ì¸ ì—ëŸ¬ëŠ” ì—†ëŠ”ê±° ê°™ê³ , ë³µì¡ë„ ë¶„ì„ì´ í•„ìš”í•¨.
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì¬ê·€ í•¨ìˆ˜ë¡œ êµ¬í˜„

Phase2.
í™•ì¸: ë³µì¡ë„ ë¶„ì„: ë”± ë´ë„ combine ê³¼ì •ì—ì„œ ë³µì¡í•¨. ìµœì•…ì˜ ê²½ìš° O(n)ì„.
ê·¸ëŸ¬ë©´ ë§ˆìŠ¤í„° ì •ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ìŒ(O(n)ì„ nìœ¼ë¡œ ìƒê°í•˜ê³ )
T(n) = 2T(n/2) + n + c
    = ...
    = n^2 + n(2c-1)
O(n^2)(ë§ë‚˜?)
ì•„ë¬´íŠ¼ ì»´ë°”ì¸ ê³¼ì •ì—ì„œ ë³µì¡ë„ ì¤„ì¼ í•„ìš”ê°€ ìˆìŒ. ì§€ê¸ˆ ì„ í˜•íƒìƒ‰ì„ í•˜ëŠ”ë°, ë©”ëª¨ì´ì œì´ì…˜ì„ í•´ì•¼ í•˜ë‚˜? 
ì‹œë„: í”¼ë“œë°± ë‹¤ì‹œ ë³´ë‹ˆê¹Œ ê·¸ê²Œ ë¬¸ì œê°€ ì•„ë‹ˆë¼, ì»´ë°”ì¸ ë¡œì§ì´ ë‹¤ë¦„. ê·¼ë° ì™œ ë‹¤ë¥¸ì§€ ëª¨ë¥´ê² ìŒ.
ë¶„ì„: ë„ˆë¬´ ì–´ë µë‹¤. ì„¸ë¶€ ë¡œì§ìœ¼ë¡œ ë“¤ì–´ê°€ë©´ ì´ê±¸ ì–´ë–»ê²Œ ê³ ì•ˆí•˜ê³  ë…¼ë¦¬ë¥¼ êµ¬ì„±í•´ì•¼í• ì§€ ëª¨ë¥´ê² ë‹¤.
"""
```

# ìŠ¤íƒ: íƒ‘

https://www.acmicpc.net/problem/2493

KOI í†µì‹ ì—°êµ¬ì†ŒëŠ” ë ˆì´ì €ë¥¼ ì´ìš©í•œ ìƒˆë¡œìš´ ë¹„ë°€ í†µì‹  ì‹œìŠ¤í…œ ê°œë°œì„ ìœ„í•œ ì‹¤í—˜ì„ í•˜ê³  ìˆë‹¤. ì‹¤í—˜ì„ ìœ„í•˜ì—¬ ì¼ì§ì„  ìœ„ì— Nê°œì˜ ë†’ì´ê°€ ì„œë¡œ ë‹¤ë¥¸ íƒ‘ì„ ìˆ˜í‰ ì§ì„ ì˜ ì™¼ìª½ë¶€í„° ì˜¤ë¥¸ìª½ ë°©í–¥ìœ¼ë¡œ ì°¨ë¡€ë¡œ ì„¸ìš°ê³ , ê° íƒ‘ì˜ ê¼­ëŒ€ê¸°ì— ë ˆì´ì € ì†¡ì‹ ê¸°ë¥¼ ì„¤ì¹˜í•˜ì˜€ë‹¤. ëª¨ë“  íƒ‘ì˜ ë ˆì´ì € ì†¡ì‹ ê¸°ëŠ” ë ˆì´ì € ì‹ í˜¸ë¥¼ ì§€í‘œë©´ê³¼ í‰í–‰í•˜ê²Œ ìˆ˜í‰ ì§ì„ ì˜ ì™¼ìª½ ë°©í–¥ìœ¼ë¡œ ë°œì‚¬í•˜ê³ , íƒ‘ì˜ ê¸°ë‘¥ ëª¨ë‘ì—ëŠ” ë ˆì´ì € ì‹ í˜¸ë¥¼ ìˆ˜ì‹ í•˜ëŠ” ì¥ì¹˜ê°€ ì„¤ì¹˜ë˜ì–´ ìˆë‹¤. í•˜ë‚˜ì˜ íƒ‘ì—ì„œ ë°œì‚¬ëœ ë ˆì´ì € ì‹ í˜¸ëŠ” ê°€ì¥ ë¨¼ì € ë§Œë‚˜ëŠ” ë‹¨ í•˜ë‚˜ì˜ íƒ‘ì—ì„œë§Œ ìˆ˜ì‹ ì´ ê°€ëŠ¥í•˜ë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ ë†’ì´ê°€ 6, 9, 5, 7, 4ì¸ ë‹¤ì„¯ ê°œì˜ íƒ‘ì´ ìˆ˜í‰ ì§ì„ ì— ì¼ë ¬ë¡œ ì„œ ìˆê³ , ëª¨ë“  íƒ‘ì—ì„œëŠ” ì£¼ì–´ì§„ íƒ‘ ìˆœì„œì˜ ë°˜ëŒ€ ë°©í–¥(ì™¼ìª½ ë°©í–¥)ìœ¼ë¡œ ë™ì‹œì— ë ˆì´ì € ì‹ í˜¸ë¥¼ ë°œì‚¬í•œë‹¤ê³  í•˜ì. ê·¸ëŸ¬ë©´, ë†’ì´ê°€ 4ì¸ ë‹¤ì„¯ ë²ˆì§¸ íƒ‘ì—ì„œ ë°œì‚¬í•œ ë ˆì´ì € ì‹ í˜¸ëŠ” ë†’ì´ê°€ 7ì¸ ë„¤ ë²ˆì§¸ íƒ‘ì´ ìˆ˜ì‹ ì„ í•˜ê³ , ë†’ì´ê°€ 7ì¸ ë„¤ ë²ˆì§¸ íƒ‘ì˜ ì‹ í˜¸ëŠ” ë†’ì´ê°€ 9ì¸ ë‘ ë²ˆì§¸ íƒ‘ì´, ë†’ì´ê°€ 5ì¸ ì„¸ ë²ˆì§¸ íƒ‘ì˜ ì‹ í˜¸ë„ ë†’ì´ê°€ 9ì¸ ë‘ ë²ˆì§¸ íƒ‘ì´ ìˆ˜ì‹ ì„ í•œë‹¤. ë†’ì´ê°€ 9ì¸ ë‘ ë²ˆì§¸ íƒ‘ê³¼ ë†’ì´ê°€ 6ì¸ ì²« ë²ˆì§¸ íƒ‘ì´ ë³´ë‚¸ ë ˆì´ì € ì‹ í˜¸ëŠ” ì–´ë–¤ íƒ‘ì—ì„œë„ ìˆ˜ì‹ ì„ í•˜ì§€ ëª»í•œë‹¤.

íƒ‘ë“¤ì˜ ê°œìˆ˜ Nê³¼ íƒ‘ë“¤ì˜ ë†’ì´ê°€ ì£¼ì–´ì§ˆ ë•Œ, ê°ê°ì˜ íƒ‘ì—ì„œ ë°œì‚¬í•œ ë ˆì´ì € ì‹ í˜¸ë¥¼ ì–´ëŠ íƒ‘ì—ì„œ ìˆ˜ì‹ í•˜ëŠ”ì§€ë¥¼ ì•Œì•„ë‚´ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ë¼.

## Phase1. í’€ì´ ì„±ê³µ. 

í•œ 45ë¶„ ê±¸ë¦°ë“¯.

```python
"""
1. ë¬¸ì œ ì½ê¸°: íƒ‘ ë²ˆí˜¸ëŠ” 1 based.
2. ë¬¸ì œ í’€ê¸°
ìŠ¤íƒì„ ì¨ì„œ...ë‹¹ì—°íˆ... 
íŒì„ í•œ ë‹¤ìŒ, ìˆœíšŒë¥¼ í•˜ë©´ì„œ ë‚˜ëª¨ë‹¤ í° ì• ë¥¼ ë§Œë‚ ë•Œê¹Œì§€ ì¸ë±ìŠ¤ ê°ì†Œ?
ë” ìŠ¤íƒ ë…¼ë¦¬ë¥¼ í™œìš©í•  ìˆ˜ ìˆì„ ê±° ê°™ì€ë°.
íŒì„ í•˜ê³ 
6 9 5 7 4
íŒì„ í•œ ë‹¤ìŒ ê±”ë“¤ì„ ë‹¤ë¥¸ ìŠ¤íƒì— ì°¨ë¡€ë¡œ ì €ì¥í•˜ê³ , 
ë§Œì•½ íŒ ìš”ì†Œê°€ ê°ì†Œì„¸ë¥¼ ë³´ì´ë©´ ì­‰ ê°€ë‹¤ê°€
ì¦ê°€ì„¸ë¥¼ ë³´ì´ë©´? ë¹„êµí•´ì„œ ë°˜ëŒ€ìª½ì—ì„œ íŒí•´ì„œ ì¸ë±ìŠ¤ë¥¼ ì •í•˜ë©´ ë˜ë‚˜? 


3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

class Stack:
    def __init__(self, size):
        self.stack = [0] * size
        self.ptr = 0

    class Empty(Exception):
        def __init__(self, message="Stack is empty"):
            self.message= message
            super().__init__(self.message)

    class Full(Exception):
        def __init__(self, message="Stack is full"):
            self.message = message
            super().__init__(self.message)


    def is_empty(self):
        return self.ptr == 0
    
    def is_full(self):
        return self.ptr == self.size

    def __str__(self):
        return f'{self.stack[:self.ptr]}'
    
    def clear(self):
        self.ptr = 0

    def peek(self):
        if self.is_empty(): raise Stack.Empty
        return self.stack[self.ptr-1]
    
    def push(self, n):
        if self.is_full(): raise Stack.Full
        self.stack[self.ptr] = n
        self.ptr += 1

    def pop(self):
        if self.is_empty(): raise Stack.Empty
        tmp = self.stack[self.ptr-1] 
        self.ptr -= 1
        return tmp
    
    def size(self):
        return self.ptr
    
n = int(input())
ans = [0]*n
towers = tuple(map(int, input().split()))
towers_mapped  = [[]]*n
for i in range(n):
    towers_mapped[i] = (towers[i], i, 0)

# towers ìë£Œêµ¬ì¡°ë¥¼(ë†’ì´, ìê¸° ì¸ë±ìŠ¤, ë„ë‹¬í•œ ì¸ë±ìŠ¤)ë¡œ ê´€ë¦¬í•˜ë©´ ì•ˆ ë˜ë‚˜.
towers_pass1 = Stack(n)
towers_pass2 = Stack(n)

for tower in towers_mapped:
    towers_pass1.push(tower)


while not towers_pass1.is_empty():
    towers_pass2.push(towers_pass1.pop())
    while not towers_pass1.is_empty and towers_pass1.peek() < towers_pass2.peek(): # ê°ì†Œì„¸ì¸ ë™ì•ˆ íŒ í‘¸ì‹œ ë°˜ë³µ
        towers_pass2.push(towers_pass1.pop())
    # ë§Œì•½ ë‚¨ì•„ ìˆëŠ” íƒ‘ì´ ì—†ë‹¤ë©´
    if towers_pass1.is_empty(): 
        while not towers_pass2.is_empty():
            tower = towers_pass2.pop()
        break
    # ê°ì†Œì„¸ ì• ë“¤ì€ ë‹¤ ë„£ì—ˆê³ , ì´ì œ êº¼ë‚¼ ì• ëŠ” ë‹¤ í¼
    while not towers_pass2.is_empty() and towers_pass1.peek() > towers_pass2.peek():
        tower_from = towers_pass2.pop() # ë½‘ê³ , ì¸ë±ìŠ¤ëŠ” ì–´ë–»ê²Œ í•¨?
        tower_to = towers_pass1.peek()
        ans[tower_from[1]] = tower_to[1]+1

for a in ans:
    print(a, end=' ')
```

## Phase2. í”¼ë“œë°±

ğŸ¯ ë¬¸ì œ ìš”ì•½: [ë°±ì¤€ 2493 - íƒ‘]

â€¢	ê° íƒ‘ì€ ì™¼ìª½ ë°©í–¥ìœ¼ë¡œ ë ˆì´ì €ë¥¼ ì¨.

â€¢	ê° ë ˆì´ì €ëŠ” ìì‹ ë³´ë‹¤ ì™¼ìª½ì— ìˆëŠ” íƒ‘ ì¤‘ì—ì„œ ê°€ì¥ ë¨¼ì € ìì‹ ë³´ë‹¤ ë†’ì€ íƒ‘ì—ë§Œ ë„ë‹¬í•¨.

â€¢	ê° íƒ‘ë§ˆë‹¤, ìì‹ ì˜ ë ˆì´ì €ë¥¼ ìˆ˜ì‹ í•œ íƒ‘ì˜ ë²ˆí˜¸(1-based)ë¥¼ ì¶œë ¥í•˜ì‹œì˜¤. (ì—†ìœ¼ë©´ 0)

âœ… ë¬¸ì œ í•µì‹¬ ê°œë…

ì´ ë¬¸ì œëŠ” ì „í˜•ì ì¸ â€œëª¨ë…¸í† ë‹‰ ìŠ¤íƒ(Monotonic Stack)â€ ì‘ìš©ì…ë‹ˆë‹¤.

> â€œí˜„ì¬ íƒ‘ë³´ë‹¤

ğŸ” ë‹¹ì‹ ì˜ í’€ì´: ì˜ëœ ì 

â€¢	ğŸ‘ ìì²´ ìŠ¤íƒ í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ì„œ ì§ì ‘ ë¬¸ì œë¥¼ í•´ê²°í•œ ì ì€ ë©‹ì§„ ì‹œë„ì…ë‹ˆë‹¤. ìë£Œêµ¬ì¡° êµ¬í˜„ë ¥ë„ í‚¤ìš¸ ìˆ˜ ìˆê³ , êµ¬ì¡°ë„ íŒŒì•…í•˜ë ¤ í•œ í”ì ì´ ë³´ì—¬ìš”.

â€¢	ğŸ‘ ë¬¸ì œ ì¡°ê±´(ì™¼ìª½ì—ì„œ ì˜¤ëŠ” ë ˆì´ì €, ê°€ì¥ ë¨¼ì € ë§Œë‚˜ëŠ” ë†’ì€ íƒ‘)ì— ëŒ€í•´ ìŠ¤íƒ ê¸°ë°˜ êµ¬ì¡°ë¡œ í•´ê²°í•´ì•¼ê² ë‹¤ëŠ” í° ê·¸ë¦¼ì€ ì •í™•í•©ë‹ˆë‹¤.

â€¢	ğŸ‘€ towers_mapped = (ë†’ì´, ì¸ë±ìŠ¤) í˜•ì‹ìœ¼ë¡œ ë©”íƒ€ì •ë³´ë¥¼ í•¨ê»˜ ì²˜ë¦¬í•˜ë ¤ëŠ” ì ‘ê·¼ë„ ì•„ì£¼ ì¢‹ìŠµë‹ˆë‹¤.

ğŸ› ï¸ ê°œì„ í•  ìˆ˜ ìˆëŠ” ì 

1. ë³µì¡ë„ë¥¼ ì¤„ì´ëŠ” ë°©í–¥ìœ¼ë¡œ ë¦¬íŒ©í† ë§

ë‹¹ì‹ ì˜ ë¡œì§ì€ í¬ê²Œ ë³´ë©´ ë‹¤ìŒê³¼ ê°™ì´ ì‘ë™í•©ë‹ˆë‹¤:

â€¢	ëª¨ë“  íƒ‘ì„ ìŠ¤íƒì— ì§‘ì–´ë„£ê³  ì—­ìˆœìœ¼ë¡œ í•˜ë‚˜ì”© êº¼ë‚´ë©° ë¹„êµ

â€¢	ì˜¤ë¥¸ìª½ì—ì„œ ì™¼ìª½ìœ¼ë¡œ ì´ë™í•˜ë©´ì„œ ì™¼ìª½ì— ìˆëŠ” í° íƒ‘ì„ ì°¾ìœ¼ë ¤ í•¨

â†’ í•˜ì§€ë§Œ, ë‘ ê°œì˜ ìŠ¤íƒì„ ì™”ë‹¤ê°”ë‹¤ í•˜ë©´ì„œ ë¹„êµí•˜ëŠ” êµ¬ì¡°ëŠ” ë„ˆë¬´ ë³µì¡í•˜ê³ ,

ì´ ë¬¸ì œì˜ í•µì‹¬ì¸ **â€œì™¼ìª½ì„ í•œ ë²ˆë§Œ ë³´ë©´ì„œë„ ì •ë‹µì„ ìœ ì¶”í•  ìˆ˜ ìˆëŠ” êµ¬ì¡°â€**ë¥¼ ë†“ì¹  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

2. ì •ì„ ìŠ¤íƒ í’€ì´ êµ¬ì¡° ì œì•ˆ (ë” ê°„ë‹¨í•˜ê³  ì§ê´€ì )

```plain text
n = int(input())
heights = list(map(int, input().split()))
stack = []
result = [0] * n  # 1-based ê²°ê³¼ ì €ì¥

for i in range(n):
    # ì™¼ìª½ì— ë‚˜ë³´ë‹¤ ì‘ì€ íƒ‘ì€ ì „ë¶€ ì œê±° (ì‹ í˜¸ ë„ë‹¬ ë¶ˆê°€)
    while stack and heights[stack[-1]] < heights[i]:
        stack.pop()

    if stack:
        result[i] = stack[-1] + 1  # ì¸ë±ìŠ¤ â†’ íƒ‘ ë²ˆí˜¸ëŠ” 1-based

    stack.append(i)  # í˜„ì¬ íƒ‘ì˜ ì¸ë±ìŠ¤ë¥¼ ìŠ¤íƒì— ì €ì¥

print(*result)
```

í•µì‹¬ ì•„ì´ë””ì–´:

â€¢	ìŠ¤íƒì—ëŠ” ìì‹ ë³´ë‹¤ ë†’ì€ íƒ‘ì˜ ì¸ë±ìŠ¤ë§Œ ë‚¨ê¸°ê³ , ë‚˜ë¨¸ì§€ëŠ” ì „ë¶€ pop.

â€¢	ì´ ê³¼ì •ì—ì„œ ìŠ¤íƒ topì€ ê³§ í˜„ì¬ íƒ‘ì˜ ë ˆì´ì €ê°€ ë„ë‹¬í•˜ëŠ” ì²« íƒ‘ì´ ë¨.

ğŸ§  TIL ìš”ì•½

> â€œìì‹ ë³´ë‹¤ ì‘ì€ ê°’ì€ ì˜ë¯¸ê°€ ì—†ê³ ,

ğŸ’¡ ì¶”ê°€ í•™ìŠµ íŒ

ì´ ë¬¸ì œ ìœ í˜•ì€ ë‹¤ìŒê³¼ ê°™ì€ ë¬¸ì œë“¤ê³¼ ìœ ì‚¬í•©ë‹ˆë‹¤:

â€¢	ë°±ì¤€ 17298 - ì˜¤í°ìˆ˜

â€¢	ë°±ì¤€ 17299 - ì˜¤ë“±í°ìˆ˜

â€¢	ë°±ì¤€ 3015 - ì˜¤ì•„ì‹œìŠ¤ ì¬ê²°í•©

ì´ëŸ° ë¬¸ì œë“¤ì„ **â€œëª¨ë…¸í† ë‹‰ ìŠ¤íƒ ì‹œë¦¬ì¦ˆâ€**ë¡œ ë¬¶ì–´ ë°˜ë³µ í•™ìŠµí•˜ë©´ ì‹¤ë ¥ì´ ì‘¥ì‘¥ ëŠ˜ì–´ìš”.

í•„ìš”í•˜ì‹œë©´ Notion í…œí”Œë¦¿ í˜•íƒœë¡œ ì •ë¦¬í•´ë“œë¦´ ìˆ˜ë„ ìˆì–´ìš”. ê³„ì†í•´ì„œ ì‹¤ë ¥ì´ ìŒ“ì—¬ê°€ê³  ìˆìŠµë‹ˆë‹¤. í™”ì´íŒ…ì…ë‹ˆë‹¤!

# ìŠ¤íƒ: ì› ì˜ì—­

https://www.acmicpc.net/problem/10000

xì¶• ìœ„ì— ì›ì´ Nê°œ ìˆë‹¤. ì›ì€ ì„œë¡œ êµì°¨í•˜ì§€ ì•ŠëŠ”ë‹¤. í•˜ì§€ë§Œ, ì ‘í•  ìˆ˜ëŠ” ìˆë‹¤.

ì›ìœ¼ë¡œ ë§Œë“¤ì–´ì§€ëŠ” ì˜ì—­ì´ ëª‡ ê°œì¸ì§€ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

ì˜ì—­ì€ ì ì˜ ì§‘í•©ìœ¼ë¡œ ëª¨ë“  ë‘ ì ì€ ì›ì„ êµì°¨í•˜ì§€ ì•ŠëŠ” ì—°ì†ë˜ëŠ” ê³¡ì„ ìœ¼ë¡œ ì—°ê²°ë  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤.

## Phase1. ì‹¤íŒ¨

```python
"""
1. ë¬¸ì œ ì½ê¸°
ì´í•´ê°€ ì–´ë µì§€ëŠ” ì•ŠìŒ. ê·¸ëŸ°ë° ì™œ ìŠ¤íƒ ë¬¸ì œì¸ì§€ ì˜ ëª¨ë¥´ê² ìŒ.
ìŠ¤íƒ: ì„ ì…ì„ ì¶œ
ì´ ë¬¸ì œì—ì„œ ì„ ì…ì„ ì¶œì˜ ëŒ€ìƒì€? ì›? ì›ì„ ë¨¼ì € í‘¸ì‹œí•œë‹¤ê³  í•´ë´? 
ì› ì•ˆì— ì›ì´ ìˆëŠ”ì§€ ì› ë°–ì— ìˆëŠ”ì§€ë¥¼ ì•Œë©´ ë˜ëŠ” ê±° ì•„ë‹Œê°€? ê·¸ê±¸ë¡œ categorizationì´ 
ë  ê±° ê°™ì€ë°.
find í•¨ìˆ˜ë¡œ ì› ì•ˆì˜ ì›ì„ ì°¾ì•„ì„œ ì¬ê·€ì ìœ¼ë¡œ ìŠ¤íƒì„ ì¨ì•¼í•  ê²ƒìœ¼ë¡œ ë³´ì„.
ì¼ë‹¨ ë– ì˜¤ë¥´ëŠ” ì½”ë“œë¥¼ êµ¬í˜„í•´ë³´ê¹Œ?
2. ë¬¸ì œ í’€ê¸°
3. ìˆ˜ë„ ì½”ë“œ
ì „ì²´ ë°°ì—´ì„ ìœ ì§€
ì²« ë²ˆì§¸ ì›ì„ ì‘ì—…ìŠ¤íƒì— í‘¸ì‹œí•œë‹¤.
í‘¸ì‹œí•œ ì› ì•ˆì˜ ì›ì´ ì¡´ì¬í•˜ëŠ”ì§€ ì „ì²´ ë°°ì—´ì„ ê²€ì‚¬í•œë‹¤.
ì¡´ì¬í•œë‹¤ë©´ ì „ì²´ ë°°ì—´ì—ì„œ ì œê±°í•˜ê³  ì‘ì—… ìŠ¤íƒì— í‘¸ì‹œí•œë‹¤.
ê°™ì€ ì‘ì—…ì„ ë°˜ë³µí•œë‹¤.
êº¼ë‚´ë©´ì„œ ì˜ì—­ì„ ê²€ì‚¬í•œë‹¤? ì˜ í•˜ë©´ ë  ê±° ê°™ì€ë°? base circleì´ë¼ëŠ” ê°œë…ì´ ìˆì–´ì•¼ í•˜ì§€ ì•Šê² ë‚˜.
ì›ì„ ë½‘ìœ¼ë©´ì„œ ì¹´ìš´í„° 1 ì¦ê°€ì‹œí‚¤ë©´ ë˜ì§€ ë­. 
ê·¸ë¦¬ê³  findë¡œ ì•ˆì— ìˆëŠ”ê±° ë‹¤ ì°¾ê³  ë½‘ìœ¼ë©´ì„œ ê²€ì‚¬í•˜ëŠ” ê±°ê³ .
ê·¸ëŸ¬ë‹ˆê¹Œ ëª¨ë“  ì›ì— ëŒ€í•´ ìŠ¤íƒ ì—°ì‚°ì„ í•˜ê¸´ í•´ì•¼ í•˜ëŠ” ê±°ë‹¤. ë‚˜ì˜ ìˆ˜ë„ ì½”ë“œëŒ€ë¡œë©´
n ì€ 300,000ì´ë¼ì„œ ì¢€ í¬ê¸´ í•œë°.
ì´ê±° ì•„ë‹Œê±° ê°™ì•„.
4. ì½”ë“œ êµ¬í˜„
ì´
"""

from collections import deque

n = int(input())
circles = [[]]*n
for i in range(n):
    x, r = tuple(map(int, input().split()))
    circles[i] = (x-r, r+x)
print(circles)



def find_inner(circle: tuple):
    """ì› circleë³´ë‹¤ ì•ˆì— ìˆëŠ” ì›ì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ì™„ì „ íƒìƒ‰ìœ¼ë¡œ ì°¾ì•„ì„œ ë¦¬í„´í•©ë‹ˆë‹¤."""
    ans = []
    for circle_target in circles:
        if circle == circle_target: continue
        # ì°¾ì•˜ë‹¤ë©´
        if circle[0] <= circle_target[0] and circle_target[1] <= circle[1]:
            ans.append(circle_target)
    return ans

def solve():
    for circle in circles:
        stack = deque()
        stack.append(circle)
        while stack:
            c = stack.pop()
            inner_circles = find_inner(c)
            for c2 in inner_circles:
                stack.append(c2)
            print(f"inner circles of {c}: {inner_circles}")
            """ì´ëŸ¬ë©´ ìŠ¤íƒì„ ì“¸ ì´ìœ ê°€ ì—†ì§€!"""

solve()

"""
ì´ìŠˆ
Phase1.
Phase2.
"""
```

# í: ê°€ìš´ë°ë¥¼ ë§í•´ìš”

https://www.acmicpc.net/problem/1655

ë°±ì¤€ì´ëŠ” ë™ìƒì—ê²Œ "ê°€ìš´ë°ë¥¼ ë§í•´ìš”" ê²Œì„ì„ ê°€ë¥´ì³ì£¼ê³  ìˆë‹¤. ë°±ì¤€ì´ê°€ ì •ìˆ˜ë¥¼ í•˜ë‚˜ì”© ì™¸ì¹ ë•Œë§ˆë‹¤ ë™ìƒì€ ì§€ê¸ˆê¹Œì§€ ë°±ì¤€ì´ê°€ ë§í•œ ìˆ˜ ì¤‘ì—ì„œ ì¤‘ê°„ê°’ì„ ë§í•´ì•¼ í•œë‹¤. ë§Œì•½, ê·¸ë™ì•ˆ ë°±ì¤€ì´ê°€ ì™¸ì¹œ ìˆ˜ì˜ ê°œìˆ˜ê°€ ì§ìˆ˜ê°œë¼ë©´ ì¤‘ê°„ì— ìˆëŠ” ë‘ ìˆ˜ ì¤‘ì—ì„œ ì‘ì€ ìˆ˜ë¥¼ ë§í•´ì•¼ í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ ë°±ì¤€ì´ê°€ ë™ìƒì—ê²Œ 1, 5, 2, 10, -99, 7, 5ë¥¼ ìˆœì„œëŒ€ë¡œ ì™¸ì³¤ë‹¤ê³  í•˜ë©´, ë™ìƒì€ 1, 1, 2, 2, 2, 2, 5ë¥¼ ì°¨ë¡€ëŒ€ë¡œ ë§í•´ì•¼ í•œë‹¤. ë°±ì¤€ì´ê°€ ì™¸ì¹˜ëŠ” ìˆ˜ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ë™ìƒì´ ë§í•´ì•¼ í•˜ëŠ” ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. í’€ì–´ë³´ê¸°(ì‹¤íŒ¨)

```python
"""
1. ë¬¸ì œ ì½ê¸°: ì´í•´ê°€ ì–´ë µì§„ ì•ŠìŒ
2. ë¬¸ì œ í’€ê¸°: ìƒê°ë³´ë‹¤ ì–´ë ¤ì›€. ì•„ë˜ì²˜ëŸ¼ í•˜ë©´ ë  ê±° ê°™ì€ë° ì‹œê°„ì´ˆê³¼ ë‚¨. 
ë³µì¡ë„ë¥¼ ê³„ì‚°í•´ì„œ ë” ë‚˜ì€ ë°©ì‹ìœ¼ë¡œ í’€ì–´ì•¼ í•¨.


import heapq

arr = []
heapq.heapify(arr)

n = int(input())

def get_mid(arr: list): 
    tmp = []
    end = len(arr)//2 if len(arr)%2 == 0 else len(arr)//2+1
    mid = 0
    for _ in range(end):
        mid = heapq.heappop(arr)
        tmp.append(mid)
    for t in tmp:
        heapq.heappush(arr, t)
    return mid

def solve():
    global arr
    for _ in range(n):
        heapq.heappush(arr, int(input()))
        print(get_mid(arr))
        
    
solve()

3. ìˆ˜ë„ ì½”ë“œ

4. ì½”ë“œ êµ¬í˜„
"""



"""
ì´ìŠˆ
Phase1.
Phase2.
"""
```

## Phase2. í”¼ë“œë°±(ì •ë‹µ ì œì‹œ ê¸ˆì§€)

ì¢‹ìŠµë‹ˆë‹¤! ì§€ê¸ˆê¹Œì§€ì˜ ì‹œë„ì™€ ì ‘ê·¼ì€ ì¶©ë¶„íˆ ì˜ë¯¸ ìˆì—ˆê³ , ì§€ê¸ˆì´ ë°”ë¡œ ì •ë‹µì€ ë³´ì§€ ì•Šê³  êµ¬ì¡°ë§Œ ì¡ì•„ë‚˜ê°€ê¸°ì— ë”± ì¢‹ì€ íƒ€ì´ë°ì…ë‹ˆë‹¤.

âœ… í˜„ì¬ ì½”ë“œì˜ í•µì‹¬ í•œê³„

ë‹¹ì‹ ì´ ì‚¬ìš©í•œ ë°©ì‹ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

â€¢	ìš°ì„ ìˆœìœ„ í (min heap)ì— ì›ì†Œë¥¼ ì‚½ì…

â€¢	ë§¤ë²ˆ popì„ ì—¬ëŸ¬ ë²ˆ í•˜ë©´ì„œ ì¤‘ê°„ê°’ ì¶”ì¶œ í›„ ë‹¤ì‹œ push â†’ ì‹œê°„ë³µì¡ë„: O(N \log N) ì´ìƒ

âŒ ë¬¸ì œì :

â€¢	heapqëŠ” ì •ë ¬ëœ ìˆœì„œë¥¼ ë³´ì¥í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì—, ì¤‘ê°„ê°’ì„ êµ¬í•˜ë ¤ë©´ ë§¤ë²ˆ pop/push ë°˜ë³µì´ í•„ìš”

â€¢	ê²°êµ­ ë§¤ ì…ë ¥ë§ˆë‹¤ í™ ì „ì²´ë¥¼ íƒìƒ‰í•˜ë“¯ì´ ë™ì‘í•˜ê²Œ ë˜ì–´, ì‹œê°„ ì´ˆê³¼ ë°œìƒ

ğŸ§  í•µì‹¬ ê°œë…: ë‘ ê°œì˜ í™

ì´ ë¬¸ì œë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ í•´ê²°í•˜ê¸° ìœ„í•œ ê°€ì¥ í•µì‹¬ ì•„ì´ë””ì–´ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

> ì¤‘ê°„ê°’ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ íš¨ìœ¨ì ìœ¼ë¡œ ì°¾ê¸° ìœ„í•´, â€œì‘ì€ ê°’ë“¤ë§Œ ë‹´ëŠ” í™â€ê³¼ â€œí° ê°’ë“¤ë§Œ ë‹´ëŠ” í™â€ì„ ë™ì‹œì— ìœ ì§€í•œë‹¤.

ğŸ§© êµ¬ì¡°:

ğŸ”§ ì„¤ê³„ ì „ëµ

ğŸ“Œ ë™ì‘ ì›ë¦¬:

â€¢	ìˆ˜ë¥¼ í•˜ë‚˜ì”© ì½ì„ ë•Œë§ˆë‹¤ ë‘ í™ì˜ ë°¸ëŸ°ìŠ¤ë¥¼ ìœ ì§€

â€¢	left_heap(ì‘ì€ ìˆ˜ë“¤)ì˜ ê¸¸ì´ê°€ right_heapë³´ë‹¤ ê°™ê±°ë‚˜ 1 ë” ë§ê²Œ ìœ ì§€

â€¢	ë§¤ ì…ë ¥ë§ˆë‹¤:

â€¢	ë¨¼ì € left_heapì— push (ì¤‘ê°„ê°’ í›„ë³´ë‹ˆê¹Œ)

â€¢	ê·¸ í›„ left_heapì˜ ìµœëŒ€ê°’ê³¼ right_heapì˜ ìµœì†Œê°’ì„ ë¹„êµí•´ì„œ ìˆœì„œê°€ ì–´ê¸‹ë‚˜ë©´ swap

â€¢	ê¸¸ì´ ê· í˜•ì´ ë§ì§€ ì•Šìœ¼ë©´ í•œìª½ì—ì„œ ë‹¤ë¥¸ ìª½ìœ¼ë¡œ ì´ë™

ğŸ“Œ ì¤‘ê°„ê°’ ê²°ì •:

â€¢	ë¬´ì¡°ê±´ left_heap[0]ì´ í˜„ì¬ê¹Œì§€ì˜ ì¤‘ê°„ê°’

âœï¸ Phase2 ëª©í‘œ

ë‹¹ì‹ ì˜ ëª©í‘œëŠ” ì§€ê¸ˆê¹Œì§€ì˜ êµ¬ì¡°ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë‹¤ìŒì˜ ë¡œì§ë§Œ ì¬ì •ì˜í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤:

```plain text
# ë‘ ê°œì˜ í™ ì •ì˜
left_heap = []   # max heap (ìŒìˆ˜ë¡œ push)
right_heap = []  # min heap

# ë§¤ ì…ë ¥ë§ˆë‹¤ ë‹¤ìŒ ë¡œì§
1. ìƒˆ ìˆ«ì xë¥¼ left_heapì— push(-x)
2. left_heapì˜ ìµœëŒ€ê°’(-left_heap[0]) > right_heapì˜ ìµœì†Œê°’ì´ë¼ë©´ êµí™˜
3. ë‘ í™ í¬ê¸°ë¥¼ ì¡°ì •: left_heapì€ í•­ìƒ right_heapë³´ë‹¤ í¬ê±°ë‚˜ ê°™ë„ë¡
4. ì •ë‹µì€ -left_heap[0]
```

ğŸ§© ì§ì ‘ êµ¬í˜„ ì „ì— ì ê²€í•  ì§ˆë¬¸ë“¤

â€¢	ì™œ í™ì´ ë‘ ê°œ í•„ìš”í•˜ì§€?

â€¢	ì¤‘ê°„ê°’ì„ ì¶”ì¶œí•˜ê¸° ìœ„í•´ ì–´ë–¤ ì¡°ê±´ì„ ìœ ì§€í•´ì•¼ í•˜ì§€?

â€¢	ì¤‘ê°„ê°’ì´ ë°”ë€ŒëŠ” ê¸°ì¤€ì€ ì–´ë–¤ ê²½ìš°ì§€?

ğŸ§ª ì¶”ì²œ í…ŒìŠ¤íŠ¸

í…ŒìŠ¤íŠ¸ëŠ” ë‹¤ìŒ ì…ë ¥ìœ¼ë¡œ í•´ë³´ì„¸ìš”:

```plain text
7
1
5
2
10
-99
7
5
```

ì¶œë ¥ì€:

```plain text
1
1
2
2
2
2
5
```

ì´ê±¸ ì§ì ‘ ë§ì¶°ë³´ëŠ” ê²ƒì´ ì¤‘ê°„ê°’ êµ¬ì¡°ê°€ ì˜ ìœ ì§€ë˜ëŠ”ì§€ íŒë‹¨í•˜ëŠ” ì¢‹ì€ ë°©ë²•ì…ë‹ˆë‹¤.

âœ… ë§ˆë¬´ë¦¬ ì¡°ì–¸

ì´ ë¬¸ì œëŠ” ë§ì€ ê³ ê¸‰ ë¬¸ì œë“¤ì˜ ì „ì‹ ì…ë‹ˆë‹¤:

â€¢	sliding window median

â€¢	running median

â€¢	lower_bound/upper_bound ê°œë… í™œìš© ë“±

ì •ë‹µ ì½”ë“œ ì—†ì´ ì§ì ‘ ë‘ í™ êµ¬ì¡°ë¥¼ ë§Œë“¤ì–´ë³´ê³  ì„±ê³µí•´ë³´ì„¸ìš”.

ê·¸ê²Œ ê°€ì¥ ë¹ ë¥¸ ì„±ì¥ì˜ ì§€ë¦„ê¸¸ì…ë‹ˆë‹¤.

í•„ìš”í•˜ë‹¤ë©´ â€œìŒìˆ˜ë¡œ ë„£ì–´ì„œ max heap ë§Œë“¤ê¸°â€ë¥¼ ë„ì™€ë“œë¦´ ìˆ˜ë„ ìˆì–´ìš”.

í™”ì´íŒ…ì…ë‹ˆë‹¤!

## Phase3. í”¼ë“œë°± í›„ ë‹¤ì‹œ í’€ê¸°-ì„±ê³µ

```python
"""
1. ë¬¸ì œ ì½ê¸°: ì´í•´ê°€ ì–´ë µì§„ ì•ŠìŒ
2. ë¬¸ì œ í’€ê¸°: ìƒê°ë³´ë‹¤ ì–´ë ¤ì›€. ì•„ë˜ì²˜ëŸ¼ í•˜ë©´ ë  ê±° ê°™ì€ë° ì‹œê°„ì´ˆê³¼ ë‚¨. 
ë³µì¡ë„ë¥¼ ê³„ì‚°í•´ì„œ ë” ë‚˜ì€ ë°©ì‹ìœ¼ë¡œ í’€ì–´ì•¼ í•¨.
3. ìˆ˜ë„ ì½”ë“œ
ì´ê±° ì–´ë–»ê²Œ í’€ë”ë¼. í™ì„ ë‘ ê°œ ë§Œë“¤ê³ , ìƒˆë¡œìš´ ì• ë¥¼ ë£¨íŠ¸ì™€ ë¹„êµí•´ì„œ 
ë¯¼í™ê³¼ ë§¥ìŠ¤í™ì„ ìœ ì§€í•˜ëŠ”ë°, ë¯¼í™ì€ í•­ìƒ ë§¥ìŠ¤í™ë³´ë‹¤ 1 ë§ê²Œ. 
ë¯¼í™ì˜ ë£¨íŠ¸ì™€ ë§¥ìŠ¤í™ì˜ ë£¨íŠ¸ë¥¼ ë¹„êµí•˜ê³ , ë§Œì•½ ë§¥ìŠ¤í™ ìª½ì´ ë” í¬ë©´ ë¯¼í™ ë£¨íŠ¸ì™€ ìŠ¤ì™‘
í¬ê¸° ê·œì¹™ì„ ì´ˆê³¼í•´ë„ ì˜®ê²¨ì£¼ê³  ìŠ¤ì™‘.
ì¼ë‹¨ ë‹¤ ë¯¼ í™ìœ¼ë¡œ ëª°ì•„ ë„£ì–´ì£¼ê¸°

4. ì½”ë“œ êµ¬í˜„
"""
import sys

import heapq


def solve():
    n = int(sys.stdin.readline().strip())
    # ë£¨íŠ¸ê°€ rightí™ë³´ë‹¤ í¬ë‹¤ë©´ ìŠ¤ì™‘
    left_heap = [] # right_heapë³´ë‹¤ 1 í¬ê±°ë‚˜ ê°™ê²Œ. 
    right_heap = []
    left_l, right_l = 0, 0
    heapq.heapify(left_heap) # min heap!
    heapq.heapify(right_heap) # max heap!
    for _ in range(n):
        x = int(sys.stdin.readline().strip())
        # print(f'input value: {x}')
        heapq.heappush(left_heap, -x)
        left_l += 1
        # print(f'initially pushing it to left heap: {left_heap}, size: {left_l}')
        if left_l-2 == right_l:
            # print(f'left heap got bigger: {left_l} v {right_l}')
            heapq.heappush(right_heap, (-heapq.heappop(left_heap)))
            left_l -= 1
            right_l += 1
            # print(f'now balanced: {left_heap}, {right_heap}')
        if right_l > 0:
            # compare
            left_root = -heapq.heappop(left_heap)
            right_root = heapq.heappop(right_heap)
            # print(f'comparing {left_root}  vs {right_root}')
            if left_root > right_root:
                # should be replaced
                left_root, right_root = right_root, left_root
                # print(f'swapped')
            heapq.heappush(right_heap, right_root)
            heapq.heappush(left_heap, -left_root)
            # print(f'after swapping: {left_heap}, {right_heap}')
        else:
            # right heapì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°
            left_root = -heapq.heappop(left_heap)
            # ê·¸ëƒ¥ ê¸°ë¡ë§Œ í•˜ê³  ì €ì¥
            heapq.heappush(left_heap, -left_root)
        
        print(left_root)
solve()


        
"""
ì´ìŠˆ: 1,2,3 ì…ë ¥ ì‹œ ì—ëŸ¬

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸

10
1
input value: 1
initially pushing it to left heap: [1], size: 1
1
2
input value: 2
initially pushing it to left heap: [1, 2], size: 2
left heap got bigger: 2 v 0
now balanced: [2], [-1]
comparing 2  vs 1
swapped
after swapping: [1], [-2]
1
3
input value: 3
initially pushing it to left heap: [1, 3], size: 2
comparing 1  vs 2
after swapping: [1, 3], [-2]
1

ìµœê·¼ ë³€ê²½ ì‚¬í•­: min heap, max heapì„ ì´ìš©í•œ êµ¬í˜„

Phase2.
í™•ì¸: 1,2,3 ì¼ë•Œ, 1, 2ê°€ ì™¼ìª½ì—, 3ì´ ì˜¤ë¥¸ìª½ì— ë“¤ì–´ê°€ì•¼ í•˜ëŠ”ë°, í™ íŠ¹ì„±ìƒ
ê·¸ë ‡ê²Œ ì•ˆ ë˜ê³  ìˆìŒ.
ì–´ë–»ê²Œ í•˜ëŠ”ë° ê·¸ëŸ¼? 
3 ë„£ì„ ë•Œ, ì¼ë‹¨ 1, 3 / 2ê°€ ë˜ê³ , ì—¬ê¸°ì„œ...ê·¸ëŸ¼ ì˜¤ë¥¸ìª½ì´ min heapì´ì–´ì•¼ í•˜ëŠ” ê±° ì•„ëƒ?

1 ì´ê±° ë°¸ëŸ°ìŠ¤ ë§ì¶œ ë•Œë„ í° ìª½ì„ ë°‘ì— ë„£ê³  (ê·¸ëŸ¼ ë§¥ìŠ¤ê°’ì´ê³ )
2

1 3 ì´ë•ŒëŠ”? 3ê³¼ 2 ë¹„êµí•´ì„œ ìŠ¤ì™‘
2

1 2
3

-1 1  ì´ë ‡ê²Œ ë˜ê³ . ê·¸ì§€?
3 2

ê·¸ëŸ¼ ìœ„ìª½ì´ ë§¥ìŠ¤í™, ì•„ë˜ìª½ì´ ë¯¼í™ì´ì–´ì•¼ í•œë‹¤.
ì‹œë„: ê·¸ë ‡ê²Œ ë°”ê¿”ì¤Œ
ë¶„ì„: ì„±ê³µ
"""
```



# ìš°ì„ ìˆœìœ„ í: ì¹´ë“œ ì •ë ¬í•˜ê¸°

https://jungle-compass.krafton.com/mod/page/view.php?id=6123

ì •ë ¬ëœ ë‘ ë¬¶ìŒì˜ ìˆ«ì ì¹´ë“œê°€ ìˆë‹¤ê³  í•˜ì. ê° ë¬¶ìŒì˜ ì¹´ë“œì˜ ìˆ˜ë¥¼ A, Bë¼ í•˜ë©´ ë³´í†µ ë‘ ë¬¶ìŒì„ í•©ì³ì„œ í•˜ë‚˜ë¡œ ë§Œë“œëŠ” ë°ì—ëŠ” A+B ë²ˆì˜ ë¹„êµë¥¼ í•´ì•¼ í•œë‹¤. ì´ë¥¼í…Œë©´, 20ì¥ì˜ ìˆ«ì ì¹´ë“œ ë¬¶ìŒê³¼ 30ì¥ì˜ ìˆ«ì ì¹´ë“œ ë¬¶ìŒì„ í•©ì¹˜ë ¤ë©´ 50ë²ˆì˜ ë¹„êµê°€ í•„ìš”í•˜ë‹¤.

ë§¤ìš° ë§ì€ ìˆ«ì ì¹´ë“œ ë¬¶ìŒì´ ì±…ìƒ ìœ„ì— ë†“ì—¬ ìˆë‹¤. ì´ë“¤ì„ ë‘ ë¬¶ìŒì”© ê³¨ë¼ ì„œë¡œ í•©ì³ë‚˜ê°„ë‹¤ë©´, ê³ ë¥´ëŠ” ìˆœì„œì— ë”°ë¼ì„œ ë¹„êµ íšŸìˆ˜ê°€ ë§¤ìš° ë‹¬ë¼ì§„ë‹¤. ì˜ˆë¥¼ ë“¤ì–´ 10ì¥, 20ì¥, 40ì¥ì˜ ë¬¶ìŒì´ ìˆë‹¤ë©´ 10ì¥ê³¼ 20ì¥ì„ í•©ì¹œ ë’¤, í•©ì¹œ 30ì¥ ë¬¶ìŒê³¼ 40ì¥ì„ í•©ì¹œë‹¤ë©´ (10 + 20) + (30 + 40) = 100ë²ˆì˜ ë¹„êµê°€ í•„ìš”í•˜ë‹¤. ê·¸ëŸ¬ë‚˜ 10ì¥ê³¼ 40ì¥ì„ í•©ì¹œ ë’¤, í•©ì¹œ 50ì¥ ë¬¶ìŒê³¼ 20ì¥ì„ í•©ì¹œë‹¤ë©´ (10 + 40) + (50 + 20) = 120 ë²ˆì˜ ë¹„êµê°€ í•„ìš”í•˜ë¯€ë¡œ ëœ íš¨ìœ¨ì ì¸ ë°©ë²•ì´ë‹¤.

Nê°œì˜ ìˆ«ì ì¹´ë“œ ë¬¶ìŒì˜ ê°ê°ì˜ í¬ê¸°ê°€ ì£¼ì–´ì§ˆ ë•Œ, ìµœì†Œí•œ ëª‡ ë²ˆì˜ ë¹„êµê°€ í•„ìš”í•œì§€ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. í’€ì–´ë³´ê¸°(ì‹¤íŒ¨)

```python
"""
1. ë¬¸ì œ ì½ê¸°: 
2. ë¬¸ì œ í’€ê¸°
10, 20, 40

pass1       pass2
10 + 20     30 + 40 = 100
calc order
10 + 20 + 30 + 40 = 100
10 + 40     50 + 20 = 50+70 = 120
4
10 20 30 40 
10 + 20 +30 + 60 + 40 
ë¬´ì¡°ê±´ ì‘ì€ ì• ë“¤ë¼ë¦¬ ë”í•˜ë©´ ì¢‹ì€ ê±´ê°€? ê·¸ëŸ°ë“¯. ê·¸ëƒ¥ ê·¸ë ‡ê²Œ ê·¸ë¦¬ë””í•˜ê²Œ í•˜ë©´ ë ë“¯
ë‚´ê°€ ë¬¸ì œë¥¼ ì´í•´ë¥¼ ëª»í•œ ê±° ê°™ë‹¤. 10, 20, 30, 40 ë¬¶ìŒ ì¹´ë“œê°€ ì£¼ì–´ì¡Œì„ ë•Œ
ì´ë“¤ì„ ìµœì € ë¹„êµë¡œ í•©ì¹˜ëŠ” ë°©ë²•ì€!
ì¼ë‹¨. 
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys, heapq
h = []
heapq.heapify(h)
n = int(sys.stdin.readline().strip())
for _ in range(n):
    deck_num  = heapq.heappush(h, int(sys.stdin.readline().strip()))

ans = heapq.heappop(h)
ans2 = 0
while h:
    popped = heapq.heappop(h)
    # print(f'{ans}+{popped}={ans+popped}')
    ans += popped
    ans2 += ans
    
# print(ans)
print(ans2)

"""
ì´ìŠˆ: ì˜¤ë‹µ

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: í‹€ë ¸ìŠµë‹ˆë‹¤.
ìµœê·¼ ë³€ê²½ ì‚¬í•­: í™ìœ¼ë¡œ ê·¸ë¦¬ë””í•˜ê²Œ ìµœì†Œ ë”í•˜ê¸° ì—°ì‚°ì„ í•˜ëŠ” ì½”ë“œ ì‘ì„±.

Phase2.
í™•ì¸: í‹€ë¦° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ê°€ ì¡´ì¬í•œë‹¤ëŠ” ì˜ë¯¸. 2í”„ë¡œì—ì„œ í‹€ë ¸ìœ¼ë¯€ë¡œ ê¸ˆë°© ì°¾ì„ ìˆ˜ ìˆê³ ,
ì½”ë“œì— ì¤‘ëŒ€í•œ ë…¼ë¦¬ì  ì˜¤ë¥˜ê°€ ìˆìŒì„ ì‹œì‚¬.
5
10
20
30
40
50
340

10 + 20 = 30
30 + 30 = 60
60 + 40 = 100
100 + 50 = 150
30 + 60 + 100 + 150
ì´ëŸ° ëŠë‚Œ..ì´ë©´ ë”±íˆ í‹€ë¦´ ê±´ ì—†ëŠ”ë°. 10ë¶„ ë” ìƒê°í•´ë³´ê³  íŒ¨ìŠ¤í•©ì‹œë‹¤.
ì¹´ë“œ ê°œìˆ˜ê°€ 1ì´ë©´ ì„ì„ ì¼ ì—†ì´ 0ì´ ë‚˜ì˜¤ë‹ˆ ê·¸ê²ƒë„ ì •ìƒ.

10
20
40
50

10 + 20 = 30
30 + 40 = 70
70 + 50 = 120
ì•„ ì—¬ê¸°ì„œ 110 ë‚˜ì™€ì•¼ ë˜ëŠ”ë°, ans2ê°€ ì˜ëª» ê°€ì‚°ë˜ëŠ” ê±´ê°€.
ê·¸ëƒ¥ ë‚´ê°€ ë¬¸ì œë¥¼ ì´í•´ ëª»í•œ ê±° ê°™ë‹¤.
ì‹œë„: 
ë¶„ì„: 
"""
```

## Phase2. í”¼ë“œë°±(ì •ë‹µ ì œì‹œ ê¸ˆì§€)

ì¢‹ì•„ìš”, ì´ë²ˆì—ë„ í’€ì´ í”ì ì„ ì˜ ë‚¨ê¸°ì…¨ê³ , ë¬´ì—‡ë³´ë‹¤ í‹€ë¦° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì— ëŒ€í•´ ì§ì ‘ ë¶„ì„í•˜ê³ ì ì‹œë„í•˜ì‹  ì ì´ ì•„ì£¼ ì¢‹ìŠµë‹ˆë‹¤.

âœ… í˜„ì¬ ì½”ë“œì˜ í•µì‹¬ ë¬¸ì œì 

ğŸ”¥ ë…¼ë¦¬ì  í•µì‹¬ ì‹¤ìˆ˜:

```plain text
ans = heapq.heappop(h)
ans2 = 0
while h:
    popped = heapq.heappop(h)
    ans += popped
    ans2 += ans
```

ì´ ì½”ë“œëŠ” **â€œê°€ì¥ ì‘ì€ ê°’ í•˜ë‚˜ë¥¼ ë¹¼ì„œ ansì— ì €ì¥í•˜ê³ , ë‚¨ì€ ê²ƒë“¤ê³¼ ì°¨ë¡€ëŒ€ë¡œ ë”í•´ê°€ê¸°â€**ì¸ë°ìš”,

ì—¬ê¸°ì„œì˜ í° ë¬¸ì œëŠ”:

â€¢	ansë¥¼ ëˆ„ì í•˜ê³  ìˆë‹¤ëŠ” ê²ƒ!

â€¢	**ì´ ë¬¸ì œëŠ” â€œë‘ ë¬¶ìŒì„ ë”í•œ ê²°ê³¼ë¥¼ ë‹¤ì‹œ í™ì— ë„£ê³ , ë‹¤ìŒ ë‘ ë¬¶ìŒì„ ë˜ ê³ ë¥´ëŠ” êµ¬ì¡°â€**ì…ë‹ˆë‹¤.

ì¦‰, ë§¤ ì—°ì‚°ë§ˆë‹¤ â€œë‘ ê°œë¥¼ ë”í•œ ê°’ì„ ë‹¤ì‹œ í™ì— pushâ€í•´ì•¼ ë‹¤ìŒ ì—°ì‚°ì—ì„œë„ ì“¸ ìˆ˜ ìˆê³ ,

ê·¸ë•Œë§ˆë‹¤ ìƒê¸°ëŠ” â€œë¹„êµ íšŸìˆ˜â€ë¥¼ ë”í•´ê°€ëŠ” êµ¬ì¡°ì—¬ì•¼ í•©ë‹ˆë‹¤.

ğŸ§  ë¬¸ì œì˜ ë³¸ì§ˆ

â€œë‘ ì¹´ë“œ ë¬¶ìŒì„ í•©ì¹  ë•Œ ë¹„ìš©ì´ A + Bê°€ ë˜ê³ , ê·¸ ê²°ê³¼ A + B ë¬¶ìŒì€ ë‹¤ì‹œ í™ì— ë“¤ì–´ê°€ì•¼ í•œë‹¤.â€

ì´ ë§ì€ ê²°êµ­, ë§¤ ì—°ì‚°ë§ˆë‹¤ ê°€ì¥ ì‘ì€ ë‘ ë¬¶ìŒì„ êº¼ë‚´ì„œ í•©ì¹œ ë‹¤ìŒ,

â€¢	ê·¸ í•©ì¹œ ë¬¶ìŒì„ ë‹¤ìŒ ì—°ì‚°ì— ë‹¤ì‹œ ì‚¬ìš©í•˜ë„ë¡ í™ì— ë„£ì–´ì•¼ í•œë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.

ì¦‰, ëˆ„ì ëœ ì´ ë¹„êµ íšŸìˆ˜ë§Œ ë”°ë¡œ ê´€ë¦¬í•˜ê³ ,

í•©ì³ì§„ ì¹´ë“œ ë¬¶ìŒì€ ê³„ì† í™ì— ë„£ê³ ,

í™ì— í•˜ë‚˜ ë‚¨ì„ ë•Œê¹Œì§€ ë°˜ë³µí•´ì•¼ í•©ë‹ˆë‹¤.

âœ… ì •ë¦¬ëœ ê°œì„  ì•„ì´ë””ì–´

ì˜¬ë°”ë¥¸ íë¦„:

```plain text
1. í™ì— ëª¨ë“  ì¹´ë“œ ë¬¶ìŒ ì‚½ì…
2. while í™ì˜ í¬ê¸°ê°€ 2 ì´ìƒ:
    - ê°€ì¥ ì‘ì€ ë‘ ë¬¶ìŒì„ êº¼ëƒ„ (A, B)
    - A + B â†’ ë¹„êµ íšŸìˆ˜ ì¶”ê°€
    - í•©ì¹œ ì¹´ë“œ ë¬¶ìŒ (A + B)ì„ ë‹¤ì‹œ í™ì— ì‚½ì…
3. ëˆ„ì ëœ ë¹„êµ íšŸìˆ˜ ë°˜í™˜
```

ì´ê±´ ì „í˜•ì ì¸ ê·¸ë¦¬ë”” + ìš°ì„ ìˆœìœ„ í ë¬¸ì œì…ë‹ˆë‹¤.

í•­ìƒ ê°€ì¥ ì‘ì€ ë‘ ë¬¶ìŒì„ ì„ íƒí•´ì„œ ë¹„êµ íšŸìˆ˜ë¥¼ ì¤„ì´ê¸° ë•Œë¬¸ì´ì£ .

âœï¸ TIL ì¶”ì²œ ì •ë¦¬

```plain text
# ì¹´ë“œ ì •ë ¬í•˜ê¸° ë¬¸ì œ ì‹¤íŒ¨ ì›ì¸
- âŒ ì‹¤ìˆ˜: ì²˜ìŒ ì¹´ë“œ ë¬¶ìŒ í•˜ë‚˜(ans)ë¥¼ ê³ ì •í•˜ê³ , ì´í›„ ëˆ„ì í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í•©ì‚°í–ˆìŒ
- âœ… ì •ë‹µ ë°©í–¥: í•­ìƒ ê°€ì¥ ì‘ì€ ë‘ ë¬¶ìŒì„ êº¼ë‚´ì„œ í•©ì¹œ ë’¤ ë‹¤ì‹œ í™ì— ë„£ê³ , ê·¸ ë¹„ìš©ì„ ëˆ„ì 
- ğŸ¯ í•µì‹¬ í¬ì¸íŠ¸: â€œì‘ì€ ì¹´ë“œë¼ë¦¬ ë¨¼ì € í•©ì³ì•¼ ì „ì²´ ë¹„êµ íšŸìˆ˜ê°€ ìµœì†Œê°€ ëœë‹¤â€ëŠ” **ê·¸ë¦¬ë”” êµ¬ì¡°**
- ğŸ” ìŠ¤ìŠ¤ë¡œ í•´ì„í•  ìˆ˜ ìˆëŠ” ê³µì‹:
    â€œìš°ì„ ìˆœìœ„ íì—ì„œ ìµœì†Œ ë‘ ê°’ì„ ë°˜ë³µì ìœ¼ë¡œ êº¼ë‚´ì„œ ëˆ„ì  ë¹„ìš© ê³„ì‚°â€
```

í•„ìš”í•˜ì‹œë©´ ì •ë‹µ ì—†ì´ í…ŒìŠ¤íŠ¸ í†µê³¼ êµ¬ì¡°ë§Œ ìœ ë„í•´ë“œë¦´ ìˆ˜ë„ ìˆì–´ìš”.

ë˜ëŠ” C++ì´ë‚˜ Javaë¡œë„ ë™ì¼ êµ¬ì¡° ë³´ê³  ì‹¶ë‹¤ë©´ ë§ì”€ ì£¼ì„¸ìš”!

ì´ ë¬¸ì œ ì´í›„ì—ëŠ” ë‹¤ìµìŠ¤íŠ¸ë¼, í—ˆí”„ë§Œ ì¸ì½”ë”©, CPU ìŠ¤ì¼€ì¤„ë§ ê°™ì€ ìš°ì„ ìˆœìœ„ í ê¸°ë°˜ ë¬¸ì œë¡œ ìì—°ìŠ¤ëŸ½ê²Œ í™•ì¥ë©ë‹ˆë‹¤ :)

## Phase3. í”¼ë“œë°± í›„ ì§ì ‘ í’€ê¸°

ê·¸ëƒ¥ ë¬¸ì œ ì›ë¦¬ ì½ìœ¼ë‹ˆê¹Œ ì‚¬ì‹¤ ë­ í• ê²Œ ì—†ëŠ” ë¬¸ì œì˜€ìŒâ€¦ê·¸ëƒ¥ ìë£Œêµ¬ì¡°ë¥¼ ì˜ í™œìš©í•  ìˆ˜ ìˆëŠ”ì§€ ë¬»ëŠ” ë¬¸ì œ.

```python

import sys, heapq
h = []
heapq.heapify(h)
n = int(sys.stdin.readline().strip())
for _ in range(n):
    heapq.heappush(h, int(sys.stdin.readline().strip()))
cnt = n
cost = 0
while cnt > 1:
    tmp = heapq.heappop(h) + heapq.heappop(h)
    heapq.heappush(h, tmp)
    cost += tmp
    cnt -= 1
    
# print(ans)
print(cost)

```

# ìš°ì„ ìˆœìœ„ í, ê·¸ë¦¬ë””: ì² ë¡œ

https://www.acmicpc.net/problem/13334

ì§‘ê³¼ ì‚¬ë¬´ì‹¤ì„ í†µê·¼í•˜ëŠ” nëª…ì˜ ì‚¬ëŒë“¤ì´ ìˆë‹¤. ê° ì‚¬ëŒì˜ ì§‘ê³¼ ì‚¬ë¬´ì‹¤ì€ ìˆ˜í‰ì„  ìƒì— ìˆëŠ” ì„œë¡œ ë‹¤ë¥¸ ì ì— ìœ„ì¹˜í•˜ê³  ìˆë‹¤. ì„ì˜ì˜ ë‘ ì‚¬ëŒ A, Bì— ëŒ€í•˜ì—¬, Aì˜ ì§‘ í˜¹ì€ ì‚¬ë¬´ì‹¤ì˜ ìœ„ì¹˜ê°€ Bì˜ ì§‘ í˜¹ì€ ì‚¬ë¬´ì‹¤ì˜ ìœ„ì¹˜ì™€ ê°™ì„ ìˆ˜ ìˆë‹¤. í†µê·¼ì„ í•˜ëŠ” ì‚¬ëŒë“¤ì˜ í¸ì˜ë¥¼ ìœ„í•˜ì—¬ ì¼ì§ì„  ìƒì˜ ì–´ë–¤ ë‘ ì ì„ ì‡ëŠ” ì² ë¡œë¥¼ ê±´ì„¤í•˜ì—¬, ê¸°ì°¨ë¥¼ ìš´í–‰í•˜ë ¤ê³  í•œë‹¤. ì œí•œëœ ì˜ˆì‚° ë•Œë¬¸ì—, ì² ë¡œì˜ ê¸¸ì´ëŠ” dë¡œ ì •í•´ì ¸ ìˆë‹¤. ì§‘ê³¼ ì‚¬ë¬´ì‹¤ì˜ ìœ„ì¹˜ ëª¨ë‘ ì² ë¡œ ì„ ë¶„ì— í¬í•¨ë˜ëŠ” ì‚¬ëŒë“¤ì˜ ìˆ˜ê°€ ìµœëŒ€ê°€ ë˜ë„ë¡, ì² ë¡œ ì„ ë¶„ì„ ì •í•˜ê³ ì í•œë‹¤.

ì–‘ì˜ ì •ìˆ˜ dì™€ n ê°œì˜ ì •ìˆ˜ìŒ, (hi, oi), 1 â‰¤ i â‰¤ n,ì´ ì£¼ì–´ì ¸ ìˆë‹¤. ì—¬ê¸°ì„œ hiì™€ oiëŠ” ì‚¬ëŒ iì˜ ì§‘ê³¼ ì‚¬ë¬´ì‹¤ì˜ ìœ„ì¹˜ì´ë‹¤. ê¸¸ì´ dì˜ ëª¨ë“  ì„ ë¶„ Lì— ëŒ€í•˜ì—¬, ì§‘ê³¼ ì‚¬ë¬´ì‹¤ì˜ ìœ„ì¹˜ê°€ ëª¨ë‘ Lì— í¬í•¨ë˜ëŠ” ì‚¬ëŒë“¤ì˜ ìµœëŒ€ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

ê·¸ë¦¼ 1 ì— ìˆëŠ” ì˜ˆë¥¼ ê³ ë ¤í•´ë³´ì. ì—¬ê¸°ì„œ n = 8, (h1, o1) = (5, 40), (h2, o2) = (35, 25), (h3, o3) = (10, 20), (h4, o4) = (10, 25), (h5, o5) = (30, 50), (h6, o6) = (50, 60), (h7, o7) = (30, 25), (h8, o8) = (80, 100)ì´ê³ , d = 30ì´ë‹¤. ì´ ì˜ˆì—ì„œ, ìœ„ì¹˜ 10 ê³¼ 40 ì‚¬ì´ì˜ ë¹¨ê°„ìƒ‰ ì„ ë¶„ Lì´, ê°€ì¥ ë§ì€ ì‚¬ëŒë“¤ì— ëŒ€í•˜ì—¬ ì§‘ê³¼ ì‚¬ë¬´ì‹¤ ìœ„ì¹˜ ëª¨ë‘ í¬í•¨ë˜ëŠ” ì„ ë¶„ ì¤‘ í•˜ë‚˜ì´ë‹¤. ë”°ë¼ì„œ ë‹µì€ 4 ì´ë‹¤.

## Phase1. ì§ì ‘ í’€ê¸°(ì‹¤íŒ¨)

```python
"""
1. ë¬¸ì œ ì½ê¸°
ì´ê±° ë”±ë´ë„ ê·¸ ê·¸ë¦¬ë”” ë¬¸ì œì¸ë°. ëª» ë°•ëŠ” ë¬¸ì œë‘ ê°•ì˜ì‹¤ ë°°ì •ì´ë‘ ë¹„ìŠ·í•˜ë‹¤.
2. ë¬¸ì œ í’€ê¸°
ê°•ì˜ì‹¤ ë¬¸ì œëŠ” ê¸°ì–µì´ ë‚˜ëŠ”ë°(ëŠ¦ê²Œ ëë‚˜ëŠ” ê°•ì˜ ìˆœìœ¼ë¡œ ìš°ì„  ë°°ì •), ëª» ë°•ëŠ” ë¬¸ì œëŠ” ê¸°ì–µì´ ì•ˆë‚œë‹¤.
ëª»ì€? ì•„ ì§„ì§œ ê¸°ì–µì´ ì•ˆ ë‚˜ë„¤.
x ì¢Œí‘œ ìƒì— ì„ ë“¤ì˜ ìœ„ì¹˜ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ê°€ì¥ ë§ì€ ì„ ì„ ëª»ìœ¼ë¡œ ê´€í†µí•  ê²½ìš° ì„ ì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ë¼.
ë¬¸ì œëŠ” ì´ê±°ê³ , ì •ë‹µì€? ëª»ì˜ ìœ„ì¹˜ë¥¼ ì˜®ê²¨ê°€ë©° ê´€í†µí•˜ëŠ” ì„  ìµœëŒ€ ìˆ˜ë¥¼ ì™„ì „íƒìƒ‰ìœ¼ë¡œ êµ¬í–ˆë˜ ê±° ê°™ì€ë°
(ì´ê±´ ê·¸ë¦¬ë””ê°€ ì•„ë‹ˆì–ì•„ ê·¸ëŸ¼.)
ì•„ë¬´íŠ¼, ë¬¸ì œë¥¼ ë³´ì.
ëª»ì´ë‘ ë¹„ìŠ·í•˜ê²Œ ì² ë¡œê°€ ì‹œì‘í•˜ëŠ” ì§€ì ì„ incrementalí•˜ê²Œ ì‹œë®¬ë ˆì´ì…˜í•˜ê³ ,
ì² ë¡œê°€ ëë‚˜ëŠ” ì§€ì  ì•ˆìœ¼ë¡œ ë²”ìœ„ ì•ˆì˜ ì„ ë“¤ì´ ë“¤ì–´ì˜¤ë©´ ì •ë‹µì— ë”í•´ì£¼ê¸°?
ì—¬ê¸°ì„œ í™ì„ ì–´ë–»ê²Œ ì“°ì§€? ì•„, ëª»ì´ ìµœëŒ€í•œ ë§ì´ ë°•íˆëŠ” ì§€ì ë“¤ì„ ê·¸ë¦¬ë””í•˜ê²Œ êµ¬í•´ì„œ, 
ê·¸ ìµœëŒ€ ì§€ì ë“¤ì„ ì»¤ë²„í•˜ë©´ ë˜ëŠ” ê±° ì•„ë‹Œê°€?
ì´ê²ƒë„ ì•„ë‹Œ ê±° ê°™ë‹¤. ë¬¸ì œë¥¼ ì´í•´í•˜ì§€ ëª»í•˜ê² ë‹¤.
ê°•ì˜ì‹¤ ë°°ì • ë¬¸ì œì˜ ì—­ë°œìƒì¸ ê±° ê°™ê¸°ë„ í•˜ê³ ?
íŠ¹ì • ì§€ì ì„ ëª» ë°•ê¸° ë¬¸ì œì²˜ëŸ¼ êµ¬í•œ ë‹¤ìŒ, ê°•ì˜ì‹¤ ë¬¸ì œì²˜ëŸ¼ ê·¸ë¦¬ë””í•˜ê²Œ êµ¬í•˜ë˜, 
ë¹¨ë¦¬ ì‹œì‘í•˜ëŠ” ì§€ì ë¶€í„° ë³´ë©´ì„œ ì¡°ê±´ì— ë”°ë¼ ìˆ˜ì— ì¶”ê°€í•˜ë©´? ì¼ë‹¨ ê·¸ë˜ë³¼ê¹Œ? ì•„ë‹ˆ ê·¼ë° ê·¸ëŸ¬ë©´, 
ëª¨ë“  h, o ìŒì— ëŒ€í•´ ì„ ì„ ê·¸ë ¤ë³¸ë‹¤ëŠ” ì˜ë¯¸ê³ , 
ê·¸ ê°ê°ì˜ ì´í„°ë ˆì´ì…˜ ë™ì•ˆ ìµœì•… nê°œì˜ ì„ ì´ ë²”ìœ„ ì•ˆì— ìˆëŠ”ì§€ íŒë‹¨í•´ì•¼ í•˜ë‹ˆê¹Œ
h, o ë²”ìœ„ë§Œ ë”°ì ¸ë„ -100,000,000~100,000,000ì´ê³  ì² ë¡œ ê¸¸ì´ëŠ” 200,000,000ì—ë‹¤ê°€,
ê° ì§‘ì˜ ìµœëŒ€ ê°œìˆ˜ëŠ” 100,000ì´ë‹ˆê¹Œ, 200,000,000 * 100,000ì˜ ë³µì¡ë„ê°€ ë‚˜ì˜¨ë‹¤.
ì´ëŸ¬ë©´ ì•ˆ ë í…ë°.

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""
import heapq
import sys
n = int(sys.stdin.readline().strip())
D = {}
for _ in range(n):
    x, y = tuple(map(int, sys.stdin.readline().split()))  
    x, y = x, y if x < y else y, x # ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì„  ë„£ì–´ì£¼ê¸°
    D[x] = y # ì‚¬ì „í˜•ìœ¼ë¡œ ì €ì¥í•´ë†“ê¸°.

```

## Phase2.  í”¼ë“œë°±(ì •ë‹µ ì œì‹œ ê¸ˆì§€)

ì¢‹ì€ ì‹œë„ì…ë‹ˆë‹¤! ì´ ë¬¸ì œëŠ” ì§ê´€ë§Œìœ¼ë¡œ í’€ê¸°ì—” ì‚´ì§ ê¹Œë‹¤ë¡­ê³ ,

ì•Œê³ ë¦¬ì¦˜ ì•„ì´ë””ì–´(íŠ¹íˆ ìš°ì„ ìˆœìœ„ í + ì •ë ¬)ë¥¼ ì •í™•íˆ ì¡ì•„ì•¼ ì‹œê°„ ì•ˆì— í•´ê²°í•  ìˆ˜ ìˆëŠ” ìœ í˜•ì…ë‹ˆë‹¤.

âœ… ë¬¸ì œ ìš”ì•½ ì •ë¦¬

â€¢	ê° ì‚¬ëŒì€ â€œì§‘ ìœ„ì¹˜â€ì™€ â€œì‚¬ë¬´ì‹¤ ìœ„ì¹˜â€ë¥¼ í•œ ìŒìœ¼ë¡œ ê°€ì§. (ì˜ˆ: (h, o))

â€¢	ì² ë¡œì˜ ê¸¸ì´ dê°€ ì •í•´ì§ (ì–‘ì˜ ì •ìˆ˜).

â€¢	ê¸¸ì´ê°€ dì¸ ì–´ë–¤ ì„ ë¶„ì„ ì¼ì§ì„ ìƒì— ë°°ì¹˜í•  ë•Œ,

â€¢	ì§‘ê³¼ ì‚¬ë¬´ì‹¤ì´ ëª¨ë‘ ê·¸ ì„ ë¶„ì— í¬í•¨ë˜ëŠ” ì‚¬ëŒì˜ ìˆ˜ê°€ ìµœëŒ€ê°€ ë˜ì–´ì•¼ í•¨.

â€¢	ê·¸ ìµœëŒ€ ì¸ì›ì„ êµ¬í•˜ëŠ” ë¬¸ì œ.

ì¦‰, ê° ì‚¬ëŒì— ëŒ€í•´ **[ \min(h, o), \max(h, o) ]**ë¼ëŠ” êµ¬ê°„ì´ ìˆê³ ,

ì–´ë–¤ ê¸¸ì´ dì¸ ì„ ë¶„ì´ ì´ êµ¬ê°„ì„ ì „ë¶€ ì»¤ë²„í•˜ë©´ â€œê·¸ ì‚¬ëŒì€ í¬í•¨â€ëœë‹¤ê³  ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

âŒ í”íˆ í•˜ëŠ” ì‹¤ìˆ˜

1.	**ëª¨ë“  ì‚¬ëŒì˜ êµ¬ê°„ì— ëŒ€í•´ ì„ ë¶„ì„ â€˜ì™„ì „ íƒìƒ‰â€™**í•˜ë ¤ê³  ì‹œë„

â€¢	êµ¬ê°„ ìì²´ê°€ ìµœëŒ€ 10^8 ë²”ìœ„ â†’ ë¶ˆê°€ëŠ¥ (ë„ˆë¬´ í¼)

2.	ì‚¬ì „í˜• ë“±ìœ¼ë¡œ ë‹¨ìˆœ ì €ì¥ë§Œ í•´ë‘ê³ , ë§ˆë•…í•œ ê·¸ë¦¬ë”” ë¡œì§ ì—†ì´ â€œí•œ ì ì”© ì´ë™â€

â€¢	ì—¬ì „íˆ ë²”ìœ„ê°€ ì»¤ì„œ ì‹œê°„ ì´ˆê³¼

3.	ë‘ ì¢Œí‘œ(ì§‘,ì‚¬ë¬´ì‹¤) ì°¨ì´ê°€ d ì´ˆê³¼ì¸ ì¼€ì´ìŠ¤ë„ ê³ ë ¤í•˜ëŠë¼ ë³µì¡í•´ì§

â€¢	ì‚¬ì‹¤ ì´ ê²½ìš°ëŠ” â€œì–´ë–¤ ì„ ë¶„ìœ¼ë¡œë„ ë‘˜ ë‹¤ ëª» ë‹´ëŠ”ë‹¤â€ë¼ì„œ ì• ì´ˆì— ì œì™¸í•´ë²„ë¦¬ëŠ” ê²ƒì´ ë‚«ìŠµë‹ˆë‹¤.

ğŸ’¡ í° ê·¸ë¦¼: ì •ë ¬ + ìš°ì„ ìˆœìœ„ í ë¡œ í•´ê²°

ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì „í˜•ì ì¸ ì ‘ê·¼ ë°©ì‹ì„ êµ¬ì¡°ë§Œ ê°„ë‹¨íˆ ì†Œê°œí•´ ë“œë¦´ê²Œìš”(ì •ë‹µì€ X).

1.	êµ¬ê°„í™”

â€¢	ê° ì‚¬ëŒì˜ ìœ„ì¹˜ë¥¼ [start, end] = [\min(h, o), \max(h, o)]ë¡œ í‘œí˜„

â€¢	ë§Œì•½ end - start > dë¼ë©´, ì–´ì°¨í”¼ ê¸¸ì´ dë¡œëŠ” â€œì§‘+ì‚¬ë¬´ì‹¤â€ì„ ë™ì‹œì— ì»¤ë²„í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì œì™¸í•©ë‹ˆë‹¤.

2.	ì¢…ì  ê¸°ì¤€ ì •ë ¬

â€¢	ìœ„ì—ì„œ ê±°ë¥¸ êµ¬ê°„ë“¤ë§Œ ëª¨ì•„ì„œ, êµ¬ê°„ì˜ â€œendâ€ (ì˜¤ë¥¸ìª½ ë) ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•©ë‹ˆë‹¤.

3.	ì„ ë¶„ [end - d, end]ë¥¼ ìƒê°í•˜ë©°, í¬í•¨ ê°€ëŠ¥í•œ êµ¬ê°„ ê°œìˆ˜ ì„¸ê¸°

â€¢	ì •ë ¬ëœ ìˆœì„œë¡œ êµ¬ê°„ì„ í•˜ë‚˜ì”© ë³´ë©´ì„œ,

â€¢	â€œì´ë²ˆ êµ¬ê°„ì˜ endë¥¼ ì„ ë¶„ì˜ ì˜¤ë¥¸ìª½ ëìœ¼ë¡œ ì¡ìœ¼ë©´, ì„ ë¶„ì€ [end - d, end]ì¼ ê²ƒâ€ì´ë¼ëŠ” ì•„ì´ë””ì–´

â€¢	ì´ ë•Œ, â€œêµ¬ê°„ì˜ startê°€ end - d ì´ìƒâ€ì´ë©´ ê·¸ êµ¬ê°„ì€ [end-d, end]ì— í¬í•¨ë  ê°€ëŠ¥ì„±ì´ ìˆìŒ.

â€¢	ë°˜ëŒ€ë¡œ, startê°€ < (end-d)ì¸ êµ¬ê°„ì€ ë” ì´ìƒ [end-d, end]ì— ë“¤ì–´ê°ˆ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì œì™¸.

4.	ìš°ì„ ìˆœìœ„ í(í™)ë¡œ start ê´€ë¦¬

â€¢	êµ¬ê°„ì„ â€œendâ€ ê¸°ì¤€ìœ¼ë¡œ ìˆœíšŒí•˜ë©´ì„œ,

â€¢	â€œí˜„ì¬ endì—ì„œ ì»¤ë²„ ê°€ëŠ¥í•œ startë“¤â€ë§Œ í™ì— ë„£ê³ ,

â€¢	startê°€ â€œend - dâ€ ë¯¸ë§Œì´ë©´ í™ì—ì„œ ë¹¼ëŠ” ì‹ìœ¼ë¡œ ìœ ì§€

â€¢	í™ì— ë‚¨ì•„ ìˆëŠ” êµ¬ê°„ì˜ ê°œìˆ˜ê°€ ê³§ â€œ[end-d, end]â€ì— ì™„ì „íˆ ë“¤ì–´ì˜¤ëŠ” êµ¬ê°„ ìˆ˜.

â€¢	ë§¤ë²ˆ í™ ì‚¬ì´ì¦ˆ(ì¦‰ í¬í•¨ êµ¬ê°„ ìˆ˜)ì˜ ìµœëŒ“ê°’ì„ ê°±ì‹  â†’ ì •ë‹µ.

> ì´ ë°©ì‹ìœ¼ë¡œ, â€œì–´ë””ë¥¼ ì„ ë¶„ìœ¼ë¡œ ì¡ì•„ì•¼ ìµœëŒ€ê°€ ë˜ì§€?â€ë¼ëŠ” ë¬¸ì œë¥¼

> ì •ë ¬ëœ end

> ê°€ëŠ¥í•œ start

ğŸ·ï¸ íŒíŠ¸ Q&A

1.	ì™œ êµ¬ê°„ì˜ endë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ë‚˜ìš”?

â€¢	â€œì„ ë¶„ì˜ ì˜¤ë¥¸ìª½ ëâ€ì„ ê³ ì •í•˜ë©°, ì™¼ìª½ ëì€ end - dê°€ ë˜ë¯€ë¡œ.

â€¢	ë§Œì•½ endê°€ ì˜¤ë¦„ì°¨ìˆœì´ë©´, ì´ì „ ë‹¨ê³„ì—ì„œ ê³ ë ¤í•œ startë“¤ì€ ê·¸ëŒ€ë¡œ ì¬í™œìš© ê°€ëŠ¥.

â€¢	startë¥¼ ê¸°ì¤€ìœ¼ë¡œë„ í•´ë³¼ ìˆ˜ ìˆì§€ë§Œ, ë³´í†µ end ê¸°ì¤€ì´ êµ¬í˜„ì´ ë” ì§ê´€ì .

2.	startê°€ end - d ì´ìƒì´ë©´ ëœë‹¤ëŠ” ê²Œ ë¬´ìŠ¨ ëœ»ì´ì£ ?

â€¢	ê¸¸ì´ê°€ dì¸ ì„ ë¶„ [end-d, end] ë‚´ì— êµ¬ê°„ [start, end]ê°€ ì™„ì „íˆ ë“¤ì–´ì˜¤ë ¤ë©´,

â€¢	start >= end - d ì—¬ì•¼ í•©ë‹ˆë‹¤.

3.	í™ì—ëŠ” ë­˜ push/popí•˜ë‚˜ìš”?

â€¢	ë³´í†µ êµ¬ê°„ì˜ startë¥¼ pushí•©ë‹ˆë‹¤.

â€¢	endë¥¼ í•˜ë‚˜ì”© íƒìƒ‰í•˜ë©´ì„œ, â€œí˜„ì¬ endë¡œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ì„ ë¶„â€ì— ë“¤ì–´ì˜¬ ìˆ˜ ì—†ëŠ” startë“¤ì„ popí•˜ì—¬ ì œê±°í•©ë‹ˆë‹¤.

4.	ì‹œê°„ ë³µì¡ë„?

â€¢	êµ¬ê°„ ì •ë ¬: O(N \log N)

â€¢	í™ ì—°ì‚°: ê° êµ¬ê°„ë‹¹ push/popì´ ìµœëŒ€ 1ë²ˆì”© â†’ O(N \log N)

â€¢	ì´í•©: O(N \log N) ì •ë„

âš ï¸ ì£¼ì˜

â€¢	ì…ë ¥ ë²”ìœ„: ìœ„ì¹˜ê°€ \pm 10^8

â€¢	ì¶œë ¥: ìµœëŒ€ ì¸ì› ìˆ˜

â€¢	ì •ë ¬ ë° í™ì„ ì˜ëª» êµ¬í˜„í•˜ë©´ ì‹œê°„ ì´ˆê³¼/ë©”ëª¨ë¦¬ ì´ˆê³¼ê°€ ë‚  ìˆ˜ ìˆìŒ

â€¢	êµ¬ê°„ì˜ í¬ê¸°ê°€ dë¥¼ ì´ˆê³¼í•˜ëŠ” ê²½ìš°ëŠ” ë¯¸ë¦¬ ê±°ë¥´ëŠ” ê²Œ ì¢‹ìŠµë‹ˆë‹¤.

âœï¸ ì •ë¦¬

â€¢	í•µì‹¬:

â€¢	â€œ[start, end]â€ êµ¬ê°„ì„ ë§Œë“¤ê³ , â€œendâ€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬

â€¢	ìš°ì„ ìˆœìœ„ íë¥¼ ì´ìš©í•´ â€œ\geq end - dâ€ì¸ startë§Œ ìœ ì§€

â€¢	í™ í¬ê¸°(= í˜„ì¬ í¬í•¨ ê°€ëŠ¥í•œ êµ¬ê°„ ìˆ˜)ì˜ ìµœëŒ“ê°’ì„ ì°¾ëŠ”ë‹¤

â€¢	ìë£Œêµ¬ì¡°:

â€¢	ì •ë ¬(ì˜¤ë¦„ì°¨ìˆœ by end)

â€¢	ìµœì†Œ í™(ë˜ëŠ” ìµœëŒ€ í™)ìœ¼ë¡œ startë¥¼ ê´€ë¦¬

â€¢	í•œ ë²ˆ ë¡œì§ì„ ê¹¨ë‹¬ìœ¼ë©´ ë‹¤ë¥¸ â€œì„ ë¶„ ë®ê¸°â€ ê³„ì—´ ë¬¸ì œì™€ ë¹„ìŠ·í•˜ê²Œ í’€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ ë°©í–¥ëŒ€ë¡œ êµ¬ìƒí•˜ì‹œê³ , êµ¬ì²´ ì½”ë“œ êµ¬í˜„ ì „ì— ì˜ˆì œ(íŠ¹íˆ ë¬¸ì œ ë³¸ë¬¸ ì˜ˆì œ)ë¡œ ì†ìœ¼ë¡œ ì‹œë®¬ë ˆì´ì…˜í•´ë³´ë©´ ë”ìš± í™•ì‹¤íˆ ì´í•´í•˜ì‹¤ ìˆ˜ ìˆì„ ê±°ì˜ˆìš”.

í™”ì´íŒ…ì…ë‹ˆë‹¤!

## Phase3. í”¼ë“œë°± í›„ ë‹¤ì‹œ ì‹œë„ - ì„±ê³µ~!

```python
"""
1. ë¬¸ì œ ì½ê¸°
ì´ê±° ë”±ë´ë„ ê·¸ ê·¸ë¦¬ë”” ë¬¸ì œì¸ë°. ëª» ë°•ëŠ” ë¬¸ì œë‘ ê°•ì˜ì‹¤ ë°°ì •ì´ë‘ ë¹„ìŠ·í•˜ë‹¤.
2. ë¬¸ì œ í’€ê¸°
ê°•ì˜ì‹¤ ë¬¸ì œëŠ” ê¸°ì–µì´ ë‚˜ëŠ”ë°(ëŠ¦ê²Œ ëë‚˜ëŠ” ê°•ì˜ ìˆœìœ¼ë¡œ ìš°ì„  ë°°ì •), ëª» ë°•ëŠ” ë¬¸ì œëŠ” ê¸°ì–µì´ ì•ˆë‚œë‹¤.
ëª»ì€? ì•„ ì§„ì§œ ê¸°ì–µì´ ì•ˆ ë‚˜ë„¤.
x ì¢Œí‘œ ìƒì— ì„ ë“¤ì˜ ìœ„ì¹˜ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ê°€ì¥ ë§ì€ ì„ ì„ ëª»ìœ¼ë¡œ ê´€í†µí•  ê²½ìš° ì„ ì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ë¼.
ë¬¸ì œëŠ” ì´ê±°ê³ , ì •ë‹µì€? ëª»ì˜ ìœ„ì¹˜ë¥¼ ì˜®ê²¨ê°€ë©° ê´€í†µí•˜ëŠ” ì„  ìµœëŒ€ ìˆ˜ë¥¼ ì™„ì „íƒìƒ‰ìœ¼ë¡œ êµ¬í–ˆë˜ ê±° ê°™ì€ë°
(ì´ê±´ ê·¸ë¦¬ë””ê°€ ì•„ë‹ˆì–ì•„ ê·¸ëŸ¼.)
ì•„ë¬´íŠ¼, ë¬¸ì œë¥¼ ë³´ì.
ëª»ì´ë‘ ë¹„ìŠ·í•˜ê²Œ ì² ë¡œê°€ ì‹œì‘í•˜ëŠ” ì§€ì ì„ incrementalí•˜ê²Œ ì‹œë®¬ë ˆì´ì…˜í•˜ê³ ,
ì² ë¡œê°€ ëë‚˜ëŠ” ì§€ì  ì•ˆìœ¼ë¡œ ë²”ìœ„ ì•ˆì˜ ì„ ë“¤ì´ ë“¤ì–´ì˜¤ë©´ ì •ë‹µì— ë”í•´ì£¼ê¸°?
ì—¬ê¸°ì„œ í™ì„ ì–´ë–»ê²Œ ì“°ì§€? ì•„, ëª»ì´ ìµœëŒ€í•œ ë§ì´ ë°•íˆëŠ” ì§€ì ë“¤ì„ ê·¸ë¦¬ë””í•˜ê²Œ êµ¬í•´ì„œ, 
ê·¸ ìµœëŒ€ ì§€ì ë“¤ì„ ì»¤ë²„í•˜ë©´ ë˜ëŠ” ê±° ì•„ë‹Œê°€?
ì´ê²ƒë„ ì•„ë‹Œ ê±° ê°™ë‹¤. ë¬¸ì œë¥¼ ì´í•´í•˜ì§€ ëª»í•˜ê² ë‹¤.
ê°•ì˜ì‹¤ ë°°ì • ë¬¸ì œì˜ ì—­ë°œìƒì¸ ê±° ê°™ê¸°ë„ í•˜ê³ ?
íŠ¹ì • ì§€ì ì„ ëª» ë°•ê¸° ë¬¸ì œì²˜ëŸ¼ êµ¬í•œ ë‹¤ìŒ, ê°•ì˜ì‹¤ ë¬¸ì œì²˜ëŸ¼ ê·¸ë¦¬ë””í•˜ê²Œ êµ¬í•˜ë˜, 
ë¹¨ë¦¬ ì‹œì‘í•˜ëŠ” ì§€ì ë¶€í„° ë³´ë©´ì„œ ì¡°ê±´ì— ë”°ë¼ ìˆ˜ì— ì¶”ê°€í•˜ë©´? ì¼ë‹¨ ê·¸ë˜ë³¼ê¹Œ? ì•„ë‹ˆ ê·¼ë° ê·¸ëŸ¬ë©´, 
ëª¨ë“  h, o ìŒì— ëŒ€í•´ ì„ ì„ ê·¸ë ¤ë³¸ë‹¤ëŠ” ì˜ë¯¸ê³ , 
ê·¸ ê°ê°ì˜ ì´í„°ë ˆì´ì…˜ ë™ì•ˆ ìµœì•… nê°œì˜ ì„ ì´ ë²”ìœ„ ì•ˆì— ìˆëŠ”ì§€ íŒë‹¨í•´ì•¼ í•˜ë‹ˆê¹Œ
h, o ë²”ìœ„ë§Œ ë”°ì ¸ë„ -100,000,000~100,000,000ì´ê³  ì² ë¡œ ê¸¸ì´ëŠ” 200,000,000ì—ë‹¤ê°€,
ê° ì§‘ì˜ ìµœëŒ€ ê°œìˆ˜ëŠ” 100,000ì´ë‹ˆê¹Œ, 200,000,000 * 100,000ì˜ ë³µì¡ë„ê°€ ë‚˜ì˜¨ë‹¤.
ì´ëŸ¬ë©´ ì•ˆ ë í…ë°.

â€¢	êµ¬ê°„ì„ â€œendâ€ ê¸°ì¤€ìœ¼ë¡œ ìˆœíšŒí•˜ë©´ì„œ,
ê·¸ ì™„ì „íƒìƒ‰ì„ í•˜ê¸´ í•˜ëŠ”ë°, end ê¸°ì¤€ìœ¼ë¡œ ì—­ìœ¼ë¡œ ì˜¬ë¼ê°€ë©´ì„œ ê·¸ë¦¬ë””í•˜ê²Œ ë³´ëŠ” ë¬¸ì œë‹¤.
ë§Œì•½ êµ¬ê°„ì´ dë³´ë‹¤ ì•„ì˜ˆ í¬ë©´ ë°°ì œ
end-d, endì—ì„œ end í° ìˆœìœ¼ë¡œ ì •ë ¬í•´ì„œ, í™ì— ì§‘ì–´ë„£ê³ , 
end-dê°€ startì´í•´ ë¨? ì˜¬ë‘ë§ë‘.
ì¼ë‹¨ ë£¨í”„ë¥¼ ëŒë©°ë„ˆ
(ëª¨ë“  ì§‘íšŒì‚¬ êµ¬ê°„ì— ëŒ€í•´ ë£¨í”„: start, endë¡œ ìƒê°)
    startê°€ end-dë³´ë‹¤ í° ê²½ìš°, ì´ êµ¬ê°„ì€ í¬í•¨ì‹œí‚¬ ìˆ˜ ìˆìŒ
    ì¼ë‹¨ ëŒ€ì¶© ì•Œê² ìŒ.


3. ìˆ˜ë„ ì½”ë“œ

(ëª¨ë“  êµ¬ê°„ì„ (start, end), (start<end) í˜•ì‹ìœ¼ë¡œ, endì— ëŒ€í•´ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ
ì •ë ¬í•˜ì—¬ ë°°ì—´ë¡œ ì €ì¥)

(í•¨ìˆ˜: ê·¸ë¦¬ë””í•˜ê²Œ ì² ë¡œë¡œ ì»¤ë²„í•  ìˆ˜ ìˆëŠ” êµ¬ê°„ì„ êµ¬í•˜ëŠ” í•¨ìˆ˜)
    (í™ì„ ìƒì„±)
    (ì²« ë²ˆì§¸ êµ¬ê°„ì„ í‘¸ì‹œ)
    (ì²« ë²ˆì§¸ êµ¬ê°„ì„ ì œì™¸í•œ ëª¨ë“  ì˜ì—­ì„ end ê¸°ì¤€ìœ¼ë¡œ ì´í„°ë ˆì´ì…˜(end ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬í–ˆìœ¼ë‹ˆ ë‹¹ì—°))
        (ë§Œì•½ start, end ì°¨ê°€ dë³´ë‹¤ í¬ì§€ ì•Šë‹¤ë©´)
            (í˜„ì¬ êµ¬ê°„ì˜ endëŠ” í™ ë‚´ì—ì„œ ìµœê³ ê°’ì„! ë”°ë¼ì„œ ì§€ê¸ˆ ê°€ì •í•  ìˆ˜ ìˆëŠ” ì² ë¡œ êµ¬ê°„ì€ ì•„ë˜ì™€ ê°™ìŒ)
            (end-d ~ d)
            (ì¼ë‹¨ ì•„ë¬»ë”° í˜„ì¬ êµ¬ê°„ì„ í‘¸ì‹œ. ì™œ? ì§€ê¸ˆì€ í˜„ì¬ êµ¬ê°„ ê¸°ì¤€ìœ¼ë¡œ ì² ë¡œ ê¹” ê±°ë‹ˆê¹Œ í˜„ì¬ êµ¬ê°„ì€ ë¬´ì¡°ê±´ í¬í•¨(ì² ë¡œë³´ë‹¤ ì§§ì€ êµ¬ê°„ì„ì€ ì´ë¯¸ í™•ì¸))
            (í˜„ì¬ í™ì˜ ë£¨íŠ¸ëŠ”? startê°€ ê°€ì¥ ì‘ì€ ê°’ = end-d êµ¬ê°„ì— ëª» ë“¤ì–´ê°ˆ í™•ë¥ ì´ ê°€ì¥ ë†’ì€ êµ¬ê°„)
            (while: ìœ„ ë…¼ë¦¬ì— ì˜ê±°í•´ ë£¨íŠ¸ì˜ startê°€ end-dë³´ë‹¤ ì»¤ì§ˆ ë•Œê¹Œì§€ íŒ)
            (heapì— ëŒ€í•œ ì •ë¦¬ê°€ ëë‚œ ë‹¤ìŒ max heap sizeë¥¼ ê°±ì‹ .)

4. ì½”ë“œ êµ¬í˜„
"""

import heapq
import sys

def greedy(pairs):
    h = []
    max_h = 0
    heapq.heapify(h)
    start, end = pairs[0]
    if end - start <= d: 
        heapq.heappush(h, pairs[0])
    for i in range(1, len(pairs)):
        start, end = pairs[i]
        if end - start <= d: 
            heapq.heappush(h, (start, end))
            root = heapq.heappop(h)
            while root[0] < end - d:
                root = heapq.heappop(h)
            heapq.heappush(h, root)
        max_h = max(len(h), max_h)
    return max_h


if __name__ == '__main__':
    input = sys.stdin.readline
    n  = int(input().strip())
    pairs = []
    for _ in range(n):
        start, end = tuple(map(int, input().split()))
        start, end = (end, start) if end < start else (start, end)
        pairs.append((start, end))
    pairs.sort(key=lambda x: x[1])
    d  = int(input().strip())
    print(greedy(pairs))
    
    

```

# ì´ë¶„ íƒìƒ‰: ì‚¬ëƒ¥ê¾¼



KOI ì‚¬ëƒ¥í„°ì—ëŠ” N ë§ˆë¦¬ì˜ ë™ë¬¼ë“¤ì´ ê°ê° íŠ¹ì •í•œ ìœ„ì¹˜ì— ì‚´ê³  ìˆë‹¤. ì‚¬ëƒ¥í„°ì— ì˜¨ ì‚¬ëƒ¥ê¾¼ì€ ì¼ì§ì„  ìƒì— ìœ„ì¹˜í•œ M ê°œì˜ ì‚¬ëŒ€(ì´ì„ ì˜ëŠ” ì¥ì†Œ)ì—ì„œë§Œ ì‚¬ê²©ì´ ê°€ëŠ¥í•˜ë‹¤. í¸ì˜ìƒ, ì¼ì§ì„ ì„ x-ì¶•ì´ë¼ ê°€ì •í•˜ê³ , ì‚¬ëŒ€ì˜ ìœ„ì¹˜ x1, x2, ..., xMì€ x-ì¢Œí‘œ ê°’ì´ë¼ê³  í•˜ì. ê° ë™ë¬¼ì´ ì‚¬ëŠ” ìœ„ì¹˜ëŠ” (a1, b1), (a2, b2), ..., (aN, bN)ê³¼ ê°™ì´ x,y-ì¢Œí‘œ ê°’ìœ¼ë¡œ í‘œì‹œí•˜ì. ë™ë¬¼ì˜ ìœ„ì¹˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ëª¨ë“  ì¢Œí‘œ ê°’ì€ ì–‘ì˜ ì •ìˆ˜ì´ë‹¤.

ì‚¬ëƒ¥ê¾¼ì´ ê°€ì§€ê³  ìˆëŠ” ì´ì˜ ì‚¬ì •ê±°ë¦¬ê°€ Lì´ë¼ê³  í•˜ë©´, ì‚¬ëƒ¥ê¾¼ì€ í•œ ì‚¬ëŒ€ì—ì„œ ê±°ë¦¬ê°€ L ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ìœ„ì¹˜ì˜ ë™ë¬¼ë“¤ì„ ì¡ì„ ìˆ˜ ìˆë‹¤ê³  í•œë‹¤. ë‹¨, ì‚¬ëŒ€ì˜ ìœ„ì¹˜ xiì™€ ë™ë¬¼ì˜ ìœ„ì¹˜ (aj, bj) ê°„ì˜ ê±°ë¦¬ëŠ” |xi-aj| + bjë¡œ ê³„ì‚°í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, ì•„ë˜ì˜ ê·¸ë¦¼ê³¼ ê°™ì€ ì‚¬ëƒ¥í„°ë¥¼ ìƒê°í•´ ë³´ì. (ì‚¬ëŒ€ëŠ” ì‘ì€ ì‚¬ê°í˜•ìœ¼ë¡œ, ë™ë¬¼ì˜ ìœ„ì¹˜ëŠ” ì‘ì€ ì›ìœ¼ë¡œ í‘œì‹œë˜ì–´ ìˆë‹¤.) ì‚¬ì •ê±°ë¦¬ Lì´ 4ë¼ê³  í•˜ë©´, ì ì„ ìœ¼ë¡œ í‘œì‹œëœ ì˜ì—­ì€ ì™¼ìª½ì—ì„œ ì„¸ ë²ˆì§¸ ì‚¬ëŒ€ì—ì„œ ì‚¬ëƒ¥ì´ ê°€ëŠ¥í•œ ì˜ì—­ì´ë‹¤.

ì‚¬ëŒ€ì˜ ìœ„ì¹˜ì™€ ë™ë¬¼ë“¤ì˜ ìœ„ì¹˜ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì¡ì„ ìˆ˜ ìˆëŠ” ë™ë¬¼ì˜ ìˆ˜ë¥¼ ì¶œë ¥í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì§ì ‘ í’€ê¸°(ì‹¤íŒ¨)

```python
"""
1. ë¬¸ì œ ì½ê¸°
ì‚¬ëŒ€ì˜ ìœ„ì¹˜ì—ì„œ ì»¤ë²„ì¹  ìˆ˜ ìˆëŠ” ë™ë¬¼ë“¤ì˜ ìœ„ì¹˜ë¥¼ ê³„ì‚°.
ì‚¬ëŒ€ì˜ ê°œìˆ˜ M(1 <= M <= 100,000)ì—ì„œ ë™ë¬¼ì˜ ìˆ˜ë¥¼ ì™„ì „íƒìƒ‰í•˜ë©´ ë¶ˆê°€í•˜ê² ì§€?

2. ë¬¸ì œ í’€ê¸°
ìœ ì‚¬í•œ ë¬¸ì œ: ë‚˜ë¬´ ìë¥´ê¸°? ë­ê°€ ë¹„ìŠ·í•œì§€ ëª¨ë¥´ê² ë‹¤. ê²°ì •í•¨ìˆ˜ ì„¤ì •í•˜ê³  ë§¤ê°œë³€ìˆ˜ë¥¼ ì¡°ì ˆí•´ì„œ ì´ì§„íƒìƒ‰ì„ í•´ì•¼ í•  ê±´ë°
ê²°ì •í•¨ìˆ˜: ì¡ì„ ìˆ˜ ìˆëŠ” ë™ë¬¼ ìˆ˜
ë§¤ê°œë³€ìˆ˜: ì‚¬ëŒ€ ì¢Œí‘œê² ì§€ ë‹¹ì—°íˆ.
ë¬¸ì œëŠ”, ë§¤ê°œë³€ìˆ˜ì™€ ê²°ì • í•¨ìˆ˜ì˜ ì—°ê´€ì„±ì´ ì—†ë‹¤ëŠ” ê±°ë‹¤. ë§¤ê°œë³€ìˆ˜ê°€ ë¬´ìŠ¨ ê°’ì´ë“  ê²°ì • í•¨ìˆ˜ëŠ” 
ëœë¤í•˜ê²Œ ë‚˜ì˜¨ë‹¤.
ë§¤ê°œë³€ìˆ˜ë¥¼ ì„ í˜•ìœ¼ë¡œ ì¦ê°€ì‹œí‚¤ë©´ ê²°ì •í•¨ìˆ˜ëŠ” ë‹¹ì—°íˆ ì„ í˜•ì´ê² ì§€ë§Œ,
ì „í˜€ ê°ì´ ì•ˆ ì˜¨ë‹¤. ì–´ë–¤ ì ‘ê·¼ì„ ì·¨í•´ì•¼ í•˜ëŠ” ê±°ì§€?
ì™„ì „ íƒìƒ‰ìœ¼ë¡œ í‘¼ë‹¤ë©´? ì‚¬ëŒ€ í•˜ë‚˜ë¥¼ ì •í•´ì„œ ëª¨ë“  ë™ë¬¼ë“¤ì— ì´í„°ë ˆì´ì…˜í•´ì„œ, 
ê·¸ ê°’ì´ ì‚¬ëŒ€ ë²”ìœ„ì— ë“¤ì–´ì˜¤ëŠ”ì§€ íŒë‹¨í–ˆê² ì§€ -> ì¼ë‹¨ ì•…ê¸°ë°”ë¦¬ë¡œ ì´ë ‡ê²Œë¼ë„ í’€ì–´ë´ë¼.
í’€ì—ˆë‹¤. ì´ê±¸ ì´ì§„ íƒìƒ‰ìœ¼ë¡œ ì–´ë–»ê²Œ ë°”ê¾¸ì§€?
ë§¤ê°œë³€ìˆ˜ iëŠ” ë§ë£¨ì˜ ì¸ë±ìŠ¤. 
ëª¨ë¥´ê² ë‹¤.

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys
m, n, l = tuple(map(int, sys.stdin.readline().split()))
M = tuple(map(int, sys.stdin.readline().split()))
A = [
    tuple(map(int, sys.stdin.readline().split()))
    for _ in range(n)
]

def brute_force():
    for i in range(m):
        animals = get_animal_from(i)
        print(f'hunted at {i}th step: {animals}')


def get_animal_from(i):
    tmp = 0
    for j in range(n):
        x, y = A[j]
        dist_to_animal = abs(x-M[i]) + y
        if dist_to_animal <= l:
            tmp += 1
    return tmp

brute_force()
```

## Phase2. í”¼ë“œë°±(ì •ë‹µ ì œì‹œ ê¸ˆì§€)

ì§€ê¸ˆ ì „ìˆ˜ì¡°ì‚¬(brute force) ë°©ì‹ìœ¼ë¡œ ì ‘ê·¼í•˜ì…¨ëŠ”ë°,

ì‚¬ëŒ€(M ìµœëŒ€ 100,000ê°œ) Ã— ë™ë¬¼(N ìµœëŒ€ 100,000ë§ˆë¦¬)ë¥¼ ì „ë¶€ í™•ì¸í•˜ë©´ ìµœëŒ€ 10^{10} ë²ˆì˜ ì—°ì‚°ì´ ë˜ì–´ ì‹œê°„ ì´ˆê³¼ê°€ ë‚©ë‹ˆë‹¤.

âœ… í•µì‹¬ ì•„ì´ë””ì–´

1.	ì‚¬ëŒ€ì˜ ìœ„ì¹˜(Mê°œ)ë¥¼ ì •ë ¬í•´ ë‘”ë‹¤.

2.	ê° ë™ë¬¼(ì¢Œí‘œ (x, y))ì„ ë³¼ ë•Œ,

â€¢	â€œì´ ë™ë¬¼ì„ ì‚¬ëƒ¥í•  ìˆ˜ ìˆëŠ” **ì‚¬ëŒ€(ì´ ìœ„ì¹˜)**ê°€ ì¡´ì¬í•˜ëŠ”ê°€?â€

â€¢	|x - \text{ì‚¬ëŒ€ìœ„ì¹˜}| + y \le L

â€¢	ì¦‰, |x - \text{ì‚¬ëŒ€ìœ„ì¹˜}| \le L - y

â€¢	\text{ì‚¬ëŒ€ìœ„ì¹˜}ëŠ” [\,x - (L - y), \, x + (L - y)\,] ë²”ìœ„ ë‚´ì— ì¡´ì¬í•´ì•¼ í•œë‹¤.

3.	ì´ ë²”ìœ„ë¥¼ ì´ì§„ íƒìƒ‰ì„ í†µí•´ ì‚¬ëŒ€ ìœ„ì¹˜ ë°°ì—´ì—ì„œ ë¹ ë¥´ê²Œ íƒìƒ‰:

â€¢	\text{leftBound} = x - (L - y)

â€¢	\text{rightBound} = x + (L - y)

â€¢	ì •ë ¬ëœ ì‚¬ëŒ€ ë¦¬ìŠ¤íŠ¸ì—ì„œ

â€¢	leftBound ì´ìƒì¸ ì²« ë²ˆì§¸ ì‚¬ëŒ€ ì¸ë±ìŠ¤

â€¢	rightBound ì´í•˜ì¸ ë§ˆì§€ë§‰ ì‚¬ëŒ€ ì¸ë±ìŠ¤

â€¢	ë‘˜ ì¤‘ í•˜ë‚˜ë¼ë„ í•´ë‹¹ êµ¬ê°„ ì•ˆì— ë“¤ì–´ìˆë‹¤ë©´, â€œë™ë¬¼ì„ ì‚¬ëƒ¥í•  ìˆ˜ ìˆëŠ” ì‚¬ëŒ€ê°€ ì¡´ì¬â€

â€¢	(ì •í™•íˆëŠ”, êµ¬ê°„ ì•ˆì— ì‚¬ëŒ€ê°€ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ ì¡íŒë‹¤ê³  ë³¼ ìˆ˜ ìˆìŒ)

ì´ë ‡ê²Œ í•˜ë©´ ê° ë™ë¬¼ë§ˆë‹¤ ì´ì§„ íƒìƒ‰ 2íšŒ ì •ë„ë¡œ ê°€ëŠ¥í•œ ì¸ë±ìŠ¤ ë²”ìœ„ë¥¼ ì°¾ì„ ìˆ˜ ìˆê³ ,

Në§ˆë¦¬ Ã— O(\log M) = 10^5 \times \log(10^5) â†’ ëŒ€ëµ 10^6 ìˆ˜ì¤€ ì—°ì‚°ìœ¼ë¡œ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.

ğŸ”‘ ì£¼ìš” í¬ì¸íŠ¸

1.	ì‚¬ëŒ€ ìœ„ì¹˜ ì •ë ¬ ( O(M \log M) )

2.	ê° ë™ë¬¼ì— ëŒ€í•´:

â€¢	(L - y)ê°€ ìŒìˆ˜ì¸ ê²½ìš° â†’ ì–´ì°¨í”¼ ì¡ì„ ìˆ˜ ì—†ìŒ(ê±°ë¦¬ê°€ ì•ˆ ë‹¿ìŒ) â†’ ìŠ¤í‚µ

â€¢	ë‚˜ë¨¸ì§€ ê²½ìš°, \text{ì‚¬ëŒ€ìœ„ì¹˜}ëŠ” [x - (L - y), x + (L - y)] ì•ˆì— ìˆì–´ì•¼.

â€¢	ì´ì§„ íƒìƒ‰ìœ¼ë¡œ ìœ„ êµ¬ê°„ì´ ì‚¬ëŒ€ ë¦¬ìŠ¤íŠ¸ ë‚´ì— ì‹¤ì œ ì¡´ì¬í•˜ëŠ”ì§€ íŒë³„.

â€¢	ì¡´ì¬í•˜ë©´ ì¹´ìš´íŠ¸ +1

3.	ì •ë‹µì€ ì¡ì„ ìˆ˜ ìˆëŠ” ë™ë¬¼ ìˆ˜ ì´í•©.

âœï¸ ì •ë¦¬

â€¢	ì™„ì „íƒìƒ‰ì€ O(M \times N)ìœ¼ë¡œ ì‹œê°„ ì´ˆê³¼

â€¢	â€œ|x - s| + y \le L â†’ s \in [x - (L-y), x + (L-y)]â€ í˜•íƒœë¡œ êµ¬ê°„ì„ êµ¬í•´ë‘ê³ ,

â€¢	ì •ë ¬ëœ ì‚¬ëŒ€ ë°°ì—´ì—ì„œ êµ¬ê°„ ë‚´ì— ì‚¬ëŒ€ê°€ ìˆëŠ”ì§€ ë¹ ë¥´ê²Œ ì°¾ëŠ”ë‹¤(ì´ì§„ íƒìƒ‰).

â€¢	êµ¬í˜„ ì„¸ë¶€ì—ì„œ, bisect_left, bisect_right ë“±ì„ í™œìš©í•˜ë©´ í¸ë¦¬í•©ë‹ˆë‹¤.

ì´ë ‡ê²Œ ì ‘ê·¼í•˜ì‹œê³ , ì˜ˆì œ ì…ë ¥ ëª‡ ê°€ì§€ë¥¼ ì§ì ‘ ì†ìœ¼ë¡œ ì‹œë®¬ë ˆì´ì…˜í•´ë³´ë©´

ì–´ë ¤ìš´ ì ì´ ë§ì´ í•´ì†Œë  ê±°ì˜ˆìš”. í™”ì´íŒ…ì…ë‹ˆë‹¤!

## Phase3. í”¼ë“œë°± í›„ í’€ì–´ë³´ê¸°

# ë¶„í• ì •ë³µ: í–‰ë ¬ ì œê³±

https://www.acmicpc.net/problem/10830

í¬ê¸°ê°€ N*Nì¸ í–‰ë ¬ Aê°€ ì£¼ì–´ì§„ë‹¤. ì´ë•Œ, Aì˜ Bì œê³±ì„ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤. ìˆ˜ê°€ ë§¤ìš° ì»¤ì§ˆ ìˆ˜ ìˆìœ¼ë‹ˆ, A^Bì˜ ê° ì›ì†Œë¥¼ 1,000ìœ¼ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ ì¶œë ¥í•œë‹¤.

## Phase1. ì§ì ‘ í’€ê¸° ì„±ê³µ!

```python
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
divide and conquerë¡œ í’€ì–´ì•¼ í•œë‹¤. base caseëŠ” ë¶„ëª…íˆ ê·¸ê±°.
ì œê³±ë§Œ í•˜ë©´ ë¼ì„œ
ì¼ë‹¨ ê·¸ë˜ë³´ì. ì•„ë‹Œê°€.
ê·¸ëŸ¼ ìˆ˜ë„ì½”ë“œë¥¼ ì‘ì„±í•´ë³´ì.
3. ìˆ˜ë„ ì½”ë“œ
(í•¨ìˆ˜: ì¬ê·€ì ìœ¼ë¡œ dot product, ì¸ìˆ˜: í–‰ë ¬ a, ì œê³±ìˆ˜ b)
    (base case: ë§Œì•½ bê°€ 2ë¼ë©´)
        (a by a dot productí•˜ê³  ë°”ë¡œë°”ë¡œ 1000ëª¨ë“ˆëŸ¬ ì—°ì‚° í›„)
        (ë¦¬í„´: ìœ„ì—ì„œ êµ¬í•œ aì œê³±%b)
    (recursion case)
    (temp=recur(a, b//2)) # ì¬ê·€ë¡œ êµ¬í•œ í–‰ë ¬ ê²°ê³¼ì— ëŒ€í•´,
    (result = 1ë¡œ ì´ˆê¸°í™”ëœ aì™€ ìœ„ìƒì´ ê°™ì€ í–‰ë ¬)
    result = recur(temp, 2)%b # í•œë²ˆ ë” ì¬ê³±ì„ í•´ ì£¼ë©´ ë¨.(ìƒìˆ˜ ì‹œê°„ ë³´ì¥)
    (ë§Œì•½ bê°€ í™€ìˆ˜ë¼ë©´: resultì— ëŒ€í•´ aë¥¼ dot product í•´ì¤˜ì•¼ í•¨.)
        result = (ì´ê±´ ê·¸ëƒ¥ ì—¬ê¸° dot product ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ”ê²Œ ì œì¼ ë¹ ë¥´ê² ë‹¤.)
    return result

4. ì½”ë“œ êµ¬í˜„
"""
import sys

def dot_product(a: list, b: list, n: int):
    """do dot product on identically shaped matrices"""
    result = [
        [0 for _ in range(n)]
        for _ in range(n)
    ]
    
    for i in range(n):
        for j in range(n):
            for k in range(n):
                result[i][j] += a[i][k] * b[k][j]
                # print(f'{result[i][j]} += {a[i][k]} * {b[k][j]}')
            result[i][j] %= 1000
    return result

def recur(a: list, b: int):
    if b == 1:
        result = [
            [0 for _ in range(n)]
            for _ in range(n)
        ]
        for i in range(n):
            for j in range(n):
                result[i][j] = a[i][j] % 1000
        return result
    # bê°€ 0ì¼ ìˆ˜ ìˆë‚˜? 0ì€ 1//2ì¼ ë•Œë§Œ 0ì´ ë‚˜ì˜¤ëŠ”ë°, ê·¸ê±´ ì•„ë§ˆ ë¶ˆê°€ëŠ¥í• ê±´ë°.
    # ê·¼ë° ì €ê±°, 2ì¼ë•Œë„ ì•ˆ í•´ë„ ë˜ì§€ ì•Šë‚˜? ã…‡ã…‡ 
    # ê·¼ë° ì—¬ì „íˆ í‹€ë ¸ë‹¤ê³  í•¨.
    # ì—¬ê¸°ê°€ ì£¼ ì¬ê·€
    temp = recur(a, b // 2) # ì„ í˜• ì¬ê·€
    # ì—¬ê¸°ëŠ” temp ê²°ê³¼ì— ëŒ€í•œ ì¬ê·€
    result = dot_product(temp, temp, n) # ìƒìˆ˜ì‹œê°„
    if b%2 == 1:
        """do result^a"""
        result = dot_product(result, a, n) # ìƒìˆ˜ ì‹œê°„.
    return result

if __name__ == '__main__':
    input = sys.stdin.readline
    n, b = tuple(map(int, input().split()))
    matrix = [tuple(map(int, input().split())) for _ in range(n)]
    result = recur(matrix, b)
    for row in result:
        for elem in row:
            print(elem, end=' ')
        print()

"""
ì´ìŠˆ: 80í”„ë¡œì—ì„œ í‹€ë ¸ìŠµë‹ˆë‹¤.

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: í‹€ë ¸ìŠµë‹ˆë‹¤.
ìµœê·¼ ë³€ê²½ ì‚¬í•­: í–‰ë ¬ ì œê³± ë¶„í• ì •ë³µ ì½”ë“œ ì‘ì„±

Phase2.
í™•ì¸: 80í”„ë¡œë©´ ë­˜ í™•ì¸í•´ì•¼ í•˜ì§€? 
(ê·¸ëŸ°ë° í™•ì‹¤íˆ ìˆ˜ë„ì½”ë“œ ë‹¤ ì‘ì„±í•˜ê³  ì½”ë”©í•˜ë‹ˆê¹Œ ë¹ ë¥´ê¸´ í•˜ë‹¤. 40ë¶„ ê±¸ë ¤ì„œ 80í”„ë¡œ ë§ëŠ” ì½”ë“œë¥¼ ì“°ê¸´ í–ˆìœ¼ë‹ˆ)
ë‹¤ìŒ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ë¥¼ ë°œê²¬(ì§ˆë¬¸ ê²Œì‹œíŒ)
2 1 (2 by 2 í–‰ë ¬ì„ 1ì œê³±í•˜ëŠ” í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤, ê° ì›ì†Œì˜ ìµœëŒ€ê°’ì€ 1000ì´ë¯€ë¡œ í•©ë¦¬ì ì¸ ë²”ìœ„)
1000 1000
1000 1000
ê²°ê³¼
1000 1000 
1000 1000
ì •ë‹µì€ ë‹¹ì—°íˆ ëª¨ë“  í–‰ë ¬ì´ 0ì´ì–´ì•¼ í•¨. ê·¸ëŸ°ë° ë°”ë‹¥ ì¡°ê±´ì—ì„œ ë‹¤ìŒê³¼ ê°™ì´ ì²˜ë¦¬í•˜ëŠ” ë°”ëŒì—
if b == 1:
    return a
ê²°ê³¼ê°€ ìœ„ì™€ ê°™ì´ ë‚˜ì˜¤ê²Œ ë¨.(dot_product í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ì§€ ì•Šìœ¼ë©´ ëª¨ë“ˆëŸ¬ ì—°ì‚°ì„ ê±°ì¹ 
ê¸°íšŒê°€ ì—†ìŒ!)

ì‹œë„: í–‰ë ¬ ì œê³±ì´ 1íšŒì—¬ë„ ëª¨ë“ˆëŸ¬ ì—°ì‚°ì„ í•˜ë„ë¡ ìˆ˜ì •
if b == 1:
    result = [
        [0 for _ in range(n)]
        for _ in range(n)
    ]
    for i in range(n):
        for j in range(n):
            result[i][j] = a[i][j] % 1000
    return result
ë¶„ì„: ì„±ê³µ. ê³±ì…ˆê³¼ ë„ˆë¬´ ìœ ì‚¬í•´ì„œ ì‰½ê²Œ í’€ ìˆ˜ ìˆì—ˆë‹¤.
"""
```



# ìŠ¤íƒ: ê´„í˜¸ì˜ ê°’

https://www.acmicpc.net/problem/2504

4ê°œì˜ ê¸°í˜¸ â€˜(â€™, â€˜)â€™, â€˜[â€™, â€˜]â€™ë¥¼ ì´ìš©í•´ì„œ ë§Œë“¤ì–´ì§€ëŠ” ê´„í˜¸ì—´ ì¤‘ì—ì„œ ì˜¬ë°”ë¥¸ ê´„í˜¸ì—´ì´ë€ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ëœë‹¤.

1. í•œ ìŒì˜ ê´„í˜¸ë¡œë§Œ ì´ë£¨ì–´ì§„ â€˜()â€™ì™€ â€˜[]â€™ëŠ” ì˜¬ë°”ë¥¸ ê´„í˜¸ì—´ì´ë‹¤.
1. ë§Œì¼Â Xê°€ ì˜¬ë°”ë¥¸ ê´„í˜¸ì—´ì´ë©´ â€˜(X)â€™ì´ë‚˜ â€˜[X]â€™ë„ ëª¨ë‘ ì˜¬ë°”ë¥¸ ê´„í˜¸ì—´ì´ ëœë‹¤.
1. Xì™€Â YÂ ëª¨ë‘ ì˜¬ë°”ë¥¸ ê´„í˜¸ì—´ì´ë¼ë©´ ì´ë“¤ì„ ê²°í•©í•œÂ XYë„ ì˜¬ë°”ë¥¸ ê´„í˜¸ì—´ì´ ëœë‹¤.
ì˜ˆë¥¼ ë“¤ì–´ â€˜(()[[]])â€™ë‚˜ â€˜(())[][]â€™ ëŠ” ì˜¬ë°”ë¥¸ ê´„í˜¸ì—´ì´ì§€ë§Œ â€˜([)]â€™ ë‚˜ â€˜(()()[]â€™ ì€ ëª¨ë‘ ì˜¬ë°”ë¥¸ ê´„í˜¸ì—´ì´ ì•„ë‹ˆë‹¤. ìš°ë¦¬ëŠ” ì–´ë–¤ ì˜¬ë°”ë¥¸ ê´„í˜¸ì—´Â Xì— ëŒ€í•˜ì—¬ ê·¸ ê´„í˜¸ì—´ì˜ ê°’(ê´„í˜¸ê°’)ì„ ì•„ë˜ì™€ ê°™ì´ ì •ì˜í•˜ê³  ê°’(X)ë¡œ í‘œì‹œí•œë‹¤.

1. â€˜()â€™ ì¸ ê´„í˜¸ì—´ì˜ ê°’ì€ 2ì´ë‹¤.
1. â€˜[]â€™ ì¸ ê´„í˜¸ì—´ì˜ ê°’ì€ 3ì´ë‹¤.
1. â€˜(X)â€™ ì˜ ê´„í˜¸ê°’ì€ 2Ã—ê°’(X) ìœ¼ë¡œ ê³„ì‚°ëœë‹¤.
1. â€˜[X]â€™ ì˜ ê´„í˜¸ê°’ì€ 3Ã—ê°’(X) ìœ¼ë¡œ ê³„ì‚°ëœë‹¤.
1. ì˜¬ë°”ë¥¸ ê´„í˜¸ì—´Â Xì™€Â Yê°€ ê²°í•©ëœÂ XYì˜ ê´„í˜¸ê°’ì€ ê°’(XY)= ê°’(X)+ê°’(Y) ë¡œ ê³„ì‚°ëœë‹¤.
ì˜ˆë¥¼ ë“¤ì–´ â€˜(()[[]])([])â€™ ì˜ ê´„í˜¸ê°’ì„ êµ¬í•´ë³´ì. â€˜()[[]]â€™ ì˜ ê´„í˜¸ê°’ì´ 2 + 3Ã—3=11 ì´ë¯€ë¡œ â€˜(()[[]])â€™ì˜ ê´„í˜¸ê°’ì€ 2Ã—11=22 ì´ë‹¤. ê·¸ë¦¬ê³  â€˜([])â€™ì˜ ê°’ì€ 2Ã—3=6 ì´ë¯€ë¡œ ì „ì²´ ê´„í˜¸ì—´ì˜ ê°’ì€ 22 + 6 = 28 ì´ë‹¤.

ì—¬ëŸ¬ë¶„ì´ í’€ì–´ì•¼ í•  ë¬¸ì œëŠ” ì£¼ì–´ì§„ ê´„í˜¸ì—´ì„ ì½ê³  ê·¸ ê´„í˜¸ê°’ì„ ì•ì—ì„œ ì •ì˜í•œëŒ€ë¡œ ê³„ì‚°í•˜ì—¬ ì¶œë ¥í•˜ëŠ” ê²ƒì´ë‹¤.

## Phase1. ì‹¤íŒ¨(30ë¶„ ì´ˆê³¼) - ì§„ì „ì´ ì•„ì˜ˆ ì—†ì§€ëŠ” ì•Šì€ë°, ì˜ ëª¨ë¥´ê² ìŒ.

```python
"""
1. ë¬¸ì œ ì½ê¸°: ê´„í˜¸ ì•ˆì— ìˆ«ìê°€ ë“¤ì–´ê°€ëŠ” ê±´ ì•„ë‹˜

2. ë¬¸ì œ í’€ê¸°
(() [ [] ]) ( [] )
(2+3*3)*2 + 3*2
22 + 6 = 28
ì˜¤ì¼€ì´ ì¼ë‹¨ ì†ìœ¼ë¡œëŠ” í’€ë¦°ë‹¤.
ì¼ë‹¨ ì´ê±° ì—´ë¦´ ë•Œ í‘¸ì‹œí•˜ê³ , ë‹«í ë•Œ íŒí•˜ê³ , ê¸°ë³¸ ê·¸ ë¬¸ì œì—ì„œ ì¡°ê±´ë§Œ ì¶”ê°€í•´ì„œ 
ì—°ì¥í•œ ê±° ê°™ì€ë°.
ì¼ë‹¨ ë§Œì•½ ë¹„ì—ˆëŠ”ë° ë‹«ëŠ” ê´„í˜¸ê°€ ì˜¤ë©´ ë¬´ì¡°ê±´ 0 ì¶œë ¥í•˜ë©´ ë¨.
ê·¸ë¦¬ê³  íŒ í•˜ë©´ì„œ ì¼ë‹¨ 2ì ì¸ì§€ 3ì ì¸ì§€ë§Œ íŒë‹¨í•´ë„ ë­...
ê·¸ëƒ¥ ìˆ˜ì‹ì„ ì§ê´€ì ìœ¼ë¡œ ê³„ì‚°í•˜ëŠ”ê²Œ ì¢‹ì§€ ì•Šê² ë‚˜.
tmp = 1
tmp *= 2
tmp *= 3 ì´ëŸ° ì‹ìœ¼ë¡œ
ê·¸ëŸ¬ë‹¤ê°€ ìŠ¤íƒì´ ë¹„ë©´ tmp = 1.
ì¼ë‹¨ í‘¸ì‹œ íŒ ë™ì‘ì´ ë°œìƒí•  ë•Œ ë¡œê·¸ë¥¼ ì°ì–´ì„œ ê°’ì„ ì ì ˆíˆ ì¡°í•©í•´ì„œ ë””ë²„ê¹…í•´ë‚˜ê°€ì.

ì´ê²Œ ê¸°ë³¸ì¸ë°, ì—¬ê¸°ì„œ ì ìˆ˜ë¥¼ ì–´ë–»ê²Œ ê´€ë¦¬í•˜ëŠëƒê°€ ê´€ê±´.ìŠ¤íƒì´ ë‘ê°œ ìˆì–´ì•¼ í•˜ë‚˜? -ì¼ë‹¨ í•´ê²°
ìŠ¤íƒì˜ ê´€ì ì—ì„œ ê³„ì‚° ê°’ì´ ì–´ë–¤ê²Œ ì˜¤ëŠëƒì— ë”°ë¼ ê³±ì…ˆê³¼ ë§ì…ˆì„ êµ¬ë³„.

í’€ì—ˆë‹¤!
ìŠ¤íƒ ì‚¬ì´ì¦ˆë¥¼ ìœ ì§€í•˜ê³ , íŒ í›„ì— ìŠ¤íƒ ì‚¬ì´ì¦ˆê°€ ì´ì „ì— íŒ í• ë•Œ ê¸°ë¡í•œ ì‚¬ì´ì¦ˆì™€ ê°™ìœ¼ë©´ ë§ì…ˆ
ì¤„ì—ˆìœ¼ë©´ ê³±ì…ˆ
3. ìˆ˜ë„ ì½”ë“œ
(ìŠ¤íƒì„ ì´ìš©í•´ê´„í˜¸ ì ìˆ˜ë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜)
    (ìŠ¤íƒì„ ë§Œë“§ë‹ˆë‹¤. ì„¸ ê°œ ìŠ¤íƒ í•„ìš”. ê³„ì‚° ìŠ¤íƒ)
    (ì…ë ¥ ê¸¸ì´ë§Œí¼ ì´í„°ë ˆì´ì…˜ í•©ë‹ˆë‹¤)
        (ì•„ë˜ ìŠ¤íƒì€ (, [ì— ëŒ€í•´ ê°ê° ìœ ì§€í•©ë‹ˆë‹¤.)
        (ë§Œì•½ ì—´ë¦° ê´„í˜¸ê°€ ì˜¨ë‹¤ë©´)
            (ìŠ¤íƒì— í‘¸ì‹œí•©ë‹ˆë‹¤.)
        (ë§Œì•½ ë‹«íŒ ê´„í˜¸ê°€ ì˜¨ë‹¤ë©´)  
            (ë§Œì•½ ìŠ¤íƒì´ ë¹„ì–´ ìˆë‹¤ë©´)  
                (ì•„ë¬»ë”° 0ì„ ë¦¬í„´í•©ë‹ˆë‹¤.)
            (ìŠ¤íƒì—ì„œ íŒ í•©ë‹ˆë‹¤.)
            (íŒì„ í•  ë•Œ ê³„ì‚° ìŠ¤íƒì˜ ì‚¬ì´ì¦ˆë¥¼ ê²€ì‚¬í•˜ê³ )
                (ê°™ìœ¼ë©´ ê°’ì„ ë”í•˜ê³ )
                (ì¤„ì—ˆìœ¼ë©´ ê°’ì„ ê³±í•©ë‹ˆë‹¤.)


4. ì½”ë“œ êµ¬í˜„
"""

from collections import deque
import sys

def solve(parenthesis: list):
    stack1 = deque()
    stack2 = deque()
    stack3 = deque()
    size = 0 # íŒ ë‹¹ì‹œ ê³„ì‚° ìŠ¤íƒì˜ ì‚¬ì´ì¦ˆë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤.
    result = 0
    for p in parenthesis:
        if p == '(':
            stack1.append(p)
            stack3.append(2)
        elif p == ')':
            if not stack1: return 0
            stack1.pop()
            val = stack3.pop()
            if len(stack3) == size:
                result += val
            elif len(stack3) < size:
        if p == '[':
            stack2.append(p)
            stack3.append(3)
        elif p == ']':
            if not stack2: return 0
            stack2.pop()
        print(f'p: {p}, {result}')
    return 1

if __name__ == '__main__':
    input = sys.stdin.readline
    parenthesis = list(input().strip())
    print(parenthesis)
    print(solve(parenthesis))
```

## Phase2. í”¼ë“œë°±

ì•„ë˜ì—ì„œëŠ” ìŠ¤íƒì„ í™œìš©í•´ì„œ â€œê´„í˜¸ì˜ ê°’â€ì„ ê³„ì‚°í•˜ëŠ” ì „í˜•ì ì¸ ë°©ë²•ì„ ì†Œê°œí•´ ë“œë¦½ë‹ˆë‹¤.

ì§ˆë¬¸í•˜ì‹  ì½”ë“œì—ì„œ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì€ ë¶€ë¶„ë“¤ì„ ì •ì„ì ì¸ ë¡œì§ìœ¼ë¡œ ì™„ì„±í•´ë³´ê² ìŠµë‹ˆë‹¤.

1. ì•„ì´ë””ì–´ ìš”ì•½

ì´ ë¬¸ì œ(ë°±ì¤€ 2504 â€œê´„í˜¸ì˜ ê°’â€)ì—ì„œ ìš”êµ¬í•˜ëŠ” ê²ƒì€,

1.	ê´„í˜¸ì—´ì´ ì˜¬ë°”ë¥¸ ê´„í˜¸ì—´ì¸ì§€ ë¨¼ì € í™•ì¸í•´ì•¼ í•¨.

2.	ì˜¬ë°”ë¥´ë‹¤ë©´, ì •ì˜ëœ ê·œì¹™(â€˜()`â€™=2, â€˜[]â€™=3, ê³±ì…ˆê³¼ ë§ì…ˆ)ìœ¼ë¡œ ê°’ì„ êµ¬í•´ì•¼ í•¨.

ì´ë¥¼ í•œ ë²ˆì˜ ìŠ¤ìº”ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ì „í˜•ì ì¸ ìŠ¤íƒ ë°©ì‹ì„ ì†Œê°œí•©ë‹ˆë‹¤.

1.1 ìŠ¤íƒ ì ‘ê·¼ ê°œë…

â€¢	ë¬¸ìì—´ì„ ì™¼ìª½ë¶€í„° ì˜¤ë¥¸ìª½ê¹Œì§€ ìˆœíšŒí•˜ë©´ì„œ,

â€¢	**â€˜ì—¬ëŠ” ê´„í˜¸(â€˜(â€™, â€˜[â€™)â€™**ê°€ ë‚˜ì˜¤ë©´ ìŠ¤íƒì— push

â€¢	**â€˜ë‹«ëŠ” ê´„í˜¸(â€˜)â€™, â€˜]â€™)â€™**ê°€ ë‚˜ì˜¤ë©´:

â€¢	ìŠ¤íƒì´ ë¹„ì–´ìˆìœ¼ë©´ â†’ ì˜¬ë°”ë¥¸ ê´„í˜¸ì—´ì´ ì•„ë‹˜(ê²°ê³¼=0)

â€¢	ìŠ¤íƒ topì„ í™•ì¸

â€¢	ë§Œì•½ topì´ â€œí•´ë‹¹ ë‹«ëŠ” ê´„í˜¸ì— ëŒ€ì‘í•˜ëŠ” ì—¬ëŠ” ê´„í˜¸â€ë¼ë©´(ì˜ˆ: top=â€™(â€˜ì´ê³  í˜„ì¬=â€™)â€™):

â€¢	ìŠ¤íƒì—ì„œ popí•´ì„œ ì—†ì•¤ ë’¤,

â€¢	ê·¸ ìë¦¬ì— í•´ë‹¹ ê´„í˜¸ê°’(2 ë˜ëŠ” 3)ì„ push

â€¢	ì¦‰, ()ë¥¼ ê°’=2ë¼ëŠ” ìˆ«ìë¡œ ì¹˜í™˜

â€¢	[]ë¥¼ ê°’=3ì´ë¼ëŠ” ìˆ«ìë¡œ ì¹˜í™˜

â€¢	ë§Œì•½ topì´ ìˆ«ìë¼ë©´ (ì´ë¯¸ ê³„ì‚°ëœ ê°’), ì¦‰ (...) ë‚´ë¶€ì— ê°’ì´ ë“¤ì–´ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ:

â€¢	ì—°ì†ëœ ìˆ«ìë“¤ì„ ëª¨ì•„ì„œ í•©ì„ êµ¬í•œ ë’¤,

â€¢	ê·¸ í•©ì— ê´„í˜¸ê°’(2ë‚˜ 3)ì„ ê³±í•œ ê°’ì„ ë‹¤ì‹œ ìŠ¤íƒì— push

â€¢	ì˜ˆ) â€œ( (someValue) )â€ â†’ someValueì— 2ë¥¼ ê³±

â€¢	ì˜ˆ) â€œ[ (someValue) ]â€ â†’ someValueì— 3ì„ ê³±

â€¢	ê·¸ ê³¼ì •ì—ì„œ ì—¬ëŠ” ê´„í˜¸(â€˜(â€™ ë˜ëŠ” â€˜[â€™)ë¥¼ ë§Œë‚˜ popí•˜ë©´ ì¤‘ë‹¨í•©ë‹ˆë‹¤.

â€¢	ë¬¸ìì—´ ì „ì²´ë¥¼ ì²˜ë¦¬í•œ ë’¤,

â€¢	ìŠ¤íƒì— ìˆ«ìë§Œ ë‚¨ì•„ ìˆë‹¤ë©´, ê·¸ ìˆ«ìë“¤ì˜ í•©ì´ ìµœì¢… ë‹µ.

â€¢	ë§Œì•½ ìŠ¤íƒì— ê´„í˜¸ê°€ ë‚¨ì•„ ìˆìœ¼ë©´(â€˜(â€™, â€˜[â€™) â†’ ì˜¬ë°”ë¥´ì§€ ì•Šì€ ê´„í˜¸ì—´ì´ë¯€ë¡œ 0.

ì´ ë¡œì§ëŒ€ë¡œ êµ¬í˜„í•˜ë©´,

â€¢	ì˜¬ë°”ë¥¸ ê´„í˜¸ì—´ì´ ì•„ë‹ ê²½ìš° ì¤‘ê°„ì— ë°”ë¡œ ê°ì§€ ê°€ëŠ¥(ìŠ¤íƒ top ë¶ˆì¼ì¹˜, ë¹„ì–´ìˆëŠ”ì§€ ê²€ì‚¬ ë“±).

â€¢	ì˜¬ë°”ë¥¸ ê´„í˜¸ì—´ì´ë©´, ìŠ¤íƒì— ìˆ«ìë“¤ë§Œ ë‚¨ê²Œ ë˜ê³ , ê·¸ê²ƒë“¤ì„ ì „ë¶€ í•©í•˜ë©´ ìµœì¢… ê°’.

2. ë‹¨ê³„ë³„ ë¡œì§ ì˜ˆì‹œ

ì˜ˆ) (()[[]])([])

1.	( â†’ push '('

2.	( â†’ push '('

3.	) â†’ ìŠ¤íƒ topì´ '(' â†’ íŒ í›„, 2ë¥¼ push

â€¢	ìŠ¤íƒì—ëŠ” ['(', 2]

4.	[ â†’ push '['

â€¢	ìŠ¤íƒ: ['(', 2, '[']

5.	[ â†’ push '['

â€¢	ìŠ¤íƒ: ['(', 2, '[', '[']

6.	] â†’ ìŠ¤íƒ topì´ '[' â†’ íŒ í›„, 3ì„ push

â€¢	ìŠ¤íƒ: ['(', 2, '[', 3]

7.	] â†’ ìŠ¤íƒ topì´ 3 (ìˆ«ì) â†’ ë” ì´ì „ topì€ '['(ì—¬ëŠ” ê´„í˜¸)

â€¢	ì¦‰ â€œì—°ì†ëœ ìˆ«ìâ€=3, ê·¸ í•©ì€ 3

â€¢	ì—¬ëŠ” ê´„í˜¸ '[' pop â†’ í•© Ã— 3 = 3Ã—3=9 push

â€¢	ìŠ¤íƒ: ['(', 2, 9]

8.	) â†’ ìŠ¤íƒ topì´ ìˆ«ì(9) â†’ ì´ì „ topì€ 2(ë˜ ìˆ«ì) â†’ ì´ì „ ì´ì „ topì€ '('(ì—¬ëŠ” ê´„í˜¸)

â€¢	ì¦‰, â€œì—°ì†ëœ ìˆ«ìë“¤â€ = 2 + 9 = 11

â€¢	ê·¸ ë‹¤ìŒ '('ì„ pop â†’ 11 Ã— 2 = 22 push

â€¢	ìŠ¤íƒ: [22]

9.	( â†’ push '('

10.	[ â†’ push '['

11.	] â†’ ìŠ¤íƒ topì´ '[' â†’ pop, 3 push

â€¢	ìŠ¤íƒ: [22, '(', 3]

12.	) â†’ ìŠ¤íƒ topì´ 3 â†’ ì´ì „ topì´ '(' â†’ ì—°ì†ëœ ìˆ«ì=3

â€¢	'(' pop â†’ 3Ã—2=6 push

â€¢	ìŠ¤íƒ: [22, 6]

13.	ë¬¸ìì—´ ë â†’ ìŠ¤íƒì— [22, 6]

â€¢	ì „ë¶€ ìˆ«ì â†’ 22+6=28

â€¢	ê²°ê³¼=28

ì´ ê³¼ì •ì„ ì½”ë“œí™”í•˜ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ì—¬ëŸ¬ if/elseë¡œ ë‚˜ëˆ ì§€ëŠ”ë°, êµ¬í˜„ ì‹œ â€œìŠ¤íƒ topì´ ê´„í˜¸ì¸ì§€, ìˆ«ìì¸ì§€â€ë¥¼ ì–´ë–»ê²Œ êµ¬ë¶„í• ì§€ê°€ í•µì‹¬ì…ë‹ˆë‹¤.

3. íŒŒì´ì¬ êµ¬í˜„ ì˜ˆì‹œ

ì£¼ìš” í¬ì¸íŠ¸

1.	ìŠ¤íƒì˜ ì›ì†Œ

â€¢	ë¬¸ìì—´ ë¬¸ì: â€˜(â€™, â€˜[â€™, â€¦

â€¢	ìˆ«ì(ì´ë¯¸ ê³„ì‚°ëœ ê°’): 2, 3, 6, 9, â€¦

2.	ë‹«ëŠ” ê´„í˜¸ ì²˜ë¦¬ ì‹œ

â€¢	ìŠ¤íƒ topì´ â€œê°™ì€ ì¢…ë¥˜ì˜ ì—¬ëŠ” ê´„í˜¸â€ë¼ë©´ â†’ ()=2, []=3

â€¢	ìŠ¤íƒ topì´ ìˆ«ìì´ë©´ â†’ ì—°ì†ëœ ìˆ«ìë“¤ì„ ëª¨ë‘ ë”í•œ í›„, ê·¸ ë‹¤ìŒì— ì—¬ëŠ” ê´„í˜¸ë¥¼ popí•˜ì—¬ ê³±ì…ˆ.

â€¢	ì—¬ëŠ” ê´„í˜¸ê°€ ì—†ëŠ” ê²½ìš°, ì¢…ë¥˜ê°€ ì•ˆ ë§ëŠ” ê²½ìš° â†’ 0 ë¦¬í„´(ì˜¬ë°”ë¥´ì§€ ì•ŠìŒ).

3.	ìµœì¢… ìŠ¤íƒ ê²€ì¦

â€¢	ëª¨ë“  ë¬¸ì ì²˜ë¦¬ í›„ì—ë„ ìŠ¤íƒì— â€œì—¬ëŠ” ê´„í˜¸â€ê°€ ë‚¨ì•„ ìˆìœ¼ë©´ â†’ 0 ë¦¬í„´

â€¢	ìˆ«ìë§Œ ìˆë‹¤ë©´ ê·¸ í•©ì´ ê²°ê³¼.

4. ìì£¼ í•˜ëŠ” ì‹¤ìˆ˜ì™€ ë””ë²„ê¹… íŒ

1.	ì—¬ëŸ¬ ê°’ì´ ì¤‘ì²©ë˜ì—ˆì„ ë•Œ,

â€¢	ì˜ˆ: ( [ ( ) ( ) ] ) ì²˜ëŸ¼ ë‚´ë¶€ì— ì´ë¯¸ ìˆ«ìê°€ ëˆ„ì ëœ ìƒíƒœì¼ ìˆ˜ ìˆìŒ.

â€¢	ë‹«ëŠ” ê´„í˜¸ë¥¼ ë§Œë‚˜ì„œ popí•  ë•Œ, ì—°ì†ëœ ìˆ«ìë¥¼ ëª¨ë‘ ë”í•´ ì£¼ëŠ” ê²ƒì´ í•µì‹¬ì…ë‹ˆë‹¤.

2.	ì§ì´ ì•ˆ ë§ëŠ” ê´„í˜¸ ì²˜ë¦¬

â€¢	ìŠ¤íƒì´ ë¹„ì–´ ìˆëŠ”ë° ë‹«ëŠ” ê´„í˜¸ê°€ ì˜¤ê±°ë‚˜,

â€¢	ì—¬ëŠ” ê´„í˜¸ ì¢…ë¥˜ê°€ ë‹¤ë¥´ë©´( topì´ â€˜(`ì¸ë° ë‹«ëŠ” ê´„í˜¸ê°€ â€˜]â€™ ë¼ë“ ì§€ ), ì¦‰ì‹œ 0 ë¦¬í„´.

3.	ë¬¸ìì—´ ëë‚¬ëŠ”ë°ë„ ìŠ¤íƒì— â€˜(`, â€˜[â€™ê°€ ë‚¨ì•„ ìˆë‹¤ë©´ 0.

4.	ê°’ì´ 0ì¸ ìƒíƒœì—ì„œ ê³±ì…ˆí•  ë•Œ:

â€¢	ë‚´ë¶€ê°€ ë¹„ì–´ìˆëŠ” ê´„í˜¸ìŒ: ()=2, []=3ìœ¼ë¡œ ì²˜ë¦¬ â†’ if val_sum == 0: val_sum = 2 or 3

5. ê²°ë¡ 

â€¢	ìœ„ ë¡œì§ëŒ€ë¡œ êµ¬í˜„í•˜ë©´,

1.	ê´„í˜¸ì—´ ìœ íš¨ì„± ì²´í¬

2.	ê´„í˜¸ê°’ ê³„ì‚°

ëª¨ë‘ ìŠ¤íƒ í•œ ë²ˆ ìˆœíšŒë¡œ í•´ê²° ê°€ëŠ¥í•©ë‹ˆë‹¤.

â€¢	ìŠ¤íƒì— ê´„í˜¸ì™€ ìˆ«ìë¥¼ í•¨ê»˜ ë„£ê³  ê´€ë¦¬í•˜ëŠ” ê²ƒì´ í¬ì¸íŠ¸ì…ë‹ˆë‹¤.

â€¢	ë¬¸ì œ ì¡°ê±´ì— ë§ì§€ ì•ŠëŠ” ê²½ìš°(ì§ì´ ì•ˆ ë§ê±°ë‚˜, ë¬¸ìì—´ ëë‚˜ë„ ê´„í˜¸ ë‚¨ìŒ ë“±)ëŠ” ì¦‰ì‹œ 0ìœ¼ë¡œ ì²˜ë¦¬.

ìœ„ ì½”ë“œë¥¼ ì‹¤í–‰í•´ ë³´ì‹œë©´, ì˜ˆì‹œ ì…ë ¥ (()[[]])([])ì— ëŒ€í•´ 28ì´ ì˜ ì¶œë ¥ë©ë‹ˆë‹¤.

ì„±ê³µì ìœ¼ë¡œ í†µê³¼í•˜ì‹œê¸¸ ë°”ëë‹ˆë‹¤! ì¶”ê°€ ì§ˆë¬¸ ìˆìœ¼ì‹œë©´ ì–¸ì œë“  ë‚¨ê²¨ì£¼ì„¸ìš”. í™”ì´íŒ…ì…ë‹ˆë‹¤.

# ìŠ¤íƒ: í¬ê²Œ ë§Œë“¤ê¸°

https://www.acmicpc.net/problem/2812

Nìë¦¬ ìˆ«ìê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì—¬ê¸°ì„œ ìˆ«ì Kê°œë¥¼ ì§€ì›Œì„œ ì–»ì„ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì‹¤íŒ¨

```python
"""
1. ë¬¸ì œ ì½ê¸°
Nìë¦¬ ìˆ«ìê°€ ì£¼ì–´ì¡Œì„ ë•Œ, 
ì—¬ê¸°ì„œ ìˆ«ì Kê°œë¥¼ ì§€ì›Œì„œ ì–»ì„ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

2. ë¬¸ì œ í’€ê¸°

ìŠ¤íƒ ìë£Œêµ¬ì¡°ë¥¼ ì“°ëŠ” ê±°ê² ì§€? ê·¸ëŸ¼ ì¼ë‹¨ í”Œë ˆì¸ í•˜ê²Œ ìƒê°í–ˆì„ ë•Œ ìŠ¤íƒì— ìˆ«ìë¥¼ ì°¨ë¡€ë¡œ ì§‘ì–´ ë„£ê³ 
nì€ ìµœëŒ€ 50ë§Œ ìë¦¬ìˆ˜.

ê·¼ë° í’€ì´ê°€ ìƒê° ì•ˆ ë‚œë‹¤. ìœ ì‚¬í•œ ë¬¸ì œ? 
ê°€ì¥ ì‘ì€ ìë¦¿ìˆ˜ë¥¼ ë½‘ì•„ë‚´ëŠ” ë¬¸ì œ? ì¢€ ê·¸ë¦¬ë””í•œ ê±° ê°™ì€ë°.
ìë¦¿ìˆ˜ ì ìˆ˜? 
ì•ˆìª½ì—ëŠ” í° ìˆ˜ì¼ìˆ˜ë¡ ì¢‹ê³ 
1924
1234
4321

ì‘ì€ ìˆ«ìë¥¼ êµ¬í˜„í•œë‹¤ë©´?

1 

1  
9 

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""
```

## Phase2. í”¼ë“œë°±

ì¢‹ìŠµë‹ˆë‹¤. ë¬¸ì œ ì ‘ê·¼ì„ ì‹œë„í•œ í”ì ì´ ì˜ ë³´ì´ë„¤ìš”! ì´ì œ ì´ ë¬¸ì œë¥¼ í‘¸ëŠ” í•µì‹¬ ì•„ì´ë””ì–´ì™€ í•¨ê»˜ ê·¸ë¦¬ë”” + ìŠ¤íƒ ë°©ì‹ìœ¼ë¡œ ì ‘ê·¼í•´ë³´ëŠ” í”¼ë“œë°±ì„ ë“œë¦´ê²Œìš”.

ğŸ” ë¬¸ì œ í•µì‹¬ ì •ë¦¬

â€¢	Nìë¦¬ ìˆ«ìê°€ ì£¼ì–´ì§ (ìµœëŒ€ 500,000ìë¦¬)

â€¢	ì´ ì¤‘ì—ì„œ Kê°œì˜ ìˆ«ìë¥¼ ì§€ì›Œì„œ, ê°€ì¥ í° ìˆ˜ë¥¼ ë§Œë“¤ì–´ì•¼ í•¨

â€¢	ìˆœì„œë¥¼ ë°”ê¾¸ì§€ ì•Šê³  ì¼ë¶€ ìˆ«ìë¥¼ ì œê±°í•´ì•¼ í•¨ â†’ ê·¸ë¦¬ë”” + ìŠ¤íƒ

ğŸ’¡ í•µì‹¬ ì•„ì´ë””ì–´

ê°€ì¥ í° ìˆ˜ë¥¼ ë§Œë“¤ê¸° ìœ„í•´ì„ , ì™¼ìª½ë¶€í„° ê°€ëŠ¥í•œ í•œ í° ìˆ«ìê°€ ì•ì— ì˜¤ë„ë¡ ë§Œë“¤ì–´ì•¼ í•´ìš”.

ê·¸ë˜ì„œ ìŠ¤íƒì„ ì‚¬ìš©í•´ ì•„ë˜ì™€ ê°™ì´ ì²˜ë¦¬í•´ìš”:

1.	í˜„ì¬ ìˆ«ìê°€ ìŠ¤íƒì˜ ë§¨ ìœ„ ìˆ«ìë³´ë‹¤ í´ ê²½ìš°, ì´ì „ ìˆ«ìë¥¼ ì œê±° (ë‹¨, ì•„ì§ Kê°œ ì œê±°í•˜ì§€ ì•Šì•˜ë‹¤ë©´)

2.	ì´ ê³¼ì •ì„ ë°˜ë³µí•˜ë©´ì„œ, ì•ì˜ ìˆ«ìë“¤ì„ ê°€ëŠ¥í•œ í•œ ì‘ê²Œ ë§Œë“ ë‹¤

3.	ìˆ«ìë¥¼ ë‹¤ ìŠ¤íƒì— ë„£ê³  ë‚˜ì„œë„, Kê°œë¥¼ ë‹¤ ì§€ìš°ì§€ ì•Šì•˜ë‹¤ë©´ ë’¤ì—ì„œë¶€í„° ë” ì§€ì›Œì•¼ í•¨

ğŸ§  ì˜ˆì‹œ

ì…ë ¥: 1924, K=2

ê°€ì¥ í° ìˆ˜: 94

ê³¼ì •:

â€¢	ìŠ¤íƒ: []

â€¢	1 â†’ ìŠ¤íƒ: [1]

â€¢	9 > 1 â†’ pop(1), k -= 1 â†’ ìŠ¤íƒ: [], push(9)

â€¢	2 â†’ 2 < 9 â†’ push(2) â†’ ìŠ¤íƒ: [9,2]

â€¢	4 > 2 â†’ pop(2), k -= 1 â†’ ìŠ¤íƒ: [9], push(4) â†’ [9,4]

ìµœì¢… ê²°ê³¼: 94

âœ… ê°œì„ ëœ ìˆ˜ë„ ì½”ë“œ

âœ¨ í•œ ë¬¸ì¥ ìš”ì•½

> ì•ì—ì„œë¶€í„° ì°¨ë¡€ë¡œ ìˆ«ìë¥¼ ë³´ë©°, ë’¤ ìˆ«ìê°€ í¬ë©´ ì• ìˆ«ìë¥¼ ì§€ì›Œë‚˜ê°€ë©°

í•„ìš”í•˜ë‹¤ë©´ ì „ì²´ ì½”ë“œ êµ¬í˜„ë„ ë„ì™€ë“œë¦´ê²Œìš”!

## Phase3. í”¼ë“œë°± í›„ ë‹¤ì‹œ í’€ì–´ë³´ê¸°-ì„±ê³µ

```python
"""
1. ë¬¸ì œ ì½ê¸°
Nìë¦¬ ìˆ«ìê°€ ì£¼ì–´ì¡Œì„ ë•Œ, 
ì—¬ê¸°ì„œ ìˆ«ì Kê°œë¥¼ ì§€ì›Œì„œ ì–»ì„ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

2. ë¬¸ì œ í’€ê¸°

ìŠ¤íƒ ìë£Œêµ¬ì¡°ë¥¼ ì“°ëŠ” ê±°ê² ì§€? ê·¸ëŸ¼ ì¼ë‹¨ í”Œë ˆì¸ í•˜ê²Œ ìƒê°í–ˆì„ ë•Œ ìŠ¤íƒì— ìˆ«ìë¥¼ ì°¨ë¡€ë¡œ ì§‘ì–´ ë„£ê³ 
nì€ ìµœëŒ€ 50ë§Œ ìë¦¬ìˆ˜.

ê·¼ë° í’€ì´ê°€ ìƒê° ì•ˆ ë‚œë‹¤. ìœ ì‚¬í•œ ë¬¸ì œ? 
ê°€ì¥ ì‘ì€ ìë¦¿ìˆ˜ë¥¼ ë½‘ì•„ë‚´ëŠ” ë¬¸ì œ? ì¢€ ê·¸ë¦¬ë””í•œ ê±° ê°™ì€ë°.
ìë¦¿ìˆ˜ ì ìˆ˜? 
ì•ˆìª½ì—ëŠ” í° ìˆ˜ì¼ìˆ˜ë¡ ì¢‹ê³ 
1924
1234
4321

ì‘ì€ ìˆ«ìë¥¼ êµ¬í˜„í•œë‹¤ë©´?

ê·¸ë¦¬ë””ê°€ ë§ì•˜ë‹¤. ìŠ¤íƒì— ìˆ«ìë¥¼ ë„£ê³ , (kê°œë¥¼ ëœ ì§€ìš´ ìƒíƒœì—ì„œ) í˜„ì¬ ìˆ«ìë³´ë‹¤ í° ìˆ«ìê°€ ì˜¤ë©´, 
í˜„ì¬ ìˆ«ìë¥¼ ë¹¼ê³  ëŒ€ì‹  í‘¸ì‹œ. ë˜‘ê°™ì´ ì§„í–‰í•˜ê³ 
ì´ ê³¼ì • ëë‚˜ê³  k ë§Œí¼ ì œê±°ê°€ ì•ˆ ëë‹¤ë©´ ë’¤ì—ì„œë¶€í„° ì œê±° <- ì™œ ì´ë˜ë„ ë˜ëŠ”ì§€ ì´í•´ê°€ ì˜...
ì™œëƒë©´ í° ìˆ˜ì¼ìˆ˜ë¡ ì•ì— ìˆì„ ìˆ˜ë°–ì— ì—†ìœ¼ë‹ˆê¹Œ? ì‚¬ì‹¤ ì˜ ë‚©ë“ì´ ì•ˆ ê°„ë‹¤. 
ì¼ë‹¨ ìˆ˜ë„ ì½”ë“œë¥¼ ì‘ì„±í•´ë³´ì.

3. ìˆ˜ë„ ì½”ë“œ
(ìŠ¤íƒ ì´ˆê¸°í™”)
(ëª¨ë“  ìˆ«ìì— ëŒ€í•´ ì´í„°ë ˆì´ì…˜í•œë‹¤.)
    (ë§Œì•½ ìŠ¤íƒì´ ë¹„ì–´ ìˆìœ¼ë©´ ê·¸ëƒ¥ í‘¸ì‹œí•œë‹¤.)
    (ìˆ«ìë¥¼ í”¼í¬ì™€ ë¹„êµí•œë‹¤.)
    (ë§Œì•½ ìˆ«ìê°€ í”¼í¬ë³´ë‹¤ í¬ë©´ )
        (íŒí•˜ê³  ëŒ€ì‹  ë„£ëŠ”ë‹¤.)
        (ì¹´ìš´í„°ë¥¼ ì˜¬ë¦°ë‹¤.)
    (ì‘ìœ¼ë©´ ê·¸ëƒ¥ ë„£ëŠ”ë‹¤.)
(ì´í„°ë ˆì´ì…˜ ì¢…ë£Œ)
(ë§Œì•½ ì¹´ìš´í„°ê°€ Kë³´ë‹¤ ì‘ìœ¼ë©´ ê·¸ë§Œí¼ íŒ í•œë‹¤.)


4. ì½”ë“œ êµ¬í˜„
"""


from collections import deque

import sys

def solve(nums: list):
    stack = deque()
    cnt = 0
    stack.append(nums[0])
    for num in nums[1:]:
        while stack and stack[-1] < num and cnt < k:
            tmp = stack.pop()
            # print(f'popped {tmp} from stack. now {stack}')
            cnt += 1
        stack.append(num)
        # print(f'appended {num}. now {stack}')
    while cnt < k:
        # print(f'while {cnt} < {k}')
        stack.pop()
        cnt += 1
    return stack

        

if __name__ == '__main__':
    input = sys.stdin.readline
    n, k = tuple(map(int, input().split()))
    nums = list(input().strip())
    result = solve(nums)
    for r in result:
        print(r, end='')
    print()


"""
ì´ìŠˆ: í‹€ë ¸ìŠµë‹ˆë‹¤.

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì•„ë˜ëŠ” ì •ë‹µì´ ë‚˜ì˜¤ëŠ” ê²½ìš°ì˜ ë¡œê·¸
7 3
1231234
popped 1 from stack. now deque([])
appended 2. now deque(['2'])
popped 2 from stack. now deque([])
appended 3. now deque(['3'])
appended 1. now deque(['3', '1'])
popped 1 from stack. now deque(['3'])
appended 2. now deque(['3', '2'])
appended 3. now deque(['3', '2', '3'])
appended 4. now deque(['3', '2', '3', '4'])
3234%      

ìµœê·¼ ë³€ê²½ ì‚¬í•­: ìŠ¤íƒìœ¼ë¡œ ìµœëŒ€ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í•¨ìˆ˜ ì‘ì„±.

Phase2.
í™•ì¸: ë‹¤ì–‘í•œ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‹œë„í•˜ëŠ” ë°©ë²•
ì˜¤ë¦„ì°¨ìˆœ 1234
ë‚´ë¦¼ì°¨ìˆœ 4321
ìˆ«ìë¥¼ í•˜ë‚˜ë§Œ ë‚¨ê¸°ê³  ë‹¤ ì§€ìš°ëŠ” ê²½ìš°
kê°€ 1ì´ê³  nì´ 2ì¸ ê²½ìš°.
ì–´ ë’¤ì— %ê¸°í˜¸ ë­ì§€? ìƒê´€ ì—†ì—ˆìŒ.
ëª¨ë“  ìˆ«ìê°€ ê°™ì€ ê²½ìš°. 

ì°¾ì•˜ë‹¤.
10 4
4177252841
477584
ì •ë‹µ: 775841ì„.
í•´ë‹¹ ì¼€ì´ìŠ¤ì˜ ë¡œê·¸
10 4
4177252841
appended 1. now deque(['4', '1'])
popped 1 from stack. now deque(['4'])
appended 7. now deque(['4', '7'])  <---ì´ë–„ ì™œ ë¹„êµê°€ ì•ˆ ì¼ì–´ë‚˜ì§€? ì•„,
ê·¸ ì „ì— 1ì´ ë“¤ì–´ì™”ì–´ì„œ, í•œ ë²ˆë§Œ ë¹„êµí•˜ê³  ëë‚¬êµ¬ë‚˜. whileë¡œ ë°”ê¿”ì•¼ í•¨.
appended 7. now deque(['4', '7', '7'])
appended 2. now deque(['4', '7', '7', '2'])
popped 2 from stack. now deque(['4', '7', '7'])
appended 5. now deque(['4', '7', '7', '5'])
appended 2. now deque(['4', '7', '7', '5', '2'])
popped 2 from stack. now deque(['4', '7', '7', '5'])
appended 8. now deque(['4', '7', '7', '5', '8'])
appended 4. now deque(['4', '7', '7', '5', '8', '4'])
appended 1. now deque(['4', '7', '7', '5', '8', '4', '1'])
while 3 < 4
477584

ì‹œë„: 
ì•„ë˜ ì¡°ê±´ë¬¸ì„ ë£¨í”„ë¡œ ì „í™˜
if stack[-1] < num and cnt < k:
    tmp = stack.pop()
    # print(f'popped {tmp} from stack. now {stack}')
    cnt += 1
stack.append(num)
--->
while stack and stack[-1] < num and cnt < k:
    tmp = stack.pop()
    # print(f'popped {tmp} from stack. now {stack}')
    cnt += 1
stack.append(num)
ë¶„ì„: ì„±ê³µ
"""
```

# ë¶„í• ì •ë³µ: ê°€ì¥ ê°€ê¹Œìš´ ë‘ ì 

https://www.acmicpc.net/problem/2261

2ì°¨ì› í‰ë©´ìƒì— nê°œì˜ ì ì´ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ ì ë“¤ ì¤‘ ê°€ì¥ ê°€ê¹Œìš´ ë‘ ì ì„ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì§ì ‘ í’€ê¸° - 15í”„ë¡œ ì •ë‹µâ€¦

```python
"""
1. ë¬¸ì œ ì½ê¸°
2ì°¨ì› í‰ë©´ìƒì— nê°œì˜ ì ì´ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ ì ë“¤ ì¤‘ ê°€ì¥ ê°€ê¹Œìš´ ë‘ ì ì„ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

2. ë¬¸ì œ í’€ê¸°
ì¢Œí‘œí‰ë©´ì´ë‹ˆê¹Œ
ì¢Œìƒì—ì„œ ì œì¼ ê°€ê¹Œìš´ ì  ì‚¬ì´ ê±°ë¦¬
ìš°ìƒì—ì„œ ì œì¼ ê°€ê¹Œìš´ ì  ì‚¬ì´ ê±°ë¦¬
ì¢Œí•˜ì—ì„œ ì œì¼ ê°€ê¹Œìš´ ì  ì‚¬ì´ ê±°ë¦¬
ìš°í•˜ì—ì„œ ì œì¼ ê°€ê¹Œìš´ ì  ì‚¬ì´ ê±°ë¦¬
crossì—ì„œ ì œì¼ ê°€ê¹Œìš´ ì  ì‚¬ì´ì˜ ê±°ë¦¬?
ì ì´ nê°œë¼ í•  ë•Œ ì™„ì „íƒìƒ‰ í•˜ë©´ ë‹¹ì—°íˆ n^2ì˜ ë¹„êµë¥¼ í•´ì•¼ êµ¬í•  ìˆ˜ ìˆìŒ.

ì  ìì²´ë¥¼ ë‘ ê°€ì§€ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ê³ , 
(xê°€ ì‘ì„ìˆ˜ë¡, yê°€ ì‘ì„ìˆ˜ë¡)
ê·¸ ë‹¤ìŒì— ì ë“¤ì— ëŒ€í•´ ë¶„í• ì •ë³µí•˜ë©´ ë˜ì§€ ì•Šë‚˜? 
ì™¼ìª½ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì  ì¬ê·€ë¡œ êµ¬í•˜ê³ , 
ì˜¤ë¥¸ìª½ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ê±°ë¦¬ ì¬ê·€ë¡œ êµ¬í•˜ê³ 
ê°€ìš´ë° ê±¸ì³ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì  ì»´ë°”ì¸ ê³¼ì •ì—ì„œ êµ¬í•˜ê³ 
ë¦¬í„´ì„ ìµœì†Œê°’ìœ¼ë¡œ í•´ì£¼ë©´.

ì•„ì´ë””ì–´ ìì²´ëŠ” ì´ê²Œ ë§ì„ ê±° ê°™ë‹¤.

5 -> 2, 3
4 -> 2, 2
3 -> 3
2 -> 2
1 -> ì´ëŸ° ê²½ìš° ì—†ìŒ

3. ìˆ˜ë„ ì½”ë“œ

(ê±¸ì¹˜ëŠ” ìµœì†Œë¥¼ êµ¬í•˜ëŠ” í•¨ìˆ˜(left, mid, right))
    (left, right ì˜ì—­ ì „ì²´ì—ì„œ ìµœì†Œ ê±°ë¦¬ êµ¬í•´ì£¼ê¸°. ì–´ ì´ê±° íˆìŠ¤í† ê·¸ë¨ ì‚¬ê°í˜•ì´ë‘ ë¹„ìŠ·í•˜ê²Œ í•˜ë©´ ì•ˆ ë˜ë‚˜)
    lo, hi = mid, mid+1
    (ì˜¤ë¥¸ìª½ ì ì„ ì„ íƒ í–ˆì„ ë•Œ ì™¼ìª½ ì ì„ ì„ íƒí•œ ê²½ìš°ë³´ë‹¤ ê±°ë¦¬ê°€ ì¤„ì–´ë“ ë‹¤ë©´)
        (ì˜¤ë¥¸ìª½ìœ¼ë¡œ ê°‘ë‹ˆë‹¤.)
    (ê·¸ê²Œ ì•„ë‹ˆë©´ ì™¼ìª½ìœ¼ë¡œ ê°‘ë‹ˆë‹¤.)
    (ì´ê±°ëŠ” ì•½ê°„ ê¸°ì–µì— ì˜ì¡´í•´ì„œ í•˜ê²Œ ë  ê±° ê°™ê¸´ í•œë°.)

(ì¬ê·€ì ìœ¼ë¡œ left, rightì˜ ì˜ì—­ì˜ ì ë“¤ì— ëŒ€í•´ ê°€ì¥ ê°€ê¹Œìš´ ì  ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ë¦¬í„´í•˜ëŠ” í•¨ìˆ˜)
    (ë°”ë‹¥ ì¡°ê±´: left+1 == right, ì¦‰, ì ì´ ë‘ ê°œ ìˆëŠ” ìƒí™©)
        (ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ìƒìˆ˜ì‹œê°„ì— êµ¬í•´ì„œ ë¦¬í„´)
    (left == rightì¼ìˆ˜ë„ ìˆìŒ: ê·¸ëŸ¬ë©´ ì–´ë–¡í•´ì•¼ í•¨? 0ì„ ë¦¬í„´í•˜ë©´ ì•ˆ ë˜ê³ . nì€ 2 ì´ìƒì´ë‹ˆê¹Œ, 1ì´ ì•„ë‹ˆë¼ 3ì¸ ê²½ìš°ë¥¼ ë´ì£¼ë©´ ì•ˆ ë˜ë‚˜.)
    (ì¬ê·€ì¡°ê±´)
    (ê°€ìš´ë° ì¸ë±ìŠ¤ = (left+right)//2)
    (ì™¼ìª½ ìµœì†Œ = ì¬ê·€(left, mid))
    (ì˜¤ë¥¸ìª½ ìµœì†Œ = ì¬ê·€(mid+1, right)
    (ì´ì œ ê±¸ì¹˜ëŠ” ìµœì†Œ(cross_min)ì„ êµ¬í•´ì•¼ í•¨. ì´ê±° ë³µì¡í•˜ë‹ˆê¹Œ ë³„ë„ì˜ í•¨ìˆ˜ë¡œ ë¹¼ì„œ ìƒê°í•˜ì ì¼ë‹¨.)
    (return min(ì™¼ìª½ ìµœì†Œ, ì˜¤ë¥¸ìª½ ìµœì†Œ, ê±¸ì¹˜ëŠ” ìµœì†Œ))
        

4. ì½”ë“œ êµ¬í˜„
"""

import sys

def get_cross_min(left, mid, right):
    """mid ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¢Œ ìš°ë¡œ ìµœì„ ì˜ ì„ íƒì´ ë˜ëŠ” ë™ì•ˆ ì ì„ ì„ íƒí•´ì„œ ê±°ë¦¬ë¥¼ ë¦¬í„´"""
    lo, hi = mid, mid + 1
    cross_len = (dots[lo][0] - dots[hi][0])**2 + (dots[lo][1] - dots[hi][1])**2
    while lo > left or hi < right:
        # ì™¼ìª½ìœ¼ë¡œ ê°€ëŠ” ê²½ìš°ì˜ ê¸¸ì´
        
        if hi < right and (lo == left or 
                           (dots[lo-1][0] - dots[hi][0])**2 + (dots[lo-1][1] - dots[hi][1])**2
                           >
                           (dots[lo][0] - dots[hi+1][0])**2 + (dots[lo][1] - dots[hi+1][1])**2
                           ):
            hi += 1
            cross_len = min(cross_len, (dots[lo][0] - dots[hi][0])**2 + (dots[lo][1] - dots[hi][1])**2)
        else:
            lo -= 1
            cross_len = min(cross_len, (dots[lo][0] - dots[hi][0])**2 + (dots[lo][1] - dots[hi][1])**2)
    return cross_len

def recur(left: int, right: int):
    """left, right ì˜ì—­ì˜ ì ë“¤ì— ëŒ€í•´ ê°€ì¥ ê°€ê¹Œìš´ ì  ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ë¦¬í„´í•œë‹¤."""
    if left + 2 == right: # ì˜ì—­ì— ì ì´ ì„¸ ê°œì¼ ë•Œ.
        a, b, c = dots[left], dots[left+1], dots[right] 
        # ì„¸ ì ì˜ ê±°ë¦¬ë¥¼ êµ¬í•œë‹¤.
        dist_a = (a[0] - b[0])**2 + (a[1] - b[1])**2 # a - b
        dist_b = (a[0] - c[0])**2 + (a[1] - c[1])**2 # a - c
        dist_c = (c[0] - b[0])**2 + (c[1] - b[1])**2 # b - c
        return min(dist_a, dist_b, dist_c)
    if left + 1 == right: # ì˜ì—­ì˜ ì ì´ ë‘˜ ì¼ë•Œ.
        a, b = dots[left], dots[right]
        return (a[0] - b[0])**2 + (a[1] - b[1])**2
    
    mid = (left+right)//2
    left_min = recur(left, mid)
    right_min = recur(mid+1, right)
    cross_min = get_cross_min(left, mid, right)
    return min(left_min, right_min, cross_min)



if __name__ == '__main__':
    input = sys.stdin.readline
    n = int(input().strip())
    dots = [
        tuple(map(int, input().split()))
        for _ in range(n)
    ]
    dots.sort(key=lambda x: (x[0], x[1]))
    # print(dots)
    print(recur(0, len(dots)-1))
    
```

í‹€ë¦° ì´ìœ 

![](./images/8b2d4fa6-8dec-48fd-b014-d20cd2d9294f.png)

cross_len êµ¬í•˜ëŠ” ê³¼ì •ì— ê±°ë¦¬ê°€ ê°€ê¹Œì›Œë„ ê°€ìš´ë°ì„œ ì €ë ‡ê²Œ íŠ¸ë¡¤í•˜ëŠ”(yê±°ë¦¬ê°€ ì—„ì²­ ë©€ì–´ë²„ë¦° ì• ë“¤ì´ ìˆìœ¼ë©´) ë‘ ì ì´ ì´ì–´ì§€ì§€ ëª»í•  ìˆ˜ë„ ìˆìŒ. 

ìµœì„ ì˜ ì„ íƒì€ y ê¸°ì¤€ìœ¼ë¡œ í•œë²ˆ ë” ì •ë ¬ì„ í•´ì„œ ì§„í–‰í•˜ëŠ” ê±´ë°, ì´ê²Œ ê·¸ëƒ¥ ì†”ë£¨ì…˜ì„ ë‘ë²ˆ ëŒë¦¬ë©´ ì˜¤ë‹µì„ ë‘ë²ˆ ì°¾ëŠ” ê²°ê³¼ê°€ ë‚˜ì˜¤ê¸°ë„ í•¨. ê·¸ê²Œ ì•„ë‹ˆë©´ ì¬ê·€ ê³¼ì •ì—ì„œ ì •ë ¬ ë° íƒìƒ‰ì„ í•´ì¤˜ì•¼ í•˜ëŠ”ë°, ì „ì²´ ì •ë ¬ì„ í•´ë²„ë¦¬ë©´ ì „ì²´ ì¸ë±ìŠ¤ê°€ ííŠ¸ëŸ¬ì ¸ë²„ë¦¼. 

ìŠ¬ë¼ì´ì‹±í•´ì„œ left, right ì¸ë±ìŠ¤ ì•ˆì—ì„œë§Œ ì •ë ¬ í•´ì£¼ë©´ ë˜ì§€ ì•Šë‚˜? ëª»í•˜ê² ë‹¤. ë¨¸ë¦¬ê°€ ì•ˆ ëŒì•„ê°„ë‹¤.

## Phase2. í”¼ë“œë°±

ì¢‹ì€ ì‹œë„ì˜€ì–´ìš”! ë¬¸ì œì˜ í•µì‹¬ì€ ì œëŒ€ë¡œ íŒŒì•…í•˜ì…¨ê³ , ë¶„í•  ì •ë³µ êµ¬ì¡°ë„ ì˜ ì§œì…¨ìŠµë‹ˆë‹¤. ë‹¤ë§Œ get_cross_minì—ì„œ ê°€ìš´ë° ê±¸ì¹œ ì˜ì—­ì˜ ìµœì†Œ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ë°©ì‹ì´ ì •í™•íˆ êµ¬í˜„ë˜ì§€ ì•Šì•„ ì˜¤ë‹µì´ ë°œìƒí•œ ê²ƒìœ¼ë¡œ ë³´ì…ë‹ˆë‹¤.

ì•„ë˜ëŠ” ë³´ì™„í•  ìˆ˜ ìˆëŠ” í•µì‹¬ í¬ì¸íŠ¸ì…ë‹ˆë‹¤:

âœ… í•µì‹¬ í”¼ë“œë°±

1. ê°€ì¥ ê°€ê¹Œìš´ ë‘ ì ì„ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ì˜ í•µì‹¬

â€¢	ë¶„í•  ì •ë³µì„ í†µí•´ ì¢Œ/ìš° ì˜ì—­ì„ ë‚˜ëˆ„ê³ ,

â€¢	ì¢Œ/ìš° ê°ê°ì—ì„œì˜ ìµœì†Œ ê±°ë¦¬ dë¥¼ êµ¬í•œ ë’¤,

â€¢	|x - mid_x| <= dë¥¼ ë§Œì¡±í•˜ëŠ” ì ë“¤ë§Œ ë”°ë¡œ ëª¨ì•„ì„œ,

â€¢	yì¢Œí‘œ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ í›„, yê±°ë¦¬ê°€ d ì´í•˜ì¸ ì ë“¤ ì¤‘ì—ì„œë§Œ ë‹¤ì‹œ ê±°ë¦¬ ê³„ì‚° (ìµœëŒ€ 6ìŒë§Œ ë¹„êµ)

2. get_cross_min í•¨ìˆ˜ì˜ ë¬¸ì œì 

â€¢	í˜„ì¬ êµ¬í˜„ì€ ë‹¨ìˆœíˆ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ì„ í™•ì¥í•˜ë©´ì„œ ê±°ë¦¬ë¥¼ ë¹„êµí•˜ì§€ë§Œ, yê±°ë¦¬ ì œí•œ ì¡°ê±´ì„ ê³ ë ¤í•˜ì§€ ì•Šì•„ ë¬´ì˜ë¯¸í•œ ë¹„êµê°€ ë§ê³ , ì‹¤ì œ ê°€ê¹Œìš´ ì ìŒì„ ë†“ì¹  ìˆ˜ ìˆì–´ìš”.

ğŸ“Œ ì •ì„ ì•Œê³ ë¦¬ì¦˜ ë¡œì§ ìš”ì•½ (O(n log n))

1.	x ê¸°ì¤€ ì •ë ¬, ì¬ê·€ í˜¸ì¶œë¡œ ì¢Œ/ìš°ì—ì„œ ê°ê° d1, d2 ìµœì†Œ ê±°ë¦¬ êµ¬í•¨

2.	d = min(d1, d2) ì´í›„, |x - mid_x| < d ë²”ìœ„ì˜ ì ë“¤ë§Œ ë”°ë¡œ temp ë¦¬ìŠ¤íŠ¸ì— ì €ì¥

3.	ì´ tempë¥¼ y ê¸°ì¤€ ì •ë ¬ í›„, y ê±°ë¦¬ë„ dë³´ë‹¤ ì‘ì€ ê²½ìš°ë§Œ ë¹„êµí•˜ì—¬ ìµœì†Œê°’ ê°±ì‹ 

â€¢	ì´ ê³¼ì •ì—ì„œ í•œ ì  ê¸°ì¤€ìœ¼ë¡œ ìµœëŒ€ 6ê°œ ì ë§Œ ë¹„êµí•˜ë©´ ì¶©ë¶„

âœ¨ ì°¸ê³  êµ¬í˜„ ì½”ë“œ

```python
import sys
import math
input = sys.stdin.readline

def distance(p1, p2):
    return (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2

def closest_pair(points):
    def solve(points_sorted_x, points_sorted_y):
        n = len(points_sorted_x)
        if n <= 3:
            min_dist = float('inf')
            for i in range(n):
                for j in range(i+1, n):
                    min_dist = min(min_dist, distance(points_sorted_x[i], points_sorted_x[j]))
            return min_dist

        mid = n // 2
        mid_x = points_sorted_x[mid][0]
        left_x = points_sorted_x[:mid]
        right_x = points_sorted_x[mid:]

        # y ê¸°ì¤€ ì •ë ¬ë„ ê°ê° ë‚˜ëˆ ì¤˜ì•¼ í•¨
        left_y = []
        right_y = []
        for p in points_sorted_y:
            if p[0] <= mid_x:
                left_y.append(p)
            else:
                right_y.append(p)

        d = min(solve(left_x, left_y), solve(right_x, right_y))

        # cross ì˜ì—­ í›„ë³´êµ°ë§Œ ìˆ˜ì§‘
        strip = [p for p in points_sorted_y if abs(p[0] - mid_x) < d]

        for i in range(len(strip)):
            for j in range(i+1, len(strip)):
                if (strip[j][1] - strip[i][1])**2 >= d:
                    break
                d = min(d, distance(strip[i], strip[j]))
        return d

    points_sorted_x = sorted(points)
    points_sorted_y = sorted(points, key=lambda x: x[1])
    return solve(points_sorted_x, points_sorted_y)

if __name__ == "__main__":
    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]
    print(closest_pair(points))
```

ğŸ’­ ì¶”ê°€ íŒ

â€¢	ê±°ë¦¬ì˜ ì œê³±ìœ¼ë¡œ ë¹„êµí•˜ë©´ math.sqrt() í˜¸ì¶œì´ ì—†ì–´ì ¸ ì†ë„ í–¥ìƒ ê°€ëŠ¥

â€¢	stripì˜ yì¢Œí‘œ ê¸°ì¤€ ì •ë ¬ì€ cross ì˜ì—­ì„ ë¹ ë¥´ê²Œ íƒìƒ‰í•˜ëŠ” í•µì‹¬

í•„ìš”í•˜ì‹œë©´ ì´ ì•Œê³ ë¦¬ì¦˜ì˜ ê·¸ë¦¼ ì„¤ëª…ì´ë‚˜ ìˆ˜ì‹ ì„¤ëª…, í˜¹ì€ ì¶”ê°€ ì‹¤ìŠµ ì˜ˆì œë„ ë„ì™€ë“œë¦´ê²Œìš”!

## Phase3. í”¼ë“œë°± í›„ ì¬ë„ì „ì´ì§€ë§Œâ€¦ì‹¤íŒ¨

ì†”ì§íˆ ì§€ê¸ˆ ë‘ë‡Œ ìƒíƒœë¡œ ì œëŒ€ë¡œ ë¬¸ì œë¥¼ í’€ ìì‹ ì´ ì—†ìŒ. ë°”ë¡œ ì½”ë“œ í•„ì‚¬ ë° ì±„ì ìœ¼ë¡œ ë„˜ì–´ê°ˆ ê²ƒ. 

### 1. í•„ì‚¬: ì§ˆë¬¸ ì •ë¦¬

í•„ì‚¬ í•˜ë©´ì„œ í•˜ì…”ì•¼ í•  ì¼ì€, ì½”ë“œì— ì˜ë¬¸ì„ ê°€ì§€ëŠ” ê²ë‹ˆë‹¤. ì‚¬ì§„ì„ ì²¨ë¶€í•˜ê³  ì§ˆë¬¸ ë¦¬ìŠ¤íŠ¸ë¥¼ ì •ë¦¬í•˜ì„¸ìš”

![](./images/IMG_0086.png)

![](./images/IMG_0087.png)

### 2. ì±„ì 

(ì‚¬ì§„ ì²¨ë¶€)

### 3. ì½”ë”© í˜¹ì€ ì¬ì±„ì 



