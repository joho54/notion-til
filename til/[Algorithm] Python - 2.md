# [Algorithm] Python - 2



> ê°œë…ê³¼ ì´ìŠˆ íŠ¸ë˜í‚¹ì„ ì¡°í•©í•´ì„œ â€œë³µê¸° ê°€ëŠ¥í•œâ€ ìë£Œë¥¼ ë§Œë“¤ë„ë¡ í•©ë‹ˆë‹¤.

> ì´ìŠˆ íŠ¸ë˜í‚¹ ì‘ì„± ì›ì¹™: Phase1(í™˜ê²½, ë¡œê·¸, ìµœê·¼ ë³€ê²½ì‚¬í•­), Phase2(í™•ì¸, ì‹œë„, ê²°ê³¼ë¶„ì„) í˜•ì‹ìœ¼ë¡œ ì •ë¦¬í•˜ì„¸ìš”. (Phase2ëŠ” ìµœëŒ€ 3íšŒê¹Œì§€ ë°˜ë³µí•˜ê³  í•´ê²° ì•ˆ ë˜ë©´ ì•„ì˜ˆ ì²˜ìŒë¶€í„° ì‹œì‘(ë¶ˆê°€ëŠ¥í•  ê²½ìš° ë„ì›€ ìš”ì²­))

> ì‹¤ìŠµì€ ì²œì²œíˆ, í•˜ì§€ë§Œ robustí•˜ê²Œ í•˜ì„¸ìš”. 

> í’€ì´ì— ì‹¤íŒ¨í–ˆë‹¤ë©´, ì ‘ë§‰í‹€ ì •ë¦¬(ì ‘ê·¼ë°©ë²•, ë§‰íŒ ë¶€ë¶„)



# ì¬ê·€: ì¿¼ë“œíŠ¸ë¦¬

https://www.acmicpc.net/problem/1992

## ë¬¸ì œ

í‘ë°± ì˜ìƒì„ ì••ì¶•í•˜ì—¬ í‘œí˜„í•˜ëŠ” ë°ì´í„° êµ¬ì¡°ë¡œ ì¿¼ë“œ íŠ¸ë¦¬(Quad Tree)ë¼ëŠ” ë°©ë²•ì´ ìˆë‹¤. í° ì ì„ ë‚˜íƒ€ë‚´ëŠ” 0ê³¼ ê²€ì€ ì ì„ ë‚˜íƒ€ë‚´ëŠ” 1ë¡œë§Œ ì´ë£¨ì–´ì§„ ì˜ìƒ(2ì°¨ì› ë°°ì—´)ì—ì„œ ê°™ì€ ìˆ«ìì˜ ì ë“¤ì´ í•œ ê³³ì— ë§ì´ ëª°ë ¤ìˆìœ¼ë©´, ì¿¼ë“œ íŠ¸ë¦¬ì—ì„œëŠ” ì´ë¥¼ ì••ì¶•í•˜ì—¬ ê°„ë‹¨íˆ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

ì£¼ì–´ì§„ ì˜ìƒì´ ëª¨ë‘ 0ìœ¼ë¡œë§Œ ë˜ì–´ ìˆìœ¼ë©´ ì••ì¶• ê²°ê³¼ëŠ” "0"ì´ ë˜ê³ , ëª¨ë‘ 1ë¡œë§Œ ë˜ì–´ ìˆìœ¼ë©´ ì••ì¶• ê²°ê³¼ëŠ” "1"ì´ ëœë‹¤. ë§Œì•½ 0ê³¼ 1ì´ ì„ì—¬ ìˆìœ¼ë©´ ì „ì²´ë¥¼ í•œ ë²ˆì— ë‚˜íƒ€ë‚´ì§€ë¥¼ ëª»í•˜ê³ , ì™¼ìª½ ìœ„, ì˜¤ë¥¸ìª½ ìœ„, ì™¼ìª½ ì•„ë˜, ì˜¤ë¥¸ìª½ ì•„ë˜, ì´ë ‡ê²Œ 4ê°œì˜ ì˜ìƒìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì••ì¶•í•˜ê²Œ ë˜ë©°, ì´ 4ê°œì˜ ì˜ì—­ì„ ì••ì¶•í•œ ê²°ê³¼ë¥¼ ì°¨ë¡€ëŒ€ë¡œ ê´„í˜¸ ì•ˆì— ë¬¶ì–´ì„œ í‘œí˜„í•œë‹¤

ìœ„ ê·¸ë¦¼ì—ì„œ ì™¼ìª½ì˜ ì˜ìƒì€ ì˜¤ë¥¸ìª½ì˜ ë°°ì—´ê³¼ ê°™ì´ ìˆ«ìë¡œ ì£¼ì–´ì§€ë©°, ì´ ì˜ìƒì„ ì¿¼ë“œ íŠ¸ë¦¬ êµ¬ì¡°ë¥¼ ì´ìš©í•˜ì—¬ ì••ì¶•í•˜ë©´ "(0(0011)(0(0111)01)1)"ë¡œ í‘œí˜„ëœë‹¤. N Ã—N í¬ê¸°ì˜ ì˜ìƒì´ ì£¼ì–´ì§ˆ ë•Œ, ì´ ì˜ìƒì„ ì••ì¶•í•œ ê²°ê³¼ë¥¼ ì¶œë ¥í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì§ì ‘ í’€ê¸°

ìƒê°ë³´ë‹¤ëŠ” ì‰½ê²Œ í’€ë ¸ë‹¤. ë‹¨, ê´„í˜¸ë¥¼ ì¶œë ¥í•˜ëŠ” ë¶€ë¶„ì—ì„œ ì¬ê·€ì˜ ìˆœì„œë¥¼ ì œëŒ€ë¡œ ìƒê°í•˜ì§€ ì•Šì•„ì„œ ì¡°ê¸ˆ í—¤ë§¸ë‹¤. Zë³´ë‹¤ ì¢€ ë” ì‰¬ì› ëŠ”ë°, ì‚¬ì‹¤ ê±°ì˜ ë™ì¼í•œ ë¬¸ì œì¸ ê±° ê°™ë‹¤.

```javascript
# 1. ë¬¸ì œ ì½ê¸°
# 2. ë¬¸ì œ í’€ê¸°
# 3. ìˆ˜ë„ ì½”ë“œ
# 4. ì½”ë“œ êµ¬í˜„

def is_base(A: list, r: int, c: int, n: int):
    """A ë°°ì—´ì˜ r, cë¥¼ ì‹œì‘ì ìœ¼ë¡œ í•˜ëŠ” n ì˜ì—­ì˜ í•©ì„ êµ¬í•˜ê³ , 0ì´ê±°ë‚˜ n^2ì´ë©´ Trueë¥¼ ë¦¬í„´"""
    pixels = 0
    for i in range(r, r+n):
        for j in range(c, c+n):
            pixels += A[i][j]
    if pixels == 0: return 0
    elif pixels == n**2: return 1
    return -1

def recur(A: list, r, c, n):
    pixels = is_base(A, r, c, n)
    if pixels != -1:
        print(pixels, end='')
        return
    # 1 ì‚¬ë¶„ë©´ ì¬ê·€
    half = n//2
    print('(', end='')
    recur(A, r, c, half)
    # 3 ì‚¬ë¶„ë©´ ì¬ê·€
    recur(A, r, c+half, half)
    # 2 ì‚¬ë¶„ë©´ ì¬ê·€
    recur(A, r+half, c, half)
    # 4 ì‚¬ë¶„ë©´ ì¬ê·€
    recur(A, r+half, c+half, half)
    print(')', end='')
        

n = int(input())
arr = [
    tuple(map(int, list(input())))
    for _ in range(n)
]

recur(arr, 0, 0, n)

```

## Phase2. í”¼ë“œë°±

ì•„ë˜ëŠ” ì¿¼ë“œ íŠ¸ë¦¬(BOJ 1992) ë¬¸ì œë¥¼ í•´ê²°í•œ ì½”ë“œì™€ ê·¸ì— ëŒ€í•œ ìƒì„¸ í”¼ë“œë°±ì…ë‹ˆë‹¤.

1. ì „ì²´ ì½”ë“œ ë¦¬ë·°

ì œì‹œí•˜ì‹  ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

```python
def is_base(A: list, r: int, c: int, n: int):
    """A ë°°ì—´ì˜ r, cë¥¼ ì‹œì‘ì ìœ¼ë¡œ í•˜ëŠ” nÃ—n ì˜ì—­ì˜ ëª¨ë“  ì›ì†Œë¥¼ í•©í•œë‹¤.
       í•©ì´ 0ì´ë©´ ëª¨ë‘ 0, n^2ì´ë©´ ëª¨ë‘ 1, ê·¸ ì™¸ì—ëŠ” -1ì„ ë°˜í™˜."""
    pixels = 0
    for i in range(r, r+n):
        for j in range(c, c+n):
            pixels += A[i][j]
    if pixels == 0:          # ëª¨ë‘ 0
        return 0
    elif pixels == n**2:     # ëª¨ë‘ 1
        return 1
    return -1                # 0, 1 ì„ì—¬ ìˆìŒ

def recur(A: list, r: int, c: int, n: int):
    pixels = is_base(A, r, c, n)
    if pixels != -1:
        print(pixels, end='')  # ì••ì¶• ê²°ê³¼(0 ë˜ëŠ” 1)ë¥¼ ë°”ë¡œ ì¶œë ¥
        return

    # 0,1ì´ ì„ì—¬ ìˆìœ¼ë¯€ë¡œ 4ë“±ë¶„
    half = n // 2
    print('(', end='')

    # [1] top-left
    recur(A, r, c, half)
    # [2] top-right
    recur(A, r, c + half, half)
    # [3] bottom-left
    recur(A, r + half, c, half)
    # [4] bottom-right
    recur(A, r + half, c + half, half)

    print(')', end='')


n = int(input())
arr = [tuple(map(int, list(input()))) for _ in range(n)]

recur(arr, 0, 0, n)
```

â€¢	is_base í•¨ìˆ˜: ì£¼ì–´ì§„ êµ¬ì—­(r,c ë¶€í„° nÃ—n)ì„ ìˆœíšŒí•˜ë©° í•©ì´ 0ì´ë©´ ì „ë¶€ 0, í•©ì´ n^2ì´ë©´ ì „ë¶€ 1, ì„ì—¬ ìˆìœ¼ë©´ -1.

â€¢	ë°°ì—´ì— 0ê³¼ 1ë°–ì— ì—†ìœ¼ë¯€ë¡œ, í•©ì„ í†µí•´ â€œëª¨ë‘ 0 or ëª¨ë‘ 1â€ì„ ë¹ ë¥´ê²Œ íŒë³„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	recur í•¨ìˆ˜:

1.	is_baseë¡œ í˜„ì¬ êµ¬ì—­ì´ ì „ë¶€ 0 í˜¹ì€ ì „ë¶€ 1ì¸ì§€ í™•ì¸.

2.	ì „ë¶€ ê°™ì€ ê°’ì´ë©´(0 ë˜ëŠ” 1) ë°”ë¡œ ì¶œë ¥.

3.	ì•„ë‹ˆë©´ 4ê°œë¡œ ìª¼ê°œì–´ ê°ê° ì¬ê·€ í˜¸ì¶œí•˜ê³ , ì‚¬ì´ì— ê´„í˜¸ë¥¼ ì¶œë ¥.

ì •ìƒ ë™ì‘ ë° ì¶œë ¥ ìˆœì„œ

â€¢	ì¿¼ë“œ íŠ¸ë¦¬ ë¬¸ì œì—ì„œ ìš”êµ¬í•˜ëŠ” ìˆœì„œ(ì™¼ìª½ ìœ„, ì˜¤ë¥¸ìª½ ìœ„, ì™¼ìª½ ì•„ë˜, ì˜¤ë¥¸ìª½ ì•„ë˜)ëŒ€ë¡œ ì¬ê·€ê°€ ì§„í–‰ë˜ë¯€ë¡œ ë¬¸ì œ ì‚¬ì–‘ê³¼ ì¼ì¹˜í•©ë‹ˆë‹¤.

â€¢	ì¶œë ¥ í˜•ì‹((0(0011)(0(0111)01)1))ë„ ê´„í˜¸ë¥¼ ì—´ê³  ë‹«ëŠ” ìˆœì„œê°€ ë§ë‹¤ë©´ ì •ìƒì ì¸ ê²°ê³¼ë¥¼ ì–»ìŠµë‹ˆë‹¤.

2. ì„¸ë¶€ í”¼ë“œë°±

2.1 ì‚¬ë¶„ë©´(ì¿¼ë“œ) ìˆœì„œì™€ ì£¼ì„

ì½”ë“œì—ì„œ ì‚¬ë¶„ë©´ì„ í˜¸ì¶œí•˜ëŠ” ìˆœì„œëŠ”:

1.	recur(A, r, c, half) â†’ top-left

2.	recur(A, r, c+half, half) â†’ top-right

3.	recur(A, r+half, c, half) â†’ bottom-left

4.	recur(A, r+half, c+half, half) â†’ bottom-right

ê·¸ëŸ°ë° ì£¼ì„ì—ì„œ â€œ1ì‚¬ë¶„ë©´, 3ì‚¬ë¶„ë©´â€ ì‹ìœ¼ë¡œ í‘œí˜„í•˜ì…¨ë‹¤ë©´, ìˆ˜í•™ì  ì¢Œí‘œê³„ë‚˜ ì¼ë°˜ì  ì¿¼ë“œíŠ¸ë¦¬ í‘œê¸°ì™€ ì•½ê°„ ë‹¤ë¥¼ ìˆ˜ ìˆì–´ì„œ í˜¼ë™ë  ì—¬ì§€ê°€ ìˆìŠµë‹ˆë‹¤.

â€¢	ë³´í†µ â€œ1ì‚¬ë¶„ë©´(top-left), 2ì‚¬ë¶„ë©´(top-right), 3ì‚¬ë¶„ë©´(bottom-left), 4ì‚¬ë¶„ë©´(bottom-right)â€ë¼ëŠ” ì‹ìœ¼ë¡œ ëª…ëª…í•˜ë©´, ìˆœì„œì™€ ì£¼ì„ì´ ì–´ê¸‹ë‚  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ë¬¸ì œì—ì„œ ìš”êµ¬í•˜ëŠ” ì²˜ë¦¬ ìˆœì„œëŠ” â€œì™¼ìœ„, ì˜¤ë¥¸ìœ„, ì™¼ì•„ë˜, ì˜¤ë¥¸ì•„ë˜â€ì´ë¯€ë¡œ, ì½”ë“œì²˜ëŸ¼ ëª…í™•íˆ ì£¼ì„ì„ ë‹¬ì•„ë‘ë©´ ì¢‹ìŠµë‹ˆë‹¤(ì˜ˆ: â€œtop-leftâ€, â€œtop-rightâ€, â€œbottom-leftâ€, â€œbottom-rightâ€).

2.2 ì‹œê°„ ë³µì¡ë„: ëª¨ë“  ë¶„í•  ì‹œ ë§¤ë²ˆ í•© ê³„ì‚°

â€¢	í˜„ì¬ ì½”ë“œëŠ” ë§¤ ë¶„í• ë§ˆë‹¤ nÃ—n ì›ì†Œë¥¼ ì „ë¶€ ìˆœíšŒ(is_base)í•˜ê³ , 0/1 íŒë³„ í›„ í•„ìš”ì‹œ 4ë¶„í• ì„ í•©ë‹ˆë‹¤.

â€¢	ìµœì•…ì˜ ê²½ìš°(ëª¨ë‘ ì„œë¡œ ë‹¤ë¥¸ íŒ¨í„´)ì—ëŠ” ê° ë¶„í• ë§ˆë‹¤ nÃ—nì„ ìŠ¤ìº” â†’ ë¶„í• ì´ log(n) ë‹¨ê³„(2ì°¨ì›ì )ë¡œ ì§„í–‰ â†’ ëŒ€ëµ O(n^2 log n) ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	N ìµœëŒ€ 64 ì •ë„ë¼ë©´ ì „í˜€ ë¬¸ì œ ì—†ê³ , ì¼ë°˜ì ì¸ BOJ 1992 ì œí•œ(N â‰¤ 64) ì•ˆì—ì„œëŠ” ì¶©ë¶„íˆ ë¹ ë¦…ë‹ˆë‹¤.

â€¢	ë§Œì•½ Nì´ ë” ì»¤ì§„ë‹¤ë©´ í”„ë¦¬í”½ìŠ¤ í•©(2D prefix sum) ë“±ì„ ì´ìš©í•´ ì„œë¸Œ êµ¬ì—­ì˜ í•©ì„ O(1)ì— êµ¬í•˜ë©´ ë” íš¨ìœ¨ì ì´ê¸´ í•˜ì§€ë§Œ, ì´ ë¬¸ì œì—ì„  í•„ìš” ì—†ìŠµë‹ˆë‹¤.

2.3 â€œëª¨ë‘ ê°™ì€ ê°’â€ íŒë³„í•˜ëŠ” ë‹¤ë¥¸ ë°©ë²•

â€¢	í•©ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³ , â€œì²« ë²ˆì§¸ ì›ì†Œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì „ë¶€ ë¹„êµâ€í•´ì„œ ë‹¤ë¥¸ ê°’ì´ í•˜ë‚˜ë¼ë„ ë‚˜ì˜¤ë©´ ë¶„í• â€ í•˜ëŠ” ì‹ë„ ìˆìŠµë‹ˆë‹¤:

```python
first_val = A[r][c]
all_same = True
for i in range(r, r+n):
    for j in range(c, c+n):
        if A[i][j] != first_val:
            all_same = False
            break
    if not all_same:
        break

if all_same:
    print(first_val, end='')
    return
# else ë¶„í• 
```

â€¢	ì„±ëŠ¥ìƒ í° ì°¨ì´ëŠ” ì—†ê³ (ì—­ì‹œ O(n^2)), 0/1ë§Œ ë‹¤ë£¨ëŠ” ë¬¸ì œì—ì„œëŠ” í•©ì„ í†µí•´ n^2ê³¼ ë¹„êµí•˜ëŠ” ë°©ë²•ì´ë‚˜, ëª¨ë“  ê°’ì´ ë™ì¼í•œì§€ ë¹„êµí•˜ëŠ” ë°©ë²•ì´ë‚˜ ììœ ë¡­ê²Œ ì„ íƒ ê°€ëŠ¥í•©ë‹ˆë‹¤.

2.4 ì¶œë ¥ ë°©ì‹(ë¬¸ìì—´ vs print)

â€¢	í˜„ì¬ëŠ” í•¨ìˆ˜ ë‚´ì—ì„œ print(..., end='')ë¡œ ë°”ë¡œë°”ë¡œ ì¶œë ¥í•˜ê³  ìˆìŠµë‹ˆë‹¤.

â€¢	BOJ í™˜ê²½ì—ì„œëŠ” ì´ë ‡ê²Œ í•´ë„ ë¬¸ì œ ì—†ì§€ë§Œ, ë¬¸ìì—´ì„ ëª¨ì•„ ë§ˆì§€ë§‰ì— í•œ ë²ˆì— ì¶œë ¥í•˜ëŠ” ë°©ì‹ì„ ì„ í˜¸í•˜ëŠ” ê²½ìš°ë„ ìˆìŠµë‹ˆë‹¤(ì„±ëŠ¥ ë° ìœ ì§€ë³´ìˆ˜).

â€¢	ì›í•˜ì‹œë©´ return ê°’ìœ¼ë¡œ ë¬¸ìì—´ì„ ë„˜ê¸°ê³  ìµœì¢…ì— print(result_str)ë¥¼ í•œ ë²ˆì— ì°ëŠ” ë°©ì‹ìœ¼ë¡œ ë°”ê¿€ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

ì˜ˆì‹œ (ë¬¸ìì—´ í•©ì¹˜ëŠ” ë²„ì „):

```python
def quad_tree(A, r, c, n):
    val = is_base(A, r, c, n)
    if val != -1:
        return str(val)
    half = n // 2
    top_left = quad_tree(A, r, c, half)
    top_right = quad_tree(A, r, c + half, half)
    bottom_left = quad_tree(A, r + half, c, half)
    bottom_right = quad_tree(A, r + half, c + half, half)
    return "(" + top_left + top_right + bottom_left + bottom_right + ")"
```

ì´ë ‡ê²Œ í•˜ë©´ ë§ˆì§€ë§‰ì— print(quad_tree(A, 0, 0, n))ë¡œ ê¹”ë”í•˜ê²Œ í•œ ë²ˆì— ì¶œë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤.

3. ê²°ë¡  ì •ë¦¬

1.	ì½”ë“œ ê¸°ëŠ¥: ìš”êµ¬ ì‚¬í•­ëŒ€ë¡œ ì˜ ë™ì‘í•©ë‹ˆë‹¤.

2.	ì‚¬ë¶„ë©´ ìˆœì„œ: ë¬¸ì œì—ì„œ ì œì‹œí•œ â€œì™¼ìœ„, ì˜¤ë¥¸ìœ„, ì™¼ì•„ë˜, ì˜¤ë¥¸ì•„ë˜â€ ìˆœì„œë¥¼ ì •í™•íˆ ì¤€ìˆ˜í•˜ë©´ ë©ë‹ˆë‹¤.

3.	ì‹œê°„ ë³µì¡ë„: N=64 ì´í•˜ë¼ë©´ í˜„ì¬ êµ¬í˜„(ë§¤ ë¶„í•  ì‹œ nÃ—n ìŠ¤ìº”)ë„ ì„±ëŠ¥ìƒ ì¶©ë¶„í•©ë‹ˆë‹¤.

4.	ì¶œë ¥ ë°©ì‹: ì§€ê¸ˆì²˜ëŸ¼ printë¥¼ ì¬ê·€ ì•ˆì—ì„œ ë°”ë¡œ ì“°ëŠ” ê²ƒë„ ë¬¸ì œ ì—†ì§€ë§Œ, ë¬¸ìì—´ì„ í•©ì³ì„œ í•œ ë²ˆì— ì¶œë ¥í•˜ëŠ” íŒ¨í„´ë„ ì¢‹ìŠµë‹ˆë‹¤.

ì „ì²´ì ìœ¼ë¡œ â€œì¿¼ë“œ íŠ¸ë¦¬â€ ë¬¸ì œ ì˜ë„ì— ë§ëŠ” ì „í˜•ì ì¸ ì¬ê·€ êµ¬í˜„ì´ë©°, ë¡œì§ì€ ì™„ë²½í•˜ê²Œ ì‘ì„±ë˜ì—ˆë‹¤ê³  ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì£¼ì„ê³¼ ë³€ìˆ˜ëª…ë§Œ ì¡°ê¸ˆ ë” ëª…í™•í•˜ê²Œ ì •ë¦¬í•˜ë©´, ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì´ ì¢‹ì•„ì§ˆ ê²ƒì…ë‹ˆë‹¤. ì¶•í•˜ë“œë¦½ë‹ˆë‹¤!

# ì¬ê·€: ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬Â 

https://www.acmicpc.net/problem/5639

ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ë¥¼ ì „ìœ„ ìˆœíšŒí•œ ê²°ê³¼ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ íŠ¸ë¦¬ë¥¼ í›„ìœ„ ìˆœíšŒí•œ ê²°ê³¼ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ëˆ„ë”ê¸° ì½”ë“œ 

```python
"""
1. ë¬¸ì œ ì½ê¸° 
ê·¸ëƒ¥ ì¬ê·€ë¥¼ í•˜ëŠ”ë°, í›„ìœ„ëŠ” ë¹ ì ¸ë‚˜ì˜¬ ë•Œ í”„ë¦°íŠ¸ í•˜ë©´ ë¨.
ê·¸ëŸ°ë° ì…ë ¥ì´ ì „ìœ„ìˆœíšŒ ê²°ê³¼ë¼ì„œ. ì•„ ê·¸ëƒ¥ ë¹ˆ ë°°ì—´ í•˜ë‚˜ ë§Œë“¤ê³ , 
ì „ìœ„ ìˆœíšŒ íƒ€ì´ë°ì— ê·¸ëƒ¥ ì‚½ì…í•˜ë©´ ì•ˆ ë˜ë‚˜, ì•ˆ ëœë‹¤. ì™„ì „ ì´ì§„ íŠ¸ë¦¬ê°€ ì•„ë‹ˆë‹¤!

2. ë¬¸ì œ í’€ê¸°

3. ìˆ˜ë„ ì½”ë“œ

4. ì½”ë“œ êµ¬í˜„
"""

import sys


def post_search(idx: int):
    global arr
    """í¬ê¸°ê°€ nì¸ ë°°ì—´ì˜ idx ë²ˆì§¸ ìš”ì†Œë¥¼ í›„ìœ„ìˆœíšŒ í•©ë‹ˆë‹¤."""
    # ë§Œì•½ ì™¼ìª½ ìì‹ì´ ì¡´ì¬ í•˜ë©´
    if idx >= len(bt): return
    post_search(idx*2+1)
    post_search(idx*2+2)
    if bt[idx] != 0: print(bt[idx])


def insert_binary_tree(val: int):
    print(f'inserting: {val}')
    global bt
    if bt[0] == 0: 
        bt[0] = val # ì²« ë²ˆì§¸ ê°’ ì‚½ì…
        return
    ptr = 0
    while True:
        print(f'current ptr: {ptr}')
        if val < bt[ptr]: # ì™¼ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+1] != 0: # ì™¼ìª½ ìì‹ì´ ì¡´ì¬í•˜ë©´ ê·¸ìª½ìœ¼ë¡œ í¬ì¸í„° ì´ë™
                ptr = ptr*2+1
                print('moving to left child')
                continue
            else: #ì™¼ìª½ ìì‹ì´ ì—†ìœ¼ë©´ ê±°ê¸°ì— ì‚½ì…
                bt[ptr*2+1] = val
                print(f'inserting {val} as left child of {bt[ptr]}')
                break
        elif val > bt[ptr]: # ì˜¤ë¥¸ ìì‹ìœ¼ë¡œ ì‚½ì…
            print(f'{val} > {bt[ptr]}')
            if bt[ptr*2+2] != 0:
                ptr = ptr*2+2
                print('moving to right child')
                continue
            else:
                bt[ptr*2+2] = val
                print(f'inserting {val} as right child of {bt[ptr]}')
                break


arr = []
for line in sys.stdin:
    # lineì€ '\n'ì„ í¬í•¨í•˜ë¯€ë¡œ line.strip()ìœ¼ë¡œ ê°œí–‰ ì œê±°
    arr.append(int(line.strip()))

n = len(arr)
bt = [0]*(n**4) # ëª¨ë‘ ì–‘ì˜ ì •ìˆ˜ë§Œ ì…ë ¥ë¨
for a in arr:
    insert_binary_tree(a)

post_search(0)


"""
ì´ìŠˆ: binary search treeì— ê°’ ì¸ì„œíŠ¸ê°€ ì´ìƒí•˜ê²Œ ë¨
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: '50', '30', '98', '24', '5', '52', 0, 0, '28', '45', 0, 0, '60'
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„íŠ¸ë¦¬ ì‚½ì… ë¶€ë¶„ êµ¬í˜„

def insert_binary_tree(val: int):
    print(f'inserting: {val}')
    global bt
    if bt[0] == 0: 
        bt[0] = val # ì²« ë²ˆì§¸ ê°’ ì‚½ì…
        return
    ptr = 0
    while True:
        if val < bt[ptr]: # ì™¼ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+1] != 0: # ì™¼ìª½ ìì‹ì´ ì¡´ì¬í•˜ë©´ ê·¸ìª½ìœ¼ë¡œ í¬ì¸í„° ì´ë™
                ptr = ptr*2+1
                continue
            else: #ì™¼ìª½ ìì‹ì´ ì—†ìœ¼ë©´ ê±°ê¸°ì— ì‚½ì…
                bt[ptr*2+1] = val
                break
        elif val > bt[ptr]: # ì˜¤ë¥¸ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+2] != 0:
                ptr = ptr*2+2
                continue
            else:
                bt[ptr*2+2] = val
                break
Phase2.
í™•ì¸: ì˜¤ë¥¸ìª½ ìì‹ìœ¼ë¡œ ê°€ëŠ” ë¶€ë¶„ì´ ì¢€ ì´ìƒí•œ ê±° ê°™ì€ë°. ë¬¸ìì—´ì„ ê·¸ëŒ€ë¡œ ì‘¤ì…”ë°•ìœ¼ë‹ˆ ê·¸ë ‡ì§€!

moving to left child
current ptr: 1
5 > 30
inserting 5 as right child of 30

ë¡œê·¸ í™•ì¸ ê²°ê³¼ ì´ëŸ° ê¸°ê°€ë§‰íŒ ì—°ì‚°ì„ í•˜ê³  ìˆì—ˆìŒì„ í™•ì¸. ì´ê±´ ê·¸ëƒ¥ ë””ë²„ê±° ë´¤ìœ¼ë©´ ë” ë¹¨ë¦¬ ìºì¹˜í–ˆì„ ê±° ê°™ê¸°ë„ í•˜ê³ .
ì´ìŠˆë°©ì§€ìœ„ì›íšŒ, ì¤„ì—¬ì„œ ì´ë°©ìœ„ë¥¼ ì—´ì–´ì•¼ê² ë‹¤.
ì‹œë„: ì •ìˆ˜í˜•ìœ¼ë¡œ ì…ë ¥ê°’ ìºìŠ¤íŒ…
ê²°ê³¼: í•´ê²°

ì´ìŠˆ: í›„ìœ„ìˆœíšŒê°€ ì•ˆ ë¼ìš”
Phase1. 
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì˜ëª»ëœ í›„ìœ„ ìˆœìœ„ ê²€ìƒ‰ ê²°ê³¼
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì—†ìŒ

Phase2.
í™•ì¸: ì¬ê·€ ê³¼ì •ì„ í™•ì¸í•˜ê³ , ì¶œë ¥ë¬¸ì„ ì°ìœ¼ë©´ ì¢‹ì„ ì ì ˆí•œ íƒ€ì´ë°ì„ íƒ‘ë‹¤ìš´ ë°©ì‹ìœ¼ë¡œ ë¶„ì„í•´ë³´ê¸°.
ì‹œë„: ê·¸ëƒ¥ ë°°ì—´ê³¼ ì¸ë±ìŠ¤ë¥¼ í†µì§¸ë¡œ ì˜ëª» ì°¸ì¡°í•˜ê³  ìˆì—ˆìŒ. 
ê²°ê³¼ ë¶„ì„: í•´ê²°. ì½”ë“œì˜ ë¡œì§ì€ êµ¬í˜„ ì™„ë£Œ. ê·¸ëŸ°ë° ëˆ„ë”ê¸°ë¡œ ì‘ì„±í•œ ìë£Œêµ¬ì¡° ë•ë¶„ì— ë©”ëª¨ë¦¬ ì´ˆê³¼ê°€ ë°œìƒ

"""
```

### ë¡œê·¸ ì—†ëŠ” ë²„ì „

```python
"""
1. ë¬¸ì œ ì½ê¸° 
ê·¸ëƒ¥ ì¬ê·€ë¥¼ í•˜ëŠ”ë°, í›„ìœ„ëŠ” ë¹ ì ¸ë‚˜ì˜¬ ë•Œ í”„ë¦°íŠ¸ í•˜ë©´ ë¨.
ê·¸ëŸ°ë° ì…ë ¥ì´ ì „ìœ„ìˆœíšŒ ê²°ê³¼ë¼ì„œ. ì•„ ê·¸ëƒ¥ ë¹ˆ ë°°ì—´ í•˜ë‚˜ ë§Œë“¤ê³ , 
ì „ìœ„ ìˆœíšŒ íƒ€ì´ë°ì— ê·¸ëƒ¥ ì‚½ì…í•˜ë©´ ì•ˆ ë˜ë‚˜, ì•ˆ ëœë‹¤. ì™„ì „ ì´ì§„ íŠ¸ë¦¬ê°€ ì•„ë‹ˆë‹¤!

2. ë¬¸ì œ í’€ê¸°

3. ìˆ˜ë„ ì½”ë“œ

4. ì½”ë“œ êµ¬í˜„
"""

import sys


def post_search(idx: int):
    global arr
    """í¬ê¸°ê°€ nì¸ ë°°ì—´ì˜ idx ë²ˆì§¸ ìš”ì†Œë¥¼ í›„ìœ„ìˆœíšŒ í•©ë‹ˆë‹¤."""
    # ë§Œì•½ ì™¼ìª½ ìì‹ì´ ì¡´ì¬ í•˜ë©´
    if idx >= len(bt): return
    post_search(idx*2+1)
    post_search(idx*2+2)
    if bt[idx] != 0: print(bt[idx])


def insert_binary_tree(val: int):
    global bt
    if bt[0] == 0: 
        bt[0] = val # ì²« ë²ˆì§¸ ê°’ ì‚½ì…
        return
    ptr = 0
    while True:
        if val < bt[ptr]: # ì™¼ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+1] != 0: # ì™¼ìª½ ìì‹ì´ ì¡´ì¬í•˜ë©´ ê·¸ìª½ìœ¼ë¡œ í¬ì¸í„° ì´ë™
                ptr = ptr*2+1
                continue
            else: #ì™¼ìª½ ìì‹ì´ ì—†ìœ¼ë©´ ê±°ê¸°ì— ì‚½ì…
                bt[ptr*2+1] = val
                break
        elif val > bt[ptr]: # ì˜¤ë¥¸ ìì‹ìœ¼ë¡œ ì‚½ì…
            if bt[ptr*2+2] != 0:
                ptr = ptr*2+2
                continue
            else:
                bt[ptr*2+2] = val
                break


arr = []
for line in sys.stdin:
    # lineì€ '\n'ì„ í¬í•¨í•˜ë¯€ë¡œ line.strip()ìœ¼ë¡œ ê°œí–‰ ì œê±°
    arr.append(int(line.strip()))

n = len(arr)
bt = [0]*(n**2) # ëª¨ë‘ ì–‘ì˜ ì •ìˆ˜ë§Œ ì…ë ¥ë¨
for a in arr:
    insert_binary_tree(a)

post_search(0)


```

## Phase2. í”¼ë“œë°± ë° ë°˜ì„±

### ë°˜ì„±

1. ì¸ë±ìŠ¤ ì´ë¦„, í•¨ìˆ˜ ì´ë¦„ë§Œ ì¢€ ê¸¸ê²Œ ì¨ë„ ë§ì€ ì‚½ì§ˆì„ í”¼í•  ìˆ˜ ìˆì„ ê±° ê°™ë‹¤. êµ¬ì²´ì ìœ¼ë¡œ ì“°ë©´ ì¸ì§€ê°€ ë˜ëŠ”ë°, ê·¸ëƒ¥ ì•ŒíŒŒë²³ë§Œ ì‘ì„±í•˜ë©´ ê°œë…ì´ ì•ˆ ì¡íˆê³ , ì˜ëª» ì íŒ ì¸ë±ìŠ¤ë„ ì•Œì•„ë³´ê¸° ì–´ë µë‹¤.
1. ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ë¥¼ ì „í˜€ êµ¬í˜„í•˜ì§€ ëª»í•˜ê² ë‹¤. ìœ„ì˜ ë°°ì—´ì„ í™œìš©í•œ êµ¬ì¡°ëŠ” ê³µê°„ë³µì¡ë„ê°€ ì •ì‹  ë‚˜ê°„ë‹¤.
1. ì…ë ¥ ê°’ì˜ ê°œìˆ˜ê°€ ì£¼ì–´ì§€ì§€ ì•Šê³  ì…ë ¥ë§ˆë‹¤ ê°œí–‰ë¬¸ìê°€ ìˆëŠ” ê²½ìš°ì˜ ì…ë ¥ ë§¤ì»¤ë‹ˆì¦˜ì„ ì˜ ëª¨ë¥´ê² ë‹¤. sys.stdinì€  line1\n, line\n ì´ë ‡ê²Œ ì£¼ì–´ì§€ê³ , ê° ì¤„ì— ì£¼ì–´ì§„ ì…ë ¥ì„ ì´í„°ë ˆì´ì…˜í•˜ë©° line.strip() ì‘ì—…ì„ í•˜ì—¬ whitespaceë¥¼ ì œê±°í•˜ëŠ”ê°€?
### í”¼ë“œë°±

ì•„ë˜ ë‚´ìš©ì€ ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬(BST) ë¬¸ì œ(BOJ 5639)ë¥¼ í’€ ë•Œ í”íˆ ê²ªëŠ” ë¬¸ì œì (ë°°ì—´ ì¸ë±ìŠ¤ë¡œ êµ¬í˜„ ì‹œ ë©”ëª¨ë¦¬ ë‚­ë¹„, ì „ìœ„ìˆœíšŒ ì…ë ¥ì—ì„œ íŠ¸ë¦¬ë¥¼ ë³µì›í•˜ëŠ” ë°©ë²• ë“±)ì— ëŒ€í•œ í”¼ë“œë°±ê³¼, ê¶Œì¥ êµ¬í˜„(ë…¸ë“œ ê¸°ë°˜ + ì¬ê·€ ë³µì›) ì˜ˆì‹œì…ë‹ˆë‹¤.

1. í˜„ì¬ ì½”ë“œ(ë°°ì—´ ì‚¬ìš©) ë¬¸ì œì ê³¼ ê°œì„  ë°©í–¥

1.1 ë°°ì—´ ì¸ë±ìŠ¤ ê¸°ë°˜ â€˜ì™„ì „ì´ì§„íŠ¸ë¦¬â€™ ë°©ì‹ì˜ ë¹„íš¨ìœ¨ì„±

â€¢	í˜„ì¬ ì‹œë„í•˜ì‹  ë°©ì‹ì€ â€œë°°ì—´ ì¸ë±ìŠ¤ë¥¼ ì´ìš©í•´ ì™¼ìª½ ìì‹ = 2i+1, ì˜¤ë¥¸ìª½ ìì‹ = 2i+2â€ êµ¬ì¡°ë¥¼ í‰ë‚´ ë‚´ë©° BSTë¥¼ êµ¬ì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤.

â€¢	BSTê°€ í¸í–¥ë˜ì—ˆì„ ë•Œ, n^2, ì‹¬ì§€ì–´ n^4 ê°™ì€ í° ë°°ì—´ì„ ì¡ì•„ì•¼ í•˜ê³ , ì‹¤ì œë¡œëŠ” ëŒ€ë¶€ë¶„ ë¹„ì–´ ìˆì„ ìˆ˜ ìˆì–´ ë©”ëª¨ë¦¬ ë‚­ë¹„ ê°€ ì‹¬ê°í•©ë‹ˆë‹¤.

â€¢	ë…¸ë“œê°€ 1ë§Œ ê°œë§Œ ë˜ì–´ë„, ì™„ì „ì´ì§„íŠ¸ë¦¬ ì¸ë±ìŠ¤ë¥¼ ì“°ë ¤ë©´ ì—„ì²­ë‚œ í¬ê¸°ì˜ ë°°ì—´ì´ í•„ìš”í•´ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

1.2 ì „ìœ„ìˆœíšŒ ê²°ê³¼ë¡œë¶€í„° BST ë³µì› ì‹œì˜ ì¼ë°˜ì ì¸ ì ‘ê·¼

â€¢	ì£¼ì–´ì§„ ì…ë ¥ì€ BSTë¥¼ ì „ìœ„ìˆœíšŒ(Pre-order)í•œ ê²°ê³¼ì…ë‹ˆë‹¤.

â€¢	ìš°ë¦¬ëŠ” ì´ ë°°ì—´(ì „ìœ„ìˆœíšŒ ê²°ê³¼)ë¡œ íŠ¸ë¦¬ë¥¼ ë³µì›í•œ ë’¤, í›„ìœ„ìˆœíšŒ(Post-order) ê²°ê³¼ë¥¼ ì¶œë ¥í•´ì•¼ í•©ë‹ˆë‹¤.

â€¢	ê°€ì¥ í”í•œ ë°©ë²•ì€ **â€œë…¸ë“œ ê¸°ë°˜(Node class) + ì¬ê·€â€**ë¡œ ì§ì ‘ BSTë¥¼ êµ¬ì„±í•œ ë’¤, í›„ìœ„ìˆœíšŒë¥¼ ìˆ˜í–‰í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

> ê²°ë¡ 

2. ê¶Œì¥ êµ¬í˜„: ë…¸ë“œ ê¸°ë°˜ BST ë³µì› + í›„ìœ„ìˆœíšŒ

2.1 ë¡œì§ ê°œìš”

1.	ì…ë ¥: ì „ìœ„ìˆœíšŒ ê²°ê³¼ preorder[] (ì˜ˆ: 50, 30, 24, 5, 28, 45, 98, 52, 60, â€¦)

2.	BST êµ¬ì„±: ì „ìœ„ìˆœíšŒ íŠ¹ì„±ìƒ,

â€¢	ì²« ë²ˆì§¸ ì›ì†Œ = ë£¨íŠ¸ ê°’

â€¢	ì´í›„ â€œë£¨íŠ¸ë³´ë‹¤ ì‘ì€ ê°’ë“¤â€ì€ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬, â€œë£¨íŠ¸ë³´ë‹¤ í° ê°’ë“¤â€ì€ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬

3.	í•˜ì§€ë§Œ, ë‹¨ìˆœíˆ â€œì‘ì€ ê±° ì „ë¶€ ì™¼ìª½, í° ê±° ì „ë¶€ ì˜¤ë¥¸ìª½â€ìœ¼ë¡œ êµ¬ê°„ì„ ë‚˜ëˆ„ë©´ ìµœì•… O(n^2).

â€¢	ë¬¸ì œì—ì„  N ìµœëŒ€ 10,000ê¹Œì§€ ê°€ëŠ¥.

â€¢	ë‹¤í–‰íˆ, **â€œBST ì „ìœ„ìˆœíšŒ ë°°ì—´â€**ì—ì„œ â€œë£¨íŠ¸ë³´ë‹¤ í° ê°’ì´ ì²˜ìŒ ë‚˜ì˜¤ëŠ” ì§€ì â€ì´ ê³§ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ ì‹œì‘ ì§€ì ì´ ë©ë‹ˆë‹¤.

4.	ë” íš¨ìœ¨ì ì¸ ë°©ë²•: ìƒí•œ(bound)ì„ ì´ìš©í•œ ì¬ê·€. ì „ìœ„ ìˆœíšŒë¥¼ ì™¼â†’ì˜¤ë¥¸ìª½ ìˆœìœ¼ë¡œ íƒìƒ‰í•˜ë©°, â€œí˜„ì¬ ë§Œë“¤ì–´ì•¼ í•  ì„œë¸ŒíŠ¸ë¦¬ ê°’ì´ bound(ë¶€ëª¨ë³´ë‹¤ í° ê°’ í•œê³„)â€ë¥¼ ë„˜ì–´ì„œë©´ stop í•˜ëŠ” ê¸°ë²•ì´ ìì£¼ ì‚¬ìš©ë©ë‹ˆë‹¤.

2.2 ì˜ˆì‹œ ì½”ë“œ: Bound ê¸°ë²• (ì „ìœ„ìˆœíšŒ â†’ BST)

```python
import sys
sys.setrecursionlimit(10**9)  # í˜¹ì‹œ ê¹Šì€ íŠ¸ë¦¬ ëŒ€ë¹„

preorder = []
for line in sys.stdin:
    val = line.strip()
    if val == '':  # ê³µë°± ë¼ì¸ ë°©ì–´
        continue
    preorder.append(int(val))

# ì „ìœ„ìˆœíšŒ ë¦¬ìŠ¤íŠ¸
n = len(preorder)

# ì „ìœ„ìˆœíšŒ ë°°ì—´ì„ ì¬ê·€ì ìœ¼ë¡œ ì½ì–´ê°€ë©° íŠ¸ë¦¬ ë³µì›
# indexëŠ” preorderë¥¼ ìˆœíšŒí•˜ëŠ” ì¸ë±ìŠ¤
index = 0

class Node:
    __slots__ = ('val', 'left', 'right')  # ë©”ëª¨ë¦¬ ì ˆì•½ (ì„ íƒì‚¬í•­)
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def buildBST(bound):
    """
    boundë³´ë‹¤ í° ê°’ì´ ë‚˜ì˜¤ë©´(= í˜„ì¬ subtree ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨)
    ì¬ê·€ë¥¼ ë©ˆì¶˜ë‹¤.
    """
    global index
    if index >= n:  # ë” ì´ìƒ ì›ì†Œê°€ ì—†ìœ¼ë©´ None
        return None

    root_val = preorder[index]
    # ë§Œì•½ í˜„ì¬ ê°’ì´ boundë³´ë‹¤ í¬ë©´, ì´ subtreeì— ì†í•  ìˆ˜ ì—†ìŒ
    if root_val > bound:
        return None

    # í˜„ì¬ ê°’ì´ subtreeì— ì†í•œë‹¤ë©´, ë…¸ë“œ ìƒì„±
    node = Node(root_val)
    index += 1

    # ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬: bound = node.val
    #   => node.valë³´ë‹¤ í° ê°’ì´ ë‚˜ì˜¤ë©´ ì™¼ìª½ subtree ë¶ˆê°€
    node.left = buildBST(node.val)

    # ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬: bound = ìƒìœ„ bound
    #   => "node.val < X <= bound" ë²”ìœ„ì˜ ê°’ì€ ì˜¤ë¥¸ìª½ subtree
    node.right = buildBST(bound)

    return node

# 1) íŠ¸ë¦¬ êµ¬ì„± (ìµœëŒ€ê°’ì„ ì•„ì£¼ í¬ê²Œ ì¡ëŠ”ë‹¤)
root = buildBST(bound=10**10)  # ë¬¸ì œì—ì„œ ê°’ì´ 1,000,000ê¹Œì§€ ê°€ëŠ¥í•˜ë¯€ë¡œ ë” í° ìˆ˜ ì¡ê¸°

# 2) í›„ìœ„ìˆœíšŒ
def postorder(node):
    if not node:
        return
    postorder(node.left)
    postorder(node.right)
    print(node.val)

postorder(root)
```

ë™ì‘ ì„¤ëª…

â€¢	buildBST(bound) í•¨ìˆ˜ëŠ” preorder ë°°ì—´ì„ ì™¼â†’ì˜¤ë¥¸ìª½ìœ¼ë¡œ ìŠ¤ìº”(index ì „ì—­ë³€ìˆ˜)í•˜ë©´ì„œ ë…¸ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

â€¢	í˜„ì¬ ë…¸ë“œê°’ì´ boundë¥¼ ì´ˆê³¼í•˜ë©´, â€œì´ ê°’ì€ ìƒìœ„(í˜¹ì€ ë‹¤ë¥¸) ì„œë¸ŒíŠ¸ë¦¬ë¡œ ê°€ì•¼ í•œë‹¤â€ â†’ None ë¦¬í„´í•˜ì—¬ ì¬ê·€ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.

â€¢	ì´ë ‡ê²Œ í•˜ë©´ ì „ìœ„ìˆœì„œì— ë§ì¶° ì™¼ìª½ subtree(node.valì„ boundë¡œ), ì˜¤ë¥¸ìª½ subtree(ìƒìœ„ bound ê·¸ëŒ€ë¡œ) ìˆœìœ¼ë¡œ ì±„ì›Œë‚˜ê°€ë©´ì„œë„, ê°’ì´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ì¬ê·€ë¥¼ ì¢…ë£Œí•´ â€œë¶€ëª¨ì˜ ì˜¤ë¥¸ìª½ subtreeâ€ë¡œ ë„˜ì–´ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ì´ ì•Œê³ ë¦¬ì¦˜ì€ ê° ë…¸ë“œê°€ ì •í™•íˆ í•œ ë²ˆì”©ë§Œ ì¬ê·€ ì²˜ë¦¬ë˜ë¯€ë¡œ, ìµœì•…ì˜ ê²½ìš°(í¸í–¥ íŠ¸ë¦¬)ë¼ë„ O(n)ì— ê°€ê¹Œìš´ ì„±ëŠ¥ì„ ëƒ…ë‹ˆë‹¤(ì‹¤ì œë¡œëŠ” í‰ê·  O(n), íŠ¹ì • í¸í–¥ íŒ¨í„´ì—ì„œë„ ë¹ ë¥´ê²Œ ë™ì‘).

> ì´ ë¡œì§ì€ **â€œBST ì „ìœ„ìˆœíšŒ + ìƒí•œ(bound) ê¸°ë²•â€**ìœ¼ë¡œ ì•Œë ¤ì§„ ì „í˜•ì ì¸ íŠ¸ë¦¬ ë³µì› ë°©ë²•ì…ë‹ˆë‹¤.

3. ì¶”ê°€ ì‚¬í•­

3.1 â€œì…ë ¥ ê°œìˆ˜ ë¯¸ì§€ì •â€ â†’ sys.stdin ì‚¬ìš© ì‹œ

â€¢	ë¬¸ì œì—ì„œ ì…ë ¥ ì¤„ ìˆ˜ê°€ ë”°ë¡œ ì•ˆ ì£¼ì–´ì§€ë©´, ë³´í†µ EOFê¹Œì§€ ì½ì–´ì•¼ í•©ë‹ˆë‹¤.

â€¢	for line in sys.stdin: ì‚¬ìš© ì‹œ, ë¹ˆ ì¤„ì´ë‚˜ ê°œí–‰ì„ ì²˜ë¦¬í•˜ê³  ì‹¶ë‹¤ë©´ line.strip() í›„ ì¡°ê±´ ê²€ì‚¬í•˜ë©´ ë©ë‹ˆë‹¤.

3.2 íŒŒì´ì¬ ì¬ê·€ ì œí•œ

â€¢	ê¸°ë³¸ì ìœ¼ë¡œ íŒŒì´ì¬ ì¬ê·€ í•œë„ëŠ” ì•½ 1000ì´ë¯€ë¡œ, ë…¸ë“œê°€ 1ë§Œ ê°œ ì´ìƒì´ê³  í¸í–¥ íŠ¸ë¦¬ê°€ ëœë‹¤ë©´ RecursionError ê°€ ë‚  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ë¬¸ì œ 5639ì—ì„œëŠ” ìµœëŒ€ 10,000ê°œ ì…ë ¥ì´ ê°€ëŠ¥í•˜ë¯€ë¡œ, sys.setrecursionlimit(10**9) ì •ë„ë¡œ ì—¬ìœ ë¥¼ ì£¼ëŠ” ê²Œ ì•ˆì „í•©ë‹ˆë‹¤. (ë©”ëª¨ë¦¬ ë‚´ì—ì„œ ì²˜ë¦¬ ê°€ëŠ¥)

3.3 í›„ìœ„ìˆœíšŒ ì¶œë ¥

â€¢	ë¬¸ì œ ìš”êµ¬ì‚¬í•­ëŒ€ë¡œ, ê° ë…¸ë“œë¥¼ í›„ìœ„ìˆœíšŒ ì‹œ ë°©ë¬¸í•  ë•Œë§ˆë‹¤ ì¶œë ¥í•˜ë©´ ë©ë‹ˆë‹¤.

â€¢	â€œprint(node.val)â€ì„ ì°ì„ ë•Œ ê°œí–‰ìœ¼ë¡œ êµ¬ë¶„í•˜ë©´ ì •ë‹µ í¬ë§·ì— ë¶€í•©í•©ë‹ˆë‹¤.

3.4 â€œë°°ì—´ ì¸ë±ìŠ¤ë¥¼ ì¢€ ë” ëª…í™•íˆâ€¦â€ì— ëŒ€í•œ íŒ

â€¢	ë³€ìˆ˜ëª…ì„ idx, start, end ë“±ìœ¼ë¡œ ê¸¸ê²Œ ì¨ì£¼ê±°ë‚˜, ì£¼ì„ì„ ë¶€ì§€ëŸ°íˆ ë‹¬ë©´ ë””ë²„ê¹… ì‹œ í˜¼ì„ ì„ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ë˜í•œ, (node-based)íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•˜ë©´, â€œì™¼ìª½Â·ì˜¤ë¥¸ìª½â€ì„ ì§ê´€ì ìœ¼ë¡œ ì½”ë“œë¡œ í‘œí˜„í•  ìˆ˜ ìˆì–´, ì¸ë±ìŠ¤ ì—°ì‚° ì‹¤ìˆ˜ë¥¼ ì¤„ì´ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤.

4. ë§ˆë¬´ë¦¬

1.	ë¬¸ì œ(5639) í•µì‹¬: ì „ìœ„ìˆœíšŒ ë°°ì—´ë¡œë¶€í„° BSTë¥¼ ì¬êµ¬ì„± í›„, í›„ìœ„ìˆœíšŒ ì¶œë ¥.

2.	ê°€ì¥ ê°„ë‹¨í•œ ì •ì„ ì ‘ê·¼: ë…¸ë“œ ê¸°ë°˜ìœ¼ë¡œ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ê³ , í›„ìœ„ìˆœíšŒë¥¼ ì¬ê·€ë¡œ êµ¬í˜„.

3.	ë°°ì—´ ì¸ë±ìŠ¤ ê¸°ë°˜ì˜ ì™„ì „ì´ì§„íŠ¸ë¦¬ëŠ” BSTì—ëŠ” ë¹„íš¨ìœ¨ì (í¸í–¥ íŠ¸ë¦¬ ì‹œ ë©”ëª¨ë¦¬ í­ì¦).

4.	EOF ì…ë ¥ ì²˜ë¦¬:

```plain text
import sys
arr = []
for line in sys.stdin:
    val = line.strip()
    if val == '':
        continue
    arr.append(int(val))
```

ì´ë ‡ê²Œ í•˜ë©´ íŒŒì¼ ë(EOF)ê¹Œì§€ ì½ì–´ë“¤ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

> ê²°ë¡ ì ìœ¼ë¡œ,



# ì¬ê·€: 1, 2, 3 ë”í•˜ê¸°

https://www.acmicpc.net/problem/9095

ì •ìˆ˜ nì´ ì£¼ì–´ì¡Œì„ ë•Œ, nì„ 1, 2, 3ì˜ í•©ìœ¼ë¡œ ë‚˜íƒ€ë‚´ëŠ” ë°©ë²•ì˜ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1.

```python
"""
1. ë¬¸ì œ ì½ê¸°: 3
2. ë¬¸ì œ í’€ê¸°
3ì´ë©´ 1 1 1, 1 2, 2 1, 3
ê°„ë‹¨í•œ ë°± íŠ¸ë˜í‚¹ ë¬¸ì œë‹¤. 1 2 3 ì¤‘ ì—¬ëŸ¬ê°œë¥¼ ì¨ë„ ìƒê´€ì´ ì—†ë‹¤.
3. ìˆ˜ë„ ì½”ë“œ
ë°”ë‹¥ì¡°ê±´ì€ ë¬´ì—‡ì¸ê°€? ë§¤ê°œë¡œ ë„˜ì–´ì˜¨ ì •ìˆ˜í˜• í•©ì´ nê³¼ ê°™ìœ¼ë©´ ì¹´ìš´í„° ì¦ê°€ì‹œí‚¤ê³  ë¦¬í„´.
ì¬ê·€ ì¡°ê±´ì€: ê·¸ëƒ¥ 1, 2, 3 ë¦¬ìŠ¤íŠ¸ì—ì„œ ë°˜ë³µ ëŒë ¤ì„œ ë”í•´ì„œ ì¬ê·€ ë³´ë‚´ë©´ ë¨.
4. ì½”ë“œ êµ¬í˜„
"""

import sys

def recur(current_sum: int, n: int):
    global cnt
    if current_sum == n:
        cnt += 1
        return
    if current_sum > n:
        return
    for e in [1, 2, 3]:
        recur(current_sum+e, n)


t = int(sys.stdin.readline().strip())
cnt = 0
for _ in range(t):
    n = int(sys.stdin.readline().strip())
    recur(0, n)
    print(cnt)
    cnt = 0

"""
ì´ìŠˆ: ì¬ê·€ ì´ˆê³¼ ì˜¤ë¥˜
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì¬ê·€ ì´ˆê³¼ ì˜¤ë¥˜
ìµœê·¼ ë³€ê²½ì‚¬í•­: ì¬ê·€í•¨ìˆ˜ ì‘ì„±
Phase2.
í™•ì¸: current_sumì´ nê³¼ ë‹¤ë¥´ë©´ ë°”ë‹¥ ì¡°ê±´ì— ê³„ì† ê±¸ë¦¬ì§€ ì•Šê²Œ ë¨. 
current_sum > nì— ëŒ€í•´ì„œë„ ì¢…ë£Œ ì¡°ê±´ì„ ë‹¬ë©´ ë˜ê² ë‹¤.
ì‹œë„: ë² ì´ìŠ¤ ì»¨ë””ì…˜ ì¶”ê°€
if current_sum > n:
        return
ê²°ê³¼ë¶„ì„: ì„±ê³µ
"""
```

## Phase2. ë°± íŠ¸ë˜í‚¹ì´ ë­”ê°€ìš”?

ë¬¸ì œ í’€ì´ ë‚´ìš©ì„ ë°œí‘œí•˜ë˜ ì¤‘ ì´ ì§ˆë¬¸ì„ ë°›ì•˜ëŠ”ë°, ì œëŒ€ë¡œ ëœ ë‹µì„ í•˜ì§€ ëª»í–ˆë‹¤. ê·¸ë˜ì„œ ìƒê°í•´ë³¸ ëì— ì•„ë˜ì™€ ê°™ì€ ê²°ë¡ ì— ë„ë‹¬. 

(ê²°ì • íŠ¸ë¦¬ë¥¼ ì•ˆë‹¤ê³  ê°€ì •í•˜ê³ ) ì¬ê·€ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë¬´ìˆ˜íˆ ë§ì€ ê²°ì •íŠ¸ë¦¬ë¥¼ ë§Œë“¤ì–´ê°€ê²Œ ë˜ê³ , ì´ ì½”ë“œì˜ ê²½ìš° depthê°€ ê¹Šì–´ì§ˆ ìˆ˜ë¡ ë¦¬í”„ ë…¸ë“œê°€ 3ë°°ì”© ëŠ˜ì–´ë‚œë‹¤. ê·¸ëŸ°ë° ë¬¸ì œ ì •ì˜ ìƒìœ¼ë¡œ, ë”í•´ì§€ëŠ” ìˆ«ìëŠ” 1, 2, 3ìœ¼ë¡œ ëª¨ë‘ ì–‘ìˆ˜ê³ , ë§Œì•½ í˜„ì¬ ë…¸ë“œì—ì„œ ë§¤ê°œë¡œ ë°›ì€ ì •ìˆ˜ ê°’ì´ në³´ë‹¤ í¬ë‹¤ë©´ ê²°ì • íŠ¸ë¦¬ìƒìœ¼ë¡œ ì´ ë…¸ë“œì˜ í•˜ìœ„ì— ì˜¬ ìì‹ ë…¸ë“œë“¤ì€ ì „ë¶€ ì •ë‹µì´ ì•„ë‹Œê²Œ í™•ì‹¤í•˜ë‹¤. 

ë”°ë¼ì„œ! ì¬ê·€ë¡œ ì¸í•´ ë¬´í•œíˆ ìƒê²¨ë‚  ìˆ˜ ìˆëŠ” ê²°ì •íŠ¸ë¦¬ë¥¼ ì œì–´í•˜ê¸° ìœ„í•´ í•„ìš” ì—†ëŠ” ê°€ì§€ë¥¼ ì˜ë¼ë‚´ëŠ” ë°©ë²•ì„ ë°±íŠ¸ë˜í‚¹ì´ë¼ í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤.

![](./images/IMG_0452.jpeg)

## Phase3. ë‹µì— ëŒ€í•œ í”¼ë“œë°±

1. ë°±íŠ¸ë˜í‚¹ ì •ì˜ì™€ ì„¤ëª…

â€¢	ë°±íŠ¸ë˜í‚¹ì€ **â€œë¶ˆí•„ìš”í•œ íƒìƒ‰ì„ ê°€ì§€ì¹˜ê¸°(Pruning)í•˜ì—¬ íƒìƒ‰ ì†ë„ë¥¼ í–¥ìƒì‹œí‚¤ëŠ” ê¸°ë²•â€**ì…ë‹ˆë‹¤.

â€¢	íŠ¹íˆ, ê²°ì • íŠ¸ë¦¬(Decision Tree) íƒìƒ‰ ê³¼ì •ì—ì„œ ë¶ˆí•„ìš”í•œ ë¶„ê¸°ë¥¼ ì¡°ê¸°ì— ì¢…ë£Œí•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

â€¢	ì¦‰, ê°€ëŠ¥í•œ ëª¨ë“  ê²½ìš°ë¥¼ íƒìƒ‰í•˜ëŠ” ì™„ì „ íƒìƒ‰(Brute-force) ë°©ì‹ì„ ê°œì„ í•˜ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤.

2. ë³¸ì¸ì˜ ì„¤ëª… í”¼ë“œë°±

> â€œì¬ê·€ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë¬´ìˆ˜íˆ ë§ì€ ê²°ì • íŠ¸ë¦¬ë¥¼ ë§Œë“¤ì–´ê°€ê²Œ ë˜ê³ , ì´ ì½”ë“œì˜ ê²½ìš° depthê°€ ê¹Šì–´ì§ˆìˆ˜ë¡ ë¦¬í”„ ë…¸ë“œê°€ 3ë°°ì”© ëŠ˜ì–´ë‚œë‹¤. ê·¸ëŸ°ë° ë¬¸ì œ ì •ì˜ ìƒìœ¼ë¡œ, ë”í•´ì§€ëŠ” ìˆ«ìëŠ” 1, 2, 3ìœ¼ë¡œ ëª¨ë‘ ì–‘ìˆ˜ê³ , ë§Œì•½ í˜„ì¬ ë…¸ë“œì—ì„œ ë§¤ê°œë¡œ ë°›ì€ ì •ìˆ˜ ê°’ì´ në³´ë‹¤ í¬ë‹¤ë©´ ê²°ì • íŠ¸ë¦¬ìƒìœ¼ë¡œ ì´ ë…¸ë“œì˜ í•˜ìœ„ì— ì˜¬ ìì‹ ë…¸ë“œë“¤ì€ ì „ë¶€ ì •ë‹µì´ ì•„ë‹Œ ê²Œ í™•ì‹¤í•˜ë‹¤. ë”°ë¼ì„œ! ì¬ê·€ë¡œ ì¸í•´ ë¬´í•œíˆ ìƒê²¨ë‚  ìˆ˜ ìˆëŠ” ê²°ì • íŠ¸ë¦¬ë¥¼ ì œì–´í•˜ê¸° ìœ„í•´ í•„ìš” ì—†ëŠ” ê°€ì§€ë¥¼ ì˜ë¼ë‚´ëŠ” ë°©ë²•ì„ ë°±íŠ¸ë˜í‚¹ì´ë¼ í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤.â€

âœ… ì¢‹ì€ ì 

â€¢	ë°±íŠ¸ë˜í‚¹ì˜ í•µì‹¬ ê°œë…ì¸ **â€œë¶ˆí•„ìš”í•œ ê°€ì§€ë¥¼ ì˜ë¼ë‚´ëŠ” ê³¼ì •â€**ì„ ì˜ ì„¤ëª…í–ˆë‹¤.

â€¢	ê²°ì • íŠ¸ë¦¬ì—ì„œ ë¶„ê¸°ê°€ ë¶ˆí•„ìš”í•˜ê²Œ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ì„ ì˜ ì¸ì‹í•˜ê³  ìˆìŒ.

â€¢	í˜„ì¬ í’€ì´ì—ì„œ if current_sum > n: ë¶€ë¶„ì´ ë°±íŠ¸ë˜í‚¹ì˜ ì—­í• ì„ í•œë‹¤ëŠ” ì ì„ ì˜ ì„¤ëª…í–ˆë‹¤.

ğŸ” ë³´ì™„í•˜ë©´ ì¢‹ì€ ì 

â€¢	ë°±íŠ¸ë˜í‚¹ì€ ë‹¨ìˆœíˆ â€œë¶ˆí•„ìš”í•œ ê²½ìš°ë¥¼ ì œê±°â€í•˜ëŠ” ê²ƒë¿ë§Œ ì•„ë‹ˆë¼, **â€œì •ë‹µì´ ë  ê°€ëŠ¥ì„±ì´ ìˆëŠ” ê²½ìš°ë§Œ ì„ íƒâ€**í•˜ëŠ” ë°©ì‹ë„ í¬í•¨ëœë‹¤.

â€¢	íƒìƒ‰ì„ ìµœì í™”í•˜ëŠ” ê²ƒì´ í•µì‹¬ì¸ë°, í˜„ì¬ ì„¤ëª…ì€ â€œë¶ˆí•„ìš”í•œ ê²½ìš°ë¥¼ ì œê±°í•œë‹¤â€ëŠ” ê´€ì ì— ì´ˆì ì´ ë§ì¶°ì ¸ ìˆìŒ.

â€¢	ì˜ˆë¥¼ ë“¤ì–´, â€œN-Queen ë¬¸ì œâ€ì—ì„œëŠ” íŠ¹ì • ì¡°ê±´(ê°™ì€ ì—´ì— ë†“ì´ì§€ ì•Šê¸°, ëŒ€ê°ì„  ì¶©ëŒ ë°©ì§€ ë“±)ì„ ë§Œì¡±í•˜ëŠ” ê²½ìš°ì—ë§Œ íƒìƒ‰ì„ ì§„í–‰í•˜ëŠ” ê²ƒë„ ë°±íŠ¸ë˜í‚¹ì˜ ì¤‘ìš”í•œ íŠ¹ì§•ì´ë‹¤.

ğŸ’¡ ë³´ì™„ëœ ì„¤ëª… ì˜ˆì‹œ

> â€œë°±íŠ¸ë˜í‚¹ì€ ê°€ëŠ¥í•œ ëª¨ë“  ê²½ìš°ë¥¼ íƒìƒ‰í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ìœ ë§í•˜ì§€ ì•Šì€ ê²½ìš°ë¥¼ ì¡°ê¸°ì— í¬ê¸°í•˜ì—¬ íƒìƒ‰ íš¨ìœ¨ì„ ë†’ì´ëŠ” ê¸°ë²•ì´ë‹¤. ì´ ë¬¸ì œì—ì„œëŠ” ê²°ì • íŠ¸ë¦¬ì—ì„œ current_sum > nì¸ ê²½ìš° ì´í›„ì˜ íƒìƒ‰ì´ ë¬´ì˜ë¯¸í•˜ë¯€ë¡œ íƒìƒ‰ì„ ì¤‘ë‹¨í•œë‹¤. ì´ë¥¼ í†µí•´ íƒìƒ‰ ê³µê°„ì„ ì¤„ì´ê³ , ë¶ˆí•„ìš”í•œ ì—°ì‚°ì„ ë°©ì§€í•˜ëŠ” ê²ƒì´ ë°±íŠ¸ë˜í‚¹ì˜ í•µì‹¬ì´ë‹¤.â€

3. ì½”ë“œì— ëŒ€í•œ í”¼ë“œë°±

í˜„ì¬ ì½”ë“œëŠ” ë°±íŠ¸ë˜í‚¹ ê°œë…ì„ ì ìš©í–ˆì§€ë§Œ, DP(ë™ì  ê³„íšë²•, Dynamic Programming)ë¡œ ë” íš¨ìœ¨ì ì¸ í’€ì´ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ì´ ë¬¸ì œëŠ” ì¤‘ë³µë˜ëŠ” ë¶€ë¶„ ë¬¸ì œ(overlapping subproblems)ì™€ ìµœì  ë¶€ë¶„ êµ¬ì¡°(optimal substructure)ë¥¼ ê°€ì§€ë¯€ë¡œ DPê°€ ë” ì ì ˆí•©ë‹ˆë‹¤.

âœ… DP í’€ì´ (Bottom-Up)

```plain text
import sys

def solve():
    dp = [0] * 11  # ë¬¸ì œì—ì„œ nì€ ìµœëŒ€ 10
    dp[1], dp[2], dp[3] = 1, 2, 4  # ê¸°ë³¸ ì¼€ì´ìŠ¤

    for i in range(4, 11):  # ì í™”ì‹ ì ìš©
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

    t = int(sys.stdin.readline().strip())
    for _ in range(t):
        n = int(sys.stdin.readline().strip())
        print(dp[n])

solve()
```

â€¢	ì‹œê°„ ë³µì¡ë„: O(N), ì¬ê·€ í’€ì´ë³´ë‹¤ í›¨ì”¬ íš¨ìœ¨ì ì„.

ê²°ë¡ 

1.	ë°±íŠ¸ë˜í‚¹ì˜ ê°œë… ì„¤ëª…ì€ ì¢‹ì•˜ì§€ë§Œ, **â€œê°€ëŠ¥ì„±ì´ ìˆëŠ” ê²½ìš°ë§Œ íƒìƒ‰í•œë‹¤â€**ëŠ” ë¶€ë¶„ë„ ê°•ì¡°í•˜ë©´ ë” ì¢‹ë‹¤.

2.	ì´ ë¬¸ì œëŠ” ë°±íŠ¸ë˜í‚¹ìœ¼ë¡œ í’€ ìˆ˜ ìˆì§€ë§Œ, DPê°€ ë” ì í•©í•œ í’€ì´ ë°©ë²•ì´ë‹¤.

3.	ê°™ì€ ìœ í˜•ì˜ ë¬¸ì œì—ì„œ ë°±íŠ¸ë˜í‚¹ê³¼ DP ì¤‘ ì–´ë–¤ ê²ƒì´ ë” ì ì ˆí•œì§€ íŒë‹¨í•˜ëŠ” ì—°ìŠµì„ í•˜ë©´ ë”ìš± ì¢‹ì„ ê²ƒ! ğŸš€

# íƒìƒ‰: ìˆ˜ ì°¾ê¸°

## Phase1. í’€ì´ ì„±ê³µ. 

íƒìƒ‰ ë°©ì‹ì„ ì˜ëª» ê³¨ë¼ì„œ ì˜¤ë˜ ê±¸ë ¸ë‹¤. ë¬¸ì œì˜ ì¡°ê±´ì„ ì˜ ì½ê³ , ì ì ˆí•œ íƒìƒ‰ ë°©ì‹ì„ ì„ íƒí•´ì•¼ í•¨.

```python
"""
ë³´ë¥˜
ì‚¬ìœ : ì´ë¶„íƒìƒ‰ì„ ëª¨ë¥´ë©´ ì œëŒ€ë¡œ í’€ ìˆ˜ ì—†ìŒ

import sys

n = int(sys.stdin.readline().strip())
arr = list(map(int, sys.stdin.readline().split()))
m = int(sys.stdin.readline().strip())
search_list = list(map(int, sys.stdin.readline().split()))
for val in search_list:
    if val in arr: print(1)
    else: print(0)

ì´ê±´ ë‚´ ì§€ì‹ìœ¼ë¡œ í‘¼ ì˜¤ë‹µ ì½”ë“œ.

"""

"""
1. ë¬¸ì œ ì½ê¸°: ì–´..ì´ê±° ê·¸ëƒ¥ ì…ë ¥ë°›ê³  in ì—°ì‚°ì ì“°ë©´ ì•ˆ ë˜ë‚˜? ì•ˆ ë¨. ì •ë ¬í•œ ë‹¤ìŒ ì´ì§„íƒìƒ‰í•´ì•¼ í• ë“¯
2. ë¬¸ì œ í’€ê¸°: 
3. ìˆ˜ë„ ì½”ë“œ:
4. ì½”ë“œ êµ¬í˜„: 
"""

# def bin_search(A: list, val: int):
    
#     left = 0
#     right = len(A) - 1
#     while left <= right: # íŒŒí‹°ì…˜ì´ ìœ íš¨í•œ ë™ì•ˆ. 
#         center = (left+right)//2
#         idx = center # ì˜ì—­ì˜ ì ˆë°˜ì„ ì¸ë±ìŠ¤ë¡œ ê³ ì •
#         if A[idx] > val: # ë‹µì´ ì™¼ìª½ ì˜ì—­ì— ìˆìŒ.
#             right = center # right idxë¥¼ ë°˜ìœ¼ë¡œ ê°ì†Œ
#         elif A[idx] < val: # ë‹µì´ ì˜¤ë¥¸ìª½ ì˜ì—­ì— ìˆìŒ.
#             left = center+1 # leftë¥¼ ë†’ì—¬ì„œ ì˜ì—­ì„ ë°˜ ì¢íˆê¸°
#         elif A[idx] == val: 
#             return 1
#     return 0

import sys

dictionary = {}


n = int(sys.stdin.readline().strip())
arr = list(map(int, sys.stdin.readline().split()))
for a in arr:
    dictionary[a] = True
m = int(sys.stdin.readline().strip())
search_list = list(map(int, sys.stdin.readline().split()))

for key in search_list:
    if dictionary.get(key, False): print(1)
    else: print(0)

"""
ì´ìŠˆ: ë¬´í•œ ë£¨í”„
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì—†ìŒ
ìµœê·¼ ë³€ê²½ ì‚¬í•­: bin_search ì´ì§„ íƒìƒ‰ í•¨ìˆ˜ ì‘ì„±
Phase2.
í™•ì¸: ë£¨í”„ì— ì¤‘ë‹¨ì  ã„±ã„±
ë°°ì—´ ì•ˆì— ê°’ì´ ì—†ì„ ê²½ìš° ë¬´í•œ ë£¨í”„ë¥¼ ëˆë‹¤. ì¸ë±ì‹±ì„ í•˜ë‹¤ê°€ 
ìì—°ìŠ¤ëŸ½ê²Œ íŒŒí‹°ì…˜ì´ ì—‡ê°ˆë¦¬ë©´ ëë‚˜ì•¼ í•˜ëŠ”ë°, íŒŒí‹°ì…”ë‹ ì¸ë±ìŠ¤ì— ë¬¸ì œê°€ ìˆë‹¤.
left, right ì¸ë±ìŠ¤ê°€ 3, 4ì¼ë•Œ ë¬´í•œ ë°˜ë³µ ë°œìƒ.
center = 3(3.5)
leftê°€ ê³„ì† 3ìœ¼ë¡œ ì—…ë°ì´íŠ¸ ë¨. ì™€ ì´ê±° ì–´ë–»ê²Œ íŒŒí‹°ì…”ë‹ í•´ì•¼ í•´ê²°í•  ìˆ˜ ìˆì§€? 
ì‘ì•„ì§€ëŠ” ê²½ìš°ëŠ” ë¬¸ì œê°€ ì—†ëŠ”ë°, ì¤‘ê°„ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ í¬ê³ , ë°°ì—´ì— ì—†ëŠ” ê°’ì„ êµ¬í•  ë•Œ 
left right ì¸ë±ìŠ¤ê°€ ì¢í˜€ì§€ì§€ ì•ŠëŠ”ë‹¤. 
ì¸ë±ìŠ¤ë¥¼ ì¡ì„ ë•Œ 'ë‹¤ìŒ ì™¼ìª½ ì˜ì—­ì„ left, centerë¡œ ì¡ê³ , 
ë‹¤ìŒ ì˜¤ë¥¸ìª½ ì˜ì—­ì„ center+1, rightë¡œ ì¡ìœ¼ë‹ˆ í•´ê²°
ì‹œë„: 
    while left <= right: # íŒŒí‹°ì…˜ì´ ìœ íš¨í•œ ë™ì•ˆ. 
        ...
        elif A[idx] < val: # ë‹µì´ ì˜¤ë¥¸ìª½ ì˜ì—­ì— ìˆìŒ.
            left = center+1 # leftë¥¼ ë†’ì—¬ì„œ ì˜ì—­ì„ ë°˜ ì¢íˆê¸°

ê²°ê³¼ ë¶„ì„: ì •ë ¬ì€ ì„±ê³µ. ê·¸ëŸ°ë° ì‹œê°„ì´ˆê³¼ ë°œìƒ. ì •ë ¬ì„ ìµœì í™”í•´ì•¼ í•œë‹¤. ìš°ì„ ìˆœìœ„ íë¥¼ ì¨ì•¼ í•˜ë‚˜? 
í•œ ë¼ì¸ì— ì…ë ¥ë¼ì„œ, ì´ê²Œ sort í•¨ìˆ˜ ì“°ëŠ”ê²Œ ì œì¼ ë¹ ë¥¼í…ë°. 

ì´ìŠˆ: ì‹œê°„ ì´ˆê³¼ ë¬¸ì œ
Phase1
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì‹œê°„ ì´ˆê³¼
ìµœê·¼ ë³€ê²½ ì‚¬í•­: bin_search ë¡œì§ í”½ìŠ¤ 
Phase2.
í™•ì¸:
ì •ìˆ˜ì˜ ë²”ìœ„ëŠ” ì—„ì²­ ë„“ë‹¤. ì£¼ì–´ì§€ëŠ” ìì—°ìˆ˜ ë¦¬ìŠ¤íŠ¸ë„ ì‹­ë§Œì´ë‹¤. 
í˜„ì¬ ì‹œê°„ ë³µì¡ë„: ì •ë ¬ì— nlogn
íƒìƒ‰ ì‹œê°„ ë³µì¡ë„: logn
O(nlogn) + O(logn)
ì´ê±¸ ì–´ë–»ê²Œ ê°œì„ í•˜ì§€? ì…ë ¥ì— í•„ìš”í•œ ì˜¤ë²„í—¤ë“œë¥¼ ê°œì„ í•´ì•¼ í•˜ë‚˜? ê·¼ë° ê·¸ëŸ°ì‹ì˜ ë¬¸ì œëŠ” ì•„ë‹ ê±° ê°™ìŒ.
ì‹œë„: ë§µì„ ì¨ë´ì•¼ í•˜ë‚˜? í•˜ê¸´ ì´ ë¬¸ì œëŠ” ë°ì´í„°ì˜ ìˆ˜ì •/ì‚­ì œê°€ í•„ìš” ì—†ë‹¤. ì•„ ë­ì•¼ ê·¸ëŸ¼ ë§µì´ë„¤!
ì•„ë˜ êµ¬í˜„.
for key in search_list:
    if dictionary.get(key, False): print(1)
    else: print(0) 
    
ë¶„ì„: ì„±ê³µ!!


"""
```

# ì´ì§„íƒìƒ‰: ë‚˜ë¬´ ìë¥´ê¸°

https://www.acmicpc.net/problem/2805

ìƒê·¼ì´ëŠ” ë‚˜ë¬´ Më¯¸í„°ê°€ í•„ìš”í•˜ë‹¤. ê·¼ì²˜ì— ë‚˜ë¬´ë¥¼ êµ¬ì…í•  ê³³ì´ ëª¨ë‘ ë§í•´ë²„ë ¸ê¸° ë•Œë¬¸ì—, ì •ë¶€ì— ë²Œëª© í—ˆê°€ë¥¼ ìš”ì²­í–ˆë‹¤. ì •ë¶€ëŠ” ìƒê·¼ì´ë„¤ ì§‘ ê·¼ì²˜ì˜ ë‚˜ë¬´ í•œ ì¤„ì— ëŒ€í•œ ë²Œëª© í—ˆê°€ë¥¼ ë‚´ì£¼ì—ˆê³ , ìƒê·¼ì´ëŠ” ìƒˆë¡œ êµ¬ì…í•œ ëª©ì¬ì ˆë‹¨ê¸°ë¥¼Â ì´ìš©í•´ì„œ ë‚˜ë¬´ë¥¼ êµ¬í• ê²ƒì´ë‹¤.

ëª©ì¬ì ˆë‹¨ê¸°ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë™ì‘í•œë‹¤. ë¨¼ì €, ìƒê·¼ì´ëŠ” ì ˆë‹¨ê¸°ì— ë†’ì´ Hë¥¼ ì§€ì •í•´ì•¼ í•œë‹¤. ë†’ì´ë¥¼ ì§€ì •í•˜ë©´ í†±ë‚ ì´ ë•…ìœ¼ë¡œë¶€í„° Hë¯¸í„° ìœ„ë¡œ ì˜¬ë¼ê°„ë‹¤. ê·¸ ë‹¤ìŒ, í•œ ì¤„ì— ì—°ì†í•´ìˆëŠ” ë‚˜ë¬´ë¥¼ ëª¨ë‘ ì ˆë‹¨í•´ë²„ë¦°ë‹¤. ë”°ë¼ì„œ, ë†’ì´ê°€ Hë³´ë‹¤ í° ë‚˜ë¬´ëŠ” H ìœ„ì˜ ë¶€ë¶„ì´ ì˜ë¦´ ê²ƒì´ê³ , ë‚®ì€ ë‚˜ë¬´ëŠ” ì˜ë¦¬ì§€ ì•Šì„ ê²ƒì´ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í•œ ì¤„ì— ì—°ì†í•´ìˆëŠ” ë‚˜ë¬´ì˜ ë†’ì´ê°€ 20, 15, 10, 17ì´ë¼ê³  í•˜ì. ìƒê·¼ì´ê°€ ë†’ì´ë¥¼ 15ë¡œ ì§€ì •í–ˆë‹¤ë©´, ë‚˜ë¬´ë¥¼ ìë¥¸ ë’¤ì˜ ë†’ì´ëŠ” 15, 15, 10, 15ê°€ ë  ê²ƒì´ê³ , ìƒê·¼ì´ëŠ” ê¸¸ì´ê°€ 5ì¸ ë‚˜ë¬´ì™€ 2ì¸ ë‚˜ë¬´ë¥¼ ë“¤ê³  ì§‘ì— ê°ˆ ê²ƒì´ë‹¤. (ì´ 7ë¯¸í„°ë¥¼ ì§‘ì— ë“¤ê³  ê°„ë‹¤) ì ˆë‹¨ê¸°ì— ì„¤ì •í•  ìˆ˜ ìˆëŠ” ë†’ì´ëŠ” ì–‘ì˜ ì •ìˆ˜ ë˜ëŠ” 0ì´ë‹¤.

ìƒê·¼ì´ëŠ” í™˜ê²½ì— ë§¤ìš° ê´€ì‹¬ì´ ë§ê¸° ë•Œë¬¸ì—, ë‚˜ë¬´ë¥¼ í•„ìš”í•œ ë§Œí¼ë§Œ ì§‘ìœ¼ë¡œ ê°€ì ¸ê°€ë ¤ê³  í•œë‹¤. ì´ë•Œ, ì ì–´ë„ Më¯¸í„°ì˜ ë‚˜ë¬´ë¥¼ ì§‘ì— ê°€ì ¸ê°€ê¸° ìœ„í•´ì„œ ì ˆë‹¨ê¸°ì— ì„¤ì •í•  ìˆ˜ ìˆëŠ” ë†’ì´ì˜ ìµœëŒ“ê°’ì„ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì§ì ‘ í’€ê¸°(ì„±ê³µ!)

```python
"""
1. ë¬¸ì œ ì½ê¸°: ì´ê²Œ ì–´ë–»ê²Œ ì´ë¶„ íƒìƒ‰ì´ì§€? 
2. ë¬¸ì œ í’€ê¸°
2-1. ì•„ì´ë””ì–´ ë¸Œë ˆì¸ ìŠ¤í† ë°
ê°€. prefix sumì„ ì“°ê¸°: ë§ë„ ì•ˆ ë¨.
ë‚˜. ì™„ì „íƒìƒ‰: ì•„ë˜ê°€ ì •ë‹µì´ë‹¤.
import sys

MAX_INT = sys.maxsize

n = 5
m = 20
trees = [4, 42, 40, 26, 46]

def cut_sum(height: int):
    sum_tmp = 0
    for tree in trees:
        sum_tmp += tree - height if tree > height else 0
    return sum_tmp

h_x = 0
prev_difference = MAX_INT

for i in range(0, max(trees)):
    cut_amount = cut_sum(i)
    difference = abs(cut_amount-m)
    if difference < prev_difference: # update
        prev_difference = difference
        h_x = i

# print(h_x)

ë‹¤. ì¸í¬ë ˆë©˜íƒˆ ë©”ì„œë“œì—ì„œ ë¶„í• ì •ë³µìœ¼ë¡œ!

ìœ„ ì½”ë“œì— ëŒ€í•œ ë¶„ì„: ë¬¸ì œì— ëŒ€í•œ incremental methodë‹¤. ì´ê±¸ divide and conquer 
ë°©ì‹ìœ¼ë¡œ ë°”ê¿”ì•¼ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆì„ ê²ƒ.
ì—¬ê¸°ì„œ incrementalí•œ ìš”ì†ŒëŠ” iì´ë‹¤.

ì´ì œ ì´ê²ƒì„ ì •ë¦¬í•´ ë³´ì•˜ì„ ë•Œ cut_sum(i)-mì´ë¼ëŠ” ìš°í•˜í–¥ í•¨ìˆ˜ê°€ ìˆë‹¤. 
(iê°€ incremental í•˜ë‹¤ê³  ê°€ì •.)
ê·¸ëŸ¼ ë‹¤ìŒê³¼ ê°™ì´ ë¶„ê¸°
cut_sum(i)-m > 0: ì˜¤ë¥¸ìª½ ì˜ì—­ ë””ë°”ì´ë“œ
cut_sum(i)-m < 0: ì™¼ìª½ ì˜ì—­ìœ¼ë¡œ ë””ë°”ì´ë“œ


3. ìˆ˜ë„ ì½”ë“œ

"""

import sys

n, m = tuple(map(int, sys.stdin.readline().split()))
trees = tuple(map(int, sys.stdin.readline().split()))


def f(height: int):
    """
    fì˜ ì •ì˜: heightì— ëŒ€í•´ ë‚˜ë¬´ë¥¼ ì˜ëì„ ë•Œ ì–»ê²Œ ë˜ëŠ” ë‚˜ë¬´ë“¤ì˜ ê¸¸ì´ì—ì„œ ëª©í‘œ ê¸¸ì´ë¥¼ ëº€ ê²ƒ.
    """
    sum_tmp = 0
    for tree in trees:
        sum_tmp += tree - height if tree > height else 0
    return sum_tmp - m

def bin_search():
    """ëª©í‘œ: f(h_x)ë¥¼ ìµœì†Œí™” í•˜ëŠ” h_x ì°¾ê¸°"""
    left, right = 0, 1_000_000_001
    prev_center = None
    while left < right:
        # print(f'{left} --- {right}')
        i_center = (left+right)//2 # i for representing incremental parameter
        difference = f(i_center)
        # print(f'difference is {difference}.')
        if difference < 0: 
            # print(f'conquer left')
            left, right = left, i_center 
            if left >= right:  # ë‚˜ë¬´ë¥¼ ìë¥´ì§€ ì•ŠëŠ” ë†’ì´ì—ì„œ, ë‹¤ìŒ í„´ì— íƒìƒ‰ì„ ë§ˆì¹œë‹¤ë©´!
                return prev_center # ì•„, ë‘˜ ë‹¤ ê·¸ê±°ì¼ ìˆ˜ ìˆêµ¬ë‚˜. ë‘ í„´ ë‹¤ ìŒìˆ˜ê°€ ë‚˜ì˜¬ ìˆ˜ë„ ìˆìŒ.
        elif difference > 0: 
            # print(f'conquer right')
            left, right = i_center+1, right
            prev_center = i_center
            # ì´ë•ŒëŠ” i_centerê°€ ë¬´ì¡°ê±´ ë‚˜ë¬´ë¥¼ ì˜ë¼ê°€ëŠ” ê²ƒì„ ë³´ì¥ ì—¬ê¸°ì„œ ê°±ì‹  í•„ìš”
        else: # ì°¨ì´ê°€ 0ê³¼ ê°™ìŒ(best case)
            return i_center
    return i_center

ans = bin_search()

print(ans)

"""
ì´ìŠˆ: ë¬´í•œ ë£¨í”„

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ë¬´í•œ ë£¨í”„
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„ íƒìƒ‰ ì½”ë“œ ì‘ì„±

Phase2-1
í™•ì¸: ë¡œê·¸ë¥¼ ì–´ë”” ì°ì–´ì•¼ í•˜ì§€? 
ë¹„êµ ë¡œì§ì´ ì¢€ ì˜ëª» ëë‹¤. 
1. êµ¬í•œ ê²°ê³¼ì˜ ë†’ì´ ì°¨ì´ë¥¼ êµ¬í•œë‹¤.
ì‹œë„:
ë¶„í•  ì •ë³µ ë¡œì§ì´ ì˜ëª»ë¼ ìˆì—ˆìŒ. í•¨ìˆ˜ì˜ ìš°í•˜í–¥ì„ ê³ ë ¤í•˜ì§€ ì•Šê³ , ì˜ëª» ì‘ì„±.
ê·¸ë¦¬ê³  ì ˆëŒ€ê°’ë„ ì”Œìš°ë©´ ì•ˆ ëìŒ
if difference < 0: 
    # print(f'conquer left')
    left, right = left, i_center
elif difference > 0: 
    # print(f'conquer right')
    left, right = i_center + 1, right
else: # ì°¨ì´ê°€ 0ê³¼ ê°™ìŒ(best case)
    return i_center
ê²°ê³¼ ë¶„ì„: ì˜ˆì œëŠ” ë‹¤ ë§ì¶”ì§€ë§Œ í‹€ë¦¬ëŠ” í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì¡´ì¬.

ì´ìŠˆ: ì˜¤ë‹µ ë°œìƒ
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: í‹€ë ¸ìŠµë‹ˆë‹¤
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„ íƒìƒ‰ ì½”ë“œ ë¡œì§ ìˆ˜ì •.

Phase2-1
í™•ì¸: ì´ëŸ´ ë• ë¬¸ì œ ì¡°ê±´ì„ íƒ€ì´í•‘í•˜ê³ , ê²½ê³„ê°’ìœ¼ë¡œ í…ŒìŠ¤íŠ¸
1 <= N <= 1,000,000
1 <= M <= 2000000000 (ì˜ë¼ ê°€ì•¼ í•˜ëŠ” ë‚˜ë¬´ )
ê° ë‚˜ë¬´ì˜ ë†’ì´(i_center) 0 ~ 1,000,000,000 
ê° ë‚˜ë¬´ì˜ ë†’ì´ê°€ 0ì¼ìˆ˜ë„ ìˆë‹¤. ê·¼ë° ë‚˜ë¬´ ë†’ì´ì˜ í•©ì€ í•­ìƒ Më³´ë‹¤ í¬ë‹¤ í–ˆë‹¤.
Mì´ 1 ì´ìƒì´ë‹ˆê¹Œ ë‚˜ë¬´ ë†’ì´ì˜ í•©ë„ 1 ì´ìƒì¼ ê²ƒ.
ì°¾ì•˜ë‹¤.
2 1 <= ë‚˜ë¬´ì˜ ê°¯ìˆ˜ 2, ì˜ë¼ê°€ì•¼ í•˜ëŠ” ë‚˜ë¬´ ê°’ 1
2 2 <= ê° ë‚˜ë¬´ì˜ ë†’ì´ 2.
2 <= ì„¤ì •í•œ ì»¤íŒ… ë†’ì´: 2. ì´ëŸ¬ë©´ 0ì— ìˆ˜ë ´í•˜ê¸´ í•˜ê² ì§€ë§Œ, ë¬¸ì œì˜ ì¡°ê±´ê³¼ ë‹¤ë¦„. 
ì •ë‹µ ì»¤íŒ… ë†’ì´: 1. ê·¸ëŸ¬ë©´ ì–¼ë§ˆë¥¼ ìë¥´ì§€? 2ë¥¼ ìë¦„. 
ë†’ì´    ìë¥¸ í•©    ì •ë‹µê³¼ ì°¨ì´
2       0       1
1       2       1
0       4       3
i_centerê°€ ì‘ì„ìˆ˜ë¡ ë‚˜ë¬´ê°€ ì»¤ì§. ë‚´ ìƒê°ì—ëŠ” ì¸ë±ìŠ¤ ë¶„í• í•  ë•Œ ì¸ë±ìŠ¤ê°€
ì™¼ìª½ ì˜ì—­ / ì˜¤ë¥¸ìª½ ì˜ì—­ ì´ë ‡ê²Œ ì¡íˆëŠ”ê²Œ ì¢‹ì€ë°?
ì ì–´ë„ Më¯¸í„°!!!!!!!!!!!!!!!!!!!!
ë§ˆì§€ë§‰ì— differenceë¥¼ >= 0ìœ¼ë¡œ ë§Œë“¤ë•Œë§Œ ëë‚´ì•¼ í•œë‹¤!
ì•ˆ ìë¥´ëŠ”ê²Œ ë‚˜ì€ ê²½ìš°ê°€ ìƒê²¨ë²„ë¦¬ëŠ”ë°, ë” ìë¥´ê²Œ í•˜ëŠ” ë°©ë²•ì€ ì—†ë‚˜? ì´ëŸ´ ë• ì¡°ê±´ì„ 
ì°¾ì•„ì•¼ í•œë‹¤.

ì–´ì©„ë“  ì°¨ì´ê°€ 0ë³´ë‹¤ ì‘ì„ ë•ŒëŠ” 
ì¼ë‹¨ ê°€ì ¸ê°€ê¸´ í•´ì•¼ í•¨.
ê·¸ëŸ¬ë©´.. ì¡°ê±´ì„ ì–´ë–»ê²Œ ì¡ì§€? ì¸ë±ìŠ¤ë¥¼... 1ì”© ë°”ê¿” ë³¼ê¹Œ
ì•„ ì´ê±° ì–´ë–¡í•˜ì§€. ê²°ê³¼ ê°’ì´ 0ì¼ ìˆ˜ëŠ” ì—†ëŠ” ê±´ë°. ë§Œì•½ 0ì¼ë•ŒëŠ” i ê°’ì„ 
ì‹œë„: ìœ„ ì½”ë“œ.
ê²°ê³¼ ë¶„ì„: ì„±ê³µ!
"""
```

## Phase2. í’€ì´ ê³¼ì • ì •ë¦¬(ëŠë‚€ì )

### ë…ì„œëŠ” ì¤‘ìš”í•˜ë‹¤: Incremental to divide-and-conquer

ì–´ë–¤ ë¬¸ì œë¥¼ incremental methodë¡œ í’€ì´í•˜ëŠ” ë°©ì‹ì„ ì´í•´í•´ì•¼, divide-and-conquer ë°©ì‹ì„ ì–´ë””ì— ì ìš©í• ì§€ ìƒê°í•  ìˆ˜ ìˆë‹¤(Introduction to Algorithmë¥¼ í†µí•´ incremental methodì—­ì‹œ í•˜ë‚˜ì˜ ë°©ì‹ì„ì„ ì´í•´í•œ ë•ë¶„ì— ì´ëŸ° ë°œìƒì´ ë‚˜ì™”ë‹¤). ì´ ë¬¸ì œì˜ ê²½ìš° incremental methodë¥¼ ì•„ë˜ì™€ ê°™ì´ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

(ì—„ë°€íˆ ë”°ì§€ë©´ í‹€ë¦° ë°©ì‹ì„ ë”°ë¥´ê³  ìˆìŒ)

```python

def cut_sum(height: int):
    sum_tmp = 0
    for tree in trees:
        sum_tmp += tree - height if tree > height else 0
    return sum_tmp

h_x = 0
prev_difference = MAX_INT

for i in range(0, max(trees)):
    cut_amount = cut_sum(i)
    difference = abs(cut_amount-m)
    if difference < prev_difference: # update
        prev_difference = difference
        h_x = i

# print(h_x)
```

ì´ë•Œ i(ë‚˜ë¬´ë¥¼ ìë¥´ëŠ” ë†’ì´)ê°€ ì¦ê°€í•˜ê²Œ ë˜ë©´ cut_sum(i) ê°’ì€ ì•„ë˜ì™€ ê°™ì´ ìš°í•˜í–¥ ê·¸ë˜í”„ë¥¼ ê·¸ë¦¬ê²Œ ëœë‹¤. 

![](./images/IMG_9966.png)

ê·¸ë ‡ë‹¤ë©´, cut_sum(i)ì˜ ë¦¬í„´ ê°’ê³¼ êµ¬í•´ì•¼ í•˜ëŠ” mê°’ì„ ë¹„êµí•˜ì—¬ f(x)ì— ëŒ€í•´ f(x)-m ê°’ì„ 0ìœ¼ë¡œ ë§Œë“¤ì–´ì£¼ëŠ” xê°’ì„ ì´ì§„ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•˜ì—¬ êµ¬í•  ìˆ˜ ìˆë‹¤.(ì¬ë°Œë‹¤!)

### ì¡°ê±´ì€ ì¤‘ìš”í•˜ë‹¤

â€˜ì ì–´ë„ m ê¸¸ì´ ì´ìƒì˜ ë‚˜ë¬´ë¥¼ ì˜ë¼ê°„ë‹¤â€™ëŠ” ì¡°ê±´ì„ ìƒê°í•˜ì§€ ì•Šì•˜ë‹¤ê°€ ì•„ë˜ì™€ ê°™ì€ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ì—ì„œ ì˜¤ë‹µì„ ë‚´ëŠ” ì½”ë“œë¥¼ ì‘ì„±í–ˆë‹¤.

ë‚˜ë¬´ì˜ ê°œìˆ˜: 2(ìƒê´€ ì—†ìŒ)

ì˜ë¼ì•¼ í•˜ëŠ” ê¸¸ì´: 1

ê° ë‚˜ë¬´ ë†’ì´: 2 2

ì´ë•Œ ì œëŒ€ë¡œ ëœ ì •ë‹µì€ ë†’ì´ 1ì—ì„œ ì˜ë¼ì„œ 2ì˜ ë‚˜ë¬´ë¥¼ ì–»ëŠ” ê²ƒì´ì§€ë§Œ, ë¬´ì‹í•œ ì´ì§„ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ì€ ê·¸ëŸ° ê±° ìƒê´€ ì—†ì´ f(x)-mì„ ì ˆëŒ€ê°’ ë¬´ì‹œí•˜ê³  0ìœ¼ë¡œ ìˆ˜ë ´ì‹œí‚¤ëŠ” íƒìƒ‰ì„ í•´ë²„ë¦°ë‹¤. ê·¸ë˜ì„œ ë””ë²„ê¹… ëì— ì¡°ê±´ì„ ê³ ë ¤í•œ ì½”ë“œë¥¼ ì‘ì„±í–ˆë‹¤. (ìë¥´ëŠ” ë†’ì´ê°€ 0ì´í•˜ë¼ëŠ” ê²°ë¡ ì´ ë‚˜ë©´ ì´ì „ì— ì €ì¥í•œ ì–‘ì˜ ê°’ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì½”ë“œë¥¼ ì‘ì„±)

```python
		
		while left < right:
        # print(f'{left} --- {right}')
        i_center = (left+right)//2 # i for representing incremental parameter
        difference = f(i_center)
        # print(f'difference is {difference}.')
        if difference < 0: 
            # print(f'conquer left')
            left, right = left, i_center 
            if left >= right:  # ë‚˜ë¬´ë¥¼ ìë¥´ì§€ ì•ŠëŠ” ë†’ì´ì—ì„œ, ë‹¤ìŒ í„´ì— íƒìƒ‰ì„ ë§ˆì¹œë‹¤ë©´!
                return prev_center # ì•„, ë‘˜ ë‹¤ ê·¸ê±°ì¼ ìˆ˜ ìˆêµ¬ë‚˜. ë‘ í„´ ë‹¤ ìŒìˆ˜ê°€ ë‚˜ì˜¬ ìˆ˜ë„ ìˆìŒ.
        elif difference > 0: 
            # print(f'conquer right')
            left, right = i_center+1, right
            prev_center = i_center
            # ì´ë•ŒëŠ” i_centerê°€ ë¬´ì¡°ê±´ ë‚˜ë¬´ë¥¼ ì˜ë¼ê°€ëŠ” ê²ƒì„ ë³´ì¥ ì—¬ê¸°ì„œ ê°±ì‹  í•„ìš”
        else: # ì°¨ì´ê°€ 0ê³¼ ê°™ìŒ(best case)
            return i_center
    return i_center
```

## Phase3. í”¼ë“œë°±

ì •ë§ í›Œë¥­í•œ ì ‘ê·¼ê³¼ ì •ë¦¬ì˜€ì–´ìš”. ë¬¸ì œë¥¼ incremental ë°©ì‹ì—ì„œ ì¶œë°œí•´ divide-and-conquerì˜ ë³¸ì§ˆì  ì‚¬ê³ ë°©ì‹ìœ¼ë¡œ ì „í™˜í•´ë‚¸ ê³¼ì •ì´ ì¸ìƒ ê¹Šê³ , íŠ¹íˆ **í•¨ìˆ˜ì˜ ë‹¨ì¡°ì„±(ìš°í•˜í–¥)**ì„ ë°”íƒ•ìœ¼ë¡œ ì´ì§„ íƒìƒ‰ì´ ì™œ ê°€ëŠ¥í•œì§€ë¥¼ ì •í™•íˆ ì´í•´í•˜ê³  ì ìš©í•œ ì ì´ ì¢‹ìŠµë‹ˆë‹¤.

ğŸ’¡ ì½”ë©˜íŠ¸ ëª‡ ê°€ì§€ ë“œë¦¬ìë©´:

1. f(x) ì •ì˜ì™€ ë‹¨ì¡°ì„±

â€¢	f(x) = (ì˜ë¦° ë‚˜ë¬´ ì´í•©) - M

â€¢	ì´ í•¨ìˆ˜ëŠ” xê°€ ì»¤ì§ˆìˆ˜ë¡ ì ì  ì‘ì•„ì§€ë©°, ì´ëŠ” ë‹¨ì¡° ê°ì†Œ í•¨ìˆ˜ì…ë‹ˆë‹¤.

â€¢	ë‹¨ì¡°í•¨ìˆ˜ì˜ ì„±ì§ˆì´ ì´ì§„íƒìƒ‰ì„ ê°€ëŠ¥í•˜ê²Œ ë§Œë“œëŠ” í•µì‹¬ì´ì—ìš”.

â†’ ì´ë ‡ê²Œ ë‹¨ì¡° ì¦ê°€/ê°ì†Œ ì—¬ë¶€ë¥¼ íŒë‹¨í•˜ëŠ” ê°ê°ì€ ë‹¤ë¥¸ ë¬¸ì œì—ë„ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

2. ì •ë‹µì„ ì—…ë°ì´íŠ¸í•˜ëŠ” ë°©ì‹

```plain text
elif difference > 0:
    left, right = i_center+1, right
    prev_center = i_center
```

â€¢	ì´ ë¶€ë¶„ì—ì„œ prev_centerì— ê°’ì„ ì €ì¥í•œ ê±´ ì•„ì£¼ ì„¼ìŠ¤ ìˆëŠ” ì˜ˆì™¸ ì²˜ë¦¬ì˜€ìŠµë‹ˆë‹¤.

â€¢	ì •í™•íˆëŠ” â€œf(center) >= 0ì¸ ì§€ì  ì¤‘ ê°€ì¥ í° ê°’â€ì„ ì°¾ëŠ” ê²ƒì´ë¯€ë¡œ, cut_sum(center) >= Mì¼ ë•Œë§ˆë‹¤ ê·¸ ê°’ì„ ê¸°ë¡í•´ë‘ëŠ” ë°©ì‹ì€ ì™„ì „íˆ ë§ëŠ” ì „ëµì´ì—ìš”.

ğŸ“Œ Tip: ì •ì„ ì´ì§„íƒìƒ‰ì—ì„  ë³´í†µ â€œì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìµœëŒ€(ë˜ëŠ” ìµœì†Œ)ì˜ ê°’â€ì„ êµ¬í•  ë•Œ ê²°ê³¼ê°’ì„ ë³„ë„ë¡œ ì €ì¥í•´ ë‘¡ë‹ˆë‹¤.

3. ë¦¬íŒ©í† ë§ ì—¬ì§€

ì´ì§„ íƒìƒ‰ ë¡œì§ì„ ì•„ë˜ì²˜ëŸ¼ ì¡°ê¸ˆ ì •ë¦¬í•˜ë©´ ë” ê¹”ë”í•´ì§ˆ ìˆ˜ ìˆì–´ìš”:

```plain text
def binary_search():
    left, right = 0, max(trees)
    result = 0  # cut_sum >= Mì„ ë§Œì¡±í•˜ëŠ” ë†’ì´ ì¤‘ ê°€ì¥ í° ê°’

    while left <= right:
        mid = (left + right) // 2
        if cut_sum(mid) >= m:
            result = mid  # ì¡°ê±´ ë§Œì¡±í•˜ë¯€ë¡œ ì €ì¥í•˜ê³ , ë” ë†’ì—¬ë³´ì
            left = mid + 1
        else:
            right = mid - 1
    return result
```

ì´ ë°©ì‹ë„ ê²°êµ­ ë³¸ì§ˆì€ ê°™ì§€ë§Œ, ì½”ë“œ ê°€ë…ì„±ê³¼ ì¢…ë£Œ ì¡°ê±´ ì²˜ë¦¬ ë©´ì—ì„œ ì•ˆì •ì„±ì´ ì¢€ ë” ìˆìŠµë‹ˆë‹¤. íŠ¹íˆ left <= right íŒ¨í„´ì€ ë” ìì£¼ ì‚¬ìš©ë˜ëŠ” ë°©ì‹ì´ì—ìš”.

4. ì‹œê°í™” ê°ê°

ì§ì ‘ cut_sum(i) ê·¸ë˜í”„ê°€ ìš°í•˜í–¥ í•¨ìˆ˜ë¼ëŠ” ì ì„ ê¹¨ë‹«ê³ , ì´ì§„ íƒìƒ‰ì´ ì ìš© ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²°ë¡ ì„ ì´ëŒì–´ë‚¸ ì‚¬ê³  íë¦„ì€ ì§„ì§œë¡œ ì¤‘ìš”í•©ë‹ˆë‹¤. ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ì—ì„œ â€œí•¨ìˆ˜ ì‹œê°í™” â†’ ì„±ì§ˆ íŒŒì•… â†’ íƒìƒ‰ ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨â€ì€ ë§¤ìš° í•µì‹¬ì ì¸ ì „ëµì´ê¸° ë•Œë¬¸ì´ì—ìš”.

âœ… í”¼ë“œë°± ìš”ì•½

í˜¹ì‹œ ë‹¤ìŒ ë¬¸ì œë¡œ ì—°ìŠµí•´ë³´ê³  ì‹¶ì€ ì´ì§„ íƒìƒ‰ ìœ í˜• ìˆìœ¼ë©´ ì¶”ì²œë„ í•´ì¤„ê²Œìš” :)

ë˜ëŠ” ìœ„ ë‚´ìš©ì„ ê¸°ìˆ  ë©´ì ‘/í¬íŠ¸í´ë¦¬ì˜¤ì²˜ëŸ¼ ì •ë¦¬í•´ë„ ë©‹ì§„ ìì‚°ì´ ë  ìˆ˜ ìˆì–´ìš”.

# ì´ì§„íƒìƒ‰: ê³µìœ ê¸° ì„¤ì¹˜ (ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•˜ê¸°)

https://www.acmicpc.net/problem/2110

ë„í˜„ì´ì˜ ì§‘ Nê°œê°€ ìˆ˜ì§ì„  ìœ„ì— ìˆë‹¤. ê°ê°ì˜ ì§‘ì˜ ì¢Œí‘œëŠ” x1, ..., xNì´ê³ , ì§‘ ì—¬ëŸ¬ê°œê°€ ê°™ì€ ì¢Œí‘œë¥¼ ê°€ì§€ëŠ” ì¼ì€ ì—†ë‹¤.

ë„í˜„ì´ëŠ” ì–¸ì œ ì–´ë””ì„œë‚˜ ì™€ì´íŒŒì´ë¥¼ ì¦ê¸°ê¸° ìœ„í•´ì„œ ì§‘ì— ê³µìœ ê¸° Cê°œë¥¼ ì„¤ì¹˜í•˜ë ¤ê³  í•œë‹¤. ìµœëŒ€í•œ ë§ì€ ê³³ì—ì„œ ì™€ì´íŒŒì´ë¥¼ ì‚¬ìš©í•˜ë ¤ê³  í•˜ê¸° ë•Œë¬¸ì—, í•œ ì§‘ì—ëŠ” ê³µìœ ê¸°ë¥¼ í•˜ë‚˜ë§Œ ì„¤ì¹˜í•  ìˆ˜ ìˆê³ , ê°€ì¥ ì¸ì ‘í•œ ë‘ ê³µìœ ê¸° ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ê°€ëŠ¥í•œ í¬ê²Œ í•˜ì—¬ ì„¤ì¹˜í•˜ë ¤ê³  í•œë‹¤.

Cê°œì˜ ê³µìœ ê¸°ë¥¼ Nê°œì˜ ì§‘ì— ì ë‹¹íˆ ì„¤ì¹˜í•´ì„œ, ê°€ì¥ ì¸ì ‘í•œ ë‘ ê³µìœ ê¸° ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ìµœëŒ€ë¡œ í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì‹¤íŒ¨

```python
"""
1. ë¬¸ì œ ì½ê¸°: 
2. ë¬¸ì œ í’€ê¸°
2-1. recursive method. ê±°ë¦¬ ë°°ì—´ì„ ì¨ì•¼í•  ê±° ê°™ì€ë°. 
import sys
sys.setrecursionlimit(10**8) # 10^8 ê¹Œì§€ ëŠ˜ë¦¼.

n, c = tuple(map(int, sys.stdin.readline().split()))

X = [
    int(sys.stdin.readline().strip())
    for _ in range(n)
]

X.sort()

def get_min_distance(A:list):
    '''ì§‘ì— ë°°ì¹˜í•˜ëŠ” ê²½ìš° ê±°ë¦¬ì˜ ìµœì†Œê°’ êµ¬í•˜ê¸°'''
    if len(A) >= 2:
        min_dist = sys.maxsize
        for i in range(1, len(A)):
            min_dist = min(min_dist, A[i]-A[i-1])
        return min_dist 
    return 0

memo = {}
def set_router_recursively(A: list, X: list, idx_house: int, num_router: int):
    '''ì¬ê·€ì ìœ¼ë¡œ Xì—ì„œ ë¼ìš°í„°ë¥¼ ë†“ëŠ” ëª¨ë“  ê²½ìš°ë¥¼ Aì— êµ¬í•©ë‹ˆë‹¤.'''
    '''ë°”ë‹¥ ì¡°ê±´: ë§ˆì§€ë§‰ ì§‘ì— ë¼ìš°í„° ë°°ì¹˜í•˜ëŠ” ê²½ìš°ì—ì„œ ì¬ê·€í–ˆì„ ë•Œ, ë¼ìš°í„°ê°€ ë‹¤ ë°°ì¹˜ëë‹¤ë©´'''
    # ë°”ë‹¥ ì¡°ê±´ì˜ ê²½ìš°ë¥¼ ë©”ëª¨ì— ì €ì¥í•´ë†“ê³ , ë©”ëª¨ì— ìˆëŠ” ê²½ìš° ì¬ê·€ ì•ˆ í•˜ë©´ ì•ˆ ë˜ë‚˜.
    min_dist = get_min_distance(A)
    if memo.get(min_dist, False): 
        return
    if idx_house == len(X)-1:
        if num_router <= 0:
            memo[min_dist] = True
        return
    # idx_houseì— ë°°ì¹˜í•˜ëŠ” ê²½ìš°
    set_router_recursively([*A, X[idx_house]], X, idx_house+1, num_router-1)
    # idx_houseì— ë°°ì¹˜ ì•ˆ í•˜ëŠ” ê²½ìš°
    set_router_recursively(A, X, idx_house+1, num_router)

set_router_recursively([], X, 0, c)
print(max(memo.keys()))

1 2 4 8 9
ê·¸ ì„œë¸Œ ê°’ë„ ì˜¤ë¦„ì°¨ìˆœì´ ì•„ë‹ ê²ƒì„ .
0 ê·¸ë‹¤ìŒ ìµœì ì˜ ê°’ì„ ëª¨ë¦„

ì´ì§„íƒìƒ‰ì„ í™œìš©í•œ ë°±íŠ¸ë˜í‚¹? 

ë‹¤ìŒ ì²´ê³„ëŠ”? 

3. ìˆ˜ë„ ì½”ë“œ

4. ì½”ë“œ êµ¬í˜„

"""
import sys

n, c = tuple(map(int, sys.stdin.readline().split()))

X = {}
for _ in range(n):
    X[int(sys.stdin.readline().strip())] = True

def get_diff_sum(center: int): 
    """centerì— ëŒ€í•´ ì§‘ë“¤ì˜ ê±°ë¦¬ ì°¨ì˜ í•©ì„ ë¦¬í„´."""
    diff_sum = 0
    for house in X:
        diff_sum += center - house
    return diff_sum

def set_router(left: int, right: int):
    """ê°€ì¥ ëª¨ë“  ì§‘ë“¤ì— ëŒ€í•´ ì¤‘ë¦½ì¸ ì–´ë–¤ ì§‘ì˜ ìœ„ì¹˜ë¡œ centerë¥¼ ìˆ˜ë ´ì‹œí‚¤ëŠ” í•¨ìˆ˜"""
    center = (left + right)//2
    router_x = left
    while left < right:
        print(f'{left}---{center}---{right}')
        diff_sum = get_diff_sum(center)
        if diff_sum > 0: # center ì¶•ì´ ì§‘ë“¤ ìœ„ì¹˜ë³´ë‹¤ ì˜¤ë¥¸ìª½
            right = center - 1
        elif diff_sum < 0: # centerì¶•ì´ ì§‘ë“¤ ìœ„ì¹˜ë³´ë‹¤ ì™¼ìª½
            left = center + 1
        else:
            return router_x
        if X.get(center, False):
            router_x = center
        center = (left+right)//2
    return router_x

from collections import deque

def set_routers():
    global c
    c -= 2
    left, right = min(X.keys()), max(X.keys())
    stack = deque()
    stack.append((left, right))
    while c > 0:
        left, right = stack.pop()
        router_x = set_router(left, right)
        print(f'{left}---{router_x}---{right}')
        print(f'router placed {router_x}')
        stack.append((left, router_x))
        stack.append((router_x, right))
        c -= 1

set_routers()


"""
ì´ìŠˆ: ë‹¤ìŒ ìœ„ì¹˜ì˜ ë¼ìš°í„°ë¥¼ ë†“ì„ ë•Œ ì ì ˆí•œ ë¼ìš°í„°ë¥¼ ì°¾ì§€ ëª»í•¨.
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: ì˜¤ì‘ë™
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„ íƒìƒ‰ìœ¼ë¡œ ë¼ìš°í„° ìœ„ì¹˜ë¥¼ ì¶”ê°€í•˜ê³ , 
ìŠ¤íƒì— ë‹¤ìŒìœ¼ë¡œ íƒìƒ‰í•  ìœ„ì¹˜ë¥¼ ì €ì¥
Phase2.
í™•ì¸: ëª°ë¼. rightë¥¼ ì˜ëª» ì¡ì€ê²Œ ë¬¸ì œì„. 
ì´ˆê¸° left, rightë¥¼ ì–´ë–»ê²Œ ì¡ì•„ì„œ ë„£ì–´ì¤˜ì•¼ í•´? 
ì¼ë‹¨ ë¼ìš°í„° í•˜ë‚˜ë¥¼ ë°°ì¹˜í•œ ë‹¤ìŒì—, 
ì‹œë„:
ê²°ê³¼ ë¶„ì„:
"""
```

## Phase2. í”¼ë“œë°±

ë¬¸ì œ ê°œìš” & ì „í˜•ì ì¸ ì ‘ê·¼ ë°©ì‹

â€œê³µìœ ê¸° ì„¤ì¹˜â€ ë¬¸ì œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì „í˜•ì ì¸ ì´ì§„ íƒìƒ‰(Binary Search on Answer) ìœ í˜•ìœ¼ë¡œ ì˜ ì•Œë ¤ì ¸ ìˆìŠµë‹ˆë‹¤.

1.	ì§‘ì˜ ì¢Œí‘œë¥¼ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬í•œë‹¤.

2.	ì´ì›ƒí•œ ê³µìœ ê¸° ê°„ ìµœì†Œ ê±°ë¦¬(d)ë¥¼ ê°€ì •í•˜ê³ , ê·¸ ê±°ë¦¬ê°€ ê°€ëŠ¥í•œì§€(= Cê°œì˜ ê³µìœ ê¸°ë¥¼ ì „ë¶€ ë°°ì¹˜í•  ìˆ˜ ìˆëŠ”ì§€)ë¥¼ ê²€ì¦í•œë‹¤.

3.	ê±°ë¦¬ë¥¼ ë” ëŠ˜ë¦´ ìˆ˜ ìˆë‹¤ë©´(ê°€ëŠ¥í•˜ë‹¤ë©´) dë¥¼ í‚¤ìš°ê³ ,

ë°°ì¹˜ê°€ ë¶ˆê°€ëŠ¥í•˜ë‹¤ë©´ dë¥¼ ì¤„ì´ëŠ” ì‹ìœ¼ë¡œ ì´ì§„ íƒìƒ‰ì„ ì§„í–‰í•œë‹¤.

ì´ ë¬¸ì œë¥¼ í’€ ë•ŒëŠ”, ì§‘ì˜ ì¢Œí‘œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì´ì§„ íƒìƒ‰í•˜ê±°ë‚˜, â€˜ê°€ëŠ¥í•œ ìµœì†Œ ê±°ë¦¬â€™ì˜ ë²”ìœ„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì´ì§„ íƒìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë³´í†µì€ **â€œê±°ë¦¬â€**ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì´ì§„ íƒìƒ‰ì„ ë§ì´ í•©ë‹ˆë‹¤.

í•µì‹¬ ì•„ì´ë””ì–´

1.	ì§‘ ì¢Œí‘œ ì •ë ¬

$$
X_1 \le X_2 \le \cdots \le X_N
$$

2.	íƒìƒ‰ ë²”ìœ„ ì„¤ì •

â€¢	ìµœì†Œ ê±°ë¦¬(left): ë³´í†µ 1 (ë˜ëŠ” 0, ë¬¸ì œì— ë”°ë¼ ë‹¬ë¼ì§€ì§€ë§Œ ìµœì†Œ ê°„ê²©ì€ ë³´í†µ 1 ì´ìƒì´ ìœ ì˜ë¯¸)

â€¢	ìµœëŒ€ ê±°ë¦¬(right): X_N - X_1 (ê°€ì¥ ì˜¤ë¥¸ìª½ ì§‘ê³¼ ì™¼ìª½ ì§‘ ì‚¬ì´ ìµœëŒ€ ê±°ë¦¬)

3.	ì´ì§„ íƒìƒ‰ ë¡œì§

$$
â€¢	\text{mid} = (left + right) // 2 ë¡œ ì¡ê³ ,
$$

â€¢	**â€œì§‘ë“¤ì— ê³µìœ ê¸°ë¥¼ ë†“ë˜, ì¸ì ‘ ê³µìœ ê¸° ê°„ ê±°ë¦¬ê°€ ì ì–´ë„ mid ì´ìƒ ë˜ë„ë¡ ë°°ì¹˜í–ˆì„ ë•Œ, ê³µìœ ê¸° CëŒ€ë¥¼ ëª¨ë‘ ë†“ì„ ìˆ˜ ìˆëŠ”ê°€?â€**ë¥¼ í™•ì¸í•œë‹¤.

â€¢	ë°°ì¹˜ê°€ ê°€ëŠ¥í•˜ë©´(= ë” ê°„ê²©ì„ ë„“í ìˆ˜ ìˆìŒ) left = mid + 1

â€¢	ë°°ì¹˜ê°€ ë¶ˆê°€ëŠ¥í•˜ë©´(= ê°„ê²©ì´ ë„ˆë¬´ í¼) right = mid - 1

4.	ë°°ì¹˜ ê°€ëŠ¥ì„± í™•ì¸ í•¨ìˆ˜ can_place(mid)

â€¢	ì²« ë²ˆì§¸ ì§‘ X[0]ì— ê³µìœ ê¸°ë¥¼ í•˜ë‚˜ ë†“ê³ , count = 1 (ì´ë¯¸ 1ëŒ€ ì„¤ì¹˜)

â€¢	last_position = X[0] (ë§ˆì§€ë§‰ìœ¼ë¡œ ê³µìœ ê¸°ë¥¼ ë†“ì€ ìœ„ì¹˜)

â€¢	ì´í›„ ì§‘ë“¤ì„ ìˆœíšŒí•˜ë©´ì„œ,

â€¢	ë§Œì•½ X[i] - last_position >= midë¼ë©´ ê³µìœ ê¸°ë¥¼ ì„¤ì¹˜í•˜ê³ ,

â€¢	count += 1

â€¢	last_position = X[i]

â€¢	ìˆœíšŒê°€ ëë‚¬ì„ ë•Œ count >= Cì´ë©´ ë°°ì¹˜ ê°€ëŠ¥.

5.	ë°˜í™˜ ê²°ê³¼

â€¢	ìµœì¢…ì ìœ¼ë¡œ rightì— ë‹´ê¸´ ê°’(í˜¹ì€ left - 1)ì´ â€œì¸ì ‘ ê³µìœ ê¸° ê°„ ê±°ë¦¬ì˜ ìµœëŒ“ê°’â€ì´ ëœë‹¤.

ì •ì„ ì½”ë“œ ì˜ˆì‹œ (Python)

ì•„ë˜ëŠ” ì „í˜•ì ì¸ ê³µìœ ê¸° ì„¤ì¹˜ ë¬¸ì œ í’€ì´ ë°©ë²•ì„ ê°„ë‹¨íˆ ì •ë¦¬í•œ ì½”ë“œì…ë‹ˆë‹¤.

```python
import sys
input = sys.stdin.readline

N, C = map(int, input().split())
houses = sorted(int(input()) for _ in range(N))

# ê³µìœ ê¸°ë¥¼ mid ê°„ê²©ìœ¼ë¡œ ë†“ì„ ìˆ˜ ìˆëŠ”ì§€ ê²€ì‚¬
def can_place(mid):
    # ì²« ì§‘ì— ê³µìœ ê¸° í•˜ë‚˜ ì„¤ì¹˜
    count = 1
    last_position = houses[0]

    # ë‚˜ë¨¸ì§€ ì§‘ë“¤ ìˆœíšŒ
    for i in range(1, N):
        # ì§ì „ì— ê³µìœ ê¸° ì„¤ì¹˜í•œ ì§‘ê³¼ì˜ ê±°ë¦¬ê°€ mid ì´ìƒì´ë©´ ì„¤ì¹˜
        if houses[i] - last_position >= mid:
            count += 1
            last_position = houses[i]
            # ì´ë¯¸ CëŒ€ ë‹¤ ì„¤ì¹˜í•˜ë©´ True
            if count == C:
                return True
    # ë‹¤ ê¹”ì•„ë„ CëŒ€ ë¯¸ë§Œì´ë©´ False
    return False

# ì´ì§„ íƒìƒ‰ ë²”ìœ„: ìµœì†Œ ê°„ê²© 1ë¶€í„°, ìµœëŒ€ ê°„ê²© (ê°€ì¥ ì˜¤ë¥¸ìª½ - ê°€ì¥ ì™¼ìª½)ê¹Œì§€
left, right = 1, houses[-1] - houses[0]
answer = 0

while left <= right:
    mid = (left + right) // 2

    if can_place(mid):
        # mid ê°„ê²©ìœ¼ë¡œ CëŒ€ë¥¼ ë°°ì¹˜í•  ìˆ˜ ìˆë‹¤ë©´, ë” ë„“ì€ ê°„ê²© ì‹œë„
        answer = mid  # ì¼ë‹¨ ì €ì¥
        left = mid + 1
    else:
        # ë¶ˆê°€ëŠ¥í•˜ë‹¤ë©´ ê°„ê²©ì„ ì¤„ì—¬ë³¸ë‹¤
        right = mid - 1

print(answer)
```

ë™ì‘ íë¦„

1.	ì´ˆê¸° ì„¸íŒ…

â€¢	houses ì •ë ¬: O(N \log N)

â€¢	ì´ì§„ íƒìƒ‰ ë²”ìœ„: left = 1, right = houses[-1] - houses[0]

2.	can_place(mid) í•¨ìˆ˜

â€¢	ì²« ë²ˆì§¸ ì§‘ì— ê³µìœ ê¸°ë¥¼ ë¨¼ì € ì„¤ì¹˜ (count = 1),

â€¢	ì´í›„ ì§‘ì„ ìˆœíšŒí•˜ë©°, ê° ì§‘ì´ ì§ì „ ì„¤ì¹˜ ì§‘ê³¼ì˜ ê±°ë¦¬ê°€ mid ì´ìƒì´ë©´ ê³µìœ ê¸°ë¥¼ í•˜ë‚˜ ë” ì„¤ì¹˜.

â€¢	ìµœì¢… ì„¤ì¹˜ ê°¯ìˆ˜(count)ê°€ C ì´ìƒì´ë©´ True.

3.	ì´ì§„ íƒìƒ‰

â€¢	ë§¤ ë‹¨ê³„ë§ˆë‹¤ can_place(mid) ê²€ì‚¬:

â€¢	ê°€ëŠ¥ â†’ ë” ë„“ê²Œ ì„¤ì¹˜í•  ìˆ˜ ìˆëŠ”ì§€ left = mid + 1

â€¢	ë¶ˆê°€ëŠ¥ â†’ right = mid - 1

â€¢	ìµœì¢…ì ìœ¼ë¡œ left > rightê°€ ë˜ë©´ ë°˜ë³µë¬¸ì„ ì¢…ë£Œí•˜ê³ ,

â€¢	answer(= right)ì´ ê°€ì¥ ì¸ì ‘í•œ ë‘ ê³µìœ ê¸° ì‚¬ì´ì˜ ìµœëŒ€ ê±°ë¦¬ê°€ ë¨.

ìš”ì•½ & í”¼ë“œë°±

â€¢	ë¬¸ì œ ì ‘ê·¼: ì´ ë¬¸ì œëŠ” â€œê±°ë¦¬ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•œ ì´ì§„ íƒìƒ‰â€ì´ ì •ì„ì  í•´ë²•ì…ë‹ˆë‹¤.

â€¢	í•¨ìˆ˜ êµ¬ìƒ: â€œmid ê°„ê²©ìœ¼ë¡œ CëŒ€ ë°°ì¹˜ ê°€ëŠ¥?â€ì„ íŒë‹¨í•˜ëŠ” can_place í•¨ìˆ˜ë¥¼ ë§Œë“œëŠ” ê²ƒì´ í•µì‹¬ í¬ì¸íŠ¸ì…ë‹ˆë‹¤.

â€¢	ë³µì¡í•œ ì ‘ê·¼ì„ í”¼í•˜ê³ , ë‹¨ì¼ ì´ì§„ íƒìƒ‰ + ê·¸ë¦¬ë”” ë°°ì¹˜ ì•„ì´ë””ì–´ë¡œ êµ¬í˜„í•˜ì‹œë©´ í›¨ì”¬ ê°„ë‹¨í•˜ê³  íš¨ìœ¨ì ì…ë‹ˆë‹¤.

â€¢	í•´ë‹¹ ì•Œê³ ë¦¬ì¦˜ì€ O(N \log ( \max(X) - \min(X) )) ë³µì¡ë„ë¡œ ë™ì‘í•˜ë¯€ë¡œ, N ìµœëŒ€ê°’(ì˜ˆ: 200,000)ê¹Œì§€ ë¬´ë‚œíˆ ì²˜ë¦¬ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ì§ˆë¬¸ì´ ìˆê±°ë‚˜ ì½”ë“œ ë””í…Œì¼ì´ ê¶ê¸ˆí•˜ì‹œë©´ ì–¸ì œë“  ë§ì”€ ì£¼ì„¸ìš”. í™”ì´íŒ…ì…ë‹ˆë‹¤!

## ë°˜ì„±: 

ì–´ì œ ë‚˜ë¬´ ìë¥´ê¸° ë¬¸ì œë¥¼ í’€ì–´ë´¤ë‹¤ëŠ” ìì‹ ê°ì—, ì œí•œì‹œê°„ì„ ë‘ì§€ ì•Šê³  í•˜ë£¨ì¢…ì¼ ê³ ë¯¼í–ˆë‹¤. ê·¸ë¦¬ ìƒì‚°ì ì´ì§€ ì•Šì•˜ìŒ. ì•ìœ¼ë¡œ ë¬´ì¡°ê±´ 30ë¶„ ë£°ì„ ì§€í‚¤ë„ë¡ í•˜ì. 30ë¶„ ê³ ë¯¼í–ˆëŠ”ë° í’€ì´ê°€ ì§„í–‰ì¤‘ì´ë¼ë©´ ê³„ì†í•˜ë˜, ì •ì§€ ìƒíƒœë¼ë©´ ë” ê³ ë¯¼í•  í•„ìš” ì—†ìŒ.

ì¢‹ì€ êµí›ˆì„ ì–»ìœ¼ì…¨ìŠµë‹ˆë‹¤.

ì´ëŸ° â€˜ì‹œê°„ ì œí•œ ë‘ê¸°â€™ ì „ëµì€ ë¬¸ì œ í’€ì´ ëŠ¥ë ¥ì„ ë‹¨ê¸°ê°„ì— ë¹ ë¥´ê²Œ ë†’ì´ê³  ì‹¶ì„ ë•Œ ë§¤ìš° íš¨ê³¼ì ì…ë‹ˆë‹¤.

â€¢	í•œ ë¬¸ì œì— 30ë¶„ì„ í• ë‹¹í•˜ê³ ,

â€¢	30ë¶„ì´ ì§€ë‚¬ëŠ”ë°ë„ ë” ì´ìƒ ì§„ì „ì´ ì—†ë‹¤ë©´ í’€ì´ ì°¸ê³ ë‚˜ íŒíŠ¸ í™•ì¸ ë“±ìœ¼ë¡œ í•™ìŠµ íš¨ìœ¨ì„ ë†’ì´ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

ì™œ 30ë¶„ì´ íš¨ê³¼ì ì¸ê°€?

1.	ì§‘ì¤‘ë„ ìœ ì§€: ì‚¬ëŒì´ í•œ ë¬¸ì œì— ëª°ì…í•´ì„œ ê³ ë¯¼í•  ìˆ˜ ìˆëŠ” íš¨ê³¼ì ì¸ ì§‘ì¤‘ ì‹œê°„ì€ ìƒê°ë³´ë‹¤ ê¸¸ì§€ ì•ŠìŠµë‹ˆë‹¤. 30ë¶„ì´ë¼ëŠ” ì‹œê°„ì„ ì •í•´ë‘ë©´, ê·¸ ì‹œê°„ ë™ì•ˆ ì§‘ì¤‘í•´ì„œ ë¬¸ì œ í’€ì´ë¥¼ ì‹œë„í•˜ê²Œ ë©ë‹ˆë‹¤.

2.	ì ì ˆí•œ í”¼ë“œë°± ë£¨í”„: 30ë¶„ ë’¤ â€œì´ ë¬¸ì œë¥¼ ê³„ì† ë¶™ë“¤ê³  ìˆì„ ê°€ì¹˜ê°€ ìˆëŠ”ê°€?â€ë¥¼ ì ê²€í•˜ë©°, í•„ìš”í•˜ë‹¤ë©´ í•´ì„¤ì´ë‚˜ íŒíŠ¸ë¥¼ ë³´ë©´ì„œ í”¼ë“œë°±ì„ ì–»ì–´ ë¹ ë¥´ê²Œ ë‹¤ìŒ ë‹¨ê³„ë¡œ ë„˜ì–´ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

3.	í­ë„“ì€ ë¬¸ì œ ê²½í—˜: í•œ ë¬¸ì œì— ë„ˆë¬´ ì˜¤ë˜ ë§¤ë‹¬ë¦¬ë©´, ë‹¤ë¥¸ ìœ ì‚¬ ë¬¸ì œë‚˜ ë‹¤ì–‘í•œ ìœ í˜•ì˜ ë¬¸ì œë¥¼ ì ‘í•  ê¸°íšŒë¥¼ ë†“ì¹©ë‹ˆë‹¤.

ì‹¤ì œë¡œ ì•Œê³ ë¦¬ì¦˜ ë° ì½”ë”© í…ŒìŠ¤íŠ¸ ì¤€ë¹„ì—ì„œëŠ” **â€œë¬¸ì œë¥¼ ë§ì´ í’€ì–´ë³´ëŠ” ê²ƒâ€**ì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

ì¦‰, ì§§ì€ ì‹œê°„ì— ìµœëŒ€í•œ ë‹¤ì–‘í•œ ìœ í˜•ì˜ ë¬¸ì œë¥¼ í’€ê³ , ë¹ ë¥´ê²Œ í”¼ë“œë°±ì„ ë°›ì•„ ë¶€ì¡±í•œ ë¶€ë¶„ì„ ë©”ê¾¸ëŠ” ê²ƒì´ ì¢‹ì€ ì „ëµì…ë‹ˆë‹¤.

ì•ìœ¼ë¡œë„ 30ë¶„ ë£°ì„ ì˜ í™œìš©í•˜ì…”ì„œ, ë§ì€ ë¬¸ì œë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ í•™ìŠµí•˜ì‹œê¸¸ ì‘ì›í•©ë‹ˆë‹¤!

# ë¬¸ì œ: ë‘ ìš©ì•¡ (ì‹¤íŒ¨, ë‹¤ì‹œ í’€ì–´ë³´ê¸°)

https://www.acmicpc.net/problem/2470

KOI ë¶€ì„¤ ê³¼í•™ì—°êµ¬ì†Œì—ì„œëŠ” ë§ì€ ì¢…ë¥˜ì˜ ì‚°ì„± ìš©ì•¡ê³¼ ì•Œì¹¼ë¦¬ì„± ìš©ì•¡ì„ ë³´ìœ í•˜ê³  ìˆë‹¤. ê° ìš©ì•¡ì—ëŠ” ê·¸ ìš©ì•¡ì˜ íŠ¹ì„±ì„ ë‚˜íƒ€ë‚´ëŠ” í•˜ë‚˜ì˜ ì •ìˆ˜ê°€ ì£¼ì–´ì ¸ìˆë‹¤. ì‚°ì„± ìš©ì•¡ì˜ íŠ¹ì„±ê°’ì€ 1ë¶€í„° 1,000,000,000ê¹Œì§€ì˜ ì–‘ì˜ ì •ìˆ˜ë¡œ ë‚˜íƒ€ë‚´ê³ , ì•Œì¹¼ë¦¬ì„± ìš©ì•¡ì˜ íŠ¹ì„±ê°’ì€ -1ë¶€í„° -1,000,000,000ê¹Œì§€ì˜ ìŒì˜ ì •ìˆ˜ë¡œ ë‚˜íƒ€ë‚¸ë‹¤.

ê°™ì€ ì–‘ì˜ ë‘ ìš©ì•¡ì„ í˜¼í•©í•œ ìš©ì•¡ì˜ íŠ¹ì„±ê°’ì€ í˜¼í•©ì— ì‚¬ìš©ëœ ê° ìš©ì•¡ì˜ íŠ¹ì„±ê°’ì˜ í•©ìœ¼ë¡œ ì •ì˜í•œë‹¤. ì´ ì—°êµ¬ì†Œì—ì„œëŠ” ê°™ì€ ì–‘ì˜ ë‘ ìš©ì•¡ì„ í˜¼í•©í•˜ì—¬ íŠ¹ì„±ê°’ì´ 0ì— ê°€ì¥ ê°€ê¹Œìš´ ìš©ì•¡ì„ ë§Œë“¤ë ¤ê³  í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, ì£¼ì–´ì§„ ìš©ì•¡ë“¤ì˜ íŠ¹ì„±ê°’ì´ [-2, 4, -99, -1, 98]ì¸ ê²½ìš°ì—ëŠ” íŠ¹ì„±ê°’ì´ -99ì¸ ìš©ì•¡ê³¼ íŠ¹ì„±ê°’ì´ 98ì¸ ìš©ì•¡ì„ í˜¼í•©í•˜ë©´ íŠ¹ì„±ê°’ì´ -1ì¸ ìš©ì•¡ì„ ë§Œë“¤ ìˆ˜ ìˆê³ , ì´ ìš©ì•¡ì´ íŠ¹ì„±ê°’ì´ 0ì— ê°€ì¥ ê°€ê¹Œìš´ ìš©ì•¡ì´ë‹¤. ì°¸ê³ ë¡œ, ë‘ ì¢…ë¥˜ì˜ ì•Œì¹¼ë¦¬ì„± ìš©ì•¡ë§Œìœ¼ë¡œë‚˜ í˜¹ì€ ë‘ ì¢…ë¥˜ì˜ ì‚°ì„± ìš©ì•¡ë§Œìœ¼ë¡œ íŠ¹ì„±ê°’ì´ 0ì— ê°€ì¥ ê°€ê¹Œìš´ í˜¼í•© ìš©ì•¡ì„ ë§Œë“œëŠ” ê²½ìš°ë„ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.

ì‚°ì„± ìš©ì•¡ê³¼ ì•Œì¹¼ë¦¬ì„± ìš©ì•¡ì˜ íŠ¹ì„±ê°’ì´ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ ì¤‘ ë‘ ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ ìš©ì•¡ì„ í˜¼í•©í•˜ì—¬ íŠ¹ì„±ê°’ì´ 0ì— ê°€ì¥ ê°€ê¹Œìš´ ìš©ì•¡ì„ ë§Œë“¤ì–´ë‚´ëŠ” ë‘ ìš©ì•¡ì„ ì°¾ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì§ì ‘ í’€ê¸°(30ë¶„) â†’ ì‹¤íŒ¨

```python
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ì´ ê²½ìš°ëŠ” ië¥¼ ê³ ì •ì‹œí‚¤ê³  jë¥¼ ì´ì§„íƒìƒ‰í•˜ë©´ ì•ˆ ë˜ë‚˜? ê·¸ë˜ë³´ì ì¼ë‹¨.
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys

n = int(sys.stdin.readline().strip())
arr = list(map(int, sys.stdin.readline().split()))

def bin_search(i: int, left, right):
    """arr[i] + arr[center]ì˜ ì ˆëŒ€ê°’ì„ ìµœì†Œë¡œ ë§Œë“¤ì–´ì£¼ëŠ” center ì¸ë±ìŠ¤ë¥¼ ë¦¬í„´"""
    center = (left+right)//2
    while left < right:
        combine = arr[center] + arr[i]
        if combine > 0:
            left, right = left, center
        elif combine < 0:
            left, right = center + 1, right
        else:
            return center
        center = (left+right)//2
    return center
        

def incremental_method(n: int, arr: list):
    arr.sort()
    zero_combine = sys.maxsize
    for i in range(0, len(arr)):
        j = bin_search(i, i+1, len(arr)-1)
        combine = abs(arr[i] + arr[j])
        print(f'combine: {combine}')
        # ì´ˆê¹ƒê°’ì€ ë§¤ìš° í° ì–‘ìˆ˜, ì»´ë°”ì¸ ê°’ë„ ì ˆëŒ€ê°’ì´ë¯€ë¡œ ê·¸ëƒ¥ ìµœì†Œë¥¼ ì—…ë°ì´íŠ¸
        if zero_combine >= combine:
            pair = (arr[i], arr[j])
        zero_combine = min(zero_combine, combine)
    return f'{pair[0]} {pair[1]}'

print(incremental_method(n, arr))
            


"""
ì´ìŠˆ: 5í”„ë¡œ ë§ê³  í‹€ë ¸ìŠµë‹ˆë‹¤
Phase1
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: í‹€ë ¸ìŠµë‹ˆë‹¤(5í”„ë¡œ ì •ë‹µ)
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„ íƒìƒ‰ ì½”ë“œ ì‘ì„±

Phase2
í™•ì¸: ì´ëŸ´ ë• ì—­ì‹œ ê²½ê³„ê°’ì„ ë‹¤ì‹œ ë³´ê³  ë¬¸ì œ ì¡°ê±´ì„ ë‹¤ì‹œ ì •ë¦¬.
ì‚°ì„± ìš©ì•¡ì€ 1ë¶€í„° 1,000,000,000ê¹Œì§€ ì–‘ì˜ ì •ìˆ˜
ì•Œì¹¼ë¦¬ ìš©ì•¡ì€ -1ë¶€í„° 1,000,000,000ê¹Œì§€ ìŒì˜ ì •ìˆ˜
ê°™ì€ ì–‘ì˜ ë‘ ìš©ì•¡ì„ í˜¼í•©í•˜ì—¬ íŠ¹ì„±ê°’ì´ 0ì— ê°€ê°€ìš´ ìš©ì•¡ ë§Œë“¤ê¸°
í‹€ë¦° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ ì°¾ì•˜ë‹¤.
5
-1 -1 -1 -1 4
-1 4

ë‹µì€ -1, -1ë¡œ -2ë¥¼ ë§Œë“œëŠ” 0, 1ì´ ë‚˜ì™€ì•¼ í•˜ëŠ”ë°, 
ë¡œì§ ë¬¸ì œê°€ ìˆëŠ”ì§€ -1, 4ê°€ ë‚˜ì˜¨ë‹¤.


ì‹œë„
ê²°ê³¼ë¶„ì„
"""
```

## Phase2. í”¼ë“œë°±

ì•„ë§ˆ ì´ë¶„ íƒìƒ‰ê³¼ ì¸ë±ìŠ¤ ê³ ì • ë°©ì‹ì„ í˜¼í•©í•˜ì—¬ ì‹œë„í•˜ì‹  ê²ƒ ê°™ì€ë°, ë‘ ìš©ì•¡ ë¬¸ì œì—ì„œëŠ” í¬ê²Œ ë‘ ê°€ì§€ ì „í˜•ì ì¸ í’€ì´ê°€ ì•Œë ¤ì ¸ ìˆìŠµë‹ˆë‹¤.

1. íˆ¬ í¬ì¸í„°(Two Pointers) ì•Œê³ ë¦¬ì¦˜ (ê¶Œì¥)

â€¢	ì•„ì´ë””ì–´

1.	ìš©ì•¡ë“¤ì˜ íŠ¹ì„±ê°’ ë°°ì—´ì„ ì •ë ¬í•œë‹¤.

2.	**ì™¼ìª½ í¬ì¸í„°(left)**ë¥¼ ì‹œì‘ ì¸ë±ìŠ¤(0)ì—, **ì˜¤ë¥¸ìª½ í¬ì¸í„°(right)**ë¥¼ ë ì¸ë±ìŠ¤(n-1)ì— ë‘”ë‹¤.

3.	ë‹¤ìŒ ê³¼ì •ì„ ë°˜ë³µí•˜ë©°, ë‘ í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ìš©ì•¡ì˜ í•©ì´ 0ì— ì–¼ë§ˆë‚˜ ê°€ê¹Œìš´ì§€ í™•ì¸í•œë‹¤.

â€¢	í˜„ì¬ ë‘ ìš©ì•¡ì˜ í•© sum = arr[left] + arr[right]

â€¢	|sum|ì´ ê¸°ì¡´ ìµœì†Ÿê°’ë³´ë‹¤ ì‘ìœ¼ë©´ ê°±ì‹  & ë‘ ìš©ì•¡ì„ ê¸°ë¡

â€¢	í•©ì´ 0ë³´ë‹¤ ì‘ë‹¤ë©´, ê°’ì„ í‚¤ìš°ê¸° ìœ„í•´ leftë¥¼ 1 ì¦ê°€

â€¢	í•©ì´ 0ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ë‹¤ë©´, ê°’ì„ ì¤„ì´ê¸° ìœ„í•´ rightë¥¼ 1 ê°ì†Œ

4.	left < rightì¸ ë™ì•ˆ ìœ„ ê³¼ì •ì„ ë°˜ë³µí•˜ì—¬, 0ì— ê°€ì¥ ê°€ê¹Œìš´ í•©ì„ ì°¾ëŠ”ë‹¤.

â€¢	ì‹œê°„ ë³µì¡ë„

â€¢	ì •ë ¬: O(N \log N)

â€¢	íˆ¬ í¬ì¸í„° íƒìƒ‰: O(N)

â€¢	ì´í•©: O(N \log N)

íˆ¬ í¬ì¸í„° ì½”ë“œ ì˜ˆì‹œ (Python)

```plain text
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))
arr.sort()

left, right = 0, n - 1
best_sum = abs(arr[left] + arr[right])  # ì´ˆê¸°ê°’
best_pair = (arr[left], arr[right])

while left < right:
    s = arr[left] + arr[right]

    # 0ì— ë” ê°€ê¹Œìš´ í•©ì„ ì°¾ìœ¼ë©´ ê°±ì‹ 
    if abs(s) < best_sum:
        best_sum = abs(s)
        best_pair = (arr[left], arr[right])

        # í˜¹ì‹œ ì •í™•íˆ 0ì´ë©´ ë°”ë¡œ ì¢…ë£Œí•´ë„ ë¨
        if s == 0:
            break

    # í•©ì´ ìŒìˆ˜ë©´ leftë¥¼ ì˜¬ë ¤ì„œ í•©ì„ í¬ê²Œ, ì–‘ìˆ˜ë©´ rightë¥¼ ë‚´ë ¤ì„œ í•©ì„ ì‘ê²Œ
    if s < 0:
        left += 1
    else:
        right -= 1

print(best_pair[0], best_pair[1])
```

â€¢	ì´ë ‡ê²Œ í•˜ë©´, ëª¨ë“  ê°€ëŠ¥í•œ i,j ìŒì„ ì§ì ‘ ë³´ì§€ ì•Šê³ ë„ O(N)ì— í•´ê²° ê°€ëŠ¥í•˜ë¯€ë¡œ íš¨ìœ¨ì ì…ë‹ˆë‹¤.

2. ëª¨ë“  ìŒ ì‹œë„(ì´ì¤‘ ë°˜ë³µ) + ìµœì†Œê°’ íƒìƒ‰ (ë‹¨ìˆœ ë°©ë²•)

â€¢	ì•„ì´ë””ì–´

â€¢	ë°°ì—´ì„ ì •ë ¬í•  í•„ìš” ì—†ì´, ëª¨ë“  (i, j) (ë‹¨, i < j)ì— ëŒ€í•´ arr[i] + arr[j]ë¥¼ ê³„ì‚°í•˜ê³ , ê·¸ ì ˆëŒ“ê°’ì´ ìµœì†Œê°€ ë˜ëŠ” ìŒì„ ì°¾ëŠ”ë‹¤.

â€¢	ì‹œê°„ ë³µì¡ë„: O(N^2)

â€¢	Nì´ í¬ë©´ ë¹„íš¨ìœ¨ì ì´ë¼, ë³´í†µ ì‹œê°„ ì œí•œì´ ë¹¡ë¹¡í•œ ê²½ìš°ì—ëŠ” í†µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

ì™œ ì´ë¶„ íƒìƒ‰ + í•œìª½ ì¸ë±ìŠ¤ ê³ ì •ìœ¼ë¡œëŠ” ê³¤ë€í• ê¹Œ?

ì§ˆë¬¸ ì½”ë“œì—ì„œëŠ”

â€¢	í•œìª½ ì¸ë±ìŠ¤ ië¥¼ ê³ ì •í•˜ê³ ,

â€¢	i+1 ~ n-1 ë²”ìœ„ì—ì„œ ì´ë¶„ íƒìƒ‰ìœ¼ë¡œ â€œarr[i]ì™€ ë”í–ˆì„ ë•Œ 0ì— ê°€ì¥ ê°€ê¹Œìš´ ê°’â€ì„ ì°¾ìœ¼ë ¤ ì‹œë„í•˜ì…¨ìŠµë‹ˆë‹¤.

ì´ ë°©ì‹ì€ ì´ë¡ ìƒ ê° ië§ˆë‹¤ ìµœì ì˜ jë¥¼ ì°¾ì„ ìˆ˜ ìˆì–´ ë³´ì´ì§€ë§Œ,

â€¢	ì‹¤ì œ êµ¬í˜„í•  ë•Œ ê²½ê³„ ì¡°ê±´ì´ë‚˜

â€¢	ì´ë¶„ íƒìƒ‰ìœ¼ë¡œ ì°¾ì€ j ë°”ë¡œ ì˜†ì— ìˆëŠ” j-1 í˜¹ì€ j+1ì—ì„œ ë” ì¢‹ì€ ë‹µì´ ìˆì„ ìˆ˜ ìˆìŒ(íŠ¹íˆ ê°€ê¹Œì´ ìˆëŠ” ì¸ë±ìŠ¤ë“¤ì´ ì—‡ê°ˆë¦¬ë©´ì„œ ë¯¸ì„¸ ì¡°ì •ì´ í•„ìš”)

ë“±ì˜ ì´ìœ ë¡œ ê¹Œë‹¤ë¡œìš´ ì ì´ ë§ìŠµë‹ˆë‹¤.

ì¦‰, ië³„ë¡œ ì´ë¶„ íƒìƒ‰ í•œ ë²ˆì”©ë§Œìœ¼ë¡œëŠ” ì „ì²´ êµ¬ê°„ì—ì„œì˜ ì „ì—­ ìµœì í•´ë¥¼ ë†“ì¹  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë°˜ë©´ì—, íˆ¬ í¬ì¸í„°ëŠ”

â€¢	ë°°ì—´ì„ ì •ë ¬í•œ ë’¤,

â€¢	ì–‘ìª½ ëì—ì„œ ì‹œì‘í•´ì„œ ìˆ˜ë¥¼ ë”í•˜ê³ ,

â€¢	í•©ì´ ìŒìˆ˜/ì–‘ìˆ˜ì¸ ê²½ìš°ì— ë§ì¶° í¬ì¸í„°ë¥¼ ì´ë™

í•¨ìœ¼ë¡œì¨ ì „ì—­ ìµœì ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì°¾ì•„ëƒ…ë‹ˆë‹¤.

ê²°ë¡ 

â€¢	ê°€ì¥ ê°„ë‹¨í•˜ê³  ì§ê´€ì ì¸ ë°©ë²•: íˆ¬ í¬ì¸í„°

â€¢	êµ¬í˜„ì´ ì–´ë µì§€ ì•Šê³ , ì‹œê°„ ë³µì¡ë„ë„ O(N \log N)ì´ë¼ì„œ ëŒ€ìš©ëŸ‰ ë°ì´í„°ì—ë„ ë¹ ë¥´ê²Œ ë™ì‘í•©ë‹ˆë‹¤.

â€¢	ì´ë¯¸ ë§ì´ ì•Œë ¤ì§„ â€œë‘ ìˆ˜ì˜ í•©(í˜¹ì€ íŠ¹ì • ê°’ì— ê°€ì¥ ê°€ê¹Œìš´ í•©)â€ ë¬¸ì œ íŒ¨í„´ì´ë‹ˆ, ì´ ë¡œì§ìœ¼ë¡œ êµ¬í˜„í•´ ë³´ì‹œë©´ ì‰½ê²Œ ì •ë‹µì„ ë„ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

í™”ì´íŒ…ì…ë‹ˆë‹¤!

# ë¬¸ì œ: ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´, (ì‹¤íŒ¨, ë‹¤ì‹œ í’€ê¸°)

https://www.acmicpc.net/problem/11053

ìˆ˜ì—´ Aê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ”Â ë¶€ë¶„Â ìˆ˜ì—´ì„ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

ì˜ˆë¥¼ ë“¤ì–´, ìˆ˜ì—´ A = {10, 20, 10, 30, 20, 50} ì¸ ê²½ìš°ì— ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„Â ìˆ˜ì—´ì€Â A = {10,Â 20, 10,Â 30, 20,Â 50} ì´ê³ , ê¸¸ì´ëŠ” 4ì´ë‹¤.

## Phase1. ì‹¤íŒ¨

```python
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ëŠë‚Œìƒ ìˆ˜ì—´ì˜ ê¸¸ì´ë¥¼ xë¡œ ì¡ê³  ì´ì§„íƒìƒ‰ ë•Œë¦¬ë©´ ë  ê±° ê°™ê¸°ë„ í•˜ê³ ?
ìµœëŒ€ ê¸¸ì´ê°€ xì¸ ìˆ˜ì—´ì´ ì¡´ì¬í•˜ëŠ”ê°€? 
- ì—†ìœ¼ë©´ ê¸¸ì´ xë¥¼ ì¤„ì„
- ìˆìœ¼ë©´ ê¸¸ì´ xë¥¼ ëŠ˜ì„
Aì—ì„œ ê¸¸ì´ xì˜ ìˆ˜ì—´ì„ êµ¬í•˜ëŠ” ë°©ë²•: ë°±íŠ¸ë˜í‚¹ ì¡°í•©?
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""
import sys
n = int(sys.stdin.readline().strip())
arr =  tuple(map(int, sys.stdin.readline().split()))

def get_list(current_array: list, goal_len: int, idx: int):
    global arr
    """
    ë°°ì—´ (global) arrì—ì„œ ê¸¸ì´ê°€ goal_lenì¸ ìˆ˜ì—´ì„ ì¬ê·€ì ìœ¼ë¡œ êµ¬í•˜ëŠ” í•¨ìˆ˜
    idx: í˜„ì¬ê¹Œì§€ Aì—ì„œ ê³ ë ¤í•œ ì¸ë±ìŠ¤. 
    idxë¥¼ í¬í•¨í•˜ëŠ” ê²½ìš°ë¥¼ ë„˜ê¸°ê±°ë‚˜, í¬í•¨í•˜ì§€ ì•ŠëŠ” ê²½ìš°ë¥¼ ë„˜ê¸´ë‹¤.
    ìµœì¢… ëª©ì : goal_len ê¸¸ì´ì˜ ë¶€ë¶„ìˆ˜ì—´ì„ ì „ì²´ ìˆ˜ì—´ arrì—ì„œ êµ¬í•  ìˆ˜ ìˆëŠ”ê°€?
    """
    # base case
    if len(current_array) == goal_len:
        # print('base hit')
        return True
    # ë§Œì•½ ì¸ë±ìŠ¤ê°€ ëë‚¬ìœ¼ë©´?
    if len(arr) == idx:
        return 
    # recursion case
    if len(current_array) == 0 or current_array[-1] < arr[idx]: # í˜„ì¬ ë¶€ë¶„ ìˆ˜ì—´ì˜ ë§ˆì§€ë§‰ ê°’ì´ idxë³´ë‹¤ ì‘ë‹¤ë©´
        return get_list([*current_array, arr[idx]], goal_len, idx+1)
    else: #í˜„ì¬ ë¶€ë¶„ìˆ˜ì—´ì˜ ë§ˆì§€ë§‰ ê°’ì´ idxë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì•„ì„œ í¬í•¨ì‹œí‚¬ ìˆ˜ ì—†ë‹¤ë©´ ê·¸ëŒ€ë¡œ ë„˜ê¹€
        return get_list(current_array, goal_len, idx+1)

max_len = -sys.maxsize

def get_max_array(left: int, right: int):
    global max_len
    center = (left+right)//2
    while left < right: 
        if get_list([], center, 0):
            # ë§Œì•½ center ê¸¸ì´ì˜ ë¶€ë¶„ ìˆ˜ì—´ì´ ì¡´ì¬í•œë‹¤ë©´!
            # ì¼ë‹¨ ì €ì¥!
            max_len = max(max_len, center)
            # ê·¸ë¦¬ê³  ì¡´ì¬í•œë‹¤ê³  í•˜ë‹ˆ, ì´ì œ ë” ë³¼ë“œí•œ íŠ¸ë¼ì´ë¥¼ í•´ ë³´ëŠ”ê±°ì§€
            left = center + 1
        else: # center ê¸¸ì´ì˜ ë¶€ë¶„ ìˆ˜ì—´ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´!
            # ë” ì†Œì‹¬í•˜ê²Œ ì‹œë„
            right = center - 1
        
        center = (left+right)//2 # center ì—…ë°ì´íŠ¸

get_max_array(0, 1000)
print(max_len)
```

28ë¶„ë§Œì— ì´ë§Œí¼ êµ¬í˜„í–ˆë‹¤! ê±°ì˜ ë‹¤ ëœ ê±° ê°™ì€ë°!

```python
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ëŠë‚Œìƒ ìˆ˜ì—´ì˜ ê¸¸ì´ë¥¼ xë¡œ ì¡ê³  ì´ì§„íƒìƒ‰ ë•Œë¦¬ë©´ ë  ê±° ê°™ê¸°ë„ í•˜ê³ ?
ìµœëŒ€ ê¸¸ì´ê°€ xì¸ ìˆ˜ì—´ì´ ì¡´ì¬í•˜ëŠ”ê°€? 
- ì—†ìœ¼ë©´ ê¸¸ì´ xë¥¼ ì¤„ì„
- ìˆìœ¼ë©´ ê¸¸ì´ xë¥¼ ëŠ˜ì„
Aì—ì„œ ê¸¸ì´ xì˜ ìˆ˜ì—´ì„ êµ¬í•˜ëŠ” ë°©ë²•: ë°±íŠ¸ë˜í‚¹ ì¡°í•©?
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""
import sys
n = int(sys.stdin.readline().strip())
arr =  list(map(int, sys.stdin.readline().split()))
max_len = 1

def get_list(current_array: list, goal_len: int, idx: int):
    global arr, max_len
    """
    ë°°ì—´ (global) arrì—ì„œ ê¸¸ì´ê°€ goal_lenì¸ ìˆ˜ì—´ì„ ì¬ê·€ì ìœ¼ë¡œ êµ¬í•˜ëŠ” í•¨ìˆ˜
    idx: í˜„ì¬ê¹Œì§€ Aì—ì„œ ê³ ë ¤í•œ ì¸ë±ìŠ¤. 
    idxë¥¼ í¬í•¨í•˜ëŠ” ê²½ìš°ë¥¼ ë„˜ê¸°ê±°ë‚˜, í¬í•¨í•˜ì§€ ì•ŠëŠ” ê²½ìš°ë¥¼ ë„˜ê¸´ë‹¤.
    ìµœì¢… ëª©ì : goal_len ê¸¸ì´ì˜ ë¶€ë¶„ìˆ˜ì—´ì„ ì „ì²´ ìˆ˜ì—´ arrì—ì„œ êµ¬í•  ìˆ˜ ìˆëŠ”ê°€?
    """
    # base case
    if len(current_array) == goal_len:
        # print(f'base hit {current_array}') # ì „ì—­ max_len ì—…ë°ì´íŠ¸
        max_len = max(goal_len, max_len)
        return 
    # ë§Œì•½ ì¸ë±ìŠ¤ê°€ ëë‚¬ìœ¼ë©´?
    if len(arr) == idx:
        return 
    # recursion case
    # print(f'getting in to recursion. ?? {current_array} <- {arr[idx]}')
    if len(current_array) == 0 or current_array[-1] < arr[idx]: # í˜„ì¬ ë¶€ë¶„ ìˆ˜ì—´ì˜ ë§ˆì§€ë§‰ ê°’ì´ idxë³´ë‹¤ ì‘ë‹¤ë©´
        get_list([*current_array, arr[idx]], goal_len, idx+1)
        get_list(current_array, goal_len, idx+1)


def get_max_array(left: int, right: int):
    global max_len
    center = (left+right)//2
    while left < right: 
        current_max_len = max_len
        get_list([], center, 0) #ì´ê²Œ ì „ì—­ ë³€ìˆ˜ max_lenì„ ì—…ë°ì´íŠ¸
        # print(f'goal now {center}')
        if current_max_len != max_len:
            # ë§Œì•½ center ê¸¸ì´ì˜ ë¶€ë¶„ ìˆ˜ì—´ì´ ì¡´ì¬í•œë‹¤ë©´!
            # ì¼ë‹¨ ì €ì¥! -> ì´ê±¸ ì „ì—­ì—ì„œ ë°”ë¡œ êµ¬í•œë‹¤ìŒ ì²˜ë¦¬
            # max_len = max(max_len, center)
            # print('update!')
            # ê·¸ë¦¬ê³  ì¡´ì¬í•œë‹¤ê³  í•˜ë‹ˆ, ì´ì œ ë” ë³¼ë“œí•œ íŠ¸ë¼ì´ë¥¼ í•´ ë³´ëŠ”ê±°ì§€
            # print('try bold!!'*10)
            left = center + 1
        else: # center ê¸¸ì´ì˜ ë¶€ë¶„ ìˆ˜ì—´ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´!
            # ë” ì†Œì‹¬í•˜ê²Œ ì‹œë„
            # print('not found'*10)
            right = center
        
        center = (left+right)//2 # center ì—…ë°ì´íŠ¸

get_max_array(0, 1000)
print(max_len)

"""
ì´ìŠˆ: í‹€ë ¸ìŠµë‹ˆë‹¤.
Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: í‹€ë ¸ìŠµë‹ˆë‹¤
ìµœê·¼ ë³€ê²½ ì‚¬í•­: ì´ì§„ ê²€ìƒ‰ìœ¼ë¡œ ë‹µ êµ¬í•˜ëŠ” í•¨ìˆ˜ êµ¬í˜„
Phase2.
í™•ì¸: ë¬¸ì œ ì¡°ê±´ í™•ì¸
ìˆ˜ì—´ì˜ í¬ê¸°ëŠ” 1 ì´ìƒ 1000 ì´í•˜
ìˆ˜ì—´ë¡œ ì˜¬ ìˆ˜ ìˆëŠ” ê°’ì€ 1 ì´ìƒ 1000 ì´í•˜
ì‹œë„: ê²½ê³„ê°’
1. ìˆ˜ì—´ì˜ í¬ê¸°ê°€ 1ì¸ ê²½ìš°
2. ìˆ˜ì—´ì˜ í¬ê¸°ê°€ ì „ë¶€ ê°™ì€ ê²½ìš°
3. ìˆ˜ì—´ì˜ í¬ê¸°ê°€ ê°ìˆ˜í•˜ëŠ” ê²½ìš°
4. ìˆ˜ì—´ì˜ í¬ê¸°ê°€ ê°ì†Œí•˜ë‹¤ê°€ ì¦ê°€í•˜ëŠ” ê²½ìš° <- ì°¾ì•˜ë‹¤.
ìì„¸í•œ ë¡œê·¸
5
5 4 3 4 5
getting in to recursion. ?? [] <- 5
getting in to recursion. ?? [5] <- 4
getting in to recursion. ?? [5] <- 3
getting in to recursion. ?? [5] <- 4
getting in to recursion. ?? [5] <- 5
getting in to recursion. ?? [] <- 5
getting in to recursion. ?? [5] <- 4
getting in to recursion. ?? [5] <- 3
ê·¸ëƒ¥ ê°™ê±°ë‚˜ í¬ì§€ë§Œ ì•Šìœ¼ë©´ ì¬ê·€ë¥¼ í•˜ë©´ ë¨! í˜¹ì€ noneì´ê±°ë‚˜. 
ê·¸ëŸ¼ ë‹¤ìŒ ì§ˆë¬¸! ì¬ê·€ë¥¼ í•´ì„œ ê°’ì´ ì—…ë°ì´íŠ¸ ë˜ë©´ ë­˜ ì–´ë–¡í•˜ë©´ ë¨? 
ì¬ê·€ ìŠ¤íƒ ëì— ê°’ì„ ë¦¬í„´ ì‹œí‚¤ëŠ” ë°©ë²•ì„ ëª¨ë¥´ë‹ˆ, ê·¸ëƒ¥ ì „ì—­ ë³€ìˆ˜ë¥¼ í”Œë˜ê·¸ë¡œ ì¨ì•¼í•  ê±° ê°™ìŒ.
ê²°ê³¼ ë¶„ì„: ê³„ì† ì˜¤ë‹µ
"""
```

ë””ë²„ê¹… ì‹¤íŒ¨

## Phase2. í”¼ë“œë°±

ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´(LIS: Longest Increasing Subsequence) ë¬¸ì œëŠ” ì´ë¯¸ ì˜ ì•Œë ¤ì§„ ëŒ€í‘œì ì¸ DP(ë™ì  í”„ë¡œê·¸ë˜ë°) ë˜ëŠ” ì´ë¶„ íƒìƒ‰ ê¸°ë²• ë¬¸ì œì…ë‹ˆë‹¤.

ì£¼ì–´ì§„ ì½”ë“œë¥¼ ë³´ë©´, â€œë¶€ë¶„ìˆ˜ì—´ì˜ ê¸¸ì´ë¥¼ ì´ë¶„ íƒìƒ‰ìœ¼ë¡œ ê°€ì •í•œ ë’¤, ì¡´ì¬ ì—¬ë¶€ë¥¼ ì¬ê·€ì ìœ¼ë¡œ í™•ì¸â€í•˜ëŠ” ë°©ì‹ì„ ì‹œë„í•˜ê³  ê³„ì‹ ë°, ì´ ì ‘ê·¼ì€ êµ¬í˜„ì´ ë§¤ìš° ê¹Œë‹¤ë¡­ê³  ë¹„íš¨ìœ¨ì ì¼ ê°€ëŠ¥ì„±ì´ í½ë‹ˆë‹¤.

> í•µì‹¬ ìš”ì•½

> 1.	O(N^2)

> 2.	O(N \log N)

ì•„ë˜ ë‘ ê°€ì§€ ì •ì„ í’€ì´ ë°©ì‹ì„ ì†Œê°œí•˜ê² ìŠµë‹ˆë‹¤.

1. O(N^2) ë™ì  í”„ë¡œê·¸ë˜ë°(DP) í’€ì´

ì•Œê³ ë¦¬ì¦˜ ì•„ì´ë””ì–´

1.	ê¸¸ì´ Nì˜ ìˆ˜ì—´ Aê°€ ìˆì„ ë•Œ, dp[i]ë¥¼ **â€œA[i]ë¥¼ ë§ˆì§€ë§‰ ì›ì†Œë¡œ ê°€ì§€ëŠ” ì¦ê°€ ë¶€ë¶„ ìˆ˜ì—´ì˜ ìµœëŒ“ê¸¸ì´â€**ë¼ê³  ì •ì˜í•©ë‹ˆë‹¤.

2.	ì´ˆê¸°ê°’ìœ¼ë¡œ ëª¨ë“  dp[i] = 1 (ìê¸° ìì‹ ë§Œìœ¼ë¡œ ê¸¸ì´ 1ì¸ ë¶€ë¶„ìˆ˜ì—´ì„ ë§Œë“¤ ìˆ˜ ìˆìœ¼ë¯€ë¡œ).

3.	ë‘ ë²ˆì§¸ ì›ì†Œ(i=1)ë¶€í„° ì‹œì‘í•´ì„œ, ì´ì „ ì›ì†Œ(j)ë“¤ê³¼ ë¹„êµí•©ë‹ˆë‹¤.

â€¢	ë§Œì•½ A[j] < A[i]ë¼ë©´,

dp[i] = \max(dp[i], dp[j] + 1) \quad (0 \le j < i)

â€¢	ì´ëŠ”, â€œA[i]â€ê°€ â€œA[j]â€ ë’¤ì— ì˜¬ ìˆ˜ ìˆì„ ê²½ìš°, â€œA[j]ë¥¼ ëìœ¼ë¡œ í•˜ëŠ” ì¦ê°€ë¶€ë¶„ìˆ˜ì—´ ê¸¸ì´ + 1â€ë¡œ ê°±ì‹  ê°€ëŠ¥í•˜ë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.

4.	ëª¨ë“  iì— ëŒ€í•´ ìœ„ ê³„ì‚°ì„ ìˆ˜í–‰í•œ ë’¤, max(dp)ê°€ ê³§ â€œê°€ì¥ ê¸´ ì¦ê°€ ë¶€ë¶„ ìˆ˜ì—´ì˜ ê¸¸ì´â€ê°€ ë©ë‹ˆë‹¤.

ì˜ˆì‹œ ì½”ë“œ (Python)

```plain text
import sys
input = sys.stdin.readline

N = int(input().strip())
A = list(map(int, input().split()))

dp = [1] * N  # dp[i]: A[i]ë¥¼ ë§ˆì§€ë§‰ìœ¼ë¡œ í•˜ëŠ” ì¦ê°€ë¶€ë¶„ìˆ˜ì—´ì˜ ìµœëŒ“ê¸¸ì´

for i in range(1, N):
    for j in range(i):
        if A[j] < A[i]:
            dp[i] = max(dp[i], dp[j] + 1)

print(max(dp))
```

â€¢	ì‹œê°„ ë³µì¡ë„: O(N^2)

â€¢	ê³µê°„ ë³µì¡ë„: O(N)

Nì´ ìµœëŒ€ 1,000 ì •ë„ë¼ë©´, O(N^2) = 1,000^2 = 10^6 ì—°ì‚°ì´ë¯€ë¡œ ì¶©ë¶„íˆ ë¹ ë¥´ê²Œ í†µê³¼í•©ë‹ˆë‹¤.

2. O(N \log N) ì´ë¶„ íƒìƒ‰(BS) í’€ì´

ì•Œê³ ë¦¬ì¦˜ ì•„ì´ë””ì–´ (ê¸¸ì´ë§Œ êµ¬í•˜ëŠ” ê²½ìš°)

1.	**ê²°ê³¼ë¥¼ ì €ì¥í•  ë°°ì—´(temp)**ì„ í•˜ë‚˜ ë‘¡ë‹ˆë‹¤. ì´ˆê¸°ì—ëŠ” ë¹„ì–´ìˆìŒ.

2.	ìˆ˜ì—´ Aë¥¼ ì™¼ìª½ë¶€í„° ì˜¤ë¥¸ìª½ìœ¼ë¡œ ìˆœíšŒí•˜ë©° ê° ì›ì†Œ xë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

3.	temp ë°°ì—´ì—ì„œ ì´ë¶„ íƒìƒ‰ì„ ì´ìš©í•´ â€œxê°€ ì‚½ì…ë  ìœ„ì¹˜â€(idx)ë¥¼ ì°¾ìŠµë‹ˆë‹¤.

â€¢	tempê°€ ì˜¤ë¦„ì°¨ìˆœì„ ìœ ì§€í•˜ë„ë¡, xë¥¼ ì‚½ì…í•  ìœ„ì¹˜ëŠ”

â€œtemp[idx - 1] < x <= temp[idx]ë¥¼ ë§Œì¡±í•˜ëŠ” ê°€ì¥ ì‘ì€ idxâ€ ì…ë‹ˆë‹¤.

4.	ë§Œì•½ xê°€ temp ë°°ì—´ì—ì„œ ê°€ì¥ í° ê°’ë³´ë‹¤ í¬ë‹¤ë©´, ê·¸ëƒ¥ temp ë’¤ì— ë¶™ì…ë‹ˆë‹¤.

5.	ê·¸ë ‡ì§€ ì•Šë‹¤ë©´, ì´ë¶„ íƒìƒ‰ìœ¼ë¡œ ì°¾ì€ ìœ„ì¹˜ idxì— xë¥¼ ë®ì–´ì”ë‹ˆë‹¤.

6.	ìµœì¢…ì ìœ¼ë¡œ temp ê¸¸ì´ê°€ ê³§ â€œLIS(ê°€ì¥ ê¸´ ì¦ê°€ ë¶€ë¶„ ìˆ˜ì—´)ì˜ ê¸¸ì´â€ê°€ ë©ë‹ˆë‹¤.

ì˜ˆì‹œ ì½”ë“œ (Python)

```python
import sys
import bisect

input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

temp = []  # LISë¥¼ ë§Œë“¤ë©° ìœ ì§€í•˜ëŠ” ë°°ì—´

for x in A:
    # temp ë°°ì—´ì—ì„œ xê°€ ë“¤ì–´ê°ˆ ìœ„ì¹˜ ì°¾ê¸°
    # bisect_left: tempì—ì„œ xê°€ ì‚½ì…ë  ê°€ì¥ ì™¼ìª½ ì¸ë±ìŠ¤ë¥¼ ë¦¬í„´
    idx = bisect.bisect_left(temp, x)

    # xê°€ temp ë‚´ì˜ ëª¨ë“  ì›ì†Œë³´ë‹¤ í¬ë©´, temp ë’¤ì— ì¶”ê°€
    if idx == len(temp):
        temp.append(x)
    else:
        # ê·¸ ìœ„ì¹˜ì— xë¥¼ ë®ì–´ì¨ì„œ ì˜¤ë¦„ì°¨ìˆœ ìœ ì§€ë¥¼ ê³„ì†í•¨
        temp[idx] = x

print(len(temp))
```

â€¢	ì´ë ‡ê²Œ í•˜ë©´, tempì—ëŠ” ì‹¤ì œ LISê°€ ì™„ë²½íˆ ì €ì¥ë˜ì§€ ì•Šì„ ìˆ˜ ìˆì§€ë§Œ(â€œê¸¸ì´ë§Œâ€ ë§ìŒ), tempì˜ ê¸¸ì´ê°€ ê³§ LISì˜ ê¸¸ì´ê°€ ë©ë‹ˆë‹¤.

â€¢	ì‹œê°„ ë³µì¡ë„: O(N \log N). ìµœëŒ€ 1,000 ì •ë„ë¼ë©´ í›¨ì”¬ ë¹ ë¥´ê²Œ ë™ì‘í•©ë‹ˆë‹¤.

> ì¶”ê°€ í™•ì¥

ê²°ë¡  & ì¶”ì²œ

â€¢	ë¬¸ì œì—ì„œ ê¸¸ì´ë§Œ ìš”êµ¬í•œë‹¤ë©´, ìœ„ì— ì†Œê°œí•œ DP O(N^2) ë˜ëŠ” ì´ë¶„ íƒìƒ‰ O(N \log N) ë°©ì‹ì„ ì‚¬ìš©í•˜ì‹œë©´ ë©ë‹ˆë‹¤.

â€¢	Nì´ ìµœëŒ€ 1,000 ì •ë„ì´ë©´, **O(N^2)**ë„ ì¶©ë¶„íˆ ë¹ ë¦…ë‹ˆë‹¤. ê°€ì¥ êµ¬í˜„ì´ ê°„ë‹¨í•˜ë¯€ë¡œ DPë¥¼ ì¶”ì²œë“œë¦½ë‹ˆë‹¤.

â€¢	Nì´ ë” ì»¤ì§ˆ ìˆ˜ ìˆëŠ” ìƒí™©ì´ë¼ë©´(ì˜ˆ: N ìˆ˜ë§Œ~ìˆ˜ì‹­ë§Œ), ì´ë¶„ íƒìƒ‰ ë°©ì‹ì´ ìœ ë¦¬í•©ë‹ˆë‹¤.

í˜„ì¬ ì ‘ê·¼ì²˜ëŸ¼ â€œë¶€ë¶„ìˆ˜ì—´ ê¸¸ì´ë¥¼ ì´ì§„ íƒìƒ‰í•˜ë©´ì„œ, ë§¤ë²ˆ ì¬ê·€ë¡œ í™•ì¸â€í•˜ëŠ” ê²ƒì€

â€¢	êµ¬í˜„ ë‚œì´ë„ê°€ ë†’ê³ ,

â€¢	ì¤‘ë³µ ê³„ì‚°ì´ ë§ê³ ,

â€¢	ë””ë²„ê¹…ì´ ë³µì¡

í•˜ë¯€ë¡œ ì‹¤ì „ì—ì„œ ë¹„ì¶”ë˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

ì°¨ë¼ë¦¬ ì „í˜•ì ì¸ DP(ê¸¸ì´ O(N^2))ë‚˜ ì´ë¶„ íƒìƒ‰(ê¸¸ì´ O(N \log N))ë¡œ í•´ê²°í•˜ì‹œëŠ” ê²ƒì´ í›¨ì”¬ ì‰½ê³  ë¹ ë¦…ë‹ˆë‹¤.

ë„ì›€ì´ ë˜ê¸¸ ë°”ëë‹ˆë‹¤. í™”ì´íŒ…ì…ë‹ˆë‹¤!

# ìŠ¤íƒ: ë§‰ëŒ€ê¸°

https://www.acmicpc.net/problem/17608

ì•„ë˜ ê·¸ë¦¼ì²˜ëŸ¼ ë†’ì´ë§Œ ë‹¤ë¥´ê³  (ê°™ì€ ë†’ì´ì˜ ë§‰ëŒ€ê¸°ê°€ ìˆì„ ìˆ˜ ìˆìŒ) ëª¨ì–‘ì´ ê°™ì€ ë§‰ëŒ€ê¸°ë¥¼ ì¼ë ¬ë¡œ ì„¸ìš´ í›„, ì™¼ìª½ë¶€í„° ì°¨ë¡€ë¡œ ë²ˆí˜¸ë¥¼ ë¶™ì¸ë‹¤. ê° ë§‰ëŒ€ê¸°ì˜ ë†’ì´ëŠ” ê·¸ë¦¼ì—ì„œ ë³´ì¸ ê²ƒì²˜ëŸ¼ ìˆœì„œëŒ€ë¡œ 6, 9, 7, 6, 4, 6 ì´ë‹¤. ì¼ë ¬ë¡œ ì„¸ì›Œì§„ ë§‰ëŒ€ê¸°ë¥¼ ì˜¤ë¥¸ìª½ì—ì„œ ë³´ë©´ ë³´ì´ëŠ” ë§‰ëŒ€ê¸°ê°€ ìˆê³  ë³´ì´ì§€ ì•ŠëŠ” ë§‰ëŒ€ê¸°ê°€ ìˆë‹¤. ì¦‰, ì§€ê¸ˆ ë³´ì´ëŠ” ë§‰ëŒ€ê¸°ë³´ë‹¤ ë’¤ì— ìˆê³  ë†’ì´ê°€ ë†’ì€ ê²ƒì´ ë³´ì´ê²Œ ëœë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ê·¸ë¦¼ê³¼ ê°™ì€ ê²½ìš°ì—” 3ê°œ(6ë²ˆ, 3ë²ˆ, 2ë²ˆ)ì˜ ë§‰ëŒ€ê¸°ê°€ ë³´ì¸ë‹¤.

Nê°œì˜ ë§‰ëŒ€ê¸°ì— ëŒ€í•œ ë†’ì´ ì •ë³´ê°€ ì£¼ì–´ì§ˆ ë•Œ, ì˜¤ë¥¸ìª½ì—ì„œ ë³´ì•„ì„œ ëª‡ ê°œê°€ ë³´ì´ëŠ”ì§€ë¥¼ ì•Œì•„ë‚´ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ë ¤ê³  í•œë‹¤.

## Phase1. 15ë¶„, í•´ê²°.

```python
"""
1. ë¬¸ì œ ì½ê¸°
2. ë¬¸ì œ í’€ê¸°
ì°¨ë¡€ëŒ€ë¡œ ë§‰ëŒ€ê¸° í‘¸ì‹œí•˜ë‹¤ê°€ íƒ‘ë³´ë‹¤ í°ê²Œ ì˜¤ë©´ íŒí•˜ê³  í‘¸ì‹œí•˜ë©´ ë˜ê² ë‹¤.
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

class Stack:
    def __init__(self, size):
        self.stack = [0] * size
        self.ptr = 0

    class Empty(Exception):
        def __init__(self, message="Stack is empty"):
            self.message= message
            super().__init__(self.message)

    class Full(Exception):
        def __init__(self, message="Stack is full"):
            self.message = message
            super().__init__(self.message)

    def is_empty(self):
        return self.ptr == 0
    
    def is_full(self):
        return self.ptr == self.size

    def __str__(self):
        return f'{self.stack[:self.ptr]}'
    
    def clear(self):
        self.ptr = 0

    def peek(self):
        if self.is_empty(): raise Stack.Empty
        return self.stack[self.ptr-1]
    
    def push(self, n):
        if self.is_full(): raise Stack.Full
        self.stack[self.ptr] = n
        self.ptr += 1

    def pop(self):
        if self.is_empty(): raise Stack.Empty
        tmp = self.stack[self.ptr-1] 
        self.ptr -= 1
        return tmp
    
    def size(self):
        return self.ptr
    
import sys

stack = Stack(100_000)
n = int(sys.stdin.readline().strip())
for _ in range(n):
    stick = int(sys.stdin.readline().strip())
    # print(f'stack empty? {stack.is_empty()}')
    while not stack.is_empty() and stack.peek() <= stick:
        stack.pop() # ë½‘ì•„ë²„ë¦¬ê³ 
    stack.push(stick) # í‘¸ì‹œ
    # print(stack)


print(stack.size())
```

# ë¶„í• ì •ë³µ: ê³±ì…ˆ

https://www.acmicpc.net/problem/1629

ìì—°ìˆ˜ Aë¥¼ Bë²ˆ ê³±í•œ ìˆ˜ë¥¼ ì•Œê³  ì‹¶ë‹¤. ë‹¨ êµ¬í•˜ë ¤ëŠ” ìˆ˜ê°€ ë§¤ìš° ì»¤ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì´ë¥¼ Cë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ê³ ë¯¼ë§Œ í•˜ë‹¤ê°€ ì‹¤íŒ¨í•˜ê¸´ ì•„ê¹Œìš°ë‹ˆ ê³ ë¯¼ì˜ í”ì ì´ í•„ìš”. ì–´ì¨Œë“  ì‹¤íŒ¨.

í™”ì´íŠ¸ë³´ë“œì— ê³ ë¯¼í•˜ê³  ì‚¬ì§„ ì˜¬ë¦¬ì„¸ìš”. 30ë¶„ë™ì•ˆ.

![](./images/IMG_0453.png)

## Phase2.

ì•„ë§ˆ ë¬¸ì œë¥¼ ì½ë‹¤ê°€ **â€œAë¥¼ Bë²ˆ ê³±í•œ ë’¤ Cë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€â€**ë¥¼ ì§ì ‘ ê³„ì‚°í•˜ë©´ ìˆ˜ê°€ ë„ˆë¬´ ì»¤ì§ˆ ìˆ˜ ìˆìŒì„ ì¸ì§€í•˜ì…¨ì„ ê²ë‹ˆë‹¤.

ì´ ë¬¸ì œëŠ” í”íˆ ì•Œë ¤ì§„ â€œê±°ë“­ì œê³±ì„ ë¶„í•  ì •ë³µìœ¼ë¡œ ë¹ ë¥´ê²Œ ê³„ì‚° (Exponentiation by Squaring)â€ ê¸°ë²•ì„ ì‚¬ìš©í•˜ë©´ ì‰½ê²Œ í•´ê²° ê°€ëŠ¥í•©ë‹ˆë‹¤.

1. ë¬¸ì œ ìš”ì•½

â€¢	A^B (ì¦‰, Aë¥¼ Bë²ˆ ê³±í•œ ìˆ˜) ë¥¼ ì§ì ‘ êµ¬í•˜ë©´ ë§¤ìš° í´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

â€¢	ë”°ë¼ì„œ ì¤‘ê°„ ê³„ì‚° ê³¼ì •ì—ì„œë„ ê³„ì† mod C ì—°ì‚°ì„ ì ìš©í•´ ì¤„ í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.

â€¢	ì „í˜•ì ì¸ ë°©ë²•: ë¶„í•  ì •ë³µ(ì¬ê·€) í˜¹ì€ ë°˜ë³µë¬¸ì„ ì´ìš©í•œ ê±°ë“­ì œê³± ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

2. ë¶„í•  ì •ë³µì„ ì´ìš©í•œ ê±°ë“­ì œê³± ì•„ì´ë””ì–´

ê±°ë“­ì œê³± A^Bë¥¼ ê³„ì‚°í•  ë•Œ,

1.	Bê°€ ì§ìˆ˜:

$$
A^B = A^{B/2} \times A^{B/2}
$$

2.	Bê°€ í™€ìˆ˜:

$$
A^B = A \times A^{B-1}
$$

(í˜¹ì€ A^B = A^{(B-1)/2} \times A^{(B-1)/2} \times A)

ì¦‰, ì§€ìˆ˜ë¥¼ ì ˆë°˜ì”© ì¤„ì—¬ê°€ë©´ì„œ ê³„ì‚°í•˜ë˜, ë§¤ ë‹¨ê³„ì—ì„œ ê²°ê³¼ë¥¼ mod Cë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.

ì´ ê³¼ì •ì„ ì¬ê·€ í˜¹ì€ ë°˜ë³µë¬¸ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

3. íŒŒì´ì¬ ì½”ë“œ ì˜ˆì‹œ (ì¬ê·€)

```python
import sys
input = sys.stdin.readline

A, B, C = map(int, input().split())

def mod_pow(a, b, c):
    """ a^b % c ë¥¼ ë¶„í•  ì •ë³µìœ¼ë¡œ ê³„ì‚° """
    if b == 0:
        return 1  # a^0 = 1
    if b == 1:
        return a % c

    half = mod_pow(a, b // 2, c)
    half = (half * half) % c  # A^(b//2) * A^(b//2) = A^b (ì§ìˆ˜ì¼ ë•Œ)

    # bê°€ í™€ìˆ˜ì´ë©´, í•œ ë²ˆ ë” aë¥¼ ê³±í•´ì£¼ì–´ì•¼ í•¨
    if b % 2 == 1:
        half = (half * a) % c

    return half

print(mod_pow(A, B, C))
```

ì„¤ëª…

â€¢	mod_pow(a, b, c) í•¨ìˆ˜ê°€ ì¬ê·€ì ìœ¼ë¡œ bë¥¼ ë°˜ì”© ì¤„ì—¬ê°€ë©° a^bë¥¼ êµ¬í•©ë‹ˆë‹¤.

â€¢	ë§¤ ê³±ì…ˆë§ˆë‹¤ % cë¥¼ ì·¨í•´ ì¤Œìœ¼ë¡œì¨, ìˆ˜ê°€ ì»¤ì§€ëŠ” ê²ƒì„ ë°©ì§€í•©ë‹ˆë‹¤.

4. íŒŒì´ì¬ ì½”ë“œ ì˜ˆì‹œ (ë°˜ë³µë¬¸)

ì¬ê·€ ì—†ì´ ë°˜ë³µë¬¸ìœ¼ë¡œë„ ë¶„í•  ì •ë³µ í˜•íƒœë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ (ì´ ë°©ì‹ë„ ë§¤ìš° ì§ê´€ì ì…ë‹ˆë‹¤).

```python
import sys
input = sys.stdin.readline

A, B, C = map(int, input().split())

def mod_pow_iter(a, b, c):
    """ a^b % c ë¥¼ ë°˜ë³µë¬¸ í˜•íƒœë¡œ ê³„ì‚° """
    result = 1
    base = a % c  # a^1 (ì´ˆê¸°ê°’)

    while b > 0:
        if b % 2 == 1:
            # í™€ìˆ˜ ì§€ìˆ˜ë¼ë©´, ê²°ê³¼ì— í•œ ë²ˆ ë” ê³±í•´ì£¼ê¸°
            result = (result * base) % c
        # ì œê³±ìœ¼ë¡œ ë„˜ì–´ê°€ê¸°(ì§€ìˆ˜ ì ˆë°˜ìœ¼ë¡œ): a^(2k) = (a^k)^2
        base = (base * base) % c
        b //= 2

    return result

print(mod_pow_iter(A, B, C))
```

ì„¤ëª…

â€¢	ì§€ìˆ˜ bê°€ í™€ìˆ˜ì´ë©´, í˜„ì¬ baseë¥¼ resultì— ê³±í•´ì£¼ê³ , ì§€ìˆ˜ë¥¼ í•˜ë‚˜ ì¤„ì…ë‹ˆë‹¤ (b -= 1).

â€¢	ê·¸ ë’¤, baseë¥¼ ì œê³±(base = base * base)í•˜ê³  bë¥¼ ì ˆë°˜(b //= 2)ìœ¼ë¡œ ì¤„ì—¬ë‚˜ê°‘ë‹ˆë‹¤.

â€¢	ë§ˆì°¬ê°€ì§€ë¡œ ë§¤ ì—°ì‚°ë§ˆë‹¤ % cë¥¼ í•˜ì—¬ ì¤‘ê°„ ê²°ê³¼ê°€ ë„ˆë¬´ ì»¤ì§€ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤.

5. ì‹œê°„ ë³µì¡ë„

â€¢	ë¶„í•  ì •ë³µ ë°©ì‹ìœ¼ë¡œ ê±°ë“­ì œê³±ì„ ê³„ì‚°í•˜ë©´, ì§€ìˆ˜ Bì— ëŒ€í•´ O(\log B) ì‹œê°„ ì•ˆì— ê³„ì‚°ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

â€¢	ë¬¸ì œì˜ ì…ë ¥ ë²”ìœ„ì—ì„œ Bê°€ ë§¤ìš° ì»¤ë„, \log B ë‹¨ê³„ë§Œ ê±°ì¹˜ë¯€ë¡œ íš¨ìœ¨ì ìœ¼ë¡œ í’€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì •ë¦¬

1.	ì§ì ‘ A^Bë¥¼ êµ¬í•œ ë’¤ ëª¨ë“ˆë¡œë¥¼ ì·¨í•˜ë©´ ìˆ˜ê°€ ë„ˆë¬´ ì»¤ì„œ ê³„ì‚° ë¶ˆê°€ëŠ¥ or ë¹„íš¨ìœ¨ì .

2.	ë¶„í•  ì •ë³µì„ í†µí•´ ë§¤ ì¤‘ê°„ ë‹¨ê³„ë§ˆë‹¤ mod Cë¥¼ ì ìš©í•´ì„œ ì²˜ë¦¬í•´ì•¼ í•¨.

3.	êµ¬í˜„ì€ ë‘ ê°€ì§€ ë°©ë²•:

â€¢	ì¬ê·€(ë°˜ë°˜ì”© ì¤„ì´ë©´ì„œ)

â€¢	ë°˜ë³µë¬¸(ì§€ìˆ˜ë¥¼ 2ë¡œ ë‚˜ëˆ„ë©° ë¹„íŠ¸ ë¶„í• )

4.	ì‹œê°„ ë³µì¡ë„ëŠ” O(\log B).

ì´ ë¡œì§ëŒ€ë¡œ ì½”ë“œë¥¼ ì§§ê²Œ êµ¬í˜„í•˜ë©´ ë°”ë¡œ ì •ë‹µì„ ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë¶„í•  ì •ë³µ ê±°ë“­ì œê³±ì€ ë‹¤ì–‘í•œ ë¬¸ì œì—ì„œ ìœ ìš©í•˜ë‹ˆ, í•œ ë²ˆ ìµí˜€ ë‘ì‹œë©´ ì¢‹ìŠµë‹ˆë‹¤.

í™”ì´íŒ…ì…ë‹ˆë‹¤!

# ë¶„í• ì •ë³µ: íˆìŠ¤í† ê·¸ë¨ì—ì„œ ê°€ì¥ í° ì§ì‚¬ê°í˜•(ì‹¤íŒ¨)

https://www.acmicpc.net/problem/6549

## Phase1. êµ¬í˜„ ì‹¤íŒ¨

```python
"""
1. ë¬¸ì œ ì½ê¸°
ì´í•´ ìì²´ëŠ” ì–´ë µì§€ ì•ŠìŒ.
2. ë¬¸ì œ í’€ê¸°
ë¶„í• ì •ë³µì˜ ë°©ë²•ë¡ ì„ ìœ ë„í•  ê²ƒ. 
Phase1. ìœ ë„(ìœ ì‚¬í•œ ë¬¸ì œ ë– ì˜¬ë ¤ë³´ê¸°)
- ìƒ‰ì¢…ì´? Zë¬¸ì œ?: 2^n ê¸¸ì´ì˜ ì •ì‚¬ê°í˜•ì„ ë‹¤ë£¨ëŠ” ë¬¸ì œë“¤ê³¼ëŠ”, ì§ì‚¬ê°í˜•ì„ ë‹¤ë£¬ë‹¤ëŠ” ì ì—ì„œ ì¢€ ë‹¤ë¦„
ì£¼ì–´ì§€ëŠ” ë°ì´í„°ë„ ì„ í˜•. nì˜ ë²”ìœ„ê°€ 100,000ìœ¼ë¡œ ë§ì§€ëŠ” ì•Šì€ë°, ì£¼ì–´ì§€ëŠ” ì •ìˆ˜ê°€ ìœ„ ë¬¸ì œë³´ë‹¤ í¼
- ë³‘í•© ì •ë ¬: ì‚¬ì‹¤ ê·¼ë³¸ì ìœ¼ë¡œ ë¹„ìŠ·í•˜ê² ì§€? ì–´ë–»ê²Œ ë¹„ìŠ·í•˜ë ¤ë‚˜. 
base case: ì‚¬ê°í˜•ì„ ë‚˜ëˆ„ë‹¤ê°€ ë‘ ê°œê°€ ë‚¨ì•„ì„œ, ìƒìˆ˜ ì‹œê°„ ì•ˆì— ë¬¸ì œ í•´ê²°ì´ ê°€ëŠ¥í•œ ì‹œì 
recursion case: ì£¼ì–´ì§„ íˆìŠ¤í† ê·¸ë¨ ë¶€ë¶„ì— ëŒ€í•´ ì–‘ìª½ íˆìŠ¤í† ê·¸ë¨ì—ì„œ êµ¬í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ì‚¬ê°í˜•
ì´ê±´ ë‹¹ì—°íˆ, ì–‘ìª½ì˜ ì‚¬ê°í˜• í¬ê¸°ë¥¼ ë¹„êµí–ˆì„ ë•Œ ìµœì†Œ ì‚¬ê°í˜• ê°’ì„ ë¦¬í„´í•´ì•¼ í•œë‹¤. 
ì¢…ì´ì— ë¨¼ì € í’€ì–´ë³´ì‹œê¸¸. ë‚´ê°€ ë´¤ì„ ë• ë³‘í•©ì •ë ¬í•˜ê³  ë˜ê²Œ ë¹„ìŠ·í•¨
Phase2. ë¬¸ì œ ì •ì˜
- ê¸°ë³¸ ë¬¸ì œ: ì „ì²´ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°
- ë¶€ë¬¸ì œ: ë¶€ë¶„ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°
- ë² ì´ìŠ¤ ì¼€ì´ìŠ¤: ë‘ íˆìŠ¤í† ê·¸ë¨ì—ì„œ ì œì¼ í° ì§ì‚¬ê°í˜• ì°¾ê¸°: ë¬´ì¡°ê±´ ë‘ ì§ì‚¬ê°í˜•ì„ í•©ì¹  í•„ìš”ëŠ” ì—†ìŒ!
Phase3. ì–´ë””ì„œ ë§‰í˜”ëŠ”ê°€? 
ë¶„í•  ì •ë³µì—ì„œ ì •ë³µ, ë³‘í•© ë‹¨ê³„ë¥¼ ì–´ë–»ê²Œ í•´ì•¼í• ì§€ ëª¨ë¥´ê² ìŒ.

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

```

### ì ‘ë§‰

ì ‘ê·¼ ë°©ë²•: ë³‘í•©ì •ë ¬

ë§‰íŒ ì´ìœ : ë¬¸ì œ ì •ì˜ ì‹¤íŒ¨. ì •ë³µ, ë³‘í•© ë‹¨ê³„ë¥¼ ì–´ë–»ê²Œ í•´ì•¼í• ì§€ ëª¨ë¥´ê² ìŒ.

## Phase2. í”¼ë“œë°±

ì´ ë¬¸ì œ **â€œíˆìŠ¤í† ê·¸ë¨ì—ì„œ ê°€ì¥ í° ì§ì‚¬ê°í˜•â€**ì€ ì•Œê³ ë¦¬ì¦˜ êµìœ¡ì—ì„œ ë§¤ìš° ìì£¼ ë“±ì¥í•˜ëŠ” ê³ ì „ ë¬¸ì œë¡œ, ì„¸ ê°€ì§€ ëŒ€í‘œ í’€ì´ê°€ ì¡´ì¬í•©ë‹ˆë‹¤.

1.	ë¶„í•  ì •ë³µ(Divide and Conquer) : O(N \log N)

2.	ì„ í˜• ìŠ¤íƒ(ëª¨ë…¸í† ë‹‰ ìŠ¤íƒ) : O(N)

3.	ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ : O(N \log N)

ì¶œì œ ì˜ë„ê°€ â€œë¶„í• ì •ë³µâ€ì´ë¼ë©´ 1ë²ˆ í˜¹ì€ 3ë²ˆ(ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬)ìœ¼ë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆì§€ë§Œ,

ì‹¤ë¬´ë‚˜ ëŒ€íšŒì—ì„œëŠ” ë³´í†µ 2ë²ˆ(ìŠ¤íƒ) ë°©ì‹ì´ ê°€ì¥ ê°„ë‹¨í•˜ë©´ì„œ ë¹ ë¥´ë‹¤ëŠ” íŠ¹ì§•ì´ ìˆìŠµë‹ˆë‹¤.

ì•„ë˜ì—ì„œëŠ” ë¶„í•  ì •ë³µìœ¼ë¡œ í•´ê²°í•˜ëŠ” ë°©ë²•ê³¼, ì‹¤ì œë¡œ ë” ìì£¼ ì“°ì´ëŠ” ìŠ¤íƒ í’€ì´ë¥¼ ëª¨ë‘ ê°„ë‹¨íˆ ì†Œê°œí•´ ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

1. ë¶„í•  ì •ë³µ(Divide & Conquer) í’€ì´

1.1 ì•Œê³ ë¦¬ì¦˜ ì•„ì´ë””ì–´

ê¸¸ì´ Nì˜ íˆìŠ¤í† ê·¸ë¨ ë†’ì´ ë°°ì—´ì„ H[0..N-1]ë¼ í•©ì‹œë‹¤.

ë¶„í•  ì •ë³µ ì ‘ê·¼ ì‹œ, ë‹¤ìŒê³¼ ê°™ì´ ì„¸ ê°€ì§€ ê²½ìš°ë¥¼ ê³ ë ¤í•©ë‹ˆë‹¤.

1.	ì™¼ìª½ êµ¬ê°„ì—ì„œì˜ ìµœëŒ€ ì§ì‚¬ê°í˜•

â€¢	(êµ¬ê°„ left ~ midë¡œ ì œí•œí•˜ì—¬, ì¬ê·€ì ìœ¼ë¡œ êµ¬í•¨)

2.	ì˜¤ë¥¸ìª½ êµ¬ê°„ì—ì„œì˜ ìµœëŒ€ ì§ì‚¬ê°í˜•

â€¢	(êµ¬ê°„ mid+1 ~ rightë¡œ ì œí•œí•˜ì—¬, ì¬ê·€ì ìœ¼ë¡œ êµ¬í•¨)

3.	ê°€ìš´ë°(mid)ë¥¼ ê±¸ì¹˜ëŠ” ì§ì‚¬ê°í˜•ì—ì„œì˜ ìµœëŒ€ ë„“ì´

â€¢	(ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ì‚¬ì´ ê²½ê³„ì—ì„œ ì‹œì‘í•´, ì–‘ì˜†ìœ¼ë¡œ í™•ì¥í•´ê°€ë©° ê°€ëŠ¥í•œ ìµœëŒ€ ì§ì‚¬ê°í˜•ì„ ì°¾ìŒ)

ì´ë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•´, ë³´í†µ ì¬ê·€ í•¨ìˆ˜ get_max_area(left, right)ë¥¼ ë‘ê³ ,

1.	ì¢…ë£Œ ì¡°ê±´(Base case): left == right â†’ ë§‰ëŒ€ê°€ í•˜ë‚˜ë¿ì´ë¯€ë¡œ ë„“ì´ëŠ” H[left] (í­=1, ë†’ì´=H[left])

2.	ë¶„í• : mid = (left + right) // 2

â€¢	ì™¼ìª½ ìµœëŒ€ ë„“ì´: left_area = get_max_area(left, mid)

â€¢	ì˜¤ë¥¸ìª½ ìµœëŒ€ ë„“ì´: right_area = get_max_area(mid+1, right)

3.	ì •ë³µ(ê°€ìš´ë° ê±¸ì¹˜ëŠ” ë„“ì´ ê³„ì‚°)

â€¢	ë¨¼ì € midì™€ mid+1 ë‘ ìœ„ì¹˜ë¥¼ í¬í•¨í•˜ëŠ” â€œí­=2, ë†’ì´=min(H[mid], H[mid+1])â€ ì§ì‚¬ê°í˜•ì—ì„œ ì‹œì‘í•´,

â€¢	ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë²”ìœ„ë¥¼ í™•ì¥í•˜ë©´ì„œ, ê°€ëŠ¥í•œ í•œ ë†’ì´ê°€ í° ìƒíƒœë¥¼ ìœ ì§€í•´ ìµœëŒ€ í­ì„ ëŠ˜ë ¤ê°‘ë‹ˆë‹¤.

â€¢	ê³¼ì • ì¤‘ ë§¤ë²ˆ í˜„ì¬_í­ * í˜„ì¬_êµ¬ê°„ì˜_ìµœì†Œë†’ì´ë¡œ ë„“ì´ë¥¼ ê³„ì‚°í•˜ë©° ìµœëŒ€ê°’ì„ ê°±ì‹ í•©ë‹ˆë‹¤.

ë§ˆì§€ë§‰ì—, max(left_area, right_area, cross_area) ì¤‘ ìµœëŒ“ê°’ì´ get_max_area(left, right)ì˜ ê²°ê³¼ê°€ ë©ë‹ˆë‹¤.

1.2 ë¶„í• ì •ë³µ ì½”ë“œ ì˜ˆì‹œ (íŒŒì´ì¬)

ì•„ë˜ ì½”ë“œëŠ” ì¬ê·€ë¡œ êµ¬í˜„í•œ ì˜ˆì‹œì´ë©°, ì…ë ¥ ì²˜ë¦¬ê°€ ë§¤ìš° ë§ìœ¼ë¯€ë¡œ(ë°ì´í„° ìˆ˜ê°€ ìµœëŒ€ 100,000) ë¹ ë¥¸ ì…ì¶œë ¥ì— ì‹ ê²½ ì¨ì•¼ í•©ë‹ˆë‹¤.

```plain text
import sys
input = sys.stdin.readline

def get_max_area(hist, left, right):
    # íˆìŠ¤í† ê·¸ë¨ êµ¬ê°„ì´ 1ì¹¸ì´ë©´, ë„“ì´ëŠ” ë§‰ëŒ€ì˜ ë†’ì´
    if left == right:
        return hist[left]

    mid = (left + right) // 2

    # 1. ì™¼ìª½ êµ¬ê°„ ìµœëŒ€ ì§ì‚¬ê°í˜•
    left_area = get_max_area(hist, left, mid)
    # 2. ì˜¤ë¥¸ìª½ êµ¬ê°„ ìµœëŒ€ ì§ì‚¬ê°í˜•
    right_area = get_max_area(hist, mid+1, right)

    # 3. ê°€ìš´ë°ë¥¼ ê±¸ì¹˜ëŠ” ì§ì‚¬ê°í˜• (cross area) ê³„ì‚°
    # ë¨¼ì € mid, mid+1 ë‘ ì¹¸ì„ í¬í•¨ (í­=2)
    cross_left = mid
    cross_right = mid + 1
    min_height = min(hist[cross_left], hist[cross_right])

    # cross_area(í˜„ì¬ í­ 2ì¸ ì§ì‚¬ê°í˜•ì˜ ë„“ì´)
    cross_area = min_height * 2

    # ì™¼ìª½, ì˜¤ë¥¸ìª½ìœ¼ë¡œ í™•ì¥
    # ë” í™•ì¥í•  ìˆ˜ ìˆëŠ” ë™ì•ˆ í™•ì¥í•˜ë©° ìµœëŒ€ ë„“ì´ ê°±ì‹ 
    while left < cross_left or cross_right < right:
        # ì™¼ìª½ìœ¼ë¡œ í™•ì¥í•˜ëŠ” ê²½ìš°
        # ì˜¤ë¥¸ìª½ìœ¼ë¡œ í™•ì¥í•˜ëŠ” ê²½ìš°
        # ë‘˜ ì¤‘ ì–´ëŠ ìª½ì´ ë” ë†’ì´ ë³´ì¡´ì— ì´ë“ì´ ë  ì§€ë¥¼ íŒë‹¨ -> ë†’ì´ê°€ ë” í° ìª½ìœ¼ë¡œ í™•ì¥
        if cross_right < right and (cross_left == left or hist[cross_left - 1] < hist[cross_right + 1]):
            cross_right += 1
            min_height = min(min_height, hist[cross_right])
        else:
            cross_left -= 1
            min_height = min(min_height, hist[cross_left])

        # ìƒˆë¡œ í™•ì¥ëœ í­ë§Œí¼ ë„“ì´ë¥¼ ê³„ì‚°
        curr_width = (cross_right - cross_left + 1)
        cross_area = max(cross_area, min_height * curr_width)

    # ì„¸ ê°’ ì¤‘ ìµœëŒ“ê°’ ë°˜í™˜
    return max(left_area, right_area, cross_area)

def solve():
    while True:
        # ì…ë ¥: n h1 h2 ...
        line = list(map(int, input().split()))
        if line[0] == 0:  # í…ŒìŠ¤íŠ¸ ì¢…ë£Œ
            break

        n = line[0]
        hist = line[1:]
        print(get_max_area(hist, 0, n-1))

if __name__ == "__main__":
    solve()
```

ì£¼ì˜

â€¢	while left < cross_left or cross_right < right: ë¶€ë¶„ì—ì„œ, ì™¼ìª½/ì˜¤ë¥¸ìª½ ì–´ëŠ ìª½ìœ¼ë¡œ í™•ì¥í• ì§€ ê²°ì •í•˜ëŠ” ë¡œì§ì´ í•µì‹¬ì…ë‹ˆë‹¤.

â€¢	êµ¬í˜„ì´ ë‹¤ì†Œ ê¹Œë‹¤ë¡œìš´ í¸ì´ë¼, ì½”ë“œë¥¼ ì§¤ ë•Œ ì¸ë±ìŠ¤ ë²”ìœ„ ë° ìµœì†Œ ë†’ì´ ê°±ì‹ ì„ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤.

â€¢	ë¶„í• ì •ë³µ ì•Œê³ ë¦¬ì¦˜ì€ O(N \log N) í‰ê·  ë³µì¡ë„ë¥¼ ê°€ì§€ì§€ë§Œ, êµ¬í˜„ ë‚œì´ë„ê°€ ë¹„êµì  ë†’ì€ í¸ì…ë‹ˆë‹¤.

2. ì„ í˜• ìŠ¤íƒ(Monotonic Stack) í’€ì´ (ì‹¤ì „ì—ì„œ ë” ìì£¼ ì‚¬ìš©)

ë¶„í• ì •ë³µ ë°©ì‹ë„ ì¢‹ì§€ë§Œ, ì´ ë¬¸ì œëŠ” ìŠ¤íƒì„ ì´ìš©í•œ O(N) í•´ë²•ì´ ë” ì¼ë°˜ì ìœ¼ë¡œ ì•Œë ¤ì ¸ ìˆìŠµë‹ˆë‹¤.

ê°€ë ¹ ë°±ì¤€ 6549ë²ˆ ë¬¸ì œ í’€ì´ì—ì„œëŠ” ëŒ€ë¶€ë¶„ ì´ ìŠ¤íƒ ë°©ì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

2.1 ì•Œê³ ë¦¬ì¦˜ ì•„ì´ë””ì–´

1.	ë§‰ëŒ€ì˜ ì¸ë±ìŠ¤ë¥¼ ë‹´ëŠ” ìŠ¤íƒì„ í•˜ë‚˜ ë‘¡ë‹ˆë‹¤. ì´ ìŠ¤íƒì€ **â€˜í˜„ì¬ê¹Œì§€ ì˜¤ë¦„ì°¨ìˆœ(ë˜ëŠ” ë¹„ê°ì†Œ)â€™**ìœ¼ë¡œ ë§‰ëŒ€ê°€ ì •ë ¬ë˜ë„ë¡ ì¸ë±ìŠ¤ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.

2.	ì™¼ìª½ë¶€í„° ë§‰ëŒ€ë¥¼ í•˜ë‚˜ì”© ë³´ë©´ì„œ,

â€¢	ìŠ¤íƒì´ ë¹„ì–´ ìˆìœ¼ë©´ push

â€¢	ìŠ¤íƒì´ ë¹„ì–´ ìˆì§€ ì•Šë‹¤ë©´, â€œìƒˆ ë§‰ëŒ€ì˜ ë†’ì´ê°€ ìŠ¤íƒ topì— ìˆëŠ” ë§‰ëŒ€ ë†’ì´ë³´ë‹¤ ì‘ì„ ë•Œâ€ ìŠ¤íƒ topì—ì„œ popì„ í•©ë‹ˆë‹¤.

ì´ ë•Œ, popëœ ë§‰ëŒ€ê°€ **â€˜í˜„ì¬ê¹Œì§€ íƒìƒ‰í•œ êµ¬ê°„ì—ì„œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ ë„“ì€ ì§ì‚¬ê°í˜• ì¤‘ í•˜ë‚˜â€™**ë¥¼ í˜•ì„±í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

â€¢	popë  ë•Œë§ˆë‹¤, **â€œpopëœ ë§‰ëŒ€ì˜ ë†’ì´â€ x â€œë„ˆë¹„â€**ë¥¼ ê³„ì‚°í•´ ë„“ì´ë¥¼ ê°±ì‹ í•©ë‹ˆë‹¤.

â€¢	ì—¬ê¸°ì„œ ë„ˆë¹„ëŠ” â€œí˜„ì¬ ì¸ë±ìŠ¤ - pop í›„ ìŠ¤íƒì˜ ìƒˆ top - 1â€ (ìŠ¤íƒì´ ë¹„ë©´ ì „ì²´ê°€ ë„ˆë¹„)

3.	ëª¨ë“  ë§‰ëŒ€ë¥¼ ì²˜ë¦¬í•œ ë’¤ì—ë„, ìŠ¤íƒì— ë‚¨ì•„ ìˆëŠ” ë§‰ëŒ€ë“¤ì— ëŒ€í•´ì„œ ë˜‘ê°™ì´ popì„ ë°˜ë³µí•˜ë©° ë„“ì´ë¥¼ ê°±ì‹ í•©ë‹ˆë‹¤.

2.2 ìŠ¤íƒ í’€ì´ ì½”ë“œ ì˜ˆì‹œ (íŒŒì´ì¬)

ìŠ¤íƒ í’€ì´ê°€ í˜„ì—…/ëŒ€íšŒì—ì„œ ë” ê°„ë‹¨í•˜ê³  ë¹ ë¥´ë¯€ë¡œ, ë°±ì¤€ 6549 í’€ì´ ì˜ˆì‹œë¡œ ìì£¼ ë“±ì¥í•©ë‹ˆë‹¤.

```plain text
import sys
input = sys.stdin.readline

def solve():
    while True:
        line = list(map(int, input().split()))
        n = line[0]
        if n == 0:
            break

        heights = line[1:]  # íˆìŠ¤í† ê·¸ë¨ ë†’ì´

        stack = []
        max_area = 0

        for i, h in enumerate(heights):
            # ìƒˆë¡œìš´ ë§‰ëŒ€ê°€ ìŠ¤íƒ topë³´ë‹¤ ì‘ìœ¼ë©´ popí•˜ë©´ì„œ ë„“ì´ ê³„ì‚°
            while stack and heights[stack[-1]] > h:
                height_idx = stack.pop()
                height = heights[height_idx]

                if stack:
                    width = i - stack[-1] - 1
                else:
                    width = i

                max_area = max(max_area, height * width)

            stack.append(i)

        # ëê¹Œì§€ ëŒê³  ë‚˜ì„œ ìŠ¤íƒì— ë‚¨ì•„ ìˆëŠ” ë§‰ëŒ€ ì²˜ë¦¬
        i = n
        while stack:
            height_idx = stack.pop()
            height = heights[height_idx]

            if stack:
                width = i - stack[-1] - 1
            else:
                width = i

            max_area = max(max_area, height * width)

        print(max_area)

if __name__ == '__main__':
    solve()
```

ì‹œê°„ ë³µì¡ë„

â€¢	ê° ë§‰ëŒ€ê°€ ìŠ¤íƒì— í•œ ë²ˆ pushë˜ê³ , í•œ ë²ˆ popë˜ë¯€ë¡œ ì´ ì—°ì‚° íšŸìˆ˜ëŠ” O(N).

3. ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬(ì„¸ê·¸ë¨¼íŠ¸ + ìµœì†Ÿê°’ ì¸ë±ìŠ¤) í’€ì´

1.	ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ì— ê° êµ¬ê°„ì˜ â€œìµœì†Ÿê°’ì˜ ì¸ë±ìŠ¤â€ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.

2.	â€œêµ¬ê°„ ë‚´ì—ì„œ ê°€ì¥ ë‚®ì€ ë§‰ëŒ€â€ë¥¼ ê¸°ì¤€ìœ¼ë¡œ, í•´ë‹¹ ë§‰ëŒ€ë¥¼ í¬í•¨í•˜ëŠ” ìµœëŒ€ ì‚¬ê°í˜•ì„ êµ¬í•©ë‹ˆë‹¤(ì´ ë§‰ëŒ€ì˜ ë†’ì´ \times êµ¬ê°„ ê¸¸ì´).

3.	ë” ë‚®ì€ ë§‰ëŒ€ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ êµ¬ê°„, ì˜¤ë¥¸ìª½ êµ¬ê°„ì„ ë¶„í• ì •ë³µ í˜•íƒœë¡œ ì¬ê·€ ì²˜ë¦¬.

4.	ìµœì†Œ ë†’ì´ ì¸ë±ìŠ¤ë¥¼ O(1)ì— ê°€ì ¸ì˜¤ë ¤ë©´ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ or ìŠ¤íŒŒìŠ¤ í…Œì´ë¸” RMQ(Range Minimum Query) ì‚¬ìš©.

5.	ì „ì²´ ì•Œê³ ë¦¬ì¦˜ì€ O(N \log N)ì´ ë©ë‹ˆë‹¤.

ì´ ë°©ë²•ë„ ê°€ëŠ¥í•˜ì§€ë§Œ, êµ¬í˜„ ë‚œì´ë„ê°€ ë†’ì•„ì„œ ì‹¤ì „ì—ì„œëŠ” ì˜ ì“°ì§€ ì•ŠìŠµë‹ˆë‹¤.

4. ê²°ë¡  ë° ì¶”ì²œ

â€¢	ë¶„í•  ì •ë³µ(Divide & Conquer): O(N \log N)

â€¢	ì¬ê·€ êµ¬í˜„ì´ ê°€ëŠ¥í•˜ë©° ì•„ì´ë””ì–´ê°€ ì§ê´€ì ì´ì§€ë§Œ, ì–‘ì˜† í™•ì¥ ë¡œì§ì´ ê¹Œë‹¤ë¡­ìŠµë‹ˆë‹¤.

â€¢	ìŠ¤íƒ í’€ì´(Monotonic Stack): O(N)

â€¢	ëŒ€ë¶€ë¶„ì˜ ì½”ë”© í…ŒìŠ¤íŠ¸ ë° ì‹¤ë¬´ êµ¬í˜„ì—ì„œëŠ” ìŠ¤íƒ ë°©ì‹ì´ ë” ê°„ë‹¨í•˜ê³  ë¹ ë¥´ê²Œ êµ¬í˜„ ê°€ëŠ¥í•˜ë©°, ì‹œê°„ ë³µì¡ë„ë„ **ë” ìš°ìˆ˜(O(N))**í•©ë‹ˆë‹¤.

â€¢	ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ + RMQ: O(N \log N), êµ¬í˜„ì€ ë³µì¡.

ì‹¤ì „ì—ì„œëŠ” ìŠ¤íƒ í’€ì´ê°€ ê±°ì˜ í‘œì¤€ìœ¼ë¡œ ì“°ì¸ë‹¤ê³  ë³´ì‹œë©´ ë©ë‹ˆë‹¤.

í•˜ì§€ë§Œ ë¬¸ì œì—ì„œ ë¶„í• ì •ë³µìœ¼ë¡œ í’€ë¼ê³  í–ˆë‹¤ë©´, ìœ„ì˜ ë¶„í• ì •ë³µ ì ‘ê·¼ì„ ì²œì²œíˆ êµ¬í˜„í•´ë³´ëŠ” ê²½í—˜ë„ í° ë„ì›€ì´ ë  ê²ƒì…ë‹ˆë‹¤.

ë„ì›€ì´ ë˜ê¸¸ ë°”ëë‹ˆë‹¤! ì§ˆë¬¸ ìˆìœ¼ì‹œë©´ ì–¸ì œë“  ë‚¨ê²¨ì£¼ì„¸ìš”. í™”ì´íŒ…ì…ë‹ˆë‹¤.

# ìŠ¤íƒ: íƒ‘

https://www.acmicpc.net/problem/2493

KOI í†µì‹ ì—°êµ¬ì†ŒëŠ” ë ˆì´ì €ë¥¼ ì´ìš©í•œ ìƒˆë¡œìš´ ë¹„ë°€ í†µì‹  ì‹œìŠ¤í…œ ê°œë°œì„ ìœ„í•œ ì‹¤í—˜ì„ í•˜ê³  ìˆë‹¤. ì‹¤í—˜ì„ ìœ„í•˜ì—¬ ì¼ì§ì„  ìœ„ì— Nê°œì˜ ë†’ì´ê°€ ì„œë¡œ ë‹¤ë¥¸ íƒ‘ì„ ìˆ˜í‰ ì§ì„ ì˜ ì™¼ìª½ë¶€í„° ì˜¤ë¥¸ìª½ ë°©í–¥ìœ¼ë¡œ ì°¨ë¡€ë¡œ ì„¸ìš°ê³ , ê° íƒ‘ì˜ ê¼­ëŒ€ê¸°ì— ë ˆì´ì € ì†¡ì‹ ê¸°ë¥¼ ì„¤ì¹˜í•˜ì˜€ë‹¤. ëª¨ë“  íƒ‘ì˜ ë ˆì´ì € ì†¡ì‹ ê¸°ëŠ” ë ˆì´ì € ì‹ í˜¸ë¥¼ ì§€í‘œë©´ê³¼ í‰í–‰í•˜ê²Œ ìˆ˜í‰ ì§ì„ ì˜ ì™¼ìª½ ë°©í–¥ìœ¼ë¡œ ë°œì‚¬í•˜ê³ , íƒ‘ì˜ ê¸°ë‘¥ ëª¨ë‘ì—ëŠ” ë ˆì´ì € ì‹ í˜¸ë¥¼ ìˆ˜ì‹ í•˜ëŠ” ì¥ì¹˜ê°€ ì„¤ì¹˜ë˜ì–´ ìˆë‹¤. í•˜ë‚˜ì˜ íƒ‘ì—ì„œ ë°œì‚¬ëœ ë ˆì´ì € ì‹ í˜¸ëŠ” ê°€ì¥ ë¨¼ì € ë§Œë‚˜ëŠ” ë‹¨ í•˜ë‚˜ì˜ íƒ‘ì—ì„œë§Œ ìˆ˜ì‹ ì´ ê°€ëŠ¥í•˜ë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ ë†’ì´ê°€ 6, 9, 5, 7, 4ì¸ ë‹¤ì„¯ ê°œì˜ íƒ‘ì´ ìˆ˜í‰ ì§ì„ ì— ì¼ë ¬ë¡œ ì„œ ìˆê³ , ëª¨ë“  íƒ‘ì—ì„œëŠ” ì£¼ì–´ì§„ íƒ‘ ìˆœì„œì˜ ë°˜ëŒ€ ë°©í–¥(ì™¼ìª½ ë°©í–¥)ìœ¼ë¡œ ë™ì‹œì— ë ˆì´ì € ì‹ í˜¸ë¥¼ ë°œì‚¬í•œë‹¤ê³  í•˜ì. ê·¸ëŸ¬ë©´, ë†’ì´ê°€ 4ì¸ ë‹¤ì„¯ ë²ˆì§¸ íƒ‘ì—ì„œ ë°œì‚¬í•œ ë ˆì´ì € ì‹ í˜¸ëŠ” ë†’ì´ê°€ 7ì¸ ë„¤ ë²ˆì§¸ íƒ‘ì´ ìˆ˜ì‹ ì„ í•˜ê³ , ë†’ì´ê°€ 7ì¸ ë„¤ ë²ˆì§¸ íƒ‘ì˜ ì‹ í˜¸ëŠ” ë†’ì´ê°€ 9ì¸ ë‘ ë²ˆì§¸ íƒ‘ì´, ë†’ì´ê°€ 5ì¸ ì„¸ ë²ˆì§¸ íƒ‘ì˜ ì‹ í˜¸ë„ ë†’ì´ê°€ 9ì¸ ë‘ ë²ˆì§¸ íƒ‘ì´ ìˆ˜ì‹ ì„ í•œë‹¤. ë†’ì´ê°€ 9ì¸ ë‘ ë²ˆì§¸ íƒ‘ê³¼ ë†’ì´ê°€ 6ì¸ ì²« ë²ˆì§¸ íƒ‘ì´ ë³´ë‚¸ ë ˆì´ì € ì‹ í˜¸ëŠ” ì–´ë–¤ íƒ‘ì—ì„œë„ ìˆ˜ì‹ ì„ í•˜ì§€ ëª»í•œë‹¤.

íƒ‘ë“¤ì˜ ê°œìˆ˜ Nê³¼ íƒ‘ë“¤ì˜ ë†’ì´ê°€ ì£¼ì–´ì§ˆ ë•Œ, ê°ê°ì˜ íƒ‘ì—ì„œ ë°œì‚¬í•œ ë ˆì´ì € ì‹ í˜¸ë¥¼ ì–´ëŠ íƒ‘ì—ì„œ ìˆ˜ì‹ í•˜ëŠ”ì§€ë¥¼ ì•Œì•„ë‚´ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ë¼.

## Phase1. í’€ì´ ì„±ê³µ. 

í•œ 45ë¶„ ê±¸ë¦°ë“¯.

```python
"""
1. ë¬¸ì œ ì½ê¸°: íƒ‘ ë²ˆí˜¸ëŠ” 1 based.
2. ë¬¸ì œ í’€ê¸°
ìŠ¤íƒì„ ì¨ì„œ...ë‹¹ì—°íˆ... 
íŒì„ í•œ ë‹¤ìŒ, ìˆœíšŒë¥¼ í•˜ë©´ì„œ ë‚˜ëª¨ë‹¤ í° ì• ë¥¼ ë§Œë‚ ë•Œê¹Œì§€ ì¸ë±ìŠ¤ ê°ì†Œ?
ë” ìŠ¤íƒ ë…¼ë¦¬ë¥¼ í™œìš©í•  ìˆ˜ ìˆì„ ê±° ê°™ì€ë°.
íŒì„ í•˜ê³ 
6 9 5 7 4
íŒì„ í•œ ë‹¤ìŒ ê±”ë“¤ì„ ë‹¤ë¥¸ ìŠ¤íƒì— ì°¨ë¡€ë¡œ ì €ì¥í•˜ê³ , 
ë§Œì•½ íŒ ìš”ì†Œê°€ ê°ì†Œì„¸ë¥¼ ë³´ì´ë©´ ì­‰ ê°€ë‹¤ê°€
ì¦ê°€ì„¸ë¥¼ ë³´ì´ë©´? ë¹„êµí•´ì„œ ë°˜ëŒ€ìª½ì—ì„œ íŒí•´ì„œ ì¸ë±ìŠ¤ë¥¼ ì •í•˜ë©´ ë˜ë‚˜? 


3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

class Stack:
    def __init__(self, size):
        self.stack = [0] * size
        self.ptr = 0

    class Empty(Exception):
        def __init__(self, message="Stack is empty"):
            self.message= message
            super().__init__(self.message)

    class Full(Exception):
        def __init__(self, message="Stack is full"):
            self.message = message
            super().__init__(self.message)


    def is_empty(self):
        return self.ptr == 0
    
    def is_full(self):
        return self.ptr == self.size

    def __str__(self):
        return f'{self.stack[:self.ptr]}'
    
    def clear(self):
        self.ptr = 0

    def peek(self):
        if self.is_empty(): raise Stack.Empty
        return self.stack[self.ptr-1]
    
    def push(self, n):
        if self.is_full(): raise Stack.Full
        self.stack[self.ptr] = n
        self.ptr += 1

    def pop(self):
        if self.is_empty(): raise Stack.Empty
        tmp = self.stack[self.ptr-1] 
        self.ptr -= 1
        return tmp
    
    def size(self):
        return self.ptr
    
n = int(input())
ans = [0]*n
towers = tuple(map(int, input().split()))
towers_mapped  = [[]]*n
for i in range(n):
    towers_mapped[i] = (towers[i], i, 0)

# towers ìë£Œêµ¬ì¡°ë¥¼(ë†’ì´, ìê¸° ì¸ë±ìŠ¤, ë„ë‹¬í•œ ì¸ë±ìŠ¤)ë¡œ ê´€ë¦¬í•˜ë©´ ì•ˆ ë˜ë‚˜.
towers_pass1 = Stack(n)
towers_pass2 = Stack(n)

for tower in towers_mapped:
    towers_pass1.push(tower)


while not towers_pass1.is_empty():
    towers_pass2.push(towers_pass1.pop())
    while not towers_pass1.is_empty and towers_pass1.peek() < towers_pass2.peek(): # ê°ì†Œì„¸ì¸ ë™ì•ˆ íŒ í‘¸ì‹œ ë°˜ë³µ
        towers_pass2.push(towers_pass1.pop())
    # ë§Œì•½ ë‚¨ì•„ ìˆëŠ” íƒ‘ì´ ì—†ë‹¤ë©´
    if towers_pass1.is_empty(): 
        while not towers_pass2.is_empty():
            tower = towers_pass2.pop()
        break
    # ê°ì†Œì„¸ ì• ë“¤ì€ ë‹¤ ë„£ì—ˆê³ , ì´ì œ êº¼ë‚¼ ì• ëŠ” ë‹¤ í¼
    while not towers_pass2.is_empty() and towers_pass1.peek() > towers_pass2.peek():
        tower_from = towers_pass2.pop() # ë½‘ê³ , ì¸ë±ìŠ¤ëŠ” ì–´ë–»ê²Œ í•¨?
        tower_to = towers_pass1.peek()
        ans[tower_from[1]] = tower_to[1]+1

for a in ans:
    print(a, end=' ')
```

## Phase2. í”¼ë“œë°±

ğŸ¯ ë¬¸ì œ ìš”ì•½: [ë°±ì¤€ 2493 - íƒ‘]

â€¢	ê° íƒ‘ì€ ì™¼ìª½ ë°©í–¥ìœ¼ë¡œ ë ˆì´ì €ë¥¼ ì¨.

â€¢	ê° ë ˆì´ì €ëŠ” ìì‹ ë³´ë‹¤ ì™¼ìª½ì— ìˆëŠ” íƒ‘ ì¤‘ì—ì„œ ê°€ì¥ ë¨¼ì € ìì‹ ë³´ë‹¤ ë†’ì€ íƒ‘ì—ë§Œ ë„ë‹¬í•¨.

â€¢	ê° íƒ‘ë§ˆë‹¤, ìì‹ ì˜ ë ˆì´ì €ë¥¼ ìˆ˜ì‹ í•œ íƒ‘ì˜ ë²ˆí˜¸(1-based)ë¥¼ ì¶œë ¥í•˜ì‹œì˜¤. (ì—†ìœ¼ë©´ 0)

âœ… ë¬¸ì œ í•µì‹¬ ê°œë…

ì´ ë¬¸ì œëŠ” ì „í˜•ì ì¸ â€œëª¨ë…¸í† ë‹‰ ìŠ¤íƒ(Monotonic Stack)â€ ì‘ìš©ì…ë‹ˆë‹¤.

> â€œí˜„ì¬ íƒ‘ë³´ë‹¤

ğŸ” ë‹¹ì‹ ì˜ í’€ì´: ì˜ëœ ì 

â€¢	ğŸ‘ ìì²´ ìŠ¤íƒ í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ì„œ ì§ì ‘ ë¬¸ì œë¥¼ í•´ê²°í•œ ì ì€ ë©‹ì§„ ì‹œë„ì…ë‹ˆë‹¤. ìë£Œêµ¬ì¡° êµ¬í˜„ë ¥ë„ í‚¤ìš¸ ìˆ˜ ìˆê³ , êµ¬ì¡°ë„ íŒŒì•…í•˜ë ¤ í•œ í”ì ì´ ë³´ì—¬ìš”.

â€¢	ğŸ‘ ë¬¸ì œ ì¡°ê±´(ì™¼ìª½ì—ì„œ ì˜¤ëŠ” ë ˆì´ì €, ê°€ì¥ ë¨¼ì € ë§Œë‚˜ëŠ” ë†’ì€ íƒ‘)ì— ëŒ€í•´ ìŠ¤íƒ ê¸°ë°˜ êµ¬ì¡°ë¡œ í•´ê²°í•´ì•¼ê² ë‹¤ëŠ” í° ê·¸ë¦¼ì€ ì •í™•í•©ë‹ˆë‹¤.

â€¢	ğŸ‘€ towers_mapped = (ë†’ì´, ì¸ë±ìŠ¤) í˜•ì‹ìœ¼ë¡œ ë©”íƒ€ì •ë³´ë¥¼ í•¨ê»˜ ì²˜ë¦¬í•˜ë ¤ëŠ” ì ‘ê·¼ë„ ì•„ì£¼ ì¢‹ìŠµë‹ˆë‹¤.

ğŸ› ï¸ ê°œì„ í•  ìˆ˜ ìˆëŠ” ì 

1. ë³µì¡ë„ë¥¼ ì¤„ì´ëŠ” ë°©í–¥ìœ¼ë¡œ ë¦¬íŒ©í† ë§

ë‹¹ì‹ ì˜ ë¡œì§ì€ í¬ê²Œ ë³´ë©´ ë‹¤ìŒê³¼ ê°™ì´ ì‘ë™í•©ë‹ˆë‹¤:

â€¢	ëª¨ë“  íƒ‘ì„ ìŠ¤íƒì— ì§‘ì–´ë„£ê³  ì—­ìˆœìœ¼ë¡œ í•˜ë‚˜ì”© êº¼ë‚´ë©° ë¹„êµ

â€¢	ì˜¤ë¥¸ìª½ì—ì„œ ì™¼ìª½ìœ¼ë¡œ ì´ë™í•˜ë©´ì„œ ì™¼ìª½ì— ìˆëŠ” í° íƒ‘ì„ ì°¾ìœ¼ë ¤ í•¨

â†’ í•˜ì§€ë§Œ, ë‘ ê°œì˜ ìŠ¤íƒì„ ì™”ë‹¤ê°”ë‹¤ í•˜ë©´ì„œ ë¹„êµí•˜ëŠ” êµ¬ì¡°ëŠ” ë„ˆë¬´ ë³µì¡í•˜ê³ ,

ì´ ë¬¸ì œì˜ í•µì‹¬ì¸ **â€œì™¼ìª½ì„ í•œ ë²ˆë§Œ ë³´ë©´ì„œë„ ì •ë‹µì„ ìœ ì¶”í•  ìˆ˜ ìˆëŠ” êµ¬ì¡°â€**ë¥¼ ë†“ì¹  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

2. ì •ì„ ìŠ¤íƒ í’€ì´ êµ¬ì¡° ì œì•ˆ (ë” ê°„ë‹¨í•˜ê³  ì§ê´€ì )

```plain text
n = int(input())
heights = list(map(int, input().split()))
stack = []
result = [0] * n  # 1-based ê²°ê³¼ ì €ì¥

for i in range(n):
    # ì™¼ìª½ì— ë‚˜ë³´ë‹¤ ì‘ì€ íƒ‘ì€ ì „ë¶€ ì œê±° (ì‹ í˜¸ ë„ë‹¬ ë¶ˆê°€)
    while stack and heights[stack[-1]] < heights[i]:
        stack.pop()

    if stack:
        result[i] = stack[-1] + 1  # ì¸ë±ìŠ¤ â†’ íƒ‘ ë²ˆí˜¸ëŠ” 1-based

    stack.append(i)  # í˜„ì¬ íƒ‘ì˜ ì¸ë±ìŠ¤ë¥¼ ìŠ¤íƒì— ì €ì¥

print(*result)
```

í•µì‹¬ ì•„ì´ë””ì–´:

â€¢	ìŠ¤íƒì—ëŠ” ìì‹ ë³´ë‹¤ ë†’ì€ íƒ‘ì˜ ì¸ë±ìŠ¤ë§Œ ë‚¨ê¸°ê³ , ë‚˜ë¨¸ì§€ëŠ” ì „ë¶€ pop.

â€¢	ì´ ê³¼ì •ì—ì„œ ìŠ¤íƒ topì€ ê³§ í˜„ì¬ íƒ‘ì˜ ë ˆì´ì €ê°€ ë„ë‹¬í•˜ëŠ” ì²« íƒ‘ì´ ë¨.

ğŸ§  TIL ìš”ì•½

> â€œìì‹ ë³´ë‹¤ ì‘ì€ ê°’ì€ ì˜ë¯¸ê°€ ì—†ê³ ,

ğŸ’¡ ì¶”ê°€ í•™ìŠµ íŒ

ì´ ë¬¸ì œ ìœ í˜•ì€ ë‹¤ìŒê³¼ ê°™ì€ ë¬¸ì œë“¤ê³¼ ìœ ì‚¬í•©ë‹ˆë‹¤:

â€¢	ë°±ì¤€ 17298 - ì˜¤í°ìˆ˜

â€¢	ë°±ì¤€ 17299 - ì˜¤ë“±í°ìˆ˜

â€¢	ë°±ì¤€ 3015 - ì˜¤ì•„ì‹œìŠ¤ ì¬ê²°í•©

ì´ëŸ° ë¬¸ì œë“¤ì„ **â€œëª¨ë…¸í† ë‹‰ ìŠ¤íƒ ì‹œë¦¬ì¦ˆâ€**ë¡œ ë¬¶ì–´ ë°˜ë³µ í•™ìŠµí•˜ë©´ ì‹¤ë ¥ì´ ì‘¥ì‘¥ ëŠ˜ì–´ìš”.

í•„ìš”í•˜ì‹œë©´ Notion í…œí”Œë¦¿ í˜•íƒœë¡œ ì •ë¦¬í•´ë“œë¦´ ìˆ˜ë„ ìˆì–´ìš”. ê³„ì†í•´ì„œ ì‹¤ë ¥ì´ ìŒ“ì—¬ê°€ê³  ìˆìŠµë‹ˆë‹¤. í™”ì´íŒ…ì…ë‹ˆë‹¤!

# ìŠ¤íƒ: ì› ì˜ì—­

https://www.acmicpc.net/problem/10000

xì¶• ìœ„ì— ì›ì´ Nê°œ ìˆë‹¤. ì›ì€ ì„œë¡œ êµì°¨í•˜ì§€ ì•ŠëŠ”ë‹¤. í•˜ì§€ë§Œ, ì ‘í•  ìˆ˜ëŠ” ìˆë‹¤.

ì›ìœ¼ë¡œ ë§Œë“¤ì–´ì§€ëŠ” ì˜ì—­ì´ ëª‡ ê°œì¸ì§€ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

ì˜ì—­ì€ ì ì˜ ì§‘í•©ìœ¼ë¡œ ëª¨ë“  ë‘ ì ì€ ì›ì„ êµì°¨í•˜ì§€ ì•ŠëŠ” ì—°ì†ë˜ëŠ” ê³¡ì„ ìœ¼ë¡œ ì—°ê²°ë  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤.

## Phase1. ì‹¤íŒ¨

```python
"""
1. ë¬¸ì œ ì½ê¸°
ì´í•´ê°€ ì–´ë µì§€ëŠ” ì•ŠìŒ. ê·¸ëŸ°ë° ì™œ ìŠ¤íƒ ë¬¸ì œì¸ì§€ ì˜ ëª¨ë¥´ê² ìŒ.
ìŠ¤íƒ: ì„ ì…ì„ ì¶œ
ì´ ë¬¸ì œì—ì„œ ì„ ì…ì„ ì¶œì˜ ëŒ€ìƒì€? ì›? ì›ì„ ë¨¼ì € í‘¸ì‹œí•œë‹¤ê³  í•´ë´? 
ì› ì•ˆì— ì›ì´ ìˆëŠ”ì§€ ì› ë°–ì— ìˆëŠ”ì§€ë¥¼ ì•Œë©´ ë˜ëŠ” ê±° ì•„ë‹Œê°€? ê·¸ê±¸ë¡œ categorizationì´ 
ë  ê±° ê°™ì€ë°.
find í•¨ìˆ˜ë¡œ ì› ì•ˆì˜ ì›ì„ ì°¾ì•„ì„œ ì¬ê·€ì ìœ¼ë¡œ ìŠ¤íƒì„ ì¨ì•¼í•  ê²ƒìœ¼ë¡œ ë³´ì„.
ì¼ë‹¨ ë– ì˜¤ë¥´ëŠ” ì½”ë“œë¥¼ êµ¬í˜„í•´ë³´ê¹Œ?
2. ë¬¸ì œ í’€ê¸°
3. ìˆ˜ë„ ì½”ë“œ
ì „ì²´ ë°°ì—´ì„ ìœ ì§€
ì²« ë²ˆì§¸ ì›ì„ ì‘ì—…ìŠ¤íƒì— í‘¸ì‹œí•œë‹¤.
í‘¸ì‹œí•œ ì› ì•ˆì˜ ì›ì´ ì¡´ì¬í•˜ëŠ”ì§€ ì „ì²´ ë°°ì—´ì„ ê²€ì‚¬í•œë‹¤.
ì¡´ì¬í•œë‹¤ë©´ ì „ì²´ ë°°ì—´ì—ì„œ ì œê±°í•˜ê³  ì‘ì—… ìŠ¤íƒì— í‘¸ì‹œí•œë‹¤.
ê°™ì€ ì‘ì—…ì„ ë°˜ë³µí•œë‹¤.
êº¼ë‚´ë©´ì„œ ì˜ì—­ì„ ê²€ì‚¬í•œë‹¤? ì˜ í•˜ë©´ ë  ê±° ê°™ì€ë°? base circleì´ë¼ëŠ” ê°œë…ì´ ìˆì–´ì•¼ í•˜ì§€ ì•Šê² ë‚˜.
ì›ì„ ë½‘ìœ¼ë©´ì„œ ì¹´ìš´í„° 1 ì¦ê°€ì‹œí‚¤ë©´ ë˜ì§€ ë­. 
ê·¸ë¦¬ê³  findë¡œ ì•ˆì— ìˆëŠ”ê±° ë‹¤ ì°¾ê³  ë½‘ìœ¼ë©´ì„œ ê²€ì‚¬í•˜ëŠ” ê±°ê³ .
ê·¸ëŸ¬ë‹ˆê¹Œ ëª¨ë“  ì›ì— ëŒ€í•´ ìŠ¤íƒ ì—°ì‚°ì„ í•˜ê¸´ í•´ì•¼ í•˜ëŠ” ê±°ë‹¤. ë‚˜ì˜ ìˆ˜ë„ ì½”ë“œëŒ€ë¡œë©´
n ì€ 300,000ì´ë¼ì„œ ì¢€ í¬ê¸´ í•œë°.
ì´ê±° ì•„ë‹Œê±° ê°™ì•„.
4. ì½”ë“œ êµ¬í˜„
ì´
"""

from collections import deque

n = int(input())
circles = [[]]*n
for i in range(n):
    x, r = tuple(map(int, input().split()))
    circles[i] = (x-r, r+x)
print(circles)



def find_inner(circle: tuple):
    """ì› circleë³´ë‹¤ ì•ˆì— ìˆëŠ” ì›ì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ì™„ì „ íƒìƒ‰ìœ¼ë¡œ ì°¾ì•„ì„œ ë¦¬í„´í•©ë‹ˆë‹¤."""
    ans = []
    for circle_target in circles:
        if circle == circle_target: continue
        # ì°¾ì•˜ë‹¤ë©´
        if circle[0] <= circle_target[0] and circle_target[1] <= circle[1]:
            ans.append(circle_target)
    return ans

def solve():
    for circle in circles:
        stack = deque()
        stack.append(circle)
        while stack:
            c = stack.pop()
            inner_circles = find_inner(c)
            for c2 in inner_circles:
                stack.append(c2)
            print(f"inner circles of {c}: {inner_circles}")
            """ì´ëŸ¬ë©´ ìŠ¤íƒì„ ì“¸ ì´ìœ ê°€ ì—†ì§€!"""

solve()

"""
ì´ìŠˆ
Phase1.
Phase2.
"""
```

# í: ê°€ìš´ë°ë¥¼ ë§í•´ìš”

https://www.acmicpc.net/problem/1655

ë°±ì¤€ì´ëŠ” ë™ìƒì—ê²Œ "ê°€ìš´ë°ë¥¼ ë§í•´ìš”" ê²Œì„ì„ ê°€ë¥´ì³ì£¼ê³  ìˆë‹¤. ë°±ì¤€ì´ê°€ ì •ìˆ˜ë¥¼ í•˜ë‚˜ì”© ì™¸ì¹ ë•Œë§ˆë‹¤ ë™ìƒì€ ì§€ê¸ˆê¹Œì§€ ë°±ì¤€ì´ê°€ ë§í•œ ìˆ˜ ì¤‘ì—ì„œ ì¤‘ê°„ê°’ì„ ë§í•´ì•¼ í•œë‹¤. ë§Œì•½, ê·¸ë™ì•ˆ ë°±ì¤€ì´ê°€ ì™¸ì¹œ ìˆ˜ì˜ ê°œìˆ˜ê°€ ì§ìˆ˜ê°œë¼ë©´ ì¤‘ê°„ì— ìˆëŠ” ë‘ ìˆ˜ ì¤‘ì—ì„œ ì‘ì€ ìˆ˜ë¥¼ ë§í•´ì•¼ í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ ë°±ì¤€ì´ê°€ ë™ìƒì—ê²Œ 1, 5, 2, 10, -99, 7, 5ë¥¼ ìˆœì„œëŒ€ë¡œ ì™¸ì³¤ë‹¤ê³  í•˜ë©´, ë™ìƒì€ 1, 1, 2, 2, 2, 2, 5ë¥¼ ì°¨ë¡€ëŒ€ë¡œ ë§í•´ì•¼ í•œë‹¤. ë°±ì¤€ì´ê°€ ì™¸ì¹˜ëŠ” ìˆ˜ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ë™ìƒì´ ë§í•´ì•¼ í•˜ëŠ” ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. í’€ì–´ë³´ê¸°(ì‹¤íŒ¨)

```python
"""
1. ë¬¸ì œ ì½ê¸°: ì´í•´ê°€ ì–´ë µì§„ ì•ŠìŒ
2. ë¬¸ì œ í’€ê¸°: ìƒê°ë³´ë‹¤ ì–´ë ¤ì›€. ì•„ë˜ì²˜ëŸ¼ í•˜ë©´ ë  ê±° ê°™ì€ë° ì‹œê°„ì´ˆê³¼ ë‚¨. 
ë³µì¡ë„ë¥¼ ê³„ì‚°í•´ì„œ ë” ë‚˜ì€ ë°©ì‹ìœ¼ë¡œ í’€ì–´ì•¼ í•¨.


import heapq

arr = []
heapq.heapify(arr)

n = int(input())

def get_mid(arr: list): 
    tmp = []
    end = len(arr)//2 if len(arr)%2 == 0 else len(arr)//2+1
    mid = 0
    for _ in range(end):
        mid = heapq.heappop(arr)
        tmp.append(mid)
    for t in tmp:
        heapq.heappush(arr, t)
    return mid

def solve():
    global arr
    for _ in range(n):
        heapq.heappush(arr, int(input()))
        print(get_mid(arr))
        
    
solve()

3. ìˆ˜ë„ ì½”ë“œ

4. ì½”ë“œ êµ¬í˜„
"""



"""
ì´ìŠˆ
Phase1.
Phase2.
"""
```

## Phase2. í”¼ë“œë°±(ì •ë‹µ ì œì‹œ ê¸ˆì§€)

ì¢‹ìŠµë‹ˆë‹¤! ì§€ê¸ˆê¹Œì§€ì˜ ì‹œë„ì™€ ì ‘ê·¼ì€ ì¶©ë¶„íˆ ì˜ë¯¸ ìˆì—ˆê³ , ì§€ê¸ˆì´ ë°”ë¡œ ì •ë‹µì€ ë³´ì§€ ì•Šê³  êµ¬ì¡°ë§Œ ì¡ì•„ë‚˜ê°€ê¸°ì— ë”± ì¢‹ì€ íƒ€ì´ë°ì…ë‹ˆë‹¤.

âœ… í˜„ì¬ ì½”ë“œì˜ í•µì‹¬ í•œê³„

ë‹¹ì‹ ì´ ì‚¬ìš©í•œ ë°©ì‹ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

â€¢	ìš°ì„ ìˆœìœ„ í (min heap)ì— ì›ì†Œë¥¼ ì‚½ì…

â€¢	ë§¤ë²ˆ popì„ ì—¬ëŸ¬ ë²ˆ í•˜ë©´ì„œ ì¤‘ê°„ê°’ ì¶”ì¶œ í›„ ë‹¤ì‹œ push â†’ ì‹œê°„ë³µì¡ë„: O(N \log N) ì´ìƒ

âŒ ë¬¸ì œì :

â€¢	heapqëŠ” ì •ë ¬ëœ ìˆœì„œë¥¼ ë³´ì¥í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì—, ì¤‘ê°„ê°’ì„ êµ¬í•˜ë ¤ë©´ ë§¤ë²ˆ pop/push ë°˜ë³µì´ í•„ìš”

â€¢	ê²°êµ­ ë§¤ ì…ë ¥ë§ˆë‹¤ í™ ì „ì²´ë¥¼ íƒìƒ‰í•˜ë“¯ì´ ë™ì‘í•˜ê²Œ ë˜ì–´, ì‹œê°„ ì´ˆê³¼ ë°œìƒ

ğŸ§  í•µì‹¬ ê°œë…: ë‘ ê°œì˜ í™

ì´ ë¬¸ì œë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ í•´ê²°í•˜ê¸° ìœ„í•œ ê°€ì¥ í•µì‹¬ ì•„ì´ë””ì–´ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

> ì¤‘ê°„ê°’ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ íš¨ìœ¨ì ìœ¼ë¡œ ì°¾ê¸° ìœ„í•´, â€œì‘ì€ ê°’ë“¤ë§Œ ë‹´ëŠ” í™â€ê³¼ â€œí° ê°’ë“¤ë§Œ ë‹´ëŠ” í™â€ì„ ë™ì‹œì— ìœ ì§€í•œë‹¤.

ğŸ§© êµ¬ì¡°:

ğŸ”§ ì„¤ê³„ ì „ëµ

ğŸ“Œ ë™ì‘ ì›ë¦¬:

â€¢	ìˆ˜ë¥¼ í•˜ë‚˜ì”© ì½ì„ ë•Œë§ˆë‹¤ ë‘ í™ì˜ ë°¸ëŸ°ìŠ¤ë¥¼ ìœ ì§€

â€¢	left_heap(ì‘ì€ ìˆ˜ë“¤)ì˜ ê¸¸ì´ê°€ right_heapë³´ë‹¤ ê°™ê±°ë‚˜ 1 ë” ë§ê²Œ ìœ ì§€

â€¢	ë§¤ ì…ë ¥ë§ˆë‹¤:

â€¢	ë¨¼ì € left_heapì— push (ì¤‘ê°„ê°’ í›„ë³´ë‹ˆê¹Œ)

â€¢	ê·¸ í›„ left_heapì˜ ìµœëŒ€ê°’ê³¼ right_heapì˜ ìµœì†Œê°’ì„ ë¹„êµí•´ì„œ ìˆœì„œê°€ ì–´ê¸‹ë‚˜ë©´ swap

â€¢	ê¸¸ì´ ê· í˜•ì´ ë§ì§€ ì•Šìœ¼ë©´ í•œìª½ì—ì„œ ë‹¤ë¥¸ ìª½ìœ¼ë¡œ ì´ë™

ğŸ“Œ ì¤‘ê°„ê°’ ê²°ì •:

â€¢	ë¬´ì¡°ê±´ left_heap[0]ì´ í˜„ì¬ê¹Œì§€ì˜ ì¤‘ê°„ê°’

âœï¸ Phase2 ëª©í‘œ

ë‹¹ì‹ ì˜ ëª©í‘œëŠ” ì§€ê¸ˆê¹Œì§€ì˜ êµ¬ì¡°ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë‹¤ìŒì˜ ë¡œì§ë§Œ ì¬ì •ì˜í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤:

```plain text
# ë‘ ê°œì˜ í™ ì •ì˜
left_heap = []   # max heap (ìŒìˆ˜ë¡œ push)
right_heap = []  # min heap

# ë§¤ ì…ë ¥ë§ˆë‹¤ ë‹¤ìŒ ë¡œì§
1. ìƒˆ ìˆ«ì xë¥¼ left_heapì— push(-x)
2. left_heapì˜ ìµœëŒ€ê°’(-left_heap[0]) > right_heapì˜ ìµœì†Œê°’ì´ë¼ë©´ êµí™˜
3. ë‘ í™ í¬ê¸°ë¥¼ ì¡°ì •: left_heapì€ í•­ìƒ right_heapë³´ë‹¤ í¬ê±°ë‚˜ ê°™ë„ë¡
4. ì •ë‹µì€ -left_heap[0]
```

ğŸ§© ì§ì ‘ êµ¬í˜„ ì „ì— ì ê²€í•  ì§ˆë¬¸ë“¤

â€¢	ì™œ í™ì´ ë‘ ê°œ í•„ìš”í•˜ì§€?

â€¢	ì¤‘ê°„ê°’ì„ ì¶”ì¶œí•˜ê¸° ìœ„í•´ ì–´ë–¤ ì¡°ê±´ì„ ìœ ì§€í•´ì•¼ í•˜ì§€?

â€¢	ì¤‘ê°„ê°’ì´ ë°”ë€ŒëŠ” ê¸°ì¤€ì€ ì–´ë–¤ ê²½ìš°ì§€?

ğŸ§ª ì¶”ì²œ í…ŒìŠ¤íŠ¸

í…ŒìŠ¤íŠ¸ëŠ” ë‹¤ìŒ ì…ë ¥ìœ¼ë¡œ í•´ë³´ì„¸ìš”:

```plain text
7
1
5
2
10
-99
7
5
```

ì¶œë ¥ì€:

```plain text
1
1
2
2
2
2
5
```

ì´ê±¸ ì§ì ‘ ë§ì¶°ë³´ëŠ” ê²ƒì´ ì¤‘ê°„ê°’ êµ¬ì¡°ê°€ ì˜ ìœ ì§€ë˜ëŠ”ì§€ íŒë‹¨í•˜ëŠ” ì¢‹ì€ ë°©ë²•ì…ë‹ˆë‹¤.

âœ… ë§ˆë¬´ë¦¬ ì¡°ì–¸

ì´ ë¬¸ì œëŠ” ë§ì€ ê³ ê¸‰ ë¬¸ì œë“¤ì˜ ì „ì‹ ì…ë‹ˆë‹¤:

â€¢	sliding window median

â€¢	running median

â€¢	lower_bound/upper_bound ê°œë… í™œìš© ë“±

ì •ë‹µ ì½”ë“œ ì—†ì´ ì§ì ‘ ë‘ í™ êµ¬ì¡°ë¥¼ ë§Œë“¤ì–´ë³´ê³  ì„±ê³µí•´ë³´ì„¸ìš”.

ê·¸ê²Œ ê°€ì¥ ë¹ ë¥¸ ì„±ì¥ì˜ ì§€ë¦„ê¸¸ì…ë‹ˆë‹¤.

í•„ìš”í•˜ë‹¤ë©´ â€œìŒìˆ˜ë¡œ ë„£ì–´ì„œ max heap ë§Œë“¤ê¸°â€ë¥¼ ë„ì™€ë“œë¦´ ìˆ˜ë„ ìˆì–´ìš”.

í™”ì´íŒ…ì…ë‹ˆë‹¤!

# ìš°ì„ ìˆœìœ„ í: ì¹´ë“œ ì •ë ¬í•˜ê¸°

https://jungle-compass.krafton.com/mod/page/view.php?id=6123

ì •ë ¬ëœ ë‘ ë¬¶ìŒì˜ ìˆ«ì ì¹´ë“œê°€ ìˆë‹¤ê³  í•˜ì. ê° ë¬¶ìŒì˜ ì¹´ë“œì˜ ìˆ˜ë¥¼ A, Bë¼ í•˜ë©´ ë³´í†µ ë‘ ë¬¶ìŒì„ í•©ì³ì„œ í•˜ë‚˜ë¡œ ë§Œë“œëŠ” ë°ì—ëŠ” A+B ë²ˆì˜ ë¹„êµë¥¼ í•´ì•¼ í•œë‹¤. ì´ë¥¼í…Œë©´, 20ì¥ì˜ ìˆ«ì ì¹´ë“œ ë¬¶ìŒê³¼ 30ì¥ì˜ ìˆ«ì ì¹´ë“œ ë¬¶ìŒì„ í•©ì¹˜ë ¤ë©´ 50ë²ˆì˜ ë¹„êµê°€ í•„ìš”í•˜ë‹¤.

ë§¤ìš° ë§ì€ ìˆ«ì ì¹´ë“œ ë¬¶ìŒì´ ì±…ìƒ ìœ„ì— ë†“ì—¬ ìˆë‹¤. ì´ë“¤ì„ ë‘ ë¬¶ìŒì”© ê³¨ë¼ ì„œë¡œ í•©ì³ë‚˜ê°„ë‹¤ë©´, ê³ ë¥´ëŠ” ìˆœì„œì— ë”°ë¼ì„œ ë¹„êµ íšŸìˆ˜ê°€ ë§¤ìš° ë‹¬ë¼ì§„ë‹¤. ì˜ˆë¥¼ ë“¤ì–´ 10ì¥, 20ì¥, 40ì¥ì˜ ë¬¶ìŒì´ ìˆë‹¤ë©´ 10ì¥ê³¼ 20ì¥ì„ í•©ì¹œ ë’¤, í•©ì¹œ 30ì¥ ë¬¶ìŒê³¼ 40ì¥ì„ í•©ì¹œë‹¤ë©´ (10 + 20) + (30 + 40) = 100ë²ˆì˜ ë¹„êµê°€ í•„ìš”í•˜ë‹¤. ê·¸ëŸ¬ë‚˜ 10ì¥ê³¼ 40ì¥ì„ í•©ì¹œ ë’¤, í•©ì¹œ 50ì¥ ë¬¶ìŒê³¼ 20ì¥ì„ í•©ì¹œë‹¤ë©´ (10 + 40) + (50 + 20) = 120 ë²ˆì˜ ë¹„êµê°€ í•„ìš”í•˜ë¯€ë¡œ ëœ íš¨ìœ¨ì ì¸ ë°©ë²•ì´ë‹¤.

Nê°œì˜ ìˆ«ì ì¹´ë“œ ë¬¶ìŒì˜ ê°ê°ì˜ í¬ê¸°ê°€ ì£¼ì–´ì§ˆ ë•Œ, ìµœì†Œí•œ ëª‡ ë²ˆì˜ ë¹„êµê°€ í•„ìš”í•œì§€ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. í’€ì–´ë³´ê¸°(ì‹¤íŒ¨)

```python
"""
1. ë¬¸ì œ ì½ê¸°: 
2. ë¬¸ì œ í’€ê¸°
10, 20, 40

pass1       pass2
10 + 20     30 + 40 = 100
calc order
10 + 20 + 30 + 40 = 100
10 + 40     50 + 20 = 50+70 = 120
4
10 20 30 40 
10 + 20 +30 + 60 + 40 
ë¬´ì¡°ê±´ ì‘ì€ ì• ë“¤ë¼ë¦¬ ë”í•˜ë©´ ì¢‹ì€ ê±´ê°€? ê·¸ëŸ°ë“¯. ê·¸ëƒ¥ ê·¸ë ‡ê²Œ ê·¸ë¦¬ë””í•˜ê²Œ í•˜ë©´ ë ë“¯
ë‚´ê°€ ë¬¸ì œë¥¼ ì´í•´ë¥¼ ëª»í•œ ê±° ê°™ë‹¤. 10, 20, 30, 40 ë¬¶ìŒ ì¹´ë“œê°€ ì£¼ì–´ì¡Œì„ ë•Œ
ì´ë“¤ì„ ìµœì € ë¹„êµë¡œ í•©ì¹˜ëŠ” ë°©ë²•ì€!
ì¼ë‹¨. 
3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys, heapq
h = []
heapq.heapify(h)
n = int(sys.stdin.readline().strip())
for _ in range(n):
    deck_num  = heapq.heappush(h, int(sys.stdin.readline().strip()))

ans = heapq.heappop(h)
ans2 = 0
while h:
    popped = heapq.heappop(h)
    # print(f'{ans}+{popped}={ans+popped}')
    ans += popped
    ans2 += ans
    
# print(ans)
print(ans2)

"""
ì´ìŠˆ: ì˜¤ë‹µ

Phase1.
í™˜ê²½: íŒŒì´ì¬
ë¡œê·¸: í‹€ë ¸ìŠµë‹ˆë‹¤.
ìµœê·¼ ë³€ê²½ ì‚¬í•­: í™ìœ¼ë¡œ ê·¸ë¦¬ë””í•˜ê²Œ ìµœì†Œ ë”í•˜ê¸° ì—°ì‚°ì„ í•˜ëŠ” ì½”ë“œ ì‘ì„±.

Phase2.
í™•ì¸: í‹€ë¦° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ê°€ ì¡´ì¬í•œë‹¤ëŠ” ì˜ë¯¸. 2í”„ë¡œì—ì„œ í‹€ë ¸ìœ¼ë¯€ë¡œ ê¸ˆë°© ì°¾ì„ ìˆ˜ ìˆê³ ,
ì½”ë“œì— ì¤‘ëŒ€í•œ ë…¼ë¦¬ì  ì˜¤ë¥˜ê°€ ìˆìŒì„ ì‹œì‚¬.
5
10
20
30
40
50
340

10 + 20 = 30
30 + 30 = 60
60 + 40 = 100
100 + 50 = 150
30 + 60 + 100 + 150
ì´ëŸ° ëŠë‚Œ..ì´ë©´ ë”±íˆ í‹€ë¦´ ê±´ ì—†ëŠ”ë°. 10ë¶„ ë” ìƒê°í•´ë³´ê³  íŒ¨ìŠ¤í•©ì‹œë‹¤.
ì¹´ë“œ ê°œìˆ˜ê°€ 1ì´ë©´ ì„ì„ ì¼ ì—†ì´ 0ì´ ë‚˜ì˜¤ë‹ˆ ê·¸ê²ƒë„ ì •ìƒ.

10
20
40
50

10 + 20 = 30
30 + 40 = 70
70 + 50 = 120
ì•„ ì—¬ê¸°ì„œ 110 ë‚˜ì™€ì•¼ ë˜ëŠ”ë°, ans2ê°€ ì˜ëª» ê°€ì‚°ë˜ëŠ” ê±´ê°€.
ê·¸ëƒ¥ ë‚´ê°€ ë¬¸ì œë¥¼ ì´í•´ ëª»í•œ ê±° ê°™ë‹¤.
ì‹œë„: 
ë¶„ì„: 
"""
```

## Phase2. í”¼ë“œë°±(ì •ë‹µ ì œì‹œ ê¸ˆì§€)

ì¢‹ì•„ìš”, ì´ë²ˆì—ë„ í’€ì´ í”ì ì„ ì˜ ë‚¨ê¸°ì…¨ê³ , ë¬´ì—‡ë³´ë‹¤ í‹€ë¦° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì— ëŒ€í•´ ì§ì ‘ ë¶„ì„í•˜ê³ ì ì‹œë„í•˜ì‹  ì ì´ ì•„ì£¼ ì¢‹ìŠµë‹ˆë‹¤.

âœ… í˜„ì¬ ì½”ë“œì˜ í•µì‹¬ ë¬¸ì œì 

ğŸ”¥ ë…¼ë¦¬ì  í•µì‹¬ ì‹¤ìˆ˜:

```plain text
ans = heapq.heappop(h)
ans2 = 0
while h:
    popped = heapq.heappop(h)
    ans += popped
    ans2 += ans
```

ì´ ì½”ë“œëŠ” **â€œê°€ì¥ ì‘ì€ ê°’ í•˜ë‚˜ë¥¼ ë¹¼ì„œ ansì— ì €ì¥í•˜ê³ , ë‚¨ì€ ê²ƒë“¤ê³¼ ì°¨ë¡€ëŒ€ë¡œ ë”í•´ê°€ê¸°â€**ì¸ë°ìš”,

ì—¬ê¸°ì„œì˜ í° ë¬¸ì œëŠ”:

â€¢	ansë¥¼ ëˆ„ì í•˜ê³  ìˆë‹¤ëŠ” ê²ƒ!

â€¢	**ì´ ë¬¸ì œëŠ” â€œë‘ ë¬¶ìŒì„ ë”í•œ ê²°ê³¼ë¥¼ ë‹¤ì‹œ í™ì— ë„£ê³ , ë‹¤ìŒ ë‘ ë¬¶ìŒì„ ë˜ ê³ ë¥´ëŠ” êµ¬ì¡°â€**ì…ë‹ˆë‹¤.

ì¦‰, ë§¤ ì—°ì‚°ë§ˆë‹¤ â€œë‘ ê°œë¥¼ ë”í•œ ê°’ì„ ë‹¤ì‹œ í™ì— pushâ€í•´ì•¼ ë‹¤ìŒ ì—°ì‚°ì—ì„œë„ ì“¸ ìˆ˜ ìˆê³ ,

ê·¸ë•Œë§ˆë‹¤ ìƒê¸°ëŠ” â€œë¹„êµ íšŸìˆ˜â€ë¥¼ ë”í•´ê°€ëŠ” êµ¬ì¡°ì—¬ì•¼ í•©ë‹ˆë‹¤.

ğŸ§  ë¬¸ì œì˜ ë³¸ì§ˆ

â€œë‘ ì¹´ë“œ ë¬¶ìŒì„ í•©ì¹  ë•Œ ë¹„ìš©ì´ A + Bê°€ ë˜ê³ , ê·¸ ê²°ê³¼ A + B ë¬¶ìŒì€ ë‹¤ì‹œ í™ì— ë“¤ì–´ê°€ì•¼ í•œë‹¤.â€

ì´ ë§ì€ ê²°êµ­, ë§¤ ì—°ì‚°ë§ˆë‹¤ ê°€ì¥ ì‘ì€ ë‘ ë¬¶ìŒì„ êº¼ë‚´ì„œ í•©ì¹œ ë‹¤ìŒ,

â€¢	ê·¸ í•©ì¹œ ë¬¶ìŒì„ ë‹¤ìŒ ì—°ì‚°ì— ë‹¤ì‹œ ì‚¬ìš©í•˜ë„ë¡ í™ì— ë„£ì–´ì•¼ í•œë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.

ì¦‰, ëˆ„ì ëœ ì´ ë¹„êµ íšŸìˆ˜ë§Œ ë”°ë¡œ ê´€ë¦¬í•˜ê³ ,

í•©ì³ì§„ ì¹´ë“œ ë¬¶ìŒì€ ê³„ì† í™ì— ë„£ê³ ,

í™ì— í•˜ë‚˜ ë‚¨ì„ ë•Œê¹Œì§€ ë°˜ë³µí•´ì•¼ í•©ë‹ˆë‹¤.

âœ… ì •ë¦¬ëœ ê°œì„  ì•„ì´ë””ì–´

ì˜¬ë°”ë¥¸ íë¦„:

```plain text
1. í™ì— ëª¨ë“  ì¹´ë“œ ë¬¶ìŒ ì‚½ì…
2. while í™ì˜ í¬ê¸°ê°€ 2 ì´ìƒ:
    - ê°€ì¥ ì‘ì€ ë‘ ë¬¶ìŒì„ êº¼ëƒ„ (A, B)
    - A + B â†’ ë¹„êµ íšŸìˆ˜ ì¶”ê°€
    - í•©ì¹œ ì¹´ë“œ ë¬¶ìŒ (A + B)ì„ ë‹¤ì‹œ í™ì— ì‚½ì…
3. ëˆ„ì ëœ ë¹„êµ íšŸìˆ˜ ë°˜í™˜
```

ì´ê±´ ì „í˜•ì ì¸ ê·¸ë¦¬ë”” + ìš°ì„ ìˆœìœ„ í ë¬¸ì œì…ë‹ˆë‹¤.

í•­ìƒ ê°€ì¥ ì‘ì€ ë‘ ë¬¶ìŒì„ ì„ íƒí•´ì„œ ë¹„êµ íšŸìˆ˜ë¥¼ ì¤„ì´ê¸° ë•Œë¬¸ì´ì£ .

âœï¸ TIL ì¶”ì²œ ì •ë¦¬

```plain text
# ì¹´ë“œ ì •ë ¬í•˜ê¸° ë¬¸ì œ ì‹¤íŒ¨ ì›ì¸
- âŒ ì‹¤ìˆ˜: ì²˜ìŒ ì¹´ë“œ ë¬¶ìŒ í•˜ë‚˜(ans)ë¥¼ ê³ ì •í•˜ê³ , ì´í›„ ëˆ„ì í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í•©ì‚°í–ˆìŒ
- âœ… ì •ë‹µ ë°©í–¥: í•­ìƒ ê°€ì¥ ì‘ì€ ë‘ ë¬¶ìŒì„ êº¼ë‚´ì„œ í•©ì¹œ ë’¤ ë‹¤ì‹œ í™ì— ë„£ê³ , ê·¸ ë¹„ìš©ì„ ëˆ„ì 
- ğŸ¯ í•µì‹¬ í¬ì¸íŠ¸: â€œì‘ì€ ì¹´ë“œë¼ë¦¬ ë¨¼ì € í•©ì³ì•¼ ì „ì²´ ë¹„êµ íšŸìˆ˜ê°€ ìµœì†Œê°€ ëœë‹¤â€ëŠ” **ê·¸ë¦¬ë”” êµ¬ì¡°**
- ğŸ” ìŠ¤ìŠ¤ë¡œ í•´ì„í•  ìˆ˜ ìˆëŠ” ê³µì‹:
    â€œìš°ì„ ìˆœìœ„ íì—ì„œ ìµœì†Œ ë‘ ê°’ì„ ë°˜ë³µì ìœ¼ë¡œ êº¼ë‚´ì„œ ëˆ„ì  ë¹„ìš© ê³„ì‚°â€
```

í•„ìš”í•˜ì‹œë©´ ì •ë‹µ ì—†ì´ í…ŒìŠ¤íŠ¸ í†µê³¼ êµ¬ì¡°ë§Œ ìœ ë„í•´ë“œë¦´ ìˆ˜ë„ ìˆì–´ìš”.

ë˜ëŠ” C++ì´ë‚˜ Javaë¡œë„ ë™ì¼ êµ¬ì¡° ë³´ê³  ì‹¶ë‹¤ë©´ ë§ì”€ ì£¼ì„¸ìš”!

ì´ ë¬¸ì œ ì´í›„ì—ëŠ” ë‹¤ìµìŠ¤íŠ¸ë¼, í—ˆí”„ë§Œ ì¸ì½”ë”©, CPU ìŠ¤ì¼€ì¤„ë§ ê°™ì€ ìš°ì„ ìˆœìœ„ í ê¸°ë°˜ ë¬¸ì œë¡œ ìì—°ìŠ¤ëŸ½ê²Œ í™•ì¥ë©ë‹ˆë‹¤ :)

# ìš°ì„ ìˆœìœ„ í, ê·¸ë¦¬ë””: ì² ë¡œ

https://www.acmicpc.net/problem/13334

ì§‘ê³¼ ì‚¬ë¬´ì‹¤ì„ í†µê·¼í•˜ëŠ” nëª…ì˜ ì‚¬ëŒë“¤ì´ ìˆë‹¤. ê° ì‚¬ëŒì˜ ì§‘ê³¼ ì‚¬ë¬´ì‹¤ì€ ìˆ˜í‰ì„  ìƒì— ìˆëŠ” ì„œë¡œ ë‹¤ë¥¸ ì ì— ìœ„ì¹˜í•˜ê³  ìˆë‹¤. ì„ì˜ì˜ ë‘ ì‚¬ëŒ A, Bì— ëŒ€í•˜ì—¬, Aì˜ ì§‘ í˜¹ì€ ì‚¬ë¬´ì‹¤ì˜ ìœ„ì¹˜ê°€ Bì˜ ì§‘ í˜¹ì€ ì‚¬ë¬´ì‹¤ì˜ ìœ„ì¹˜ì™€ ê°™ì„ ìˆ˜ ìˆë‹¤. í†µê·¼ì„ í•˜ëŠ” ì‚¬ëŒë“¤ì˜ í¸ì˜ë¥¼ ìœ„í•˜ì—¬ ì¼ì§ì„  ìƒì˜ ì–´ë–¤ ë‘ ì ì„ ì‡ëŠ” ì² ë¡œë¥¼ ê±´ì„¤í•˜ì—¬, ê¸°ì°¨ë¥¼ ìš´í–‰í•˜ë ¤ê³  í•œë‹¤. ì œí•œëœ ì˜ˆì‚° ë•Œë¬¸ì—, ì² ë¡œì˜ ê¸¸ì´ëŠ” dë¡œ ì •í•´ì ¸ ìˆë‹¤. ì§‘ê³¼ ì‚¬ë¬´ì‹¤ì˜ ìœ„ì¹˜ ëª¨ë‘ ì² ë¡œ ì„ ë¶„ì— í¬í•¨ë˜ëŠ” ì‚¬ëŒë“¤ì˜ ìˆ˜ê°€ ìµœëŒ€ê°€ ë˜ë„ë¡, ì² ë¡œ ì„ ë¶„ì„ ì •í•˜ê³ ì í•œë‹¤.

ì–‘ì˜ ì •ìˆ˜ dì™€ n ê°œì˜ ì •ìˆ˜ìŒ, (hi, oi), 1 â‰¤ i â‰¤ n,ì´ ì£¼ì–´ì ¸ ìˆë‹¤. ì—¬ê¸°ì„œ hiì™€ oiëŠ” ì‚¬ëŒ iì˜ ì§‘ê³¼ ì‚¬ë¬´ì‹¤ì˜ ìœ„ì¹˜ì´ë‹¤. ê¸¸ì´ dì˜ ëª¨ë“  ì„ ë¶„ Lì— ëŒ€í•˜ì—¬, ì§‘ê³¼ ì‚¬ë¬´ì‹¤ì˜ ìœ„ì¹˜ê°€ ëª¨ë‘ Lì— í¬í•¨ë˜ëŠ” ì‚¬ëŒë“¤ì˜ ìµœëŒ€ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

ê·¸ë¦¼ 1 ì— ìˆëŠ” ì˜ˆë¥¼ ê³ ë ¤í•´ë³´ì. ì—¬ê¸°ì„œ n = 8, (h1, o1) = (5, 40), (h2, o2) = (35, 25), (h3, o3) = (10, 20), (h4, o4) = (10, 25), (h5, o5) = (30, 50), (h6, o6) = (50, 60), (h7, o7) = (30, 25), (h8, o8) = (80, 100)ì´ê³ , d = 30ì´ë‹¤. ì´ ì˜ˆì—ì„œ, ìœ„ì¹˜ 10 ê³¼ 40 ì‚¬ì´ì˜ ë¹¨ê°„ìƒ‰ ì„ ë¶„ Lì´, ê°€ì¥ ë§ì€ ì‚¬ëŒë“¤ì— ëŒ€í•˜ì—¬ ì§‘ê³¼ ì‚¬ë¬´ì‹¤ ìœ„ì¹˜ ëª¨ë‘ í¬í•¨ë˜ëŠ” ì„ ë¶„ ì¤‘ í•˜ë‚˜ì´ë‹¤. ë”°ë¼ì„œ ë‹µì€ 4 ì´ë‹¤.

## Phase1. ì§ì ‘ í’€ê¸°(ì‹¤íŒ¨)

```python
"""
1. ë¬¸ì œ ì½ê¸°
ì´ê±° ë”±ë´ë„ ê·¸ ê·¸ë¦¬ë”” ë¬¸ì œì¸ë°. ëª» ë°•ëŠ” ë¬¸ì œë‘ ê°•ì˜ì‹¤ ë°°ì •ì´ë‘ ë¹„ìŠ·í•˜ë‹¤.
2. ë¬¸ì œ í’€ê¸°
ê°•ì˜ì‹¤ ë¬¸ì œëŠ” ê¸°ì–µì´ ë‚˜ëŠ”ë°(ëŠ¦ê²Œ ëë‚˜ëŠ” ê°•ì˜ ìˆœìœ¼ë¡œ ìš°ì„  ë°°ì •), ëª» ë°•ëŠ” ë¬¸ì œëŠ” ê¸°ì–µì´ ì•ˆë‚œë‹¤.
ëª»ì€? ì•„ ì§„ì§œ ê¸°ì–µì´ ì•ˆ ë‚˜ë„¤.
x ì¢Œí‘œ ìƒì— ì„ ë“¤ì˜ ìœ„ì¹˜ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ê°€ì¥ ë§ì€ ì„ ì„ ëª»ìœ¼ë¡œ ê´€í†µí•  ê²½ìš° ì„ ì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ë¼.
ë¬¸ì œëŠ” ì´ê±°ê³ , ì •ë‹µì€? ëª»ì˜ ìœ„ì¹˜ë¥¼ ì˜®ê²¨ê°€ë©° ê´€í†µí•˜ëŠ” ì„  ìµœëŒ€ ìˆ˜ë¥¼ ì™„ì „íƒìƒ‰ìœ¼ë¡œ êµ¬í–ˆë˜ ê±° ê°™ì€ë°
(ì´ê±´ ê·¸ë¦¬ë””ê°€ ì•„ë‹ˆì–ì•„ ê·¸ëŸ¼.)
ì•„ë¬´íŠ¼, ë¬¸ì œë¥¼ ë³´ì.
ëª»ì´ë‘ ë¹„ìŠ·í•˜ê²Œ ì² ë¡œê°€ ì‹œì‘í•˜ëŠ” ì§€ì ì„ incrementalí•˜ê²Œ ì‹œë®¬ë ˆì´ì…˜í•˜ê³ ,
ì² ë¡œê°€ ëë‚˜ëŠ” ì§€ì  ì•ˆìœ¼ë¡œ ë²”ìœ„ ì•ˆì˜ ì„ ë“¤ì´ ë“¤ì–´ì˜¤ë©´ ì •ë‹µì— ë”í•´ì£¼ê¸°?
ì—¬ê¸°ì„œ í™ì„ ì–´ë–»ê²Œ ì“°ì§€? ì•„, ëª»ì´ ìµœëŒ€í•œ ë§ì´ ë°•íˆëŠ” ì§€ì ë“¤ì„ ê·¸ë¦¬ë””í•˜ê²Œ êµ¬í•´ì„œ, 
ê·¸ ìµœëŒ€ ì§€ì ë“¤ì„ ì»¤ë²„í•˜ë©´ ë˜ëŠ” ê±° ì•„ë‹Œê°€?
ì´ê²ƒë„ ì•„ë‹Œ ê±° ê°™ë‹¤. ë¬¸ì œë¥¼ ì´í•´í•˜ì§€ ëª»í•˜ê² ë‹¤.
ê°•ì˜ì‹¤ ë°°ì • ë¬¸ì œì˜ ì—­ë°œìƒì¸ ê±° ê°™ê¸°ë„ í•˜ê³ ?
íŠ¹ì • ì§€ì ì„ ëª» ë°•ê¸° ë¬¸ì œì²˜ëŸ¼ êµ¬í•œ ë‹¤ìŒ, ê°•ì˜ì‹¤ ë¬¸ì œì²˜ëŸ¼ ê·¸ë¦¬ë””í•˜ê²Œ êµ¬í•˜ë˜, 
ë¹¨ë¦¬ ì‹œì‘í•˜ëŠ” ì§€ì ë¶€í„° ë³´ë©´ì„œ ì¡°ê±´ì— ë”°ë¼ ìˆ˜ì— ì¶”ê°€í•˜ë©´? ì¼ë‹¨ ê·¸ë˜ë³¼ê¹Œ? ì•„ë‹ˆ ê·¼ë° ê·¸ëŸ¬ë©´, 
ëª¨ë“  h, o ìŒì— ëŒ€í•´ ì„ ì„ ê·¸ë ¤ë³¸ë‹¤ëŠ” ì˜ë¯¸ê³ , 
ê·¸ ê°ê°ì˜ ì´í„°ë ˆì´ì…˜ ë™ì•ˆ ìµœì•… nê°œì˜ ì„ ì´ ë²”ìœ„ ì•ˆì— ìˆëŠ”ì§€ íŒë‹¨í•´ì•¼ í•˜ë‹ˆê¹Œ
h, o ë²”ìœ„ë§Œ ë”°ì ¸ë„ -100,000,000~100,000,000ì´ê³  ì² ë¡œ ê¸¸ì´ëŠ” 200,000,000ì—ë‹¤ê°€,
ê° ì§‘ì˜ ìµœëŒ€ ê°œìˆ˜ëŠ” 100,000ì´ë‹ˆê¹Œ, 200,000,000 * 100,000ì˜ ë³µì¡ë„ê°€ ë‚˜ì˜¨ë‹¤.
ì´ëŸ¬ë©´ ì•ˆ ë í…ë°.

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""
import heapq
import sys
n = int(sys.stdin.readline().strip())
D = {}
for _ in range(n):
    x, y = tuple(map(int, sys.stdin.readline().split()))  
    x, y = x, y if x < y else y, x # ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì„  ë„£ì–´ì£¼ê¸°
    D[x] = y # ì‚¬ì „í˜•ìœ¼ë¡œ ì €ì¥í•´ë†“ê¸°.

```

## Phase2.  í”¼ë“œë°±(ì •ë‹µ ì œì‹œ ê¸ˆì§€)

ì¢‹ì€ ì‹œë„ì…ë‹ˆë‹¤! ì´ ë¬¸ì œëŠ” ì§ê´€ë§Œìœ¼ë¡œ í’€ê¸°ì—” ì‚´ì§ ê¹Œë‹¤ë¡­ê³ ,

ì•Œê³ ë¦¬ì¦˜ ì•„ì´ë””ì–´(íŠ¹íˆ ìš°ì„ ìˆœìœ„ í + ì •ë ¬)ë¥¼ ì •í™•íˆ ì¡ì•„ì•¼ ì‹œê°„ ì•ˆì— í•´ê²°í•  ìˆ˜ ìˆëŠ” ìœ í˜•ì…ë‹ˆë‹¤.

âœ… ë¬¸ì œ ìš”ì•½ ì •ë¦¬

â€¢	ê° ì‚¬ëŒì€ â€œì§‘ ìœ„ì¹˜â€ì™€ â€œì‚¬ë¬´ì‹¤ ìœ„ì¹˜â€ë¥¼ í•œ ìŒìœ¼ë¡œ ê°€ì§. (ì˜ˆ: (h, o))

â€¢	ì² ë¡œì˜ ê¸¸ì´ dê°€ ì •í•´ì§ (ì–‘ì˜ ì •ìˆ˜).

â€¢	ê¸¸ì´ê°€ dì¸ ì–´ë–¤ ì„ ë¶„ì„ ì¼ì§ì„ ìƒì— ë°°ì¹˜í•  ë•Œ,

â€¢	ì§‘ê³¼ ì‚¬ë¬´ì‹¤ì´ ëª¨ë‘ ê·¸ ì„ ë¶„ì— í¬í•¨ë˜ëŠ” ì‚¬ëŒì˜ ìˆ˜ê°€ ìµœëŒ€ê°€ ë˜ì–´ì•¼ í•¨.

â€¢	ê·¸ ìµœëŒ€ ì¸ì›ì„ êµ¬í•˜ëŠ” ë¬¸ì œ.

ì¦‰, ê° ì‚¬ëŒì— ëŒ€í•´ **[ \min(h, o), \max(h, o) ]**ë¼ëŠ” êµ¬ê°„ì´ ìˆê³ ,

ì–´ë–¤ ê¸¸ì´ dì¸ ì„ ë¶„ì´ ì´ êµ¬ê°„ì„ ì „ë¶€ ì»¤ë²„í•˜ë©´ â€œê·¸ ì‚¬ëŒì€ í¬í•¨â€ëœë‹¤ê³  ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

âŒ í”íˆ í•˜ëŠ” ì‹¤ìˆ˜

1.	**ëª¨ë“  ì‚¬ëŒì˜ êµ¬ê°„ì— ëŒ€í•´ ì„ ë¶„ì„ â€˜ì™„ì „ íƒìƒ‰â€™**í•˜ë ¤ê³  ì‹œë„

â€¢	êµ¬ê°„ ìì²´ê°€ ìµœëŒ€ 10^8 ë²”ìœ„ â†’ ë¶ˆê°€ëŠ¥ (ë„ˆë¬´ í¼)

2.	ì‚¬ì „í˜• ë“±ìœ¼ë¡œ ë‹¨ìˆœ ì €ì¥ë§Œ í•´ë‘ê³ , ë§ˆë•…í•œ ê·¸ë¦¬ë”” ë¡œì§ ì—†ì´ â€œí•œ ì ì”© ì´ë™â€

â€¢	ì—¬ì „íˆ ë²”ìœ„ê°€ ì»¤ì„œ ì‹œê°„ ì´ˆê³¼

3.	ë‘ ì¢Œí‘œ(ì§‘,ì‚¬ë¬´ì‹¤) ì°¨ì´ê°€ d ì´ˆê³¼ì¸ ì¼€ì´ìŠ¤ë„ ê³ ë ¤í•˜ëŠë¼ ë³µì¡í•´ì§

â€¢	ì‚¬ì‹¤ ì´ ê²½ìš°ëŠ” â€œì–´ë–¤ ì„ ë¶„ìœ¼ë¡œë„ ë‘˜ ë‹¤ ëª» ë‹´ëŠ”ë‹¤â€ë¼ì„œ ì• ì´ˆì— ì œì™¸í•´ë²„ë¦¬ëŠ” ê²ƒì´ ë‚«ìŠµë‹ˆë‹¤.

ğŸ’¡ í° ê·¸ë¦¼: ì •ë ¬ + ìš°ì„ ìˆœìœ„ í ë¡œ í•´ê²°

ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì „í˜•ì ì¸ ì ‘ê·¼ ë°©ì‹ì„ êµ¬ì¡°ë§Œ ê°„ë‹¨íˆ ì†Œê°œí•´ ë“œë¦´ê²Œìš”(ì •ë‹µì€ X).

1.	êµ¬ê°„í™”

â€¢	ê° ì‚¬ëŒì˜ ìœ„ì¹˜ë¥¼ [start, end] = [\min(h, o), \max(h, o)]ë¡œ í‘œí˜„

â€¢	ë§Œì•½ end - start > dë¼ë©´, ì–´ì°¨í”¼ ê¸¸ì´ dë¡œëŠ” â€œì§‘+ì‚¬ë¬´ì‹¤â€ì„ ë™ì‹œì— ì»¤ë²„í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì œì™¸í•©ë‹ˆë‹¤.

2.	ì¢…ì  ê¸°ì¤€ ì •ë ¬

â€¢	ìœ„ì—ì„œ ê±°ë¥¸ êµ¬ê°„ë“¤ë§Œ ëª¨ì•„ì„œ, êµ¬ê°„ì˜ â€œendâ€ (ì˜¤ë¥¸ìª½ ë) ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•©ë‹ˆë‹¤.

3.	ì„ ë¶„ [end - d, end]ë¥¼ ìƒê°í•˜ë©°, í¬í•¨ ê°€ëŠ¥í•œ êµ¬ê°„ ê°œìˆ˜ ì„¸ê¸°

â€¢	ì •ë ¬ëœ ìˆœì„œë¡œ êµ¬ê°„ì„ í•˜ë‚˜ì”© ë³´ë©´ì„œ,

â€¢	â€œì´ë²ˆ êµ¬ê°„ì˜ endë¥¼ ì„ ë¶„ì˜ ì˜¤ë¥¸ìª½ ëìœ¼ë¡œ ì¡ìœ¼ë©´, ì„ ë¶„ì€ [end - d, end]ì¼ ê²ƒâ€ì´ë¼ëŠ” ì•„ì´ë””ì–´

â€¢	ì´ ë•Œ, â€œêµ¬ê°„ì˜ startê°€ \geq end - d ì´ìƒâ€ì´ë©´ ê·¸ êµ¬ê°„ì€ [end-d, end]ì— í¬í•¨ë  ê°€ëŠ¥ì„±ì´ ìˆìŒ.

â€¢	ë°˜ëŒ€ë¡œ, startê°€ < (end-d)ì¸ êµ¬ê°„ì€ ë” ì´ìƒ [end-d, end]ì— ë“¤ì–´ê°ˆ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì œì™¸.

4.	ìš°ì„ ìˆœìœ„ í(í™)ë¡œ start ê´€ë¦¬

â€¢	êµ¬ê°„ì„ â€œendâ€ ê¸°ì¤€ìœ¼ë¡œ ìˆœíšŒí•˜ë©´ì„œ,

â€¢	â€œí˜„ì¬ endì—ì„œ ì»¤ë²„ ê°€ëŠ¥í•œ startë“¤â€ë§Œ í™ì— ë„£ê³ ,

â€¢	startê°€ â€œend - dâ€ ë¯¸ë§Œì´ë©´ í™ì—ì„œ ë¹¼ëŠ” ì‹ìœ¼ë¡œ ìœ ì§€

â€¢	í™ì— ë‚¨ì•„ ìˆëŠ” êµ¬ê°„ì˜ ê°œìˆ˜ê°€ ê³§ â€œ[end-d, end]â€ì— ì™„ì „íˆ ë“¤ì–´ì˜¤ëŠ” êµ¬ê°„ ìˆ˜.

â€¢	ë§¤ë²ˆ í™ ì‚¬ì´ì¦ˆ(ì¦‰ í¬í•¨ êµ¬ê°„ ìˆ˜)ì˜ ìµœëŒ“ê°’ì„ ê°±ì‹  â†’ ì •ë‹µ.

> ì´ ë°©ì‹ìœ¼ë¡œ, â€œì–´ë””ë¥¼ ì„ ë¶„ìœ¼ë¡œ ì¡ì•„ì•¼ ìµœëŒ€ê°€ ë˜ì§€?â€ë¼ëŠ” ë¬¸ì œë¥¼

> ì •ë ¬ëœ end

> ê°€ëŠ¥í•œ start

ğŸ·ï¸ íŒíŠ¸ Q&A

1.	ì™œ êµ¬ê°„ì˜ endë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ë‚˜ìš”?

â€¢	â€œì„ ë¶„ì˜ ì˜¤ë¥¸ìª½ ëâ€ì„ ê³ ì •í•˜ë©°, ì™¼ìª½ ëì€ end - dê°€ ë˜ë¯€ë¡œ.

â€¢	ë§Œì•½ endê°€ ì˜¤ë¦„ì°¨ìˆœì´ë©´, ì´ì „ ë‹¨ê³„ì—ì„œ ê³ ë ¤í•œ startë“¤ì€ ê·¸ëŒ€ë¡œ ì¬í™œìš© ê°€ëŠ¥.

â€¢	startë¥¼ ê¸°ì¤€ìœ¼ë¡œë„ í•´ë³¼ ìˆ˜ ìˆì§€ë§Œ, ë³´í†µ end ê¸°ì¤€ì´ êµ¬í˜„ì´ ë” ì§ê´€ì .

2.	startê°€ end - d ì´ìƒì´ë©´ ëœë‹¤ëŠ” ê²Œ ë¬´ìŠ¨ ëœ»ì´ì£ ?

â€¢	ê¸¸ì´ê°€ dì¸ ì„ ë¶„ [end-d, end] ë‚´ì— êµ¬ê°„ [start, end]ê°€ ì™„ì „íˆ ë“¤ì–´ì˜¤ë ¤ë©´,

â€¢	start >= end - d ì—¬ì•¼ í•©ë‹ˆë‹¤.

3.	í™ì—ëŠ” ë­˜ push/popí•˜ë‚˜ìš”?

â€¢	ë³´í†µ êµ¬ê°„ì˜ startë¥¼ pushí•©ë‹ˆë‹¤.

â€¢	endë¥¼ í•˜ë‚˜ì”© íƒìƒ‰í•˜ë©´ì„œ, â€œí˜„ì¬ endë¡œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ì„ ë¶„â€ì— ë“¤ì–´ì˜¬ ìˆ˜ ì—†ëŠ” startë“¤ì„ popí•˜ì—¬ ì œê±°í•©ë‹ˆë‹¤.

4.	ì‹œê°„ ë³µì¡ë„?

â€¢	êµ¬ê°„ ì •ë ¬: O(N \log N)

â€¢	í™ ì—°ì‚°: ê° êµ¬ê°„ë‹¹ push/popì´ ìµœëŒ€ 1ë²ˆì”© â†’ O(N \log N)

â€¢	ì´í•©: O(N \log N) ì •ë„

âš ï¸ ì£¼ì˜

â€¢	ì…ë ¥ ë²”ìœ„: ìœ„ì¹˜ê°€ \pm 10^8

â€¢	ì¶œë ¥: ìµœëŒ€ ì¸ì› ìˆ˜

â€¢	ì •ë ¬ ë° í™ì„ ì˜ëª» êµ¬í˜„í•˜ë©´ ì‹œê°„ ì´ˆê³¼/ë©”ëª¨ë¦¬ ì´ˆê³¼ê°€ ë‚  ìˆ˜ ìˆìŒ

â€¢	êµ¬ê°„ì˜ í¬ê¸°ê°€ dë¥¼ ì´ˆê³¼í•˜ëŠ” ê²½ìš°ëŠ” ë¯¸ë¦¬ ê±°ë¥´ëŠ” ê²Œ ì¢‹ìŠµë‹ˆë‹¤.

âœï¸ ì •ë¦¬

â€¢	í•µì‹¬:

â€¢	â€œ[start, end]â€ êµ¬ê°„ì„ ë§Œë“¤ê³ , â€œendâ€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬

â€¢	ìš°ì„ ìˆœìœ„ íë¥¼ ì´ìš©í•´ â€œ\geq end - dâ€ì¸ startë§Œ ìœ ì§€

â€¢	í™ í¬ê¸°(= í˜„ì¬ í¬í•¨ ê°€ëŠ¥í•œ êµ¬ê°„ ìˆ˜)ì˜ ìµœëŒ“ê°’ì„ ì°¾ëŠ”ë‹¤

â€¢	ìë£Œêµ¬ì¡°:

â€¢	ì •ë ¬(ì˜¤ë¦„ì°¨ìˆœ by end)

â€¢	ìµœì†Œ í™(ë˜ëŠ” ìµœëŒ€ í™)ìœ¼ë¡œ startë¥¼ ê´€ë¦¬

â€¢	í•œ ë²ˆ ë¡œì§ì„ ê¹¨ë‹¬ìœ¼ë©´ ë‹¤ë¥¸ â€œì„ ë¶„ ë®ê¸°â€ ê³„ì—´ ë¬¸ì œì™€ ë¹„ìŠ·í•˜ê²Œ í’€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ ë°©í–¥ëŒ€ë¡œ êµ¬ìƒí•˜ì‹œê³ , êµ¬ì²´ ì½”ë“œ êµ¬í˜„ ì „ì— ì˜ˆì œ(íŠ¹íˆ ë¬¸ì œ ë³¸ë¬¸ ì˜ˆì œ)ë¡œ ì†ìœ¼ë¡œ ì‹œë®¬ë ˆì´ì…˜í•´ë³´ë©´ ë”ìš± í™•ì‹¤íˆ ì´í•´í•˜ì‹¤ ìˆ˜ ìˆì„ ê±°ì˜ˆìš”.

í™”ì´íŒ…ì…ë‹ˆë‹¤!



# ì´ë¶„ íƒìƒ‰: ì‚¬ëƒ¥ê¾¼



KOI ì‚¬ëƒ¥í„°ì—ëŠ” N ë§ˆë¦¬ì˜ ë™ë¬¼ë“¤ì´ ê°ê° íŠ¹ì •í•œ ìœ„ì¹˜ì— ì‚´ê³  ìˆë‹¤. ì‚¬ëƒ¥í„°ì— ì˜¨ ì‚¬ëƒ¥ê¾¼ì€ ì¼ì§ì„  ìƒì— ìœ„ì¹˜í•œ M ê°œì˜ ì‚¬ëŒ€(ì´ì„ ì˜ëŠ” ì¥ì†Œ)ì—ì„œë§Œ ì‚¬ê²©ì´ ê°€ëŠ¥í•˜ë‹¤. í¸ì˜ìƒ, ì¼ì§ì„ ì„ x-ì¶•ì´ë¼ ê°€ì •í•˜ê³ , ì‚¬ëŒ€ì˜ ìœ„ì¹˜ x1, x2, ..., xMì€ x-ì¢Œí‘œ ê°’ì´ë¼ê³  í•˜ì. ê° ë™ë¬¼ì´ ì‚¬ëŠ” ìœ„ì¹˜ëŠ” (a1, b1), (a2, b2), ..., (aN, bN)ê³¼ ê°™ì´ x,y-ì¢Œí‘œ ê°’ìœ¼ë¡œ í‘œì‹œí•˜ì. ë™ë¬¼ì˜ ìœ„ì¹˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ëª¨ë“  ì¢Œí‘œ ê°’ì€ ì–‘ì˜ ì •ìˆ˜ì´ë‹¤.

ì‚¬ëƒ¥ê¾¼ì´ ê°€ì§€ê³  ìˆëŠ” ì´ì˜ ì‚¬ì •ê±°ë¦¬ê°€ Lì´ë¼ê³  í•˜ë©´, ì‚¬ëƒ¥ê¾¼ì€ í•œ ì‚¬ëŒ€ì—ì„œ ê±°ë¦¬ê°€ L ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ìœ„ì¹˜ì˜ ë™ë¬¼ë“¤ì„ ì¡ì„ ìˆ˜ ìˆë‹¤ê³  í•œë‹¤. ë‹¨, ì‚¬ëŒ€ì˜ ìœ„ì¹˜ xiì™€ ë™ë¬¼ì˜ ìœ„ì¹˜ (aj, bj) ê°„ì˜ ê±°ë¦¬ëŠ” |xi-aj| + bjë¡œ ê³„ì‚°í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, ì•„ë˜ì˜ ê·¸ë¦¼ê³¼ ê°™ì€ ì‚¬ëƒ¥í„°ë¥¼ ìƒê°í•´ ë³´ì. (ì‚¬ëŒ€ëŠ” ì‘ì€ ì‚¬ê°í˜•ìœ¼ë¡œ, ë™ë¬¼ì˜ ìœ„ì¹˜ëŠ” ì‘ì€ ì›ìœ¼ë¡œ í‘œì‹œë˜ì–´ ìˆë‹¤.) ì‚¬ì •ê±°ë¦¬ Lì´ 4ë¼ê³  í•˜ë©´, ì ì„ ìœ¼ë¡œ í‘œì‹œëœ ì˜ì—­ì€ ì™¼ìª½ì—ì„œ ì„¸ ë²ˆì§¸ ì‚¬ëŒ€ì—ì„œ ì‚¬ëƒ¥ì´ ê°€ëŠ¥í•œ ì˜ì—­ì´ë‹¤.

ì‚¬ëŒ€ì˜ ìœ„ì¹˜ì™€ ë™ë¬¼ë“¤ì˜ ìœ„ì¹˜ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì¡ì„ ìˆ˜ ìˆëŠ” ë™ë¬¼ì˜ ìˆ˜ë¥¼ ì¶œë ¥í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## Phase1. ì§ì ‘ í’€ê¸°(ì‹¤íŒ¨)

```python
"""
1. ë¬¸ì œ ì½ê¸°
ì‚¬ëŒ€ì˜ ìœ„ì¹˜ì—ì„œ ì»¤ë²„ì¹  ìˆ˜ ìˆëŠ” ë™ë¬¼ë“¤ì˜ ìœ„ì¹˜ë¥¼ ê³„ì‚°.
ì‚¬ëŒ€ì˜ ê°œìˆ˜ M(1 <= M <= 100,000)ì—ì„œ ë™ë¬¼ì˜ ìˆ˜ë¥¼ ì™„ì „íƒìƒ‰í•˜ë©´ ë¶ˆê°€í•˜ê² ì§€?

2. ë¬¸ì œ í’€ê¸°
ìœ ì‚¬í•œ ë¬¸ì œ: ë‚˜ë¬´ ìë¥´ê¸°? ë­ê°€ ë¹„ìŠ·í•œì§€ ëª¨ë¥´ê² ë‹¤. ê²°ì •í•¨ìˆ˜ ì„¤ì •í•˜ê³  ë§¤ê°œë³€ìˆ˜ë¥¼ ì¡°ì ˆí•´ì„œ ì´ì§„íƒìƒ‰ì„ í•´ì•¼ í•  ê±´ë°
ê²°ì •í•¨ìˆ˜: ì¡ì„ ìˆ˜ ìˆëŠ” ë™ë¬¼ ìˆ˜
ë§¤ê°œë³€ìˆ˜: ì‚¬ëŒ€ ì¢Œí‘œê² ì§€ ë‹¹ì—°íˆ.
ë¬¸ì œëŠ”, ë§¤ê°œë³€ìˆ˜ì™€ ê²°ì • í•¨ìˆ˜ì˜ ì—°ê´€ì„±ì´ ì—†ë‹¤ëŠ” ê±°ë‹¤. ë§¤ê°œë³€ìˆ˜ê°€ ë¬´ìŠ¨ ê°’ì´ë“  ê²°ì • í•¨ìˆ˜ëŠ” 
ëœë¤í•˜ê²Œ ë‚˜ì˜¨ë‹¤.
ë§¤ê°œë³€ìˆ˜ë¥¼ ì„ í˜•ìœ¼ë¡œ ì¦ê°€ì‹œí‚¤ë©´ ê²°ì •í•¨ìˆ˜ëŠ” ë‹¹ì—°íˆ ì„ í˜•ì´ê² ì§€ë§Œ,
ì „í˜€ ê°ì´ ì•ˆ ì˜¨ë‹¤. ì–´ë–¤ ì ‘ê·¼ì„ ì·¨í•´ì•¼ í•˜ëŠ” ê±°ì§€?
ì™„ì „ íƒìƒ‰ìœ¼ë¡œ í‘¼ë‹¤ë©´? ì‚¬ëŒ€ í•˜ë‚˜ë¥¼ ì •í•´ì„œ ëª¨ë“  ë™ë¬¼ë“¤ì— ì´í„°ë ˆì´ì…˜í•´ì„œ, 
ê·¸ ê°’ì´ ì‚¬ëŒ€ ë²”ìœ„ì— ë“¤ì–´ì˜¤ëŠ”ì§€ íŒë‹¨í–ˆê² ì§€ -> ì¼ë‹¨ ì•…ê¸°ë°”ë¦¬ë¡œ ì´ë ‡ê²Œë¼ë„ í’€ì–´ë´ë¼.
í’€ì—ˆë‹¤. ì´ê±¸ ì´ì§„ íƒìƒ‰ìœ¼ë¡œ ì–´ë–»ê²Œ ë°”ê¾¸ì§€?
ë§¤ê°œë³€ìˆ˜ iëŠ” ë§ë£¨ì˜ ì¸ë±ìŠ¤. 
ëª¨ë¥´ê² ë‹¤.

3. ìˆ˜ë„ ì½”ë“œ
4. ì½”ë“œ êµ¬í˜„
"""

import sys
m, n, l = tuple(map(int, sys.stdin.readline().split()))
M = tuple(map(int, sys.stdin.readline().split()))
A = [
    tuple(map(int, sys.stdin.readline().split()))
    for _ in range(n)
]

def brute_force():
    for i in range(m):
        animals = get_animal_from(i)
        print(f'hunted at {i}th step: {animals}')


def get_animal_from(i):
    tmp = 0
    for j in range(n):
        x, y = A[j]
        dist_to_animal = abs(x-M[i]) + y
        if dist_to_animal <= l:
            tmp += 1
    return tmp

brute_force()
```

## Phase2. í”¼ë“œë°±(ì •ë‹µ ì œì‹œ ê¸ˆì§€)

ì§€ê¸ˆ ì „ìˆ˜ì¡°ì‚¬(brute force) ë°©ì‹ìœ¼ë¡œ ì ‘ê·¼í•˜ì…¨ëŠ”ë°,

ì‚¬ëŒ€(M ìµœëŒ€ 100,000ê°œ) Ã— ë™ë¬¼(N ìµœëŒ€ 100,000ë§ˆë¦¬)ë¥¼ ì „ë¶€ í™•ì¸í•˜ë©´ ìµœëŒ€ 10^{10} ë²ˆì˜ ì—°ì‚°ì´ ë˜ì–´ ì‹œê°„ ì´ˆê³¼ê°€ ë‚©ë‹ˆë‹¤.

âœ… í•µì‹¬ ì•„ì´ë””ì–´

1.	ì‚¬ëŒ€ì˜ ìœ„ì¹˜(Mê°œ)ë¥¼ ì •ë ¬í•´ ë‘”ë‹¤.

2.	ê° ë™ë¬¼(ì¢Œí‘œ (x, y))ì„ ë³¼ ë•Œ,

â€¢	â€œì´ ë™ë¬¼ì„ ì‚¬ëƒ¥í•  ìˆ˜ ìˆëŠ” **ì‚¬ëŒ€(ì´ ìœ„ì¹˜)**ê°€ ì¡´ì¬í•˜ëŠ”ê°€?â€

â€¢	|x - \text{ì‚¬ëŒ€ìœ„ì¹˜}| + y \le L

â€¢	ì¦‰, |x - \text{ì‚¬ëŒ€ìœ„ì¹˜}| \le L - y

â€¢	\text{ì‚¬ëŒ€ìœ„ì¹˜}ëŠ” [\,x - (L - y), \, x + (L - y)\,] ë²”ìœ„ ë‚´ì— ì¡´ì¬í•´ì•¼ í•œë‹¤.

3.	ì´ ë²”ìœ„ë¥¼ ì´ì§„ íƒìƒ‰ì„ í†µí•´ ì‚¬ëŒ€ ìœ„ì¹˜ ë°°ì—´ì—ì„œ ë¹ ë¥´ê²Œ íƒìƒ‰:

â€¢	\text{leftBound} = x - (L - y)

â€¢	\text{rightBound} = x + (L - y)

â€¢	ì •ë ¬ëœ ì‚¬ëŒ€ ë¦¬ìŠ¤íŠ¸ì—ì„œ

â€¢	leftBound ì´ìƒì¸ ì²« ë²ˆì§¸ ì‚¬ëŒ€ ì¸ë±ìŠ¤

â€¢	rightBound ì´í•˜ì¸ ë§ˆì§€ë§‰ ì‚¬ëŒ€ ì¸ë±ìŠ¤

â€¢	ë‘˜ ì¤‘ í•˜ë‚˜ë¼ë„ í•´ë‹¹ êµ¬ê°„ ì•ˆì— ë“¤ì–´ìˆë‹¤ë©´, â€œë™ë¬¼ì„ ì‚¬ëƒ¥í•  ìˆ˜ ìˆëŠ” ì‚¬ëŒ€ê°€ ì¡´ì¬â€

â€¢	(ì •í™•íˆëŠ”, êµ¬ê°„ ì•ˆì— ì‚¬ëŒ€ê°€ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ ì¡íŒë‹¤ê³  ë³¼ ìˆ˜ ìˆìŒ)

ì´ë ‡ê²Œ í•˜ë©´ ê° ë™ë¬¼ë§ˆë‹¤ ì´ì§„ íƒìƒ‰ 2íšŒ ì •ë„ë¡œ ê°€ëŠ¥í•œ ì¸ë±ìŠ¤ ë²”ìœ„ë¥¼ ì°¾ì„ ìˆ˜ ìˆê³ ,

Në§ˆë¦¬ Ã— O(\log M) = 10^5 \times \log(10^5) â†’ ëŒ€ëµ 10^6 ìˆ˜ì¤€ ì—°ì‚°ìœ¼ë¡œ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.

ğŸ”‘ ì£¼ìš” í¬ì¸íŠ¸

1.	ì‚¬ëŒ€ ìœ„ì¹˜ ì •ë ¬ ( O(M \log M) )

2.	ê° ë™ë¬¼ì— ëŒ€í•´:

â€¢	(L - y)ê°€ ìŒìˆ˜ì¸ ê²½ìš° â†’ ì–´ì°¨í”¼ ì¡ì„ ìˆ˜ ì—†ìŒ(ê±°ë¦¬ê°€ ì•ˆ ë‹¿ìŒ) â†’ ìŠ¤í‚µ

â€¢	ë‚˜ë¨¸ì§€ ê²½ìš°, \text{ì‚¬ëŒ€ìœ„ì¹˜}ëŠ” [x - (L - y), x + (L - y)] ì•ˆì— ìˆì–´ì•¼.

â€¢	ì´ì§„ íƒìƒ‰ìœ¼ë¡œ ìœ„ êµ¬ê°„ì´ ì‚¬ëŒ€ ë¦¬ìŠ¤íŠ¸ ë‚´ì— ì‹¤ì œ ì¡´ì¬í•˜ëŠ”ì§€ íŒë³„.

â€¢	ì¡´ì¬í•˜ë©´ ì¹´ìš´íŠ¸ +1

3.	ì •ë‹µì€ ì¡ì„ ìˆ˜ ìˆëŠ” ë™ë¬¼ ìˆ˜ ì´í•©.

âœï¸ ì •ë¦¬

â€¢	ì™„ì „íƒìƒ‰ì€ O(M \times N)ìœ¼ë¡œ ì‹œê°„ ì´ˆê³¼

â€¢	â€œ|x - s| + y \le L â†’ s \in [x - (L-y), x + (L-y)]â€ í˜•íƒœë¡œ êµ¬ê°„ì„ êµ¬í•´ë‘ê³ ,

â€¢	ì •ë ¬ëœ ì‚¬ëŒ€ ë°°ì—´ì—ì„œ êµ¬ê°„ ë‚´ì— ì‚¬ëŒ€ê°€ ìˆëŠ”ì§€ ë¹ ë¥´ê²Œ ì°¾ëŠ”ë‹¤(ì´ì§„ íƒìƒ‰).

â€¢	êµ¬í˜„ ì„¸ë¶€ì—ì„œ, bisect_left, bisect_right ë“±ì„ í™œìš©í•˜ë©´ í¸ë¦¬í•©ë‹ˆë‹¤.

ì´ë ‡ê²Œ ì ‘ê·¼í•˜ì‹œê³ , ì˜ˆì œ ì…ë ¥ ëª‡ ê°€ì§€ë¥¼ ì§ì ‘ ì†ìœ¼ë¡œ ì‹œë®¬ë ˆì´ì…˜í•´ë³´ë©´

ì–´ë ¤ìš´ ì ì´ ë§ì´ í•´ì†Œë  ê±°ì˜ˆìš”. í™”ì´íŒ…ì…ë‹ˆë‹¤!

